<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-03T11:00:12.004Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Silence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Algorithm-Chapter3-Dynamic Programming</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter3-Dynamic%20Programming/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter3-Dynamic%20Programming/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>906</code> words</p><p>Preferred Reading Time: <code>20~25</code> minutes</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><p>Similar to Divide and Conquer, but when subproblems overlap, DP is preferred.</p><blockquote><ul><li>Recurrence is from top to bottom, while DP is from bottom to top.</li><li>Recurrence is efficient when subproblems are independent, while DP requires overlapped subproblems.</li><li>DP trades space for time.</li></ul></blockquote></li><li><p>DP is used for <strong>optimization</strong> problems</p></li><li><p><strong>Core: As long as all subproblems are optimized, the merged problem can be optimized.</strong></p><blockquote><p>Prerequisite: All subproblems cannot be completely individual, and in other words,  they have to affect each other’s solution.</p></blockquote></li></ul><h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ul><li>model subproblems</li><li>establish value connections between subproblems</li><li>bottom-up computation to get result</li><li>trace to get format answer</li></ul><h2 id="0-1-knapsack"><a href="#0-1-knapsack" class="headerlink" title="0-1 knapsack"></a>0-1 knapsack</h2><h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h3><ul><li>try all $2^n$ methods and compare them.</li></ul><h4 id="Simple-Recursion"><a href="#Simple-Recursion" class="headerlink" title="Simple Recursion"></a>Simple Recursion</h4><ul><li><p>$V[i,w]=max(V[i-1,w], v_i+V[i-1,w-w_i])$</p><ul><li><p>$V[i,w]$ denote any subset of items $\{1, 2, 3, …i\}$ value sum with <strong>at most</strong> weight $w$.</p><blockquote><p>Real weight may be smaller than $w$.</p></blockquote></li></ul></li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li>State of subproblems<ul><li>establish formal description for problem requirements</li></ul></li><li><p>Relate a problem to its subproblems</p><ul><li>establish recurrence equation</li><li>set boundary cases</li></ul></li><li><strong>Bottom-up</strong> computation of $V[i,w]$</li><li>initialize boundary cases<ul><li>Save trace when calculating $V[i,j]$, and till the end we can use recorded result to get $V[i,w]$.</li></ul></li><li>Add <code>keep[i,w]</code> to record for a specific w, whether an item is taken.</li></ul><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>DP save duplicate computation.</li><li>DP trades space for time.</li><li>Strategy<ul><li>Structure</li><li>Recursion</li><li>Bottom-up computation</li><li>Construct optimal solution: trace the table</li></ul></li></ul><h2 id="Rod-Cutting"><a href="#Rod-Cutting" class="headerlink" title="Rod Cutting"></a>Rod Cutting</h2><h3 id="brute-force-1"><a href="#brute-force-1" class="headerlink" title="brute force"></a>brute force</h3><ul><li>$r_n=max(p_n,r_1+r_{n-1},…,r_{n-1}+r_1)$<ul><li>$r_n$ is the optimal revenue of length <code>n</code> rod.</li><li>$p_n$ is the price of length <code>n</code> rod.</li><li>simpler definition:  $r_n=max_{1\leq i \leq n}(p_i+r_{n-i})$</li></ul></li><li>Even recurrence equation is established, the recursive method still contains duplicate computation.</li></ul><h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><ul><li>one-dimension array <code>r[]</code> to store max revenue of length from 0 to n.</li><li><code>r[i] = max(r[i], p[j] + r[i - j])</code></li></ul><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>$O(n^2)$</li></ul><h2 id="Chain-Matrix-Multiplication"><a href="#Chain-Matrix-Multiplication" class="headerlink" title="Chain Matrix Multiplication"></a>Chain Matrix Multiplication</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>C(<code>p*q</code> and <code>q*r</code> matrix to multiply, each entry takes $O(q)$ to calculate): $O(pqr)$</p></li><li><p>$A_1A_2A_3=(A_1A_2)A_3=A_1(A_2A_3)$</p><blockquote><p>cause of different complexity</p></blockquote></li></ul><h3 id="Exhaustive-Search"><a href="#Exhaustive-Search" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><ul><li>$\Omega(\frac{4^n}{n^{\frac{3}{2}}})$</li></ul><h3 id="DP-2"><a href="#DP-2" class="headerlink" title="DP"></a>DP</h3><p>for matrix $A_i$, it has dimension of $p_{i-1}*p_i$.</p><ul><li><p>model subproblems</p></li><li><p>establish <strong>value</strong> connection between subproblems</p><p>$m[i,j]=\begin{cases}0, &amp; i=j\\min_{i\leq k&lt;j}(m[i,k]+m[k+1,j])+p_{i-1}p_kp_j, &amp; i&lt;j\end{cases}$</p></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$<ul><li>Outlying loop layer is for traverse multiply-array’s length from 2 to n.</li></ul></li><li>space: $O(n^2)$</li></ul><h2 id="Longest-Common-Subsequence-Problem"><a href="#Longest-Common-Subsequence-Problem" class="headerlink" title="Longest Common Subsequence Problem"></a>Longest Common Subsequence Problem</h2><h3 id="Basic-Concepts-1"><a href="#Basic-Concepts-1" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>subsequence: not necessarily continuous</li><li>substring: <strong>must</strong> be continuous</li></ul><h3 id="DP-3"><a href="#DP-3" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ the length of LCS in $A[1..i]$ of $A[1..m]$ and $B[1..j]$ of $B[1..n]$</p><ul><li>$d_{i,j}=\begin{cases} 0, &amp; i,j=0 \\ d_{i-1,j-1}+1, &amp; x_i=y_j \\ max(d_{i-1.j},d_{i,j-1}), &amp; x_i\neq y_j\end{cases}$</li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(mn)$</p></li><li><p>space: $O(n^2)$</p><ul><li><p>optimization for solution matrix: only save two rows</p><blockquote><p>The trace matrix needs totally preserving.</p></blockquote></li></ul></li><li><p>Different trace may lead to different subsequence.</p></li></ul><h2 id="Longest-Common-Substring-Problem"><a href="#Longest-Common-Substring-Problem" class="headerlink" title="Longest Common Substring Problem"></a>Longest Common Substring Problem</h2><h3 id="Basic-Concepts-2"><a href="#Basic-Concepts-2" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>Different from subsequence, substring must be contiguous.</li></ul><h3 id="DP-4"><a href="#DP-4" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ to be the length of the longest common substring of $X[1..i]$ and $Y[1..j]$</p><ul><li>$d_{i,j}=\begin{cases} d_{i-1,j-1}+1, &amp;x_i=y_j\\ 0, &amp;x_i\neq y_j\end{cases}$</li><li>$maxSubstring(X,Y)=max(d_{i,j})$</li></ul><h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Without saving DP direction, we can still trace the whole substring by knowing the <strong>end index</strong> of substring $(X_i|Y_j)$ and its length $d_{i,j}$.</li><li>time: $O(mn)$</li><li>Subsequence algorithm can be used to solve this problem by only outputting diagonal $LU$ elements.</li></ul><h2 id="Minimum-Edit-Distance"><a href="#Minimum-Edit-Distance" class="headerlink" title="Minimum Edit Distance"></a>Minimum Edit Distance</h2><h3 id="Basic-Concepts-3"><a href="#Basic-Concepts-3" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><ul><li>“Spell Correction” in search engine</li><li>Computational Biology such as comparing DNA</li><li>Machine Translation, Information Extraction, Speech Recognition etc.</li></ul><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>calculate the smallest number of edit operations</p><ul><li><p>edit operations</p><ul><li>insertion: add a letter</li><li>deletion: delete a letter</li><li>substitution: replace a character</li></ul><blockquote><p>All operations’ cost is usually (throughout the course) counted as <code>1</code>, but the cost can be adjusted.</p></blockquote></li></ul><h3 id="DP-5"><a href="#DP-5" class="headerlink" title="DP"></a>DP</h3><p>define $D[i,j]$ the edit distance of $X[1..i]$ and $Y[1..j]$</p><ul><li>$D[i,j]=min\begin{cases} D[i-1,j]+1, &amp;delete\ X[i] \\ D[i,j-1]+1, &amp;insert\ Y[j] \\ D[i-1,j-1] +0, &amp;X[i]=Y[j] \\ D[i-1,j-1]+1, &amp;X[i] \neq Y[j] \end{cases}$</li></ul><blockquote><ul><li>All edit operations take place on $X[1..i]$.</li><li>When operation cost changes, the constant in equation will be changed as well.</li><li>When the problem can be depicted as a state graph, <strong>shortest path algorithm</strong> can be used to solve the problem. In other words, the problems degrades to shortest path problem.</li></ul></blockquote><h3 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>When tracing the edit process, <code>L</code>/<code>U</code>/<code>LR</code> stand for four different operations(<strong>including doing nothing</strong>).</li><li>time: $O(mn)$</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>multi-stage strategy problem</li><li>DP is not a specific method but a way of thinking.</li><li>Key to DP: basic equations and boundary conditions</li><li>DP’s effect is also called Markova effect for there’s no effect on future events. </li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;906&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;20~25&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter2-Divide and Conquer</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter2-Divide%20and%20Conquer/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter2-Divide%20and%20Conquer/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>559</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><a id="more"></a><h2 id="MCS"><a href="#MCS" class="headerlink" title="MCS"></a>MCS</h2><ul><li>Maximum Contiguous Subarray<ul><li>Find the span of years in which the company earned most</li></ul></li></ul><h3 id="Exhaustive-Search"><a href="#Exhaustive-Search" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_Val</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^3)$</li></ul><h3 id="Data-Reuse"><a href="#Data-Reuse" class="headerlink" title="Data-Reuse"></a>Data-Reuse</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_val</span></span><br></pre></td></tr></table></figure><ul><li>$V(i,j)=V(i,j-1)+A[j]$</li><li>$O(n^2)$</li></ul><h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input A[s...t]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s == t:</span><br><span class="line">    retun A[s] <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    MCS(A, s, mid) <span class="comment"># T(n/2)</span></span><br><span class="line">    MCS(A, mid, t) <span class="comment"># T(n/2)</span></span><br><span class="line">    <span class="comment"># find the max_val of cut position containing A[mid] and A[mid+1]</span></span><br></pre></td></tr></table></figure><ul><li>Be cautious the array may be at the cut position.</li><li>When finding the <code>max_val</code> containing <code>A[mid]</code> and <code>A[mid+1]</code>, we can do it from <code>mid</code> to <code>0</code>.</li><li>$T(n)=2T([n/2])+n$</li><li>$O(nlogn)$</li></ul><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, temp, ans, temp_sum;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">    temp_sum = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// When temp_sum &lt; 0, it means last temp &lt; 0, and last temp has already been compared with ans to decide whether to update the start point of the sub-array.</span></span><br><span class="line">        temp_sum = max(<span class="number">0</span>, temp_sum); </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        temp_sum += temp;</span><br><span class="line">        ans = max(temp_sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Counting-inversions"><a href="#Counting-inversions" class="headerlink" title="Counting inversions"></a>Counting inversions</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># count inversion</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^2)$</li></ul><h3 id="Merge-Sort-Idea"><a href="#Merge-Sort-Idea" class="headerlink" title="Merge Sort Idea"></a>Merge Sort Idea</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(L) == <span class="number">0</span>:</span><br><span class="line">    reutrn <span class="number">0</span>, L</span><br><span class="line">cnt_a, A = sort_and_count(L[l, mid])</span><br><span class="line">cnt_b, B = sort_and_count(L[mid+<span class="number">1</span>, r])</span><br><span class="line">cnt_c, L = merge_and_count(L[l, mid], L[mid+<span class="number">1</span>, r])</span><br><span class="line"><span class="keyword">return</span> cnt_a + cnt_b + cnt_c, L</span><br></pre></td></tr></table></figure><ul><li>Increase inversion count when merging sorted two list.</li><li>$O(nlogn)$</li></ul><h2 id="Polynomial-Multiplication"><a href="#Polynomial-Multiplication" class="headerlink" title="Polynomial Multiplication"></a>Polynomial Multiplication</h2><h3 id="Brute-Force-1"><a href="#Brute-Force-1" class="headerlink" title="Brute Force"></a>Brute Force</h3><ul><li>compute all coefficients and merge them at last<ul><li>multiplications:$O(n^2)$</li><li>addition:$O(n^2)$</li><li>complexity:$O(n^2)$</li></ul></li></ul><h3 id="Divide-and-Conquer-1"><a href="#Divide-and-Conquer-1" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><ul><li>extract $x^{\frac{n}{2}}$ to make size <code>n</code> problem into $2*2$ problem</li><li>$O(n^2)$</li></ul><h4 id="Improve"><a href="#Improve" class="headerlink" title="Improve"></a>Improve</h4><ul><li>We need $A_0B_1+A_1B_0$ instead of $A_0B_1$and$A_1B_0$.<ul><li>$\begin{cases} U=A_0B_0 \\ V=A_0B_1 \\ W=A_1B_0 \\ Z=A_1B_1\end{cases}$</li><li>Take $Y=(A_0+A_1)(B_0+B_1)$, then we can get $A_0B_1+A_1B_0=Y-U-Z$.</li><li>$T(n)=\begin{cases} 3T(n/2) + n&amp;(n&gt;1) \\ 1&amp;(n=1) \end{cases}$</li></ul></li></ul><h2 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h2><ul><li>partition with pivot as a benchmark</li><li>place pivot into right place</li><li>above can be a recursive process</li><li>$O(nlogn)$: the average complexity</li></ul><h3 id="Improve-1"><a href="#Improve-1" class="headerlink" title="Improve"></a>Improve</h3><ul><li><p>The normal complexity of quicksort is $O(n^2)$ because the array may be partially sorted.</p><p>$T(n)=T(0)+T(n-1)+O(n)$</p><blockquote><ul><li>The complexity of quick sort is $O(n^2)$ instead of $O(nlogn)$.</li><li>$O(n)$ comes from the count of key comparisons.</li></ul></blockquote></li><li><p>Adopt random pivot to get randomized partition</p><ul><li>Swap random position with the last position for reuse the partition function</li><li>This action can validly lower the probability to encounter unlucky array partition</li></ul></li></ul><h4 id="Expected-Case"><a href="#Expected-Case" class="headerlink" title="Expected Case"></a>Expected Case</h4><ul><li>Analysis for randomization algorithm</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;559&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;10~15&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter5-Greedy Algorithms</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter5-Greedy%20Algorithms/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter5-Greedy%20Algorithms/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>522</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><a id="more"></a><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li><p>Greedy algorithms don’t always produce the optimal solution.</p></li><li><p>As a result, if the result is optimal, we need to prove its correctness.</p><blockquote><p>The usual way is to prove that any other optimal solution can be converted into the greedy one.</p></blockquote></li></ul><h2 id="Fraction-Knapsack-Problem"><a href="#Fraction-Knapsack-Problem" class="headerlink" title="Fraction Knapsack Problem"></a>Fraction Knapsack Problem</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Different from 0-1 problem, knapsack can take only a fraction of an item.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li>calculate value-per-pound of every item</li><li>sort items by <strong>decreasing</strong> value-per-pound</li><li>put as much as possible weight of an item into knapsack from the starting point to the end of the sorted array</li></ul><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$, the time complexity of sort process.</li><li>Different from DP, all subproblems of greedy algorithms are optimal no matter whether they are connected with each other.</li></ul><h2 id="Huffman-Coding-Problem"><a href="#Huffman-Coding-Problem" class="headerlink" title="Huffman Coding Problem"></a>Huffman Coding Problem</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>Encode characters according to its frequency so that the variable length can save the memory space compared with fixed length.</p><blockquote><p>especially useful when storing images</p></blockquote></li><li><p>Uniquely Decodable: In order to decode correctly, the encoding method should avoid one character’s code being the prefix of another character, and then the code can be named after <strong>prefix (free) code</strong>.</p></li><li><p>Huffman coding targets at the <strong>minimized binary prefix code</strong>.</p></li></ul><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><ul><li>pick two least-occur characters from alphabet and build a subtree</li><li>the subtree’s frequency is the sum of its sub-subtrees</li><li><strong>note that the Huffman tree can be a complete binary tree as well</strong></li></ul><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$<ul><li>Every update of the priority queue is $O(logn)$ and the total operation count is $n$.</li></ul></li></ul><h2 id="Activity-Selection-Problem"><a href="#Activity-Selection-Problem" class="headerlink" title="Activity Selection Problem"></a>Activity Selection Problem</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Given activities that may overlap with each other, take part in as many activities as possible.</li><li>core: find a maximized compatible activity set</li></ul><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>sort activities list in ascending order of finishing time</p></li><li><p>select the first activity: the one <strong>finishes at the earliest time</strong></p><blockquote><p>not the one starting earliest or the shortest one</p></blockquote></li><li><p>advance the time and update sort activities until the head activity’s starting time is still valid</p></li><li><p>select next activity</p></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>Time: $O(nlogn)$ to sort activity list.</p></li><li><p>The correctness can be proved that greedy algorithms produce the optimal solution of this problem.</p><blockquote><p>Proof: we can convert any other optimal solution($P’$) to the greedy algorithm solution($P$) by replacing different elements in $P’$ with corresponding elements in $P$.</p></blockquote></li></ul><h2 id="Weighted-Activity-Selection-Problem"><a href="#Weighted-Activity-Selection-Problem" class="headerlink" title="Weighted Activity Selection Problem"></a>Weighted Activity Selection Problem</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Every activity is given a weight, and the goal is to construct the set with maximized weight sum.</li></ul><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>Greedy algorithm is correct when weight are all equal.</p></li><li><p>DP can still work in this weight-varied scenario.</p><ul><li><p><strong>First of all, sort activity with its finishing time.</strong></p></li><li><p>$p(j)$ : the largest index $i&lt;j$ guaranteeing $a_i$ compatible with $a_j$.</p><blockquote><p><strong>index</strong> is the one of <strong>sorted</strong> activity array.</p></blockquote></li><li><p>$OPT(j)$: the max weight sum of any subset in $a[1..j]$</p><script type="math/tex; mode=display">OPT(j)=\begin{cases} 0,& j=0 \\ max(OPT(i-1), w_j+OPT(p(j)), & j>0\end{cases}</script></li></ul></li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$ to sort the activity list</li><li>Greedy algorithms never reconsider its previous choices, while DP construct its solution by comparing all possible previous choices.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;522&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;10~15&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter4-mid-term review</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter4-mid-term%20review/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter4-mid-term%20review/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>413</code> words</p><p>Preferred Reading Time: <code>15~20</code> minutes</p><a id="more"></a><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2><h3 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h3><ul><li><p>Any comparison-based sorting algorithm requires $\Omega(nlogn)$ comparisons.</p><blockquote><p>proved by binary decision tree</p></blockquote></li><li><p>Thus, in order to break the lower bound, we should take other methods except comparison.</p></li><li><p>counting sort isn’t based on comparison.</p></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>When inputting numbers, count occurrences of all numbers.</p><blockquote><p>counting array’s length is based on boundary value of inputting array.</p></blockquote></li><li><p>Fill sorted array with the counting array.</p></li></ul><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n)$</li><li>counting sort is a <strong>stable</strong> sort as long as the final filling loop is from raw array’s <strong>end</strong> to its <strong>head</strong>.</li></ul><h2 id="Randomized-Selection-Problem"><a href="#Randomized-Selection-Problem" class="headerlink" title="Randomized Selection Problem"></a>Randomized Selection Problem</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>find the <code>i-th</code> smallest element in a given array</li></ul><h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h3><ul><li>sort the array and index specific element</li></ul><h3 id="Partition-and-Selection"><a href="#Partition-and-Selection" class="headerlink" title="Partition and Selection"></a>Partition and Selection</h3><ul><li>The same as quick sort, part the array into two subarrays, and then make sure the index of selected separator number.</li><li>When the index is greater than <code>i</code>, handle another branch and abandon this one, vice versa.</li></ul><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(n)$</p><blockquote><p>Different from quick sort’s $O(nlogn)$, this algorithm only deals with one branch of subproblems, while quick sort handles both branches.</p></blockquote></li></ul><h2 id="Optimal-Binary-Search-Tree"><a href="#Optimal-Binary-Search-Tree" class="headerlink" title="Optimal Binary Search Tree"></a>Optimal Binary Search Tree</h2><h3 id="Basic-Concepts-1"><a href="#Basic-Concepts-1" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>construct a BST with smallest search cost</p></li><li><p>height</p><ul><li>$node_height=max(children_height + 1)$</li><li>$leave_ height=0$</li><li>$tree_height=root_height$</li><li>$empty_tree_height = -1$</li></ul><blockquote><p><code>root_height</code> is the <strong>biggest</strong> one.</p></blockquote></li><li><p>$depth=H(root)-H(n)+1$</p><ul><li>$root_depth=1$</li></ul></li><li><p>balanced binary tree: the height difference of two subtrees cannot go beyond 1.</p><ul><li>$balance_factor = H(right)-H(left)$</li></ul></li><li><p>AVL tree: besides balanced binary tree, every node will store the height of two subtrees.</p></li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li><p>subproblem: find an optimal BST containing $keys<a href="1 \leq i \leq j \leq n">i..j</a>$</p></li><li><p>$e[i,j]$: the expected search cost of a subtree with $k[i..j]$.</p><ul><li>$e[i, j] =\begin{cases} q_{i-1}, &amp;j=i-1 \\ min_{i\leq r\leq j}(e[i, r-1]+e[r+1, j]+w[i, j]), &amp;i\leq j\end{cases}$</li><li>$w[i,j]=E_r=w[i,r-1]+p_r+w[r+1,j]=w[i,j-1]+p_j+q_j$</li></ul></li><li><p>diagonal traverse template</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>): <span class="comment"># length of fixed diagnals</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n-l+<span class="number">1</span>):</span><br><span class="line">        j = i + l - <span class="number">1</span> <span class="comment"># (n-l+1, n) is always on f(i, j)</span></span><br></pre></td></tr></table></figure><blockquote><p>Due to $i\leq j$, then the traverse should be diagonal.</p></blockquote></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$</li><li>space: $O(n^2)$</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;413&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;15~20&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter6-Graph Algorithms</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter6-Graph%20Algorithms/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter6-Graph%20Algorithms/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:09.200Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>1887</code> words</p><p>Preferred Reading Time: <code>30~45</code> minutes</p><a id="more"></a><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><ul><li><p>complete graph</p><ul><li>undirected: $|E|=n(n-1)/2$</li><li>directed: $|E|=n(n-1)$</li></ul></li><li><p>dense &amp; sparse graph: not quantitative defined</p></li><li><p>degree: number of edges incident on a vertex</p><ul><li>degree of a graph is the sum of degrees of all vertices</li></ul></li><li><p>leave node</p><ul><li>directed graph: no out degree</li><li>undirected graph: degree is <code>1</code></li></ul></li><li><p>path length: <strong>edges’</strong> count(not vertex)</p></li><li><p>simple path: all <strong>vertices</strong> are distinct on the path(no cycle, acyclic)</p></li><li><p>cycle: requires all <strong>edges</strong> are distinct with multi-exist vertices</p><blockquote><ul><li><p>an edge cannot be used twice in a cycle</p></li><li><p>Q: self-to-self edge can produce cycle?</p><p>A: Yes, that’s why a legal tree <strong>cannot</strong> have self-to-self edge.</p></li></ul></blockquote></li><li><p>connected component</p><ul><li><p><strong>disconnected</strong> graph’s biggest connected subgraph</p><blockquote><p>a disconnected graph can have <strong>more than one</strong> connected components</p></blockquote></li><li><p>connected graph itself</p></li></ul></li><li><p>included subgraph: As long as <strong>both</strong> endpoints are preserved, the edges should be preserved.</p></li><li><p>leaf</p><ul><li>directed graph: out-degree is zero</li><li>undirected graph: degree is one</li></ul></li></ul><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><ul><li>Adjacency List<ul><li>space complexity: $O(V+E)$</li><li>$adj[u]$: hold all vertices adjacent to $u$, usually a linked list.</li><li>mostly for sparse graph</li></ul></li><li>Adjacency Matrix<ul><li>space complexity: $O(V^2)$</li><li>undirected graphs always have <strong>symmetric</strong> adjacency matrix</li><li>mostly for dense graph</li></ul></li></ul><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul><li><p>data structure</p><ul><li><code>color[u]</code>: state of vertex <code>u</code><ul><li><code>undiscovered</code></li><li><code>discovered but not finishing processing</code></li><li><code>finished processing</code></li></ul></li><li><code>pred[u]</code>: the predecessor of vertex <code>u</code></li><li><code>d[u]</code>: distance from starting point to <code>u</code></li></ul></li><li><p>end-loop condition: the vertex queue is empty</p></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><blockquote><p>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</p></blockquote></li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li><p>tree-like traverse process</p></li><li><p>data structure</p><ul><li><code>color[u]</code></li><li><code>pred[u]</code></li><li><code>d[u]</code>: discovery time of vertex <code>u</code></li><li><code>f[u]</code>: finishing time of vertex <code>u</code></li></ul></li><li><p><code>u</code> is a descendant of <code>v</code> if and only if $[d[u],f[u]]\subset[d[v],f[v]]$</p><ul><li><p>tree edge$(u,v)$: $u$ is the predecessor in a DFS path</p></li><li><p>back edge$(u,v)$: $v$ is the predecessor in a DFS path</p><blockquote><p>As long as the graph is acyclic, there is no back edge.</p></blockquote></li><li><p>cross edge$(u,v)$: both vertices are endpoints of a DFS path</p></li></ul></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><ul><li>Different from normal complexity calculation, we can think it in this way: as for each vertex, $O(1)$ is needed to update the timestamp, and $O(degree(u))$ is required to run the for loop. Therefore, the total time complexity is the sum of every single time complexity.</li></ul><blockquote><ul><li>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</li><li>The time complexity is the same as the one of BFS under adjacency list.</li></ul></blockquote></li><li><p>White-path theorem: As long as $v$ is a descendant(direct or indirect) of $u$, then there is a white path between them in DFS algorithm.</p></li></ul><h2 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Topological sort is adopted for <strong>directed acyclic graph(DAG)</strong>.<ul><li>$G$ doesn’t need to be connected, for the order of disconnected parts won’t break the rule.</li></ul></li><li>find a sequence based on edge $(u,v)$ that $u$ must be ahead of $v$</li><li>If no “zero in-degree” vertex is found, the graph must contain cycle.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li>BFS<ul><li>find all vertices with in-degree as 0</li><li>delete them and their outgoing edges(decrease in-degree of its direct descendants)</li><li>repeat above steps</li></ul></li><li>DFS<ul><li>traverse all vertices and build a DFS tree</li><li>Once a vertex cannot span the tree anymore, add it into $L$.<ul><li>all direct descendants are added into $L$</li><li>no direct descendant exists</li></ul></li><li>next DFS tree traverse won’t reach vertices in $L$</li><li>Tasks with <strong>later</strong> finishing time should be down <strong>earlier</strong>, so $L$ needs reversing to be correct order.</li></ul></li></ul><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>BFS<ul><li>time: $O(|V|+|E|)$</li></ul></li><li>DFS<ul><li>time: $O(|V|+|E|)$</li></ul></li></ul><h2 id="Strongly-Connected-Components"><a href="#Strongly-Connected-Components" class="headerlink" title="Strongly Connected Components"></a>Strongly Connected Components</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>SCC is a subset of a <strong>directed</strong> graph, in which all vertices can reach each other, <strong>and</strong> the subset should be <strong>maximal</strong>(no more vertex can be added).</p><ul><li>SCC can contain <strong>only one</strong> vertex.</li></ul></li><li><p>Theorem: Suppose $S_1$ and $S_2$ are both SCCs of $G$, then the intersection must be $\Phi$.</p><blockquote><p>Proof: Any vertex in intersection can make $S_1\cup S_2$ a bigger SCC.</p><ul><li>After finding a SCC, all vertices within can be taken as a single vertex.</li></ul></blockquote></li><li><p>Finding all SCC of $G$ is to find a partition with all subset are SCC.</p></li><li><p>Sink SCC: SCC with no outgoing edge</p><ul><li><p>$G^{SCC}$ is a graph taking all SCC as a single vertex.</p></li><li><p>$G^{SCC}$ is a DAG</p><blockquote><p>Proof: As long as there is a cycle, the element of $SCC$ can be merged.</p></blockquote></li><li><p>$G^{SCC}$ must contain at least one <strong>SSCC</strong>.</p><blockquote><p>Proof: The DAG graph can be topological sorted, so the last vertex in the topological order has no outgoing edge, which means the vertex is a SSCC.</p></blockquote></li></ul></li></ul><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><ul><li>generate reverse graph $G^R$</li><li>Operate topological sort on $G^R$, and the result is $L^R$.</li><li>reverse $L^R$ to get $L$</li><li>execute DFS on $G$ with starting point as white ones in $L$</li><li>Every DFS on $G$ can produce a SCC, and corresponding vertices should be marked black.<ul><li>Starting from a SSCC, then the component won’t contain vertices of other SCC.</li></ul></li></ul><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(V+E)$</li></ul><h2 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a>Spanning Tree</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>An <strong>undirected</strong> graph’s subgraph containing all vertices.</p><blockquote><p>Q: Can spanning tree has cycle?</p><p>A: No,  tree is an <strong>acyclic</strong> graph.</p></blockquote></li><li><p>Every connected graph has at least one spanning tree.</p></li><li><p>Minimum Spanning Tree: the subgraph with smallest weight sum in a weighted undirected graph</p><ul><li><p>minimum spanning tree may <strong>not</strong> be unique</p><blockquote><p>Only when weight varies from one to another, the minimum spanning tree is unique.</p></blockquote></li></ul></li><li><p>safe edge: After adding safe edge to a subset of MST, the new set is still a subset of MST.</p><ul><li><p>Find the light edge of a cut respecting subset A, and then the light edge is the sage edge.</p><blockquote><p>Subset contains only edges, which means <strong>not all</strong> edges needs selecting even though their endpoints are with in the subset.</p></blockquote></li></ul></li><li><p>min heap</p><ul><li>root has min value</li><li>any vertex’s sons have <strong>greater</strong> value than its own value.</li></ul></li></ul><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><ul><li><p><strong>focus on vertex</strong></p></li><li><p>start with a randomly picked up <strong>vertex</strong></p></li><li><p>iterate to find the <strong>lightest</strong> edge outside the tree and add it (and its <strong>endpoint</strong>) into tree</p><ul><li><p>priority queue</p><ul><li><p>insert: insert at tail and <strong>reverse up</strong></p></li><li><p>extract min</p><ul><li><p>After extracting the first element, the last element needs swapping to the first.</p><blockquote><p>Only the last element won’t influence the tree structure.</p></blockquote></li><li><p><strong>roll down</strong> new first element to construct a new heap</p></li><li><p>time complexity is $O(logn)$</p></li></ul></li><li><p>update value: <strong>reverse up</strong> to respect the heap</p></li></ul></li></ul></li><li><p>When adding an new edge and its vertex into SMT, loop over its adjacent vertices to update key values.</p></li></ul><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><ul><li><strong>focus on edges</strong></li><li>Construct many forests, and finally they will be merged.<ul><li>When selecting edges, be cautious there cannot be cycles.<ul><li>disjoint set</li></ul></li></ul></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time</p><ul><li><p>Prim: $O(VlogV+ElogV)=O(ElogV)$</p><ul><li>Usually, $E$ is greater than $V$ and sometimes may be $V^2$, which means $E=O(V^2)$.</li></ul><blockquote><p>As for loops like <code>while Q.size() &gt; 0</code>, and <code>Q</code> is changed within, we can consider it based on every single operation instead of every loop.</p></blockquote></li><li><p>Kruskal: $O(ElogE)=O(ElogV)$</p><blockquote><p>$logE\leq logV^2 \leq 2logV \leq O(logV)$</p><ul><li>Usually place $E$ outside $log$, and $V$ is placed inside.</li></ul></blockquote></li></ul></li></ul><h2 id="Shortest-Path"><a href="#Shortest-Path" class="headerlink" title="Shortest Path"></a>Shortest Path</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><ul><li>distance is the <strong>minimal</strong> length between two vertices</li><li>lemma: Any sub-path of a shortest path must also be a shortest path.</li></ul><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><ul><li><p>single source problem</p></li><li><p>can only handle <strong>no-negative-edge</strong> graph</p></li><li><p>greedy algorithm</p></li><li><p>maintain <code>d[v]</code> and <code>S</code></p><ul><li><p><code>d[v]</code>: upper bound of length <code>l(source, v)</code></p><ul><li><p>can be optimized by priority queue</p></li><li><p>relax</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[v] &lt;- min(d[v], d[u] + w(u, v));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>S</code>: set of distance-settled vertices</p></li></ul></li></ul><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><ul><li><p>single source problem</p></li><li><p>relax according to <strong>edges</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to <span class="params">|V|</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> E <span class="keyword">do</span></span><br><span class="line">        relax(e.p1, e.p2, e.w);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>Every iteration will settle an edge in the shortest paths.</p></li><li><p>The shortest path can at <strong>most</strong> contain <code>(|V|-1)</code> edges.</p></li><li><p>Iteration at most runs for <code>(|V|-1)</code> times.</p><blockquote><p><code>ith</code> iteration settle the paths containing <code>i</code> edges</p></blockquote></li></ul></li><li><p>If relaxation still happens after <code>(|V|-1)</code> iterations, there must be negative cycles in graph.</p></li></ul><h4 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h4><ul><li><p>all-pairs problem</p></li><li><p>dynamic programming algorithm</p><ul><li><p>$f[k][i][j]=min\{f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j]\}$</p><ul><li><p>using rolling array to optimize</p><p>$f[i][j]=min\{f[i][j],f[i][k]+f[k][j]\}$</p></li></ul></li></ul></li><li><p>The sequence to traverse <code>k</code>(intermediate vertex) isn’t important.</p><blockquote><p>Proof: Mathematics Induction(<a href="https://blog.csdn.net/dypdypdyp123/article/details/50492894" target="_blank" rel="noopener">https://blog.csdn.net/dypdypdyp123/article/details/50492894</a>)</p></blockquote></li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><p>time</p><ul><li><p>Dijkstra: $O(VlogV+ElogV)=O(ElogV)$</p></li><li><p>Bellman-Ford: $O(EV)$</p></li><li><p>Floyd-Warshall: $O(V^3)$</p><blockquote><p>Apart from data structure, Floyd’s traversal decides the $n^3$ complexity.</p></blockquote></li></ul><h2 id="Maximum-Flow-amp-Minimum-Cut"><a href="#Maximum-Flow-amp-Minimum-Cut" class="headerlink" title="Maximum Flow &amp; Minimum Cut"></a>Maximum Flow &amp; Minimum Cut</h2><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>a flow network <code>G</code> with source <code>s</code>, sink <code>t</code> and no parallel edges.</p></li><li><p>capacity is nonnegative: $c(e) \geq 0$</p></li><li><p>cut’s capacity: $cap(A, B)=\sum_{e\ out\ of\ A}c(e)$</p><ul><li>a cut requires $s \in A$ and $t \in B$</li></ul></li><li><p>minimum cut: output a cut of minimum capacity</p></li><li><p>maximum flow: output a flow of maximum value</p></li><li><p>Except <code>s</code> and <code>t</code>, every vertex’s <code>out</code> equals <code>in</code>, which means it cannot store any water.</p></li><li><p>flow value: $val(f)=\sum_{e\ out\ of\ s}f(e)$, and <code>s</code> is the source.</p><blockquote><p><code>value</code> may not be the sum of capacity</p></blockquote></li></ul><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Heuristic-Algorithm"><a href="#Heuristic-Algorithm" class="headerlink" title="Heuristic Algorithm"></a>Heuristic Algorithm</h4><ul><li>initialize all <code>f(e)</code> to zero</li><li>find a <code>s-t</code> path where each edge meets $f(e)&lt;c(e)$</li><li>augment flow along <code>s-t</code> path</li><li>iterate above steps until no <code>s-t</code> path can be found</li></ul><blockquote><p><code>Heuristic Algorithm</code> <strong>cannot</strong> guarantee the optimal answer</p></blockquote><h4 id="Ford-Fulkerson-Method"><a href="#Ford-Fulkerson-Method" class="headerlink" title="Ford-Fulkerson Method"></a>Ford-Fulkerson Method</h4><ul><li><p>residual network: add reverse edges to dynamically adjust the flow of an edge</p><ul><li>residual capacity: $c_f(e)=\begin{cases} c(e)-f(e), &amp; c(e)&gt;f(e) \\ f(e), &amp;f(e)&gt;0 \end{cases}$</li></ul><blockquote><p>Once and residual capacity is zero, there is <strong>only one</strong> edge between two vertices.(even no edge at all)</p></blockquote></li><li><p>augment(ing) path: a simple <code>s-t</code> path in $G_f$</p><ul><li><p>bottleneck capacity: minimum residual capacity of any edge in augment path</p></li><li><p>key property: $val(f’)=val(f)+bottoleneck(G_f, P)$</p><ul><li>As for specific edge, the flow may decrease. However, the overall flow will increase.</li></ul></li><li><p>$val(f’)&gt;val(f)$</p><blockquote><p>the out edges of <code>s</code> must have the <strong>same</strong> direction as that in augment path</p></blockquote></li></ul></li><li><p>Process</p><ul><li>start with all <code>f(u, v) = 0</code></li><li>randomly choose an augment path to update <code>f</code> and $G_f$.</li><li>iterate until there is <strong>no</strong> augment path $\Leftrightarrow$ no <code>s-t</code> path in $G_f$</li></ul></li></ul><h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(|E||f^<em>|)$, $f^</em>$ is the max flow of graph $G$.</p><ul><li><p>BFS/DFS: $O(|V| + 2|E|)=O(|E|)$</p><blockquote><p>the worst case: one edge in $G$ has two corresponding edges in $G_f$</p></blockquote></li><li><p>The time complexity is determined by $|f^*|$, so the method to pick up an augment path is important.</p><ul><li>EK Algorithm: ignore all edges’ weight and find a shortest path</li><li>In a flow network, EK’s time complexity is $O(|V||E|)$.<ul><li>an edge <strong>at most</strong> can be critical for $|V|/2$ times</li></ul></li><li>new time complexity of Ford-Fulkerson Algorithm: $O(|V||E|^2)$</li></ul></li></ul></li><li><p>Augmenting Path Theorem: A flow of $f$ is a max-flow $\Leftrightarrow$ <strong>no</strong> augment path in $G_f$</p></li><li><p>Max Flow &amp; Min Cut Theorem</p><ul><li>$val(f)=cap(min_cut)$</li><li>$f$ is the max flow</li><li>$f$ has no augmenting path</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li><li>BUAA Algorithm MOOC, Autumn of 2020.</li><li>OI Wiki</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;1887&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;30~45&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter0-Introduction</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter0-Introduction/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter0-Introduction/</id>
    <published>2021-01-03T10:58:25.092Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>161</code> words</p><p>Preferred Reading Time: <code>3~5</code> minutes</p><a id="more"></a><h2 id="Syllabus"><a href="#Syllabus" class="headerlink" title="Syllabus"></a>Syllabus</h2><ul><li>Basics</li><li>Divide and Conquer</li><li>DP</li><li>Greedy</li><li>Graph</li><li>Hard Problems</li></ul><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ul><li>Design</li><li>Analyze</li></ul><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><ul><li>Computational Problem</li><li>Instance</li><li>Algorithm</li></ul><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><ul><li>Memory</li><li>Running time(focus of course)<ul><li>computer</li><li>implementation details</li><li>input(size etc.)</li></ul></li></ul><h3 id="Machine-independent-running-time"><a href="#Machine-independent-running-time" class="headerlink" title="Machine-independent running time"></a>Machine-independent running time</h3><ul><li>depend on quantity of <strong>primitive operations</strong><ul><li>addition</li><li>multiplication</li><li>comparison</li></ul></li><li>$T(n)$:denote the running time of n-size input<ul><li>n<ul><li>sorting: items to be sorted</li><li>graph: vertices and edges</li></ul></li></ul></li><li>Best Case: an instance for given size <code>n</code> results in the most efficient situation<ul><li>eg. A sorted list for insertion sort</li></ul></li><li>Worst Case<strong>(Mostly Used)</strong>: opposite to Best Case<ul><li>eg. A rev-sorted list for insertion sort</li></ul></li><li>Average Case: based on probability of all situations </li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li><p>$Θ(n)$ notation</p><ul><li><p>a supplement of <code>T(n)</code> notation</p><blockquote><p>$T(n)$ is exact while $Θ(n)$ is approximate</p></blockquote></li><li><p>eg. Mergesort</p><p>$T(n) = 2T(n/2) + Θ(n)\ (n&gt;1)$</p><p>$T(n)=Θ(1)\ (n=1)$</p><blockquote><p>Recursive notation</p></blockquote></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;161&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;3~5&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter1-Asymptotic Notations And Recurrence</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter1-Asymptotic%20Notations%20And%20Recurrence/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter1-Asymptotic%20Notations%20And%20Recurrence/</id>
    <published>2021-01-03T10:58:25.092Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>291</code> words</p><p>Preferred Reading Time: <code>5~10</code> minutes</p><a id="more"></a><h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><h3 id="Big-Oh"><a href="#Big-Oh" class="headerlink" title="Big-Oh"></a>Big-Oh</h3><ul><li><p><strong>Upper</strong> bounds</p></li><li><p>$f(n)=O(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\leq{c*g(n)}\ (c&gt;0, n&gt;n0)$</p></li><li><p>Example</p><ul><li>$sin(n)=O(1)$</li><li>$log(n!)=O(nlog(n))$</li><li>$\sum{1/n}=O(log(n))$</li></ul></li><li><p>$log_{b_1}(n)=O(log_{b_2}(n))$</p><blockquote><p>Bases in <code>O</code> notation are usually omitted.</p></blockquote></li></ul><h3 id="Big-Omega"><a href="#Big-Omega" class="headerlink" title="Big-Omega"></a>Big-Omega</h3><ul><li><p><strong>Lower</strong> bounds</p></li><li><p>$f(n)=Ω(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\geq{c*g(n)}\ (c&gt;0,n&gt;n0)$</p></li><li><p>Example</p><ul><li><p>$\sum{1/n}=Ω(log(n))$</p><blockquote><p><code>log(n)</code> is both bounds above and below, the difference is coefficient.</p></blockquote></li></ul></li></ul><h3 id="Big-Theta"><a href="#Big-Theta" class="headerlink" title="Big-Theta"></a>Big-Theta</h3><ul><li><strong>Tight</strong> bounds</li><li>$f(n)=Θ(g(n))$ when $f(n)=O(g(n))$ and $f(n)=Ω(g(n))$</li></ul><h2 id="Recurrence"><a href="#Recurrence" class="headerlink" title="Recurrence"></a>Recurrence</h2><script type="math/tex; mode=display">\begin{cases} T(n)=3T(n/4)+n^2&(n>1) \\ 1&(n=1) \tag{1} \end{cases}</script><ul><li>$n^2$ is workload of first level</li></ul><h3 id="Recursion-tree-Method"><a href="#Recursion-tree-Method" class="headerlink" title="Recursion-tree Method"></a>Recursion-tree Method</h3><p>$T(n) \leq n^2+3/16n^2+(3/16)^2n^2 + … =O(n^2)$</p><h3 id="Substitution-Method"><a href="#Substitution-Method" class="headerlink" title="Substitution Method"></a>Substitution Method</h3><p>Prove $T(n) \leq cn^2$.</p><p>$T(n)=3T(n/4)+n^2 \le3c(n/4)^2 =cn^2-(13c/16-1)n^2 \leq cn^2 (c\geq16/13)$</p><p>So when $c\geq16/13$, we can prove $T(n)\leq cn^2$.</p><blockquote><p>Since $T(n) \geq n^2$, then $Θ(n)=Ω(n)=O(n)$.</p></blockquote><h3 id="Master-Method-and-Master-Theorem"><a href="#Master-Method-and-Master-Theorem" class="headerlink" title="Master Method and Master Theorem"></a>Master Method and Master Theorem</h3><p>If $T(n)=aT(upper(\frac{n}{b}))+O(n^d)(a&gt;0,b&gt;1,d\geq0)$, then</p><script type="math/tex; mode=display">T(n)=\begin{cases} O(n^d)&d>lob_ba,b^d>a \\ O(n^dlogn)&d=lob_ba,b^d=a \\ O(n^{log_b{a}})&d<lob_ba,b^d<a \end{cases}</script><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;291&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;5~10&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter6-整数规划</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter6-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter6-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/</id>
    <published>2021-01-03T10:46:53.760Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>311</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>和普通规划模型不同，整数规划中的<strong>某些</strong>变量只能是整数。</li><li>纯整数规划：所有变量都是整数</li><li>混合整数规划：部分变量是整数</li><li>0-1规划：所有变量的取值只能为0或1<ul><li>常见模型：选择问题（投资项目）</li></ul></li><li>整数规划的最优解<strong>不一定</strong>出现在连续规划最优解的附近</li></ul><h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2><ul><li>求出连续情况下的最优解，例如$x_1=3.75$.</li><li>对$x_1$进行分支限界，在原问题增加约束$x1\leq 3$或$x_1\geq 4$，分别再求一次可行解。</li><li>例如在$x_1\geq 4$的分支上$x_2$不能求出整数解，则对$x_2$进行分支限界。</li><li>在限界过程中<ul><li>出现无解则抛弃该分支</li><li>出现之前被限界的变量$x_1$可行解为小数的情况，则需要对$x_1$再次进行分支限界。</li></ul></li><li>迭代上述过程，直到求出所有的可行解。</li><li>比较所有可行解，确定最优解。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;311&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter7-动态规划</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-01-03T10:46:53.760Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>428</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>动态规划的递归性质：将一个问题的最优解作为下一个问题的输入</p><ul><li><p>前向递归：把起点设在<strong>左边</strong>，然后进行递推。</p></li><li><p>后向递归：把起点设在<strong>右边</strong>，然后进行递推。</p></li><li><p>阶段划分：<code>n</code>层节点对应<code>(n-1)</code>个阶段</p></li><li><p>格式：设有<code>1-3</code>共<code>3</code>个阶段</p><ul><li><p>前向：<script type="math/tex">\begin{cases} f_i(x_i)=min\{f_{i-1}(x_{i-1})+d(x_{i-1},x_i)\} \\ f_0(x_0)=0\end{cases}</script></p></li><li><p>后向：<script type="math/tex">\begin{cases} f_i(x_i)=min\{f_{i+1}(x_{i+1})+d(x_{i},x_{i+1})\} \\ f_4(x_4)=0\end{cases}</script></p></li><li><p>每个阶段求解时，列出分类讨论的情况，并在最优值后用括号括出路径。</p><p>$f_3(1)=formula=min\{…\}=10$（节点<code>(i+1)</code>出发）</p></li></ul></li></ul></li><li><p>基本要素</p><ul><li>阶段：<code>i</code></li><li>各个阶段的可选方案（从阶段<strong>起点</strong>到阶段<strong>终点</strong>可以采用的方案）：<code>min/max</code>中对应的算法</li><li>各个阶段的状态（从整个模型的起点到该状态的累计）：<code>xi</code></li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><p>背包模型</p><p><img src="https://i.loli.net/2020/11/30/LbmSFM7Vc1J6GhX.png" alt="image-20201130114716371" style="zoom: 33%;" /></p><ul><li>当前阶段<strong>部分</strong>的解由<strong>当前状态</strong>决定</li></ul></li><li><p>劳动力规模模型</p><p><img src="https://i.loli.net/2020/11/30/JIA7ZEHw9QUKhra.png" alt="image-20201130114918767" style="zoom: 67%;" /></p><ul><li>当前阶段<strong>部分</strong>的解由<strong>前一阶段</strong>的状态决定</li></ul></li><li><p>设备更新模型</p><p><img src="https://i.loli.net/2020/11/30/EBsF5vDXRi1SoZj.png" alt="image-20201130115204212" style="zoom: 67%;" /></p><ul><li><p>当前阶段的解由不同的算法决定</p><blockquote><p>前两个模型不同的情况对应<strong>同样的</strong>算法</p></blockquote></li><li><p>通过画图确定不同阶段状态的可能取值</p><p><img src="https://i.loli.net/2020/11/30/43lSb1przDjTkRw.png" alt="image-20201130115505833" style="zoom:50%;" /></p></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;428&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter1-概论</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter1-%E6%A6%82%E8%AE%BA/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter1-%E6%A6%82%E8%AE%BA/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:37.860Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>363</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><ul><li>基本模型</li><li>基本步骤<ul><li>指定变量</li><li>确定可行域</li><li>寻找最优解</li></ul></li><li>线性规划模型</li><li>图解法</li><li>工程应用</li></ul><h2 id="线性规划图解法"><a href="#线性规划图解法" class="headerlink" title="线性规划图解法"></a>线性规划图解法</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>确定可行解空间</li><li>在可行点中确定最优解</li></ul><blockquote><p>求极大或极小的目标函数</p></blockquote><h2 id="工程应用"><a href="#工程应用" class="headerlink" title="工程应用"></a>工程应用</h2><ul><li>多元线性规划<ul><li><strong>不能</strong>使用图解法，应该使用算术进行求解。</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;363&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter2-单纯形算法</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter2-%E5%8D%95%E7%BA%AF%E5%BD%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter2-%E5%8D%95%E7%BA%AF%E5%BD%A2%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2162</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="等式形式"><a href="#等式形式" class="headerlink" title="等式形式"></a>等式形式</h2><ul><li>把约束全部转换为等式，且右端<strong>非负</strong>。</li><li>所有<strong>变量</strong>都是非负的（<strong>包括松弛变量</strong>）</li><li>解空间由<code>m</code>个同时成立的<strong>线性方程</strong>和<code>n</code>个<strong>非负变量</strong>表示</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>将不等式转换为等式</p><ul><li><p>增加<strong>松弛变量</strong></p><p>$x+y\leq24\rightarrow x+y+s=24(s\geq0)$</p></li><li><p>将右端项变为<strong>非负</strong>的（同乘<code>-1</code>）</p><p>$x+y\leq-19 \rightarrow x+y+s=-19(s\geq0) \rightarrow -x-y-s=19(s\geq0)$</p></li></ul><blockquote><p>如果是<strong>大于等于</strong></p><ul><li>先转换为<strong>小于等于</strong>再进行转换，但是如果右端无法非负，则只能使用改进单纯形方法。</li><li>使用$-s$作为松弛项</li></ul></blockquote></li></ul><h2 id="图形解和代数解"><a href="#图形解和代数解" class="headerlink" title="图形解和代数解"></a>图形解和代数解</h2><h3 id="图形解"><a href="#图形解" class="headerlink" title="图形解"></a>图形解</h3><ul><li>二维：线性规划</li><li>解空间有无穷个<strong>可行点</strong>，最优解的候选解通常是有限的。</li></ul><h3 id="代数解"><a href="#代数解" class="headerlink" title="代数解"></a>代数解</h3><ul><li>方程组有无穷个<strong>可行解</strong>，最优解的候选解对应的基本可行解通常是有限的。</li></ul><h3 id="角点"><a href="#角点" class="headerlink" title="角点"></a>角点</h3><ul><li>基本解一定对应解空间的一个（<strong>可行或不可行</strong>）的角点<ul><li>基本解：在方程组中选<code>m</code>个变量为0求解其他变量的方程得到的解<ul><li>变量包括新增的<strong>松弛变量</strong></li><li>方程组<strong>不包括</strong>非负约束（只计算加入了松弛变量的<strong>等式方程</strong>）</li><li>通过非负约束条件判断基本解是否可行（有一些角点不在可行域内）</li></ul></li></ul></li><li>角点的最大数目：$C_n^m$</li></ul><h2 id="单纯形方法"><a href="#单纯形方法" class="headerlink" title="单纯形方法"></a>单纯形方法</h2><ul><li>利用一个智能的搜索过程找到最优解</li><li>在搜素过程中，只能在可行域的边缘上移动，不能够“抄近路”。</li><li><strong>单纯形方法中求出的基本解都是可行的</strong></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><p>以<strong>最大化</strong>问题为例</p><ul><li><p>从原点<code>(0,0,...,0)</code>开始，即除松弛变量<strong>之外</strong>都作为<strong>非基变量</strong>（值为0）。</p><blockquote><p>单纯形法的选出的非基变量的组数和角点的最大数目不同，因为单纯形方法中的基变量组<strong>都是可行的</strong>。</p></blockquote></li><li><p><strong>最优性条件</strong>：每次增加一个变量，选择<strong>系数更大</strong>的变量作为<strong>进基变量</strong>。</p><blockquote><p>选择总是理性的</p></blockquote></li><li><p><strong>可行性条件</strong>：将进基变量带入，找到使进基变量取得<strong>最小非负值</strong>的方程选择<strong>离基变量</strong>。</p><blockquote><ul><li>最小的非负值保证了求到的解一定是在可行域中的，其他点并不在可行域中。</li><li>不是最小值，是<strong>最小非负值</strong>。</li><li>相当于求方程在进基变量维度的<strong>截距</strong></li></ul></blockquote></li><li><p>在离基变量方程中将进基变量系数化为1，然后把其他方程中该进基变量的系数化为0，包括目标函数。</p></li><li><p>求出进基变量的值对目标函数进行优化</p></li><li><p>当近基变量不能再被优化时，依次选择下一个进基变量。</p></li><li><p>$z=ax+by+…$形式中系数为负的非基变量<strong>不会被</strong>优化</p></li></ul><blockquote><p>最小化问题</p><ul><li>最优性条件和最大化相反，即选择系数更小（为<strong>负</strong>）的变量进行优化。最后确定最优解的表也要求所有的非基变量系数为<strong>负</strong>，表示不能够再向小优化了。</li><li>可行性条件<strong>相同</strong></li><li>系数全为正且没有添加松弛变量时求最小值，此时可能出现初始值就是最优解的情况，即不需要再进行优化。</li></ul></blockquote><h3 id="单纯形表"><a href="#单纯形表" class="headerlink" title="单纯形表"></a>单纯形表</h3><p>Gauss-Jordan运算</p><ul><li>一张单纯形表对应一组基变量</li><li><strong>基变量矩阵</strong>需要维持是<code>0-1</code>对角矩阵<ul><li>此时右侧的解列才<strong>直接等于</strong>基变量的值</li></ul></li><li>基变量所在的其他行（包括目标函数行），全部都利用<strong>枢轴行</strong>置为0.</li><li>当非基变量<strong>在表中</strong>系数都为正（即不能够再进行<strong>最大</strong>优化）时，单纯形表对应最优解。</li><li>进基变量可能在<strong>下一个</strong>变量进基时<strong>改变原有值</strong></li></ul><h2 id="改进单纯形方法"><a href="#改进单纯形方法" class="headerlink" title="改进单纯形方法"></a>改进单纯形方法</h2><ul><li>朴素单纯形方法只能够解决全是<code>&lt;=</code>约束条件和非负右端项的线性规划，因为增加松弛变量后并不影响初始解，即$Z-ax-by-0s_0-0s_1=0$仍成立。</li><li>对于存在<code>&gt;=</code>和<code>=</code>约束的最优化问题，则不能够直接增加松弛变量。<ul><li><code>&gt;=</code>：在右端本来为负数时，可以直接乘<code>-1</code>进行转换。但是右端为正时，增加$-s$松弛变量只能够起到变为<code>=</code>号的作用，并不能保证解空间依然合法。</li><li><code>=</code>：<strong>不需要</strong>增加松弛变量</li></ul></li></ul><h3 id="大M方法"><a href="#大M方法" class="headerlink" title="大M方法"></a>大M方法</h3><ul><li><p>对于不满足朴素单纯形的的约束条件（不能增加松弛变量/加了松弛变量不能保证解空间合法），将<strong>人工变量</strong>$R_i$加入<strong>初始解（人工变量非负）</strong>。</p><p>$min\ Z=4x+3y=4x+3y+0s_1+0s_2+M_1R_1+M_2R_2$</p><ul><li>$4x+3y\geq 6 \Rightarrow 4x+3y-s+MR=6$</li></ul></li><li><p>在<strong>目标函数</strong>中，对人工变量施加高惩罚使它在求解过程中变为零。</p><ul><li>将$M_1,M_2$的值设置的非常大，通常是其他系数的两个数量级。</li><li>$M\geq0$恒成立，故$MR\geq0$恒成立。</li><li>$M$可以<strong>全部</strong>取同一个值，只要满足“大”即可。</li></ul></li><li><p>在加入人工变量后，选择人工变量和松弛变量组为基变量，目标函数初始解不一定得到0，需要重新进行计算，以保证“<strong>基变量在目标函数中的系数为0</strong>”。</p></li><li><p>最后的单纯形表中的<strong>基变量数量</strong>可能<strong>大于</strong>原有的变量数，例如<code>x</code>/<code>y</code>/<code>s0</code>都是基变量。但是<code>s0</code>不影响最优解，此时<code>x</code>，<code>y</code>的值就是取得最优解时的值。</p><blockquote><p>作为最终解的基变量中</p><ul><li>有松弛变量，则松弛变量可以为任意值。</li><li>有人工变量，则人工变量必须为0，否则说明约束条件有问题。</li></ul></blockquote></li><li><p><strong>如果可行解存在，人工变量最后一定会等于0.</strong></p><blockquote><p>基变量数是由秩决定的，相当于在高维空间求出了低维空间的目标函数的最小值，这个最小值在低维空间<strong>依然是</strong>成立的。</p></blockquote></li></ul><h3 id="两阶段方法"><a href="#两阶段方法" class="headerlink" title="两阶段方法"></a>两阶段方法</h3><ul><li><p>在计算机中，大M方法可能会造成计算精度误差。</p></li><li><p>两阶段法采用<strong>不引入</strong>常数$M$的办法消除误差</p><ul><li><p>阶段一</p><ul><li><p>以是<strong>人工变量之和取最小值</strong>($min\ r=R_1+R_2$)来进行规划问题求解</p></li><li><p>判断是否有解空间，没有的话就结束，否则将人工变量列去除后，进入阶段二。</p></li></ul></li></ul></li><li>阶段二：使用阶段一得到的可行解作为原始问题的初始可行解，然后使用朴素单纯形算法计算。<ul><li>即将阶段一单纯形表中的<code>R1</code>，<code>R2</code>两列去掉后直接作为新的单纯形表，<strong>根据目标函数的系数</strong>重新对解进行计算。</li><li>之后就是朴素单纯形法工作</li></ul></li></ul><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><h3 id="退化"><a href="#退化" class="headerlink" title="退化"></a>退化</h3><ul><li>可行性条件中存在冗余（最小非负比循环出现），此时称新的基变量解为<strong>退化的</strong>。例如有一个约束条件的范围过大，没有对可行域起到任何限制作用。</li><li>表现：某个<strong>进基变量</strong>的<strong>最小非负比</strong>为0，对目标函数不能起到改善作用。</li></ul><h3 id="可选择最优解"><a href="#可选择最优解" class="headerlink" title="可选择最优解"></a>可选择最优解</h3><ul><li><p>目标函数平行于<strong>非冗余</strong>的紧约束，<strong>可能会</strong>有多个最优值。</p><blockquote><p>当变量是<strong>离散</strong>的时候，最优值可能只会有一个。</p></blockquote></li><li><p>表现：目标函数中<strong>非基变量</strong>的<strong>系数</strong>为0，对目标函数不能起到改善作用，但是会<strong>引起变量值的改变</strong>。</p></li><li><p>作用：从多个最优解中选择，但不会损害目标值。（现实意义大）</p></li></ul><h3 id="无界解"><a href="#无界解" class="headerlink" title="无界解"></a>无界解</h3><ul><li>某个变量可以无限大，但是<strong>不会</strong>影响约束条件。</li><li>表现：进基变量的最小非负比是无穷大</li></ul><h3 id="不可行解"><a href="#不可行解" class="headerlink" title="不可行解"></a>不可行解</h3><ul><li>具有不相容约束的线性规划模型没有可行解<ul><li><strong>人工变量不为零</strong>时取得最优解，说明原模型有问题。</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2162&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter4-运输问题</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter4-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter4-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1277</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><strong>最小化</strong>问题：路线等条件确定，目标是使运输费用最低。</li><li>一般的运输问题使用<strong>网络图</strong>表示</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>使用单纯形方法可以求解，但是较为复杂。</li><li>通常使用<strong>运输表</strong>求解</li><li>平衡问题（供应量和需求量关系）：当模型<strong>不平衡</strong>时，可以增加一个<strong>虚设起点</strong>或<strong>虚设终点</strong>使模型平衡。<ul><li>虚设起点或终点的运输成本应该<strong>设为0</strong>，保证不影响真实模型的最优解。</li><li><strong>不存在</strong>起点和终点同时增加的情况</li></ul></li></ul><h2 id="非传统运输问题"><a href="#非传统运输问题" class="headerlink" title="非传统运输问题"></a>非传统运输问题</h2><p>例如多方式供货问题，每个月的需求量和供应量不等，月份之间的货物可以<strong>交叉供应</strong>。</p><ul><li>起点：不同的月份的生产</li><li>终点：不同的月份的需求</li><li>运费：当月生产费及发生交叉供应时对应的存储费或延期费</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li><p>依然采用单纯形法的步骤，只是使用运输表替代单纯形表。</p></li><li><p>设<code>m</code>个起点和<code>n</code>个终点，则共有<code>(m+n)</code>个等式约束，对应<code>(m+n)</code>个基变量。</p><ul><li><p>在供需平衡的前提下，仅需要<code>(m+n-1)</code>个等式约束，及初始基本解由<code>(m+n-1)</code>个基变量组成，也就是说<strong>最优解中，最多有<code>(m+n-1)</code>个非0变量。</strong></p><blockquote><p>基变量<strong>可以为零</strong>，非基变量<strong>一定为零</strong>。</p></blockquote></li></ul></li><li><p><strong>初始解</strong>确定（不是最优解）</p><ul><li><p>西北角法：找到一个<strong>相对较优</strong>的初始解</p><ul><li><p>从西北角元素开始，选择<code>min(需求，供应)</code>，并更新行列需求。</p></li><li><p>对于更新后为0的行<strong>或</strong>列，可以直接从表中删去。</p></li><li><p>对于更新后同时为0的行<strong>和</strong>列，在行和列中任意选择一个删除。</p><blockquote><p>只能删除一个元素时，下一个元素在下方和右方任意选择，只要不跨斜角即可。</p></blockquote></li></ul></li><li><p>最小费用法：找到<strong>相对西北角法更优</strong>的初始解</p><ul><li><p>选择费用最小的结点，并更新行列需求。</p><blockquote><ul><li>出现费用相等的结点时，任意选择一个即可。</li><li>对于为供应量取值为0的<strong>最小费用路径点</strong>，<strong>不能够省略</strong>，因为它依然是一个<strong>基变量</strong>。</li></ul></blockquote></li><li><p>删除方法和西北角法相同</p></li></ul></li><li><p>Vogel（沃格尔）近似法：在最小费用法上进一步优化，避免删除过多行列后造成很高的费用被选择。</p><ul><li><p>设置惩罚量=<strong>同行/列</strong>的次小费用-最小费用</p></li><li><p>找出惩罚量<strong>最大</strong>的行或列，为<strong>最小费用单元</strong>分配尽可能多的供应量（即$min(供应，需求)$）。</p><blockquote><p>思想是为了能够把费用较大的结点借最小费用单元置零来删除</p></blockquote></li><li><p>在删除某一<strong>列</strong>后，需要更新<strong>行惩罚量</strong>，反之亦然。</p></li></ul></li></ul></li><li><p><strong>最优解</strong>确定：使用初始解作为基变量，然后使用单纯形法。</p><ul><li><p>通常使用西北角法确定初始解</p></li><li><p>乘子法：用$u_i$和$v_j$表示第$i$行和第$j$列的乘子，用于确定$Z$行非基变量的系数。（基变量系数为0）</p><ul><li><p>对任意<strong>基变量</strong>：$u_i+v_j=c_{i,j}$</p></li><li><p>初始设$u_0=0$，然后导出所有的乘子。</p></li><li><p>$Z$行中<strong>非基变量</strong>的系数=$u_i+v_j-c_{i,j}$</p><blockquote><p>通常在非基变量表格框的<strong>右下角</strong>写出系数</p></blockquote></li></ul></li><li><p>单纯形法直接在运输表上进行，不需要使用单纯形表。</p><ul><li><p>将进基变量设置为$\theta$，然后通过供需平衡调整各个基变量的值，利用<strong>非负条件</strong>求出$\theta$最大值。</p><blockquote><p>规律：需要被调整的基变量可以构成<strong>直角封闭多边形</strong></p></blockquote></li><li><p>利用$\theta_{max}$任意选择一个新值为0的<strong>原基变量</strong>作为<strong>离基变量</strong></p></li><li><p>更新乘子后重复迭代，直到$Z$行不能再被优化，即所有非基变量的系数都为小于等于0。（<strong>必要条件</strong>）</p><blockquote><p>尽管某些非基变量的系数大于0，但是求出的$\theta=0$，也就是说此时选择该非基变量进基不能够对问题的解产生优化效果，故<strong>系数大于0不是能产生优化效果的充分条件，而是一个必要条件。</strong></p><p>例如以下运输表格在使用西北角法+令<code>x11</code>作为离基变量时就会出现<code>x31</code>系数为正但是$\theta=0$的情况。</p><p>| 2    | 3    | 3    | 9         |<br>| —— | —— | —— | ————- |<br>| 1    | 2    | 4    | 15        |<br>| 3    | 4    | 5    | 6         |<br>| 5    | 10   | 15   | 需求/供给 |</p></blockquote></li></ul></li><li><p>在迭代后求最优解时，可以直接利用上一个$Z$值减去（改善量$\theta_{max}$*非基变量系数）得到改善后的$Z$值。</p></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1277&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter3-对偶理论与灵敏度分析</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter3-%E5%AF%B9%E5%81%B6%E7%90%86%E8%AE%BA%E4%B8%8E%E7%81%B5%E6%95%8F%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter3-%E5%AF%B9%E5%81%B6%E7%90%86%E8%AE%BA%E4%B8%8E%E7%81%B5%E6%95%8F%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>820</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>图形（二维）<ul><li>右端项（约束条件）变化：最优解对<strong>资源的可利用性</strong>的灵敏度<ul><li>改变约束条件的截距</li></ul></li><li>目标系数（目标函数）变化：最优解对<strong>单位利润和单位费用</strong>的灵敏度<ul><li>改变目标函数的斜率</li><li>最优性区域：改变斜率但是最优解<strong>不变</strong>的斜率取值范围</li></ul></li></ul></li><li>代数（高维）<ul><li>右端项变化</li><li>目标系数变化</li></ul></li></ul><h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul><li><strong>线性规划</strong>中目标函数改善的灵敏度是<strong>均匀的</strong></li></ul><h3 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h3><ul><li><p>对偶价格：松弛变量在最优方程中的系数（一定大于0，否则说明仍<strong>不是</strong>最优解）</p><ul><li>当系数大于0时，说明<strong>减小松弛变量</strong>就能带来收益，即增大原变量的左值，也即<strong>右端项</strong>的值。</li></ul></li><li><p>可行性区域：使对偶价格有效的区域，即对偶价格的变化的目标函数的影响<strong>保持线性</strong>的区域。</p><ul><li><strong>可行域</strong>对应的系数矩阵和<strong>松弛变量</strong>的系数矩阵相同，但是可行域在<strong>右端</strong>。</li><li>利用决策变量和松弛变量的约束条件反解可行域<ul><li>求解某个可行域时将其他可行域的值设为0</li></ul></li></ul></li><li><p>最优性区域：将改变松弛量加在目标函数系数上</p><p>$max\ z=(3+d1)x_1+(2+d_2)x_2+(5+d_3)x_3$</p></li></ul><h2 id="对偶理论"><a href="#对偶理论" class="headerlink" title="对偶理论"></a>对偶理论</h2><ul><li><p>将原模型转换为对偶模型后进行最优解计算，然后再对最优解进行<strong>特定矩阵操作</strong>即可得到原模型的最优解。</p><blockquote><p>对偶问题的解和原问题解需要特殊矩阵运算进行转化</p></blockquote></li></ul><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul><li><p>约束$\Longleftrightarrow$变量（所有变量，包括剩余变量、松弛变量、人工变量）</p><ul><li><strong>一条</strong>约束对应<strong>一个</strong>对偶变量</li></ul></li><li><p>右端项$\Longleftrightarrow$决策系数</p></li><li><p>约束方向、求解目标（最大/最小）反向</p><p>| 原问题目标 | 对偶问题目标 | 对偶问题约束方向 |<br>| ————— | —————— | ———————— |<br>| 极大化     | 极小化       | <code>&gt;=</code>             |<br>| 极小化     | 极大化       | <code>&lt;=</code>             |</p><ul><li>不论原问题中的约束是什么方向，对偶问题中约束方向<strong>只和原问题的目标</strong>有关。</li></ul></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对于等式约束<strong>不需要</strong>增加松弛、人工变量（不需要求最优解，只要转换成等式形式即可）</li><li>为每个约束条件定义一个对偶变量</li><li>约束条件中的系数<strong>列</strong>$\Rightarrow$对偶约束条件系数<strong>行</strong></li><li>约束条件的目标函数系数$\Rightarrow$对偶约束的<strong>右端项</strong></li><li>约束条件的右端项$\Rightarrow$对偶目标函数系数</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li><p>对偶变量的最优值=最优原始基变量的原目标系数行向量*最优原始逆矩阵</p></li><li><p>对偶变量<strong>不一定</strong>满足非负条件，因此对偶问题<strong>不可以</strong>直接使用单纯形方法求解。</p><blockquote><p>对于不满足的情况，可以分类讨论，每次分类设置新变量满足非负条件。</p></blockquote></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;820&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter5-目标规划</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter5-%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter5-%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>363</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>线性规划模型是对<strong>单个</strong>目标函数进行优化</li><li>目标规划情景下，多个约束通常<strong>不能</strong>够构成<strong>解空间</strong>，只能够根据不同目标的重要程度，得到折中的解。</li><li><p>将目标变为弹性的，然后根据实际情况确定是增加还是减少。</p><ul><li><p>添加$+S^-$和$-S^+$两个变量表示偏离程度，最终有一个必定为0（不可能同时既多又少）。</p><ul><li>$S^-$表示实际情况相比约束条件缺少的部分，因此<code>&gt;=</code>约束中要减少。</li><li>$S^+$表示实际情况相比约束条件多余的部分，因此<code>&lt;=</code>约束中要减少。</li></ul></li><li><p>优化目标是让各个约束的偏离程度最小化</p></li><li><p>实例</p><p><img src="https://i.loli.net/2020/11/16/vZ2GCbBdEsqKp6X.png" alt="image-20201116114612320" style="zoom:50%;" /></p><p><img src="https://i.loli.net/2020/11/16/LJ7BluCFyIf5GSZ.png" alt="image-20201116115451654" style="zoom:50%;" /></p></li></ul></li></ul><h2 id="权和法"><a href="#权和法" class="headerlink" title="权和法"></a>权和法</h2><ul><li><p>为多个$S_i$的最小化目标函数指定权值，然后合并为一个目标函数。</p><ul><li><p>权重需要<strong>归一化</strong></p><p>$minZ=2G_1+2G_2\to \frac{2}{3}S_1^-+\frac{1}{3}S_2^+$</p></li></ul></li><li><p>权和法找到的是<strong>有效解</strong>，而不一定是最优解。</p></li><li><p>求出偏离程度不为0，实际上是两阶段方法人工变量不为0的一种特殊情况。</p></li><li><p>拓展：设定优先权法</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;363&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter6-图像处理</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter6-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter6-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</id>
    <published>2020-12-04T03:28:44.164Z</published>
    <updated>2020-12-04T03:41:47.630Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>3427</code>字，推荐阅读时间<code>25~30</code>分钟。</p><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><p>采样（空间离散）：将连续图像变化为离散点的操作，即将图像划分为$M * N$网格，每个网格只提取出一个值。</p><blockquote><ul><li>上采样（图像插值、放大）：放大原图像，从而可以显示在更高分辨率的显示设备上。</li><li>下采样（池化、缩小）：使得图像符合显示区域的大小；生成对应图像的缩略图；降低特征的维度并保留有效信息，一定程度上避免过拟合，保持旋转、平移、伸缩不变形。</li></ul></blockquote></li><li><p>分辨率：采样划分网格矩阵的形状尺寸</p></li><li><p>量化（灰度离散）：确定离散点数值表示的位数，反映了采样的质量。</p><ul><li><p>灰度图：1个通道，每个离散点8bit(0-255).</p><blockquote><ul><li>256个值对应的是从黑到白的不同<strong>亮度</strong>等级，<code>0</code>是纯黑，<code>255</code>是纯白。</li><li>彩色图中的RGB值也并不是各个颜色的“浓度”，只是三个分量的灰度值，分别命名为R，G，B.也就是说，RGB图各分量<strong>并不是</strong>彩色的，而是三张灰度图，RGB只是一种来自三原色的命名。</li><li>当三色灰度”效果“相同时，产生不同灰度值的灰色调。<ul><li><code>Gray = R*0.299 + G*0.587 + B*0.114</code>（心理学公式）</li><li><code>Gray = (R*299 + G*587 + B*114 + 500) / 1000</code></li></ul></li></ul></blockquote></li><li><p>二值图：1个通道，每个离散点1bit(0-1).</p></li><li><p>彩色图：3个通道（3张灰度图），各个通道每个离散点8bit(0-255)，合成为24bit.</p><ul><li><p>以红色椅子的显示为例。</p><p>R分量的图上，椅子对应的部分比较浅（灰度值高），而在G分量和了B分量上很深。<br>随便在椅子上取一个样点，其灰度值分别是（R:179,G:45,B:9）。所以在显示的时候，红色通道里灰度值大，绿色通道和蓝色通道里的灰度值小，显示出来的就是红色。</p><blockquote><p>用灰度图的<strong>亮暗</strong>来表示三种颜色的浓度，每个通道就是指定了颜色的”颜料“，然后合并出不同的颜色，和自然界中的光的合成<strong>并不相同</strong>。</p></blockquote></li></ul></li></ul><blockquote><p>视频尺寸：时域离散*空域（空间）离散*灰度离散=<u>FPS</u>*<u>1080*720</u>*<u>3*8</u></p></blockquote></li><li><p>矢量图（图形）：一般由轮廓线构成，是用软件绘制的。不易失真，但是颜色相对没有那么丰富。</p></li><li><p>点阵图（位图，图像）：设备捕捉实际画面产生的数字矩阵，存储空间大，颜色丰富。</p></li></ul><h2 id="类型及转换"><a href="#类型及转换" class="headerlink" title="类型及转换"></a>类型及转换</h2><ul><li><p>格式</p><ul><li><p><code>double</code>：亮度值范围是<code>[0,1]</code></p><blockquote><p>通常使用<code>double</code>减少图像失真</p></blockquote></li><li><p><code>uint8</code>：亮度值范围是<code>[0,255]</code></p></li></ul></li><li><p>真彩色图像</p><ul><li>大小：<code>m*n*3</code></li><li>红色分量：<code>(:,:,1)</code>（绿色，蓝色同理）</li></ul></li><li><p>索引图像：创建调色板及对应的索引图，使用索引下标表示图像的每个像素点。</p><ul><li>调色板中色彩强度范围是<code>[0,1]</code>，大小和亮度成正比。</li><li>使用索引可以有效节省存储空间</li></ul></li><li><p>图像序列</p><ul><li><p>合并</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">cat</span> (<span class="number">1</span>，A1，A2，A3，A4，A5) <span class="comment">%按列连接（列数相同）</span></span><br><span class="line">A = <span class="built_in">cat</span> (<span class="number">2</span>，A1，A2，A3，A4，A5) <span class="comment">%按行连接（行数相同）</span></span><br><span class="line">A = <span class="built_in">cat</span> (<span class="number">3</span>，A1，A2，A3，A4，A5) <span class="comment">%按矩阵连接（行列数相同）</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cat</code>的参数是几就是<strong>改变</strong>第几维</p></blockquote></li></ul></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p><code>imread</code>：读入图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=imread(filename, fmt) <span class="comment">% imread('filename.fmt')</span></span><br><span class="line">[A, map]=imread(filename, fmt) <span class="comment">% index image</span></span><br></pre></td></tr></table></figure><ul><li>读入的图像大多数为<code>uint8</code>，对于索引图则将颜色映象表存储为双精度浮点型矩阵。</li><li>如果将<code>filename</code>和<code>fmt</code>合并，则需要保证<code>filename.fmt</code>后缀的合法性。</li></ul></li><li><p><code>imwrite</code>：输出图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imwrite(A, filename, fmt) <span class="comment">% imwrite(A, 'filename.fmt')</span></span><br><span class="line">imwrite(A, map, filename, fmt)</span><br></pre></td></tr></table></figure></li><li><p><code>imfinfo</code>：获取图片信息</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imfinfo(<span class="string">'filename.fmt'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>load/save</code>：使用<code>.mat</code>文件管理图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lena=imread(<span class="string">'lena.jpg'</span>); </span><br><span class="line">imshow(lena);</span><br><span class="line">save lena; <span class="comment">%保存图像数据，生成lena.mat</span></span><br><span class="line">clear;</span><br><span class="line">load lena;</span><br><span class="line"><span class="built_in">figure</span>, imshow(lena);</span><br></pre></td></tr></table></figure></li></ul><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><ul><li><p>灰度图</p><ul><li><p>格式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imshow(I)</span><br><span class="line">imshow(I, n) <span class="comment">% n为显示灰度级数目，缺省值为256.</span></span><br><span class="line">imshow(I, [low high]) <span class="comment">% [low high]为图像数据的值域，范围外的取0或255.</span></span><br><span class="line">imshow(I, []) <span class="comment">% 默认显示范围为[min(I(:);), max(I(:);)]</span></span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(I);</span><br><span class="line"><span class="comment">%设置显示的范围，低于100的全黑，高于200的全白</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,[<span class="number">100</span> <span class="number">200</span>]);</span><br><span class="line"><span class="comment">%设置灰度级别为2; 部分版本不支持</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%设置灰度级别为8 ; 同上</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">8</span>);</span><br><span class="line"><span class="comment">%设置灰度级别为全256 ; 同上</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二值图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BW=imread(<span class="string">'circles.png'</span>);</span><br><span class="line">imshow(BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(~BW);</span><br></pre></td></tr></table></figure></li><li><p>索引图像</p><ul><li><p>格式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imshow(X, map);</span><br></pre></td></tr></table></figure><ul><li><code>map</code>是一个p×3的矩阵，元素值均为[0, 1]之间双精度浮点型数据。每一行分别表示红、绿、蓝的颜色值。</li><li>如一幅包含256色的uint8<strong>索引图像</strong>，使用一个仅有16色的调色板显示，则所有索引值大于或等于15的像素都将被显示为调色板的最后一个颜色。</li><li>常用后缀名：<code>.tiff</code>/<code>.tif</code></li></ul></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X=imread(<span class="string">'cameraman.tif'</span>); </span><br><span class="line">imshow(X); </span><br><span class="line">colorbar;</span><br><span class="line">map=pink(<span class="number">256</span>); <span class="comment">%借助不同的调色板显示图像</span></span><br><span class="line"><span class="built_in">figure</span>, imshow(X,map); colorbar; <span class="comment">%显示颜色条</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>彩色图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%调整RGB的显示顺序</span></span><br><span class="line">img=imread(<span class="string">'i.png'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(img);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(img(:,:,[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]));</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>), imshow(img(:,:,[<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]));</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>), imshow(img(:,:,[<span class="number">3</span> <span class="number">1</span> <span class="number">2</span>]));</span><br></pre></td></tr></table></figure><blockquote><p>Q：RGB的顺序为什么对显示效果有影响</p><p>A：不同通道对应的”颜料“不同，成像时根据放进该通道的<strong>灰度图分量</strong>的灰度值，来决定显示的颜色。</p></blockquote></li></ul><h2 id="代数运算"><a href="#代数运算" class="headerlink" title="代数运算"></a>代数运算</h2><ul><li><p><code>imadd</code>：加法，数值变大。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line"><span class="comment">%图像整体亮度增加</span></span><br><span class="line">J=imadd(I, <span class="number">50</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(J);</span><br></pre></td></tr></table></figure><ul><li>超出范围的部分<strong>不会</strong>溢出，而是取<strong>边界值</strong>。</li></ul><blockquote><ul><li>图像增强</li><li>图像重叠</li><li>水印加密</li><li>图像去噪</li></ul></blockquote></li><li><p><code>imsubtract</code>：减法，数值变小。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line">J=imsubtract(I, <span class="number">50</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(J);</span><br></pre></td></tr></table></figure></li><li><p><code>immultiply</code></p><ul><li><p><code>immultiply(I, n)</code>：亮度缩放</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line">J = immultiply(I,<span class="number">0.5</span>);</span><br><span class="line">K = immultiply(I,<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>), imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>), imshow(J)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>), imshow(K)</span><br></pre></td></tr></table></figure></li><li><p><code>immultiply(I, mask)</code>：掩模</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Img=imread(<span class="string">'pears.png'</span>);</span><br><span class="line">subplot(<span class="number">131</span>), imshow(Img);</span><br><span class="line">Mask=imread(<span class="string">'PearMask.bmp'</span>);</span><br><span class="line">subplot(<span class="number">132</span>), imshow(Mask);</span><br><span class="line">PearR=immultiply(Img(:,:,<span class="number">1</span>),Mask);</span><br><span class="line">PearG=immultiply(Img(:,:,<span class="number">2</span>),Mask);</span><br><span class="line">PearB=immultiply(Img(:,:,<span class="number">3</span>),Mask);</span><br><span class="line">Pear=<span class="built_in">cat</span>(<span class="number">3</span>,PearR,PearG,PearB);</span><br><span class="line">subplot(<span class="number">133</span>), imshow(Pear);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>imdivide</code></p><ul><li><p><code>imdivide(I, n)</code>：亮度缩放</p></li><li><p><code>imdivide(I, J)</code>：去除背景</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'rice.png'</span>);</span><br><span class="line">subplot(<span class="number">131</span>),imshow(I);</span><br><span class="line">background = imopen(I,strel(<span class="string">'disk'</span>,<span class="number">15</span>));</span><br><span class="line">subplot(<span class="number">132</span>), imshow(background);</span><br><span class="line">Ip = imdivide(I,background);</span><br><span class="line">subplot(<span class="number">133</span>),imshow(Ip,[])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>直接线性运算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I)</span><br><span class="line">J=(double(I))*<span class="number">1.5</span>+<span class="number">30</span>;</span><br><span class="line"><span class="built_in">figure</span>, imshow(uint8(J))</span><br><span class="line">K=(double(I))*<span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">figure</span>, imshow(uint8(K));</span><br></pre></td></tr></table></figure></li></ul><h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><ul><li><p><code>imtransform(I, T, Interp)</code>：二维空间</p><ul><li><code>T</code>：变换结构，由<code>maketform</code>产生。</li><li><code>Interp</code>：插值方法</li></ul></li><li><p>仿射变换</p><p><img src="https://i.loli.net/2020/11/19/E5Sm6GgzvuiwZOn.png" alt="image-20201119133406026" style="zoom:50%;" /></p><ul><li><p>平移</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[height,width,dim]=<span class="built_in">size</span>(A);</span><br><span class="line">tform=maketform(<span class="string">'affine'</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">20</span> <span class="number">30</span> <span class="number">1</span>]); <span class="comment">% downward</span></span><br><span class="line">B = imtransform(A,tform,<span class="string">'nearest'</span>,<span class="string">'XData'</span>,[<span class="number">1</span></span><br><span class="line"><span class="built_in">size</span>(A,<span class="number">2</span>)],<span class="string">'YData'</span>,[<span class="number">1</span> <span class="built_in">size</span>(A,<span class="number">1</span>)])</span><br><span class="line">subplot(<span class="number">121</span>);imshow(A);</span><br><span class="line">subplot(<span class="number">122</span>); imshow(B);</span><br></pre></td></tr></table></figure></li><li><p>镜像</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[height,width,dim]=<span class="built_in">size</span>(A);</span><br><span class="line">tform=maketform(<span class="string">'affine'</span>,[<span class="number">-1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]); <span class="comment">% horizontal</span></span><br><span class="line">B=imtransform(A,tform,<span class="string">'nearest'</span>);</span><br><span class="line">tform2=maketform(<span class="string">'affine'</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]); <span class="comment">% vertical</span></span><br><span class="line">C=imtransform(A,tform2,<span class="string">'nearest'</span>);</span><br><span class="line">subplot(<span class="number">131</span>); imshow(A);</span><br><span class="line">subplot(<span class="number">132</span>); imshow(B);</span><br><span class="line">subplot(<span class="number">133</span>); imshow(C);</span><br></pre></td></tr></table></figure></li><li><p>旋转</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">transformtype = <span class="string">'affine'</span>;</span><br><span class="line">transformmatrix = [<span class="built_in">cos</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="number">0</span>;</span><br><span class="line">   -<span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="built_in">cos</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="number">0</span>;</span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]; <span class="comment">% rotate 30 degrees</span></span><br><span class="line">T = maketform(transformtype,transformmatrix);</span><br><span class="line">nI = imtransform(I,T);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(nI)</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>imrotate(A, angle)</code>，指定<code>crop</code>参数后会裁剪新图以维持画布大小不变，</p></blockquote></li><li><p>缩放</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>); <span class="built_in">figure</span>, imshow(I)</span><br><span class="line">transformtype = <span class="string">'affine'</span>;</span><br><span class="line">transformmatrix1 = [<span class="number">0.5</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0.5</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">transformmatrix2 = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">2</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">T1 = maketform(transformtype,transformmatrix1);</span><br><span class="line">T2 = maketform(transformtype,transformmatrix2);</span><br><span class="line">nI1 = imtransform(I,T1);</span><br><span class="line">nI2 = imtransform(I,T2);</span><br><span class="line"><span class="built_in">figure</span>,imshow(nI1)</span><br><span class="line"><span class="built_in">figure</span>,imshow(nI2)</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>imresize(A, times)</code>，默认等比例缩放。</p></blockquote></li></ul></li><li><p>投影变换：将二维图像按照“近大远小”的规则投影到一个平面，追求立体感。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">transformtype = <span class="string">'projective'</span>;</span><br><span class="line">transformmatrix1 =[<span class="number">0.8</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">-0.2</span> <span class="number">0.8</span> <span class="number">-0.003</span>; <span class="number">3.5</span> <span class="number">1.5</span> <span class="number">1.5</span>];</span><br><span class="line">T = maketform(transformtype,transformmatrix1);</span><br><span class="line">nI = imtransform(I,T);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(nI);</span><br></pre></td></tr></table></figure><blockquote><ul><li>对失真图像进行逆变换，就可以得到正常比例的图像。</li><li>仿射变换可看作是一种特殊的投影变换。它要求变换矩阵的最后一列除最后一个元素为<code>1</code>之外，其它的均为<code>0</code>。</li></ul></blockquote></li><li><p><code>imcrop</code>：图像裁剪</p><ul><li><p>指定区域</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = imread(<span class="string">'liftingbody.png'</span>);</span><br><span class="line">pc = imcrop(p,[<span class="number">80</span> <span class="number">180</span> <span class="number">260</span> <span class="number">220</span>]); <span class="comment">%输入矩形尺度进行选取</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>); imshow(p);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>); imshow(pc);</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>参数格式：<code>[left, bottom, width, height]</code></p></blockquote><ul><li><p><code>roipoly</code>：多边形裁剪</p><ul><li><p>人工选区</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Img=imread(<span class="string">'pears.png'</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(Img)</span><br><span class="line">bw=roipoly(Img); <span class="comment">%设定区域，用鼠标选择多边形区域</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(bw) <span class="comment">%用二值色彩显示多边形区域</span></span><br><span class="line">r=Img (:,:,<span class="number">1</span>); g=Img (:,:,<span class="number">2</span>);b=Img (:,:,<span class="number">3</span>);</span><br><span class="line">cr=bw.*double(r); cg=bw.*double(g);cb=bw.*double(b);</span><br><span class="line">J=<span class="built_in">cat</span>(<span class="number">3</span>,uint8(cr),uint8(cg),uint8(cb)); <span class="comment">%联结数组作为图像色彩</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(J)</span><br></pre></td></tr></table></figure></li><li><p>指定顶点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'eight.tif'</span>);</span><br><span class="line">c = [<span class="number">222</span> <span class="number">272</span> <span class="number">300</span> <span class="number">270</span> <span class="number">221</span> <span class="number">194</span>];</span><br><span class="line">r = [<span class="number">21</span> <span class="number">21</span> <span class="number">75</span> <span class="number">121</span> <span class="number">121</span> <span class="number">75</span>];</span><br><span class="line">BW = roipoly(I,c,r);</span><br><span class="line">Ic=immultiply(I, BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I)</span><br><span class="line"><span class="built_in">figure</span>, imshow(BW)</span><br><span class="line"><span class="built_in">figure</span>, imshow(Ic)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h2><ul><li><p><code>imadjust</code>：对某一区间内的灰度值进行变换，从而符合人眼的非线性特征。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'pout.tif'</span>); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>); imshow(I);</span><br><span class="line">J=imadjust(I); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>); imshow(J); <span class="comment">% default gamma = 1</span></span><br><span class="line">K=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>); imshow(K);</span><br><span class="line">L=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>], <span class="number">2</span>); <span class="comment">% gamma = 2</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); imshow(L);</span><br><span class="line">M=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>], <span class="number">0.3</span>); <span class="comment">% gamma = 0.3</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>); imshow(M);</span><br><span class="line">N=imadjust(I,[<span class="number">0</span> <span class="number">1</span>],[<span class="number">1</span> <span class="number">0</span>]); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>); imshow(N);</span><br></pre></td></tr></table></figure><ul><li>不指定参数时，默认处理最高和最低的<code>1%</code>，从而提高图像饱和度。</li><li><code>gamma</code>越大，图像亮度越大。</li></ul></li><li><p><code>imhist</code>：灰度分布直方图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), imhist(I);</span><br></pre></td></tr></table></figure><ul><li>可以通过参数指定灰度等级数</li><li>占满整个区间的图像通常质量更高</li></ul></li><li><p><code>histeq</code>：直方图均衡化</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'pout.tif'</span>);</span><br><span class="line">subplot(<span class="number">221</span>),imshow(I);title(<span class="string">'原图'</span>);</span><br><span class="line">subplot(<span class="number">222</span>),imhist(I);title(<span class="string">'原图直方图'</span>);</span><br><span class="line">hI=histeq(I);</span><br><span class="line">subplot(<span class="number">223</span>),imshow(hI);</span><br><span class="line">title(<span class="string">'原图均衡化处理'</span>);</span><br><span class="line">subplot(<span class="number">224</span>),imhist(hI);</span><br><span class="line">title(<span class="string">'均衡处理后直方图'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h2><ul><li><p>平滑</p><ul><li>低通滤波：低频段保留</li><li>均值滤波</li><li>中值滤波</li></ul></li><li><p>锐化</p><ul><li>高通滤波：高频段保留</li></ul></li><li><p><code>imnoise</code>：模拟图像噪声</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'coins.png'</span>);</span><br><span class="line">J=imnoise(I, <span class="string">'salt &amp; pepper'</span>,<span class="number">0.06</span>); <span class="comment">%添加椒盐噪声</span></span><br><span class="line">subplot(<span class="number">221</span>),imshow(I),title(<span class="string">'原图'</span>)</span><br><span class="line">subplot(<span class="number">222</span>),imshow(J),title(<span class="string">'含椒盐噪声图'</span>)</span><br><span class="line">H = fspecial(<span class="string">'average'</span>,[<span class="number">3</span> <span class="number">4</span>]); <span class="comment">%设计均值滤波器H</span></span><br><span class="line">am = imfilter(J,H);<span class="comment">%均值滤波</span></span><br><span class="line">subplot(<span class="number">223</span>),imshow(am),title(<span class="string">'均值滤波'</span>)</span><br><span class="line">zm=medfilt2(J);<span class="comment">%中值滤波</span></span><br><span class="line">subplot(<span class="number">224</span>),imshow(zm),title(<span class="string">'中值滤波‘)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="边缘检测与分割"><a href="#边缘检测与分割" class="headerlink" title="边缘检测与分割"></a>边缘检测与分割</h2><ul><li><p><code>edge</code>：边缘处值为1，否则为0.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[e1,s1] = edge(p,<span class="string">'sobel'</span>,<span class="number">0.03</span>,<span class="string">'both'</span>); <span class="comment">% sobel算子</span></span><br><span class="line">[e2,s2] = edge(p,<span class="string">'roberts'</span>,<span class="number">0.03</span>,<span class="string">'both'</span>); <span class="comment">% roberts算子</span></span><br><span class="line">[e3,s3] = edge(p,<span class="string">'prewitt'</span>,<span class="number">0.04</span>,<span class="string">'both'</span>); <span class="comment">% prewitt算子</span></span><br><span class="line">[e4,s4] = edge(p, <span class="string">'log'</span>,<span class="number">0.003</span>,<span class="number">2.10</span>); <span class="comment">% LoG算子</span></span><br><span class="line">[e5,s5] = edge(p, <span class="string">'canny'</span>,[<span class="number">0.05</span> <span class="number">0.12</span>],<span class="number">1.6</span>); <span class="comment">%canny算子</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>),imshow(p);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>),imshow(e1);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),imshow(e2);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);imshow(e3);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>),imshow(e4);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>),imshow(e5);</span><br></pre></td></tr></table></figure></li><li><p><code>imcontour</code>：轮廓提取函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">subplot(<span class="number">131</span>), imcontour(I,<span class="number">1</span>)</span><br><span class="line">subplot(<span class="number">132</span>), imcontour(I,<span class="number">2</span>)</span><br><span class="line">subplot(<span class="number">133</span>), imcontour(I,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>阈值分割</p><ul><li><p>极小值点</p></li><li><p>迭代</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p= imread(<span class="string">'bugs.bmp'</span>);</span><br><span class="line">p=rgb2gray(p); p=im2double(p); <span class="comment">%转换为double</span></span><br><span class="line">thresh = <span class="number">0.5</span>*(<span class="built_in">min</span>(p(:)) + <span class="built_in">max</span>(p(:))); <span class="comment">%初值为中间值</span></span><br><span class="line">flag = <span class="built_in">false</span>; <span class="comment">%迭代步长控制</span></span><br><span class="line"><span class="keyword">while</span> ~flag</span><br><span class="line">g = p&gt;=thresh; <span class="comment">%按当前阈值划分</span></span><br><span class="line">thresh_1= <span class="number">0.5</span>*(<span class="built_in">mean</span>(p(g)) + <span class="built_in">mean</span>(p(~g))); <span class="comment">%新阈值</span></span><br><span class="line">flag = <span class="built_in">abs</span>(thresh - thresh_1)&lt;<span class="number">0.5</span>; <span class="comment">%更新迭代标志</span></span><br><span class="line">thresh = thresh_1; <span class="comment">%更新阈值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>最大方差</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p= imread(<span class="string">'bugs.bmp'</span>);</span><br><span class="line">p1=rgb2gray(p);</span><br><span class="line">thresh = graythresh(p1); <span class="comment">%使用Ostu算法求得新阈值</span></span><br><span class="line">g = im2bw(p1,thresh); <span class="comment">%使用thresh对图像进行分割</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>), imshow(p);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>roifilt2</code>：特定区域增强</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'pout.tif'</span>);</span><br><span class="line">imshow(I)</span><br><span class="line">BW = roipoly(I);</span><br><span class="line">H = fspecial(<span class="string">'unsharp'</span>);</span><br><span class="line">J = roifilt2(H,I,BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(J)</span><br></pre></td></tr></table></figure></li><li><p><code>roifill</code>：区域填充</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I=ind2gray(X,map);</span><br><span class="line"><span class="built_in">figure</span>,imshow(I)</span><br><span class="line">J=roifill;</span><br><span class="line"><span class="built_in">figure</span>,imshow(J)</span><br></pre></td></tr></table></figure></li></ul><h2 id="直线检测"><a href="#直线检测" class="headerlink" title="直线检测"></a>直线检测</h2><ul><li><p>基本思想：点-线对偶性，<code>xy</code>平面上直线，对应参数<code>ab</code>平面上的一个点。</p><ul><li>过<code>xy</code>平面一个点<code>(x,y)</code>的所有直线，构成参数<code>ab</code>平面上的一条直线。</li><li>如果点<code>(x1,y1)</code>与点<code>(x2,y2)</code>共线，那么这两点在参数<code>ab</code>平面上的直线将有一个交点。</li><li>在参数<code>ab</code>平面上相交直线最多的点，对应的<code>xy</code>平面上的直线就是需要的解。</li></ul></li><li><p><code>hough</code>：霍夫变换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'circuit.tif'</span>);</span><br><span class="line">I = imrotate(I,<span class="number">33</span>,<span class="string">'crop'</span>);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I), <span class="built_in">hold</span> on</span><br><span class="line">BW = edge(I,<span class="string">'canny'</span>);</span><br><span class="line">[H,T,R] = hough(BW);</span><br><span class="line"><span class="built_in">figure</span>; imshow(H,[],<span class="string">'XData'</span>,T,<span class="string">'YData'</span>,R,<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);</span><br><span class="line">xlabel(<span class="string">'\theta'</span>), ylabel(<span class="string">'\rho'</span>);</span><br><span class="line">axis on, axis normal, <span class="built_in">hold</span> on;</span><br></pre></td></tr></table></figure></li><li><p><code>houghpeaks</code>：霍夫变换矩阵中的极值点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P = houghpeaks(H,<span class="number">3</span>,<span class="string">'threshold'</span>,<span class="built_in">ceil</span>(<span class="number">0.3</span>*<span class="built_in">max</span>(H(:))));</span><br><span class="line">x = T(P(:,<span class="number">2</span>));</span><br><span class="line">y = R(P(:,<span class="number">1</span>));</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">'s'</span>,<span class="string">'color'</span>,<span class="string">'white'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>houghlines</code>：从霍夫变换矩阵中提取线段</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lines = houghlines(BW,T,R,P,<span class="string">'FillGap'</span>,<span class="number">25</span>,<span class="string">'MinLength'</span>,<span class="number">40</span>);</span><br><span class="line">max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">length</span>(lines)</span><br><span class="line">xy = [lines(k).point1; lines(k).point2];</span><br><span class="line"><span class="built_in">plot</span>(xy(:,<span class="number">1</span>),xy(:,<span class="number">2</span>),<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'green'</span>);</span><br><span class="line"><span class="comment">% Plot beginnings and ends of lines</span></span><br><span class="line"><span class="built_in">plot</span>(xy(<span class="number">1</span>,<span class="number">1</span>),xy(<span class="number">1</span>,<span class="number">2</span>),<span class="string">'x'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'yellow'</span>);</span><br><span class="line"><span class="built_in">plot</span>(xy(<span class="number">2</span>,<span class="number">1</span>),xy(<span class="number">2</span>,<span class="number">2</span>),<span class="string">'x'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'red'</span>);</span><br><span class="line"><span class="comment">% Determine the endpoints of the longest line segment</span></span><br><span class="line">len = norm(lines(k).point1 - lines(k).point2);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; max_len)</span><br><span class="line">max_len = len; xy_long = xy;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% highlight the longest line segment</span></span><br><span class="line"><span class="built_in">plot</span>(xy_long(:,<span class="number">1</span>),xy_long(:,<span class="number">2</span>),<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'blue'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>拓展：霍夫变换同样可以适用于圆的检测，此时需要三个参数的参数空间。</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;3427&lt;/code&gt;字，推荐阅读时间&lt;code&gt;25~30&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter5-图形绘制</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter5-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter5-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/</id>
    <published>2020-12-04T03:28:44.157Z</published>
    <updated>2020-12-04T03:41:50.640Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2134</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="二维图形"><a href="#二维图形" class="headerlink" title="二维图形"></a>二维图形</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p><code>plot</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(Y) <span class="comment">% 以Y的索引/向量实部为横坐标</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y) <span class="comment">% X和Y的维度需要相同</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y, s) <span class="comment">% s设置线形 颜色 标记</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y, <span class="string">'PropName'</span>, PropVal) <span class="comment">% 设置图形属性</span></span><br><span class="line"><span class="built_in">plot</span>(X1, Y1, s1, X2, Y2, s2)</span><br></pre></td></tr></table></figure><ul><li><p>默认按照<strong>蓝色实线</strong>绘制，并做<strong>平滑</strong>处理。</p></li><li><p>统一<code>x</code>轴绘制</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(t,[y',y1',y2',y3',y4',y5'])</span><br></pre></td></tr></table></figure><blockquote><p>纵坐标<strong>行</strong>向量需要<strong>转置</strong>变成<strong>列</strong>向量</p></blockquote></li></ul></li><li><p><code>plotyy</code>：双<code>y</code>轴绘图，绘制横坐标相同，但是纵坐标对应的变量量纲、范围等不同的图形。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plotyy(X1, Y1, X2, Y2)</span><br><span class="line">plotyy(X1, Y1, X2, Y2, FUN) <span class="comment">% FUN指定绘图函数如@plot/@semilogx/@semilogy@loglog</span></span><br><span class="line">plotyy(X1, Y1, X2, Y2, fun1, fun2)</span><br></pre></td></tr></table></figure><ul><li><p><code>Y1</code>默认在左侧，<code>Y2</code>默认在右侧。</p></li><li><p><code>plotyy</code><strong>不能够</strong>直接对曲线属性进行设置，需要使用<strong>句柄图形</strong>控制完成。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">  y1 = <span class="number">200</span> * <span class="built_in">exp</span>(<span class="number">-0.05</span> * x) .* <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="number">0.8</span> * <span class="built_in">exp</span>(<span class="number">-0.5</span> * x) .* <span class="built_in">sin</span>(<span class="number">10</span> * x);</span><br><span class="line">  [AX, H1, H2] = plotyy(x, y1, x, y2, <span class="string">'plot'</span>);</span><br><span class="line">pause;</span><br><span class="line">  set(H1, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>AX(1)</code>和<code>AX(2)</code>对应两侧坐标轴的句柄，表示坐标轴属性。</p></li><li><p><code>H1</code>和<code>H2</code>是对应的曲线的句柄，可以根据函数的返回值进行操作。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(H1, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>)</span><br><span class="line">set(H2, <span class="string">'LineStyle'</span>, <span class="string">':'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>semilogx</code>：<code>x</code>轴取对数（<strong>10</strong>为底）的绘图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semilogx(x, y, <span class="string">'-*'</span>)</span><br><span class="line">semilogy(x, <span class="number">10.</span>^x)</span><br></pre></td></tr></table></figure></li><li><p><code>semilogy</code></p></li><li><p><code>loglog</code>：两个维度上都取对数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">logspace</span>(<span class="number">-1</span>,<span class="number">2</span>); <span class="comment">% 10^-1 ~ 10^2</span></span><br><span class="line">loglog(x,<span class="built_in">exp</span>(x),<span class="string">'-s'</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><ul><li><code>logspace</code>：对数空间中，以10为底数生成值（和<code>linspace</code>对应）。</li></ul></li><li><p><code>polar</code>：极坐标图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polar(theta, rho)</span><br><span class="line">polar(theta, rho, s)</span><br></pre></td></tr></table></figure><ul><li><p><code>theta</code>是<strong>弧度制</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="number">2</span> * <span class="built_in">pi</span> / <span class="number">90</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(<span class="number">4</span> * t);</span><br><span class="line">polar(t, y);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h3><h4 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h4><ul><li><code>-</code>：实线</li><li><code>--</code>：虚线</li><li><code>:</code>：点线</li><li><code>-.</code>：点划线</li><li><code>none</code>：无线</li></ul><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><ul><li><code>b</code>：蓝色</li><li><code>g</code>：绿色</li><li><code>m</code>：红紫色</li><li><code>w</code>：白色</li><li><code>c</code>：蓝绿色</li><li><code>k</code>：黑色</li><li><code>r</code>：红色</li><li><code>y</code>：黄色</li></ul><h4 id="标记符号"><a href="#标记符号" class="headerlink" title="标记符号"></a>标记符号</h4><p>对曲线上有值的点进行标记</p><ul><li><code>*</code>：星号</li><li><code>x</code>：叉号</li><li><code>s</code>：方块</li><li><code>p</code>：五角星</li><li><code>^</code>/<code>&gt;</code>/<code>.</code>/<code>O</code>/<code>d</code>/<code>h</code>/<code>v</code>/<code>&lt;</code></li></ul><h4 id="图形属性"><a href="#图形属性" class="headerlink" title="图形属性"></a>图形属性</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">tan</span>(<span class="built_in">sin</span>(x)) - <span class="built_in">cos</span>(<span class="built_in">tan</span>(x));</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">'--rp'</span>, <span class="string">'LineWidth'</span>, <span class="number">3</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'k'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'m'</span>, <span class="string">'MarkerSize'</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure><ul><li><code>LineStyle</code></li><li><code>LineWidth</code></li><li><code>Marker</code>：数据点标记符号</li><li><code>MarkerSize</code>：标记符大小</li><li><code>MarkerEdgeColor</code>：标记符<strong>边缘</strong>颜色</li><li><code>MarkerFaceColor</code>：标记符<strong>填充</strong>颜色</li></ul><h4 id="文字标注"><a href="#文字标注" class="headerlink" title="文字标注"></a>文字标注</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">y1 = <span class="built_in">sin</span>(t); y2 = <span class="built_in">cos</span>(t); <span class="built_in">plot</span>(t, y1, <span class="string">'r'</span>, t, y2, <span class="string">'b--'</span>);</span><br><span class="line">x = [<span class="number">1.7</span> * <span class="built_in">pi</span>; <span class="number">1.6</span> * <span class="built_in">pi</span>];</span><br><span class="line">y = [<span class="number">-0.3</span>; <span class="number">0.8</span>];</span><br><span class="line">s = [<span class="string">'sin(t)'</span>; <span class="string">'cos(t)'</span>];</span><br><span class="line">text(x, y, s);</span><br><span class="line">title(<span class="string">'正弦和余弦曲线'</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'正弦'</span>, <span class="string">'余弦'</span>)</span><br><span class="line">xlabel(<span class="string">'时间t'</span>), ylabel(<span class="string">'正弦、余弦'</span>)</span><br><span class="line">grid</span><br><span class="line">axis square</span><br></pre></td></tr></table></figure><ul><li><p><code>title(s)</code>：图标题</p></li><li><p><code>xlabel(s)</code>：横坐标名</p></li><li><p><code>ylabel(s)</code></p></li><li><p><code>legend(s, position)</code>：在指定位置建立<strong>图例</strong>，按照绘图函数的<strong>参数顺序</strong>生成。</p><ul><li><code>s</code>：图例中的文字注释，可用<code>s1,s2,...</code>表示。</li><li><code>position</code>：指定图例位置<ul><li><code>0</code>：自动最佳位置（<strong>不</strong>覆盖原图）</li><li><code>1</code>：右上角<strong>（默认）</strong></li><li><code>2</code>：左上角</li><li><code>3</code>：左下角</li><li><code>4</code>：右下角</li><li><code>-1</code>：图<strong>右侧</strong></li></ul></li></ul></li><li><p><code>text(x, y, s)</code>：在<code>x</code>轴和<code>y</code>轴的指定位置添加<strong>文字注释</strong></p><blockquote><p><code>x</code>和<code>y</code>是值列表</p></blockquote></li></ul><h4 id="重叠绘图"><a href="#重叠绘图" class="headerlink" title="重叠绘图"></a>重叠绘图</h4><ul><li><code>hold on</code>：保持当前图形</li><li><code>hold off</code>：<strong>取消</strong>当前图形的保持功能</li><li><code>hold</code>：<strong>双向</strong>切换开关（对当前状态取反）</li></ul><h4 id="多子图绘制"><a href="#多子图绘制" class="headerlink" title="多子图绘制"></a>多子图绘制</h4><ul><li><p><code>subplot</code>：在一图形中同时显示<strong>多幅独立</strong>的子图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplot(m, n, k) <span class="comment">% m行n列个子图 k是子图编号</span></span><br><span class="line">subplot(<span class="string">'Position'</span>, [left bottom width height]) <span class="comment">% 在指定位置上分割子图 并成为当前图</span></span><br></pre></td></tr></table></figure><ul><li><p>所有子图<strong>彼此独立</strong>，绘图命令可以在子图中使用。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">y0 = <span class="built_in">sin</span>(t); y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t); y3 = <span class="built_in">cos</span>(<span class="number">2</span> * t);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">% 左上</span></span><br><span class="line"><span class="built_in">plot</span>(t, y0)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">% 右上</span></span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">% 左下</span></span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">% 右下</span></span><br><span class="line"><span class="built_in">plot</span>(t, y3)</span><br></pre></td></tr></table></figure><blockquote><p>注意和<code>legend</code>中的位置进行区分</p></blockquote></li><li><p>非等比例子图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">y0 = <span class="built_in">sin</span>(t); y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t); y3 = <span class="built_in">cos</span>(<span class="number">2</span> * t);</span><br><span class="line">positionVector1 = [<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">0.3</span>];</span><br><span class="line">subplot(<span class="string">'Position'</span>, positionVector1)</span><br><span class="line"><span class="built_in">plot</span>(t, y0)</span><br><span class="line">positionVector2 = [<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.3</span>];</span><br><span class="line">subplot(<span class="string">'Position'</span>, positionVector2)</span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line">subplot(<span class="string">'Position'</span>, [<span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>])</span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="多窗口绘图"><a href="#多窗口绘图" class="headerlink" title="多窗口绘图"></a>多窗口绘图</h4><ul><li><p><code>figure(n)</code>：创建绘图窗口，<code>n</code>是窗口顺序号。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(t);</span><br><span class="line">y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(t, y)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br></pre></td></tr></table></figure><blockquote><p><code>figure1</code><strong>不需要</strong>单独指定</p></blockquote></li></ul><h4 id="坐标轴控制"><a href="#坐标轴控制" class="headerlink" title="坐标轴控制"></a>坐标轴控制</h4><ul><li><p><code>axis</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">x = <span class="built_in">cos</span>(t);</span><br><span class="line">y = <span class="number">2</span> * <span class="built_in">sin</span>(t);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="built_in">plot</span>(x, y); title(<span class="string">'nomal'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="built_in">plot</span>(x, y); axis equal; title(<span class="string">'equal'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="built_in">plot</span>(x, y); axis square; title(<span class="string">'square'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="built_in">plot</span>(x, y); axis image; title(<span class="string">'image'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="built_in">plot</span>(x, y); axis tight; title(<span class="string">'tight'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>); <span class="built_in">plot</span>(x, y); axis off; title(<span class="string">'axis off'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="网格线与坐标框"><a href="#网格线与坐标框" class="headerlink" title="网格线与坐标框"></a>网格线与坐标框</h4><ul><li><code>grid</code><ul><li><code>grid on</code></li><li><code>grid off</code></li><li><code>grid</code></li></ul></li><li><code>box</code>：确定当前坐标框是否呈封闭形式（省略上框线和右框线）<ul><li><code>box on</code></li><li><code>box off</code></li><li><code>box</code></li></ul></li></ul><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul><li><p><code>bar</code>：垂直条形图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Y = <span class="built_in">round</span>(<span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">3</span>)*<span class="number">10</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">bar(Y,<span class="string">'grouped'</span>)</span><br><span class="line">title <span class="string">'Group'</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">bar(Y,<span class="string">'stacked'</span>)</span><br><span class="line">title <span class="string">'Stack'</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">bar(Y,<span class="number">2.0</span>)</span><br><span class="line">title <span class="string">'Width = 2.0’</span></span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>和<code>.*</code>的区别</p><ul><li><p>对于矩阵运算来说，<code>*</code>是标准的矩阵点乘。</p></li><li><p>对于矩阵和数字的运算来说，二者<strong>没有</strong>区别。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[a b c d]</span><br><span class="line"><span class="number">2.</span>*A=[<span class="number">2</span>*a  <span class="number">2</span>*b  <span class="number">2</span>*c  <span class="number">2</span>*d]</span><br><span class="line"><span class="number">2</span>*A=[<span class="number">2</span>*a  <span class="number">2</span>*b  <span class="number">2</span>*c  <span class="number">2</span>*d]</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p><code>barh</code>：水平条形图（横向是<code>Y</code>轴）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">barh(x, y, <span class="string">'grouped'</span>); <span class="comment">% groups by row</span></span><br><span class="line">title(<span class="string">'Grouped Style'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">barh(x, y, <span class="string">'stacked'</span>); <span class="comment">% stacks values in each row together</span></span><br><span class="line">title(<span class="string">'Stacked Style'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">barh(x, y, <span class="string">'hist'</span>); <span class="comment">% centers bars over x values</span></span><br><span class="line">title(<span class="string">'hist Style'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>errorbar</code>：误差图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="built_in">pi</span>;</span><br><span class="line">Y = <span class="built_in">sin</span>(X);</span><br><span class="line">E = std(Y) * <span class="built_in">ones</span>(<span class="built_in">size</span>(X));</span><br><span class="line">errorbar(X, Y, E)</span><br></pre></td></tr></table></figure></li><li><p><code>area</code>：面积图，即填充曲线的积分面积。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="number">2</span> * <span class="built_in">sin</span>(t);</span><br><span class="line">area(t, y)</span><br></pre></td></tr></table></figure></li><li><p><code>hist</code>：柱形图，用于显示数据分布情况。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = <span class="built_in">randn</span>(<span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line">hist(y, x)</span><br><span class="line"><span class="comment">% 设置柱形图的效果</span></span><br><span class="line">h = findobj(gca, <span class="string">'Type'</span>, <span class="string">'patch'</span>);</span><br><span class="line">set(h, <span class="string">'FaceColor'</span>, <span class="string">'r'</span>, <span class="string">'EdgeColor'</span>, <span class="string">'w'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>柱形图和条形图的区别</p><ul><li>条形图用来表达数据间的比较关系，例如不同产品的销售情况。（自变量是产品种类）</li><li>柱形图用来展示数据的分布或趋势变化，自变量通常是<strong>量化数据</strong>。</li><li>柱形图不同柱一般<strong>不能</strong>重新排序，而条形图不同条<strong>可以任意</strong>重新排序。</li><li>柱形图各个柱之间通常<strong>没有</strong>空隙</li><li>柱形图的<strong>纵轴</strong>通常是横轴元素的<strong>计数结果</strong></li></ul></blockquote></li><li><p><code>stem</code>：火柴杆图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">25</span>;</span><br><span class="line">y = [<span class="built_in">exp</span>(<span class="number">-.07</span> * x) .* <span class="built_in">cos</span>(x); <span class="built_in">exp</span>(<span class="number">.05</span> * x) .* <span class="built_in">cos</span>(x)]';</span><br><span class="line">h = stem(x, y);</span><br><span class="line">set(h(<span class="number">1</span>), <span class="string">'MarkerFaceColor'</span>, <span class="string">'blue'</span>)</span><br><span class="line">set(h(<span class="number">2</span>), <span class="string">'MarkerFaceColor'</span>, <span class="string">'red'</span>, <span class="string">'Marker'</span>, <span class="string">'square'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>stairs</code>：阶梯图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-2</span> * <span class="built_in">pi</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(x);</span><br><span class="line">stairs(x, y);</span><br></pre></td></tr></table></figure></li><li><p><code>pie</code>：扇形图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2.5</span> <span class="number">4.5</span> <span class="number">1.5</span> <span class="number">0.5</span>];</span><br><span class="line">explode = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">pie(x, explode);</span><br><span class="line">colormap jet</span><br></pre></td></tr></table></figure></li><li><p><code>compass</code>：罗盘图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">randn</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">%实部对应的数据</span></span><br><span class="line">v = <span class="built_in">randn</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">%虚部对应的数据</span></span><br><span class="line">z = <span class="built_in">exp</span>(<span class="built_in">i</span> * <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">6</span>)); <span class="comment">%复数数组</span></span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">compass(u, v)<span class="comment">%利用实部与虚部绘制罗盘图</span></span><br><span class="line">xlabel(<span class="string">'(a) 利用实部与虚部绘制罗盘图'</span>);</span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">compass(z); <span class="comment">%利用复数绘制罗盘图</span></span><br><span class="line">xlabel(<span class="string">'(b) 利用复数绘制罗盘图'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>feather</code>：羽毛图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">theta = (<span class="number">-90</span>:<span class="number">10</span>:<span class="number">90</span>) * <span class="built_in">pi</span> / <span class="number">180</span>;</span><br><span class="line">r = <span class="number">2</span> * <span class="built_in">ones</span>(<span class="built_in">size</span>(theta));</span><br><span class="line"><span class="comment">%将极坐标系转换为笛卡儿坐标系</span></span><br><span class="line">[u, v] = <span class="built_in">pol2cart</span>(theta, r);</span><br><span class="line">feather(u, v);</span><br></pre></td></tr></table></figure></li></ul><h2 id="三维图形"><a href="#三维图形" class="headerlink" title="三维图形"></a>三维图形</h2><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p><code>plot3</code>：调用格式和<code>plot</code>一致</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot3</span>(x, y, z, <span class="string">'r*-'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>ezplot3</code>：对符号函数进行绘制</li></ul></li><li><p><code>mesh</code>：网格图函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x, y, z] = peaks(<span class="number">30</span>);</span><br><span class="line">mesh(x, y, z)</span><br></pre></td></tr></table></figure><ul><li><code>ezmesh</code>：符号函数的网格图绘制</li></ul></li><li><p><code>surf</code>：对网格进行填充</p><ul><li><code>ezsurf</code></li></ul></li><li><p><code>meshgrid</code>：生成二元函数$z=f(x,y)$中$X-Y$平面上的句型定义域中的数据点矩阵$X$和$Y$.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[X, Y] = <span class="built_in">meshgrid</span>(<span class="number">-2</span>:<span class="number">.2</span>:<span class="number">2</span>, <span class="number">-2</span>:<span class="number">.2</span>:<span class="number">2</span>);</span><br><span class="line">Z = X .* <span class="built_in">exp</span>(-X.^<span class="number">2</span> - Y.^<span class="number">2</span>);</span><br><span class="line">surf(X, Y, Z)</span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊情况-1"><a href="#特殊情况-1" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul><li><code>bar3</code></li><li><code>bar3h</code></li><li><code>cylinder</code></li><li><code>sphere</code></li><li><code>stem3</code></li><li><code>contour3</code></li><li><code>waterfall</code></li><li><code>pie3</code></li><li><code>surfnorm</code></li></ul><h3 id="修饰-1"><a href="#修饰-1" class="headerlink" title="修饰"></a>修饰</h3><ul><li><p><code>view</code>：控制三维图形的观察点和视角</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view(AZ, EL)</span><br></pre></td></tr></table></figure><ul><li><p><code>AZ</code>：方位角，<strong>角度制</strong>。</p><blockquote><p>绕<code>Z</code>轴<strong>顺时针为正</strong>，逆时针为负。</p></blockquote></li><li><p><code>EL</code>：仰角</p></li></ul></li><li><p><code>colormap</code>：图形颜色</p></li><li><p><code>alpha</code>：透明度</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha(v) <span class="comment">% v介于0和1之间 表示透明度大小</span></span><br><span class="line">alpha(<span class="string">'x'</span>) <span class="comment">% 随x变大透明度值变大</span></span><br><span class="line">alpha(<span class="string">'rand'</span>) <span class="comment">% 随机设置透明度</span></span><br></pre></td></tr></table></figure><ul><li>透明度值<strong>越大</strong>，图像越<strong>不透明</strong>。</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2134&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter4-符号运算</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter4-%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter4-%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97/</id>
    <published>2020-12-04T03:28:44.150Z</published>
    <updated>2020-12-04T03:41:50.855Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1986</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>和数值运算对应，使用<strong>符号</strong>表示计算结果（不给未知数赋值）。</p><ul><li><p>求解方程：$ax^2+bx+c=0$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms a b c x;</span><br><span class="line">solve(a*x^<span class="number">2</span>+b*x+c); <span class="comment">% note there is no single quote</span></span><br><span class="line">solve(a*x^<span class="number">2</span>+b*x+c==<span class="number">0</span>); <span class="comment">% note '==' instead of '='</span></span><br></pre></td></tr></table></figure></li><li><p>辨析</p><p>以$2/5+1/3$为例，数值运算的结果为$0.7333$；而$sym(2)/sym(5)+sym(1)/sym(3)$的结果为$11/15$，且这里$11/15$仍然是属于<code>sym</code>类型, 是<strong>符号数</strong>。</p><blockquote><p>符号运算只会化简到<strong>没有误差</strong>的最简形式</p></blockquote></li></ul></li><li><p>支持可变精度运算，以指定精度返回数值结果。</p></li><li><p>相比数值运算，符号运算所需运行时间较长。</p></li></ul><h2 id="符号对象"><a href="#符号对象" class="headerlink" title="符号对象"></a>符号对象</h2><ul><li><p>符号对象是一种数据结构</p></li><li><p>分类</p><ul><li><p>符号常量</p></li><li><p>符号变量</p></li><li><p>符号表达式：含有符号对象的表达式</p><blockquote><p>在MATLAB中将其存储为<strong>字符串</strong></p></blockquote></li></ul></li><li><p>符号矩阵/数组：元素是符号表达式的矩阵/数组</p></li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p><code>sym</code>：创建<strong>单个</strong>符号对象</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = sym(A, flag);</span><br></pre></td></tr></table></figure><ul><li><p><code>A</code>：常量、变量、函数、表达式</p></li><li><p><code>flag</code>：缺省为有理数<code>r</code></p><ul><li><code>d</code>：最接近的十进制数值</li><li><code>f</code>：最接近的浮点数值</li><li><code>r</code>：最接近的有理表示</li></ul></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = sym(<span class="string">'q'</span>)      <span class="comment">% 符号变量，指定a在表达式字符串中的形式。</span></span><br><span class="line">a_1 = sym(<span class="string">'pi'</span>)  <span class="comment">% 符号变量，指定a_1在表达式字符串中的形式。</span></span><br><span class="line">b = sym(<span class="number">1</span>/<span class="number">3</span>)      <span class="comment">% 符号常量，指定b在表达式中的取值。</span></span><br><span class="line">b_1 = sym(<span class="built_in">pi</span>)  <span class="comment">% 符号常量，指定b_1在表达式中的取值。</span></span><br><span class="line">c = sym(<span class="number">2</span>*a+b)    <span class="comment">% 符号表达式</span></span><br><span class="line">d = sym(<span class="built_in">sin</span>(<span class="number">1</span>))   <span class="comment">% 符号函数</span></span><br></pre></td></tr></table></figure><ul><li><p>用<code>&#39;pi&#39;</code>创建的符号变量在<code>sin(pi)</code>时不会得到0；但是<code>sym(&#39;4&#39;)</code>和<code>sym(4)</code>没有区别，都可以运算。</p></li><li><p>符号表达式和符号函数<strong>不能够</strong>使用字符串参数，因此在构造符号表达式之前需要构造好所有的符号常量和符号变量。</p><ul><li><p>如果想要直接通过字符串创建符号表达式，则应该使用<code>str2sym</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = str2sym(<span class="string">'a*x^4+b*x^3+c*x^2+d*x+e'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>str2sym</code>对<strong>所有</strong>用字符串构造符号表达式的方式<strong>都适用</strong></p></blockquote></li></ul></li><li><p>使用符号对象创建符号对象（拷贝构造）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = sym(<span class="number">10</span>);</span><br><span class="line">b = sym(a);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>syms</code>：一次性创建多个符号对象</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syms a b c; <span class="comment">% 只能用空格分隔</span></span><br><span class="line"><span class="comment">% equals to</span></span><br><span class="line">a = sym(<span class="string">'a'</span>);</span><br><span class="line">b = sym(<span class="string">'b'</span>);</span><br><span class="line">c = sym(<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></li><li><p>符号表达式</p><ul><li><p>单引号（不推荐）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="string">'sin(x)+cos(x)'</span>;</span><br></pre></td></tr></table></figure><blockquote><ul><li>字符间<strong>不能</strong>添加空格</li><li>在2020版本中不能够创建表达式，只能够表示单纯的字符串。</li></ul></blockquote></li><li><p><code>sym</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = sym(<span class="string">'sin(x)+cos(x)'</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用已经定义的符号变量组（推荐）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syms x</span><br><span class="line">f = <span class="number">3</span>*<span class="built_in">sin</span>(x)+<span class="built_in">cos</span>(x)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>符号矩阵</p><ul><li><p><code>sym</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = sym(<span class="string">'[1+x,sin(x);5,exp(x)]'</span>);</span><br></pre></td></tr></table></figure></li><li><p>数值矩阵转换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = [<span class="number">2</span>/<span class="number">3</span>, <span class="built_in">sqrt</span>(<span class="number">2</span>); <span class="number">5.2</span>, <span class="built_in">log</span>(<span class="number">3</span>)];</span><br><span class="line">C = sym(B);</span><br></pre></td></tr></table></figure></li><li><p>符号矩阵的引用和修改和数值矩阵相同</p></li></ul></li></ul><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>和数值运算中的规则、符号都相同。</p><h3 id="符号表达式"><a href="#符号表达式" class="headerlink" title="符号表达式"></a>符号表达式</h3><ul><li><p><code>numden</code>：通分并提取符号表达式的分子和分母</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N, D] = numden(f);</span><br></pre></td></tr></table></figure><ul><li><code>N</code>：通分后的<strong>分子</strong></li><li><code>D</code>：通分后的<strong>分母</strong></li></ul></li><li><p><code>factor</code>：因式分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = x^<span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">factor</span>(f);</span><br></pre></td></tr></table></figure><ul><li><p>可以用于<strong>正整数</strong>的分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">factor</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">% s = 2 2 5 5</span></span><br></pre></td></tr></table></figure></li><li><p>可以用于<strong>大正整数符号变量</strong>的分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">factor</span>(sym(<span class="string">'1234567891011121314'</span>));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>expand</code>：符号表达式展开</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = (x+<span class="number">1</span>)^<span class="number">6</span>;</span><br><span class="line">expand(f);</span><br></pre></td></tr></table></figure></li><li><p><code>collect</code>：合并同类项</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collect(s); <span class="comment">% 对符号表达式默认变量合并</span></span><br><span class="line">collect(s, v); <span class="comment">% 对符号表达式s按变量v合并</span></span><br></pre></td></tr></table></figure></li><li><p>化简</p><ul><li><p><code>simplify(f)</code></p><ul><li><p>获取最短的化简结果</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simplify(f, <span class="string">'IgnoreAnalyticConstraints'</span>, <span class="built_in">true</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>simple</code>：多种规则返回最少数目字符的字符</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[How, y] = simple(f);</span><br></pre></td></tr></table></figure><ul><li><code>How</code>：记录使用的方法</li><li><code>y</code>：最简短形式</li></ul></li></ul></li><li><p><code>horner</code>：求多项式的嵌套形式（秦九韶算法）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = x^<span class="number">4</span> + <span class="number">2</span>*x^<span class="number">3</span> + <span class="number">4</span>*x^<span class="number">2</span> + x + <span class="number">1</span>;</span><br><span class="line">g = horner(f);</span><br><span class="line"><span class="comment">% g = x*(x*(x*(x+2)+4)+1)+1</span></span><br></pre></td></tr></table></figure></li><li><p><code>pretty</code>：格式美化，转换为手写格式。</p></li><li><p>多项式转换</p><ul><li><p><code>sym2poly</code>：将符号表达式转换为<strong>降幂排列</strong>的<strong>系数行向量</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = sym(<span class="string">'2*x+3*x^2+1'</span>);</span><br><span class="line">sym2poly(f);</span><br></pre></td></tr></table></figure></li><li><p><code>poly2sym</code>：将行向量按<strong>幂降序</strong>转换为符号表达式，变量默认为<code>x</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = poly2sym([<span class="number">1</span> <span class="number">3</span> <span class="number">2</span>])</span><br><span class="line"><span class="comment">% x^2 + 3*x + 2</span></span><br></pre></td></tr></table></figure></li><li><p>只能对<strong>单符号</strong>表达式进行转换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">c = sym(<span class="number">1</span>);</span><br><span class="line">f = str2sym(<span class="string">'x+c'</span>);</span><br><span class="line">sym2poly(f);</span><br></pre></td></tr></table></figure><ul><li>尽管<code>c</code>是符号常量，但是依然不能够转换。</li></ul></li></ul></li><li><p><code>findsym</code>：查找符号<strong>变量</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findsym(s, n); <span class="comment">% 返回符号表达式s中的n个符号变量</span></span><br></pre></td></tr></table></figure><ul><li><p>当<code>n</code>不指定时，<strong>无序</strong>返回所有符号变量。</p></li><li><p>默认符号变量的选取：先选择<code>x</code>，如果<code>x</code>不存在，则选择在字母顺序中<strong>最接近</strong><code>x</code>的字符变量；如果距离相等，则选择<code>x</code><strong>后面</strong>的字符变量。</p><blockquote><p>注意：<strong>大写</strong>字母比<strong>小写</strong>字母都靠后（和ASCII码<strong>相反</strong>）</p></blockquote></li><li><p>符号常量<strong>不会</strong>被返回</p></li></ul></li><li><p><code>subs</code>：符号变量的替换</p><ul><li><code>subs(f, a)</code>：用<code>a</code>替换表达式<code>f</code>中的（第一）自由变量</li><li><code>subs(f, x, a)</code>：用<code>a</code>替换<code>f</code>中的指定符号变量<code>x</code></li></ul><blockquote><p>在数字信号处理中，进行移位、反褶、尺度变换。</p></blockquote></li><li><p><code>compose</code>：复合函数运算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compose(f, g); <span class="comment">% f(g(X))</span></span><br><span class="line">compose(f, g, z); <span class="comment">% f(g(z))</span></span><br></pre></td></tr></table></figure></li><li><p><code>finverse</code>：反函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = finverse(f);</span><br><span class="line">g = finverse(f, v); <span class="comment">% 指定默认变量</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h3><h4 id="运算方式"><a href="#运算方式" class="headerlink" title="运算方式"></a>运算方式</h4><ul><li>数值型</li><li>有理数型</li><li><code>VPA</code>型：Maple的任意精度运算</li></ul><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="number">2</span>/<span class="number">3</span>; <span class="comment">% 0.6667</span></span><br><span class="line">a2 = sym(<span class="number">2</span>/<span class="number">3</span>); <span class="comment">% 2/3</span></span><br><span class="line">a3 = vpa(<span class="string">'2/3'</span>, <span class="number">32</span>); <span class="comment">% 0.66666666666666666666666666666667</span></span><br></pre></td></tr></table></figure><ul><li><code>digits</code>：显示当前计算精度</li><li><code>digits(n)</code>：设置数值型计算精度</li><li><code>xr = vpa(x)</code>：在<code>digits</code>精度下的数值型结果<code>xr</code></li><li><code>xr = vpa(x, n)</code>：在指定精度<code>n</code>下的数值型结果<code>xr</code></li></ul><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><ul><li><code>sym</code>：数值型转换为有理数型的符号对象</li><li><code>vpa(x, n)</code>：转换为VPA型符号对象</li><li><code>double</code>：转换为数值对象</li></ul><h2 id="符号微积分"><a href="#符号微积分" class="headerlink" title="符号微积分"></a>符号微积分</h2><ul><li><p><code>limit</code>：符号极限</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">limit(f); <span class="comment">% 函数在x=0的极限值</span></span><br><span class="line">limit(f, x, a); <span class="comment">% 函数在x趋于a的极限值</span></span><br><span class="line">limit(f, x, a, <span class="string">'left'</span>); <span class="comment">% 左极限</span></span><br><span class="line">limit(f, x, a, <span class="string">'right'</span>); <span class="comment">% 右极限</span></span><br></pre></td></tr></table></figure></li><li><p><code>diff</code>：符号导数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = diff(f);</span><br><span class="line">g = diff(f, v);</span><br><span class="line">g = diff(f, n); <span class="comment">% 对默认变量求n阶导</span></span><br><span class="line">g = diff(f, v, n); <span class="comment">% 对指定变量v求n阶导</span></span><br></pre></td></tr></table></figure></li><li><p><code>int</code>：符号积分</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int(f);</span><br><span class="line">int(f, v);</span><br><span class="line">int(f, a, b); <span class="comment">% 定积分</span></span><br><span class="line">int(f, v, a, b);</span><br></pre></td></tr></table></figure><ul><li><p>与数值积分辨析</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">digits(<span class="number">128</span>);</span><br><span class="line">fun = inline(<span class="string">'-x.^2+115'</span>, <span class="string">'x'</span>);</span><br><span class="line"><span class="comment">% numerical</span></span><br><span class="line">rn_1 = polyint([<span class="number">-1</span>, <span class="number">0</span>, <span class="number">115</span>]);</span><br><span class="line">fn_2 = quad(fun, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">fn_3 = quadl(fun, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">% symbolic</span></span><br><span class="line">rs = int(str2sym(<span class="string">'-x^2+115'</span>), <span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fourier</code>：傅里叶变换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fourier(ft, t, w);</span><br><span class="line">ifourier(Fw, w, t)</span><br></pre></td></tr></table></figure></li><li><p><code>symsum</code>：级数求和</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">symsum(f, v, a, b);</span><br><span class="line">symsum(f, a, b);</span><br></pre></td></tr></table></figure></li><li><p><code>laplace</code></p></li><li><p><code>taylor</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taylor(f); <span class="comment">% 默认为6阶麦克劳林多项式</span></span><br><span class="line">taylor(f, n, v); <span class="comment">% (n-1)阶麦克劳林多项式</span></span><br><span class="line">taylor(f, n, v, a); <span class="comment">% 在a附近的(n-1)阶展开式</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="符号方程"><a href="#符号方程" class="headerlink" title="符号方程"></a>符号方程</h2><ul><li><p><code>solve</code>：解析解</p><ul><li><code>solve(f)</code></li></ul></li><li><p><code>solve(&#39;eq1&#39;, &#39;eq2&#39;, ..., &#39;v1&#39;, &#39;v2&#39;, ...)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">eq1 = str2sym(<span class="string">'x^2+2*x+1=0'</span>);</span><br><span class="line">solve(eql);</span><br><span class="line">solve(x^<span class="number">2</span>+<span class="number">2</span>*x+<span class="number">1</span>==<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p>如果用<code>=</code>则必须传入符号表达式对象，如果是现场构造则是<code>==</code>.</p><blockquote><p>如果是<code>=0/==0</code>则可以直接省略</p></blockquote></li></ul></li><li><p><code>dsolve</code>：微分方程解析解</p></li></ul><h2 id="符号函数可视化"><a href="#符号函数可视化" class="headerlink" title="符号函数可视化"></a>符号函数可视化</h2><ul><li><p><code>ezplot()</code>：绘制符号表达式的函数曲线</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ezplot(<span class="string">'x^2*y+y+2'</span>);</span><br></pre></td></tr></table></figure><ul><li><code>ezplot(3)</code>：三维曲线</li></ul></li><li><p><code>ezcontour</code>：绘制带填充颜色的等高线</p></li><li><p><code>ezmesh</code>：绘制带等位线的<strong>三维网格图</strong></p></li><li><p><code>ezsurf</code>：绘制带等位线的<strong>曲面图</strong></p></li><li><p><code>ezploar</code>：绘制极坐标曲线</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1986&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter3-数值计算</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter3-%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter3-%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</id>
    <published>2020-12-04T03:28:44.143Z</published>
    <updated>2020-12-04T03:41:51.383Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1380</code>字，推荐阅读时间<code>12~15</code>分钟。</p><a id="more"></a><h2 id="数据统计处理"><a href="#数据统计处理" class="headerlink" title="数据统计处理"></a>数据统计处理</h2><h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><p>以<code>max()</code>为例，<code>min()</code>用法相同。</p><ul><li><p>向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">max</span>(A);</span><br><span class="line">[c, idx] = <span class="built_in">max</span>(A); <span class="comment">% idx is the index of max value</span></span><br></pre></td></tr></table></figure></li><li><p>矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A); <span class="comment">% return a row vector of max values in every column</span></span><br><span class="line">c = <span class="built_in">max</span>(A, [], dim); <span class="comment">% dim can be 1 or 2, default to 1(column max).</span></span><br><span class="line"> <span class="comment">% [] cannot be neglected for overloading of max(A, n).</span></span><br><span class="line">[c, idx] = <span class="built_in">max</span>(A);</span><br></pre></td></tr></table></figure><ul><li><p>求矩阵的最大元素（降维）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A(:));</span><br></pre></td></tr></table></figure></li><li><p>比较</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">max</span>(A, B); <span class="comment">% u is matrix with all max values</span></span><br><span class="line">u = <span class="built_in">max</span>(A, n); <span class="comment">% n is scalar, and u's elements are all &gt;= n.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">mean</span>(A);</span><br><span class="line">m = <span class="built_in">mean</span>(A, dim);</span><br></pre></td></tr></table></figure><h3 id="中值"><a href="#中值" class="headerlink" title="中值"></a>中值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = median(A);</span><br><span class="line">m - median(A, dim);</span><br></pre></td></tr></table></figure><h3 id="加和"><a href="#加和" class="headerlink" title="加和"></a>加和</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = sum(A); <span class="comment">% return a row vector of production of column</span></span><br><span class="line">b = aum(A, dim);</span><br></pre></td></tr></table></figure><ul><li><p>累加和</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = cumsum(A); <span class="comment">% return a row vector of cumulative sum of column</span></span><br><span class="line">b = cumsum(A, dim);</span><br></pre></td></tr></table></figure></li></ul><h3 id="乘积"><a href="#乘积" class="headerlink" title="乘积"></a>乘积</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = prod(A); <span class="comment">% return a row vector of production of column</span></span><br><span class="line">b = prod(A, dim);</span><br></pre></td></tr></table></figure><ul><li><p>累乘积</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = cumprod(A);</span><br><span class="line">b = cumprod(A, dim);</span><br></pre></td></tr></table></figure></li></ul><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = std(A);</span><br><span class="line">s = std(A, flag, dim); <span class="comment">% flag can be 0 or 1, and 0 is (N-1) normal std while 1 is (N).</span></span><br></pre></td></tr></table></figure><h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = corrcoef(A); <span class="comment">% take every column as a variable to caculate correlate coefficient</span></span><br><span class="line">r = corrcoef(x, y)；</span><br><span class="line">r = corrcoef([x, y]);</span><br></pre></td></tr></table></figure><ul><li>相关系数矩阵的大小和原矩阵是相同的，其他时候则根据向量数确定，例如<code>corrcoef([x, y])</code>的结果是<code>2*2</code>矩阵。</li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">sort</span>(A);</span><br><span class="line">[b, idx] = <span class="built_in">sort</span>(A, dim); <span class="comment">% idx contains the positions of B's elements in A.</span></span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><ul><li>虚部使用<code>i</code>或者<code>j</code>表示</li><li>构造<ul><li>直接表示</li><li><code>complex(a, b)</code></li></ul></li></ul><h3 id="特殊运算"><a href="#特殊运算" class="headerlink" title="特殊运算"></a>特殊运算</h3><ul><li>提取实部和虚部<ul><li><code>real</code></li><li><code>imag</code></li></ul></li><li>计算模<ul><li><code>abs</code></li></ul></li><li>计算辐角<ul><li><code>angle</code></li></ul></li><li>复数共轭<ul><li><code>conj</code></li></ul></li></ul><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>直角坐标绘图和其他相同，特殊的在于<strong>极坐标</strong>绘图。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polar(theta, rho);</span><br><span class="line">polar(theta, tho, LineSpec);</span><br></pre></td></tr></table></figure><ul><li><code>theta</code>：极角</li><li><code>rho</code>：极轴</li></ul><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>多项式表达为一个<strong>系数</strong>行向量，并且其元素是降幂排列的。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = [an, ..., a2, a1, a0];</span><br></pre></td></tr></table></figure><ul><li>指数为0的项的系数<strong>不能</strong>省略</li></ul></li><li><p><code>poly</code>：根据<strong>解向量</strong>产生<strong>特征多项式</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = poly(a);</span><br></pre></td></tr></table></figure><ul><li><p><code>roots</code>：逆函数，根据<strong>系数向量</strong>求<strong>解向量</strong>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = roots(p);</span><br></pre></td></tr></table></figure><blockquote><p>系数（<strong>行</strong>向量）：<code>1 * n</code></p><p>根（<strong>列</strong>向量）：<code>n * 1</code></p></blockquote></li></ul></li><li><p><code>poly2str</code>：把多项式系数转换为<strong>字符形式</strong>的函数，省略一些不影响阅读的运算符，例如<code>2*x</code>会被表示为<code>2x</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = poly2str(p, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>poly2sym</code>：把系数数组转换为<strong>符号多项式</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = poly2sym(p, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;a =[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]; p = poly(a)</span><br><span class="line">p = <span class="number">1</span> <span class="number">-6</span> <span class="number">11</span> <span class="number">-6</span></span><br><span class="line">&gt;&gt; p1 = poly2str(p, <span class="string">'x'</span>) p2 = poly2sym(p, <span class="string">'x'</span>)</span><br><span class="line">p1 = x^<span class="number">3</span> - <span class="number">6</span> x^<span class="number">2</span> + <span class="number">11</span> x – <span class="number">6</span></span><br><span class="line">P2 = x^<span class="number">3</span> - <span class="number">6</span>*x^<span class="number">2</span> + <span class="number">11</span>*x - <span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="算数运算与求导"><a href="#算数运算与求导" class="headerlink" title="算数运算与求导"></a>算数运算与求导</h3><h4 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h4><ul><li>阶次不同时，<strong>低阶多项式</strong>必须用0填补系数数组，使其与高阶多项式有相同的阶次。</li></ul><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = conv(a, b);</span><br></pre></td></tr></table></figure><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = deconv(c, a);</span><br><span class="line">[d, r] = deconv(c, a);</span><br></pre></td></tr></table></figure><ul><li><code>d</code>：整数部分</li><li><code>r</code>：余数</li></ul><h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><ul><li><p>数组变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = polyval(p, x);</span><br></pre></td></tr></table></figure></li><li><p>矩阵变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = polyvalm(p, x);</span><br></pre></td></tr></table></figure><ul><li>变量<code>x</code>是一个<strong>方阵</strong></li></ul></li></ul><h3 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k = polyder(p);</span><br><span class="line">k = polyder(a, b); <span class="comment">% differentiate a * b</span></span><br><span class="line">[p, q] = polyder(a, b); <span class="comment">% differentiate a / b, and result is q(x)/p(x)</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/15/bPF6VulXij3ZUrz.png" alt="image-20201015133030937" style="zoom:50%;" /></p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polyint(p, k); <span class="comment">% p is coef vector, and k is const item.</span></span><br><span class="line">polyint(p); <span class="comment">% k is default to 0.</span></span><br></pre></td></tr></table></figure><h4 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I,n]=quad(<span class="string">'fname'</span>,a,b,tol,trace);</span><br><span class="line">[I,n]=quadl(<span class="string">'fname'</span>,a,b,tol,trace);</span><br></pre></td></tr></table></figure><ul><li><p><code>fname</code>可以是内联函数名</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun = inline(<span class="string">'-x.^2+115'</span>, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure><ul><li>此时如果x不是矩阵，次方需要使用<code>.^</code>.</li></ul></li><li><p><code>tol</code>用来控制积分精度，缺省时取<code>tol=0.001</code>.</p></li><li><p><code>trace</code>控制是否展现积分过程，若取非0则展现积分过程，取0则不展现，缺省时取<code>trace=0</code>.</p></li></ul><h3 id="部分分式展开"><a href="#部分分式展开" class="headerlink" title="部分分式展开"></a>部分分式展开</h3><p><img src="https://i.loli.net/2020/10/15/8k6I7hp54mGlRDT.png" alt="image-20201015115600614" style="zoom:50%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[r, p, k] = residue(b, a);</span><br></pre></td></tr></table></figure><ul><li>求<code>b/a</code>的分式展开<ul><li><code>r</code>：留数行向量</li><li><code>p</code>：部分分式极点</li><li><code>k</code>：常数项</li></ul></li><li>当多项式分母有重根时，使用<code>resi2</code>函数。</li></ul><h2 id="曲线拟合与插值"><a href="#曲线拟合与插值" class="headerlink" title="曲线拟合与插值"></a>曲线拟合与插值</h2><h3 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h3><ul><li><p><code>polyfit</code>：最小二乘拟合</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = polyfit(x, y, n);</span><br></pre></td></tr></table></figure></li></ul><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ul><li>利用已知点确定未知点</li><li>常用于图像旋转、缩放</li></ul><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yi = interp1(x, y, xi, method)</span><br></pre></td></tr></table></figure><ul><li><code>method</code><ul><li><code>nearest</code>：最近邻内插</li><li><code>linear</code>：线性内插（默认）</li><li><code>spline</code>：三次样条内插</li><li><code>cubic</code>：三次多项式内插</li></ul></li></ul><h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi = interp2(x, y, z, xi, yi, method);</span><br></pre></td></tr></table></figure><ul><li><p><code>method</code></p><ul><li><code>nearest</code></li><li><code>bilinear</code>：二维线性内插法（默认）</li><li><code>spline</code>：二维样条内插法</li><li><code>bicubic</code>：二维三次多项式内插法</li></ul></li><li><p>二维<strong>散布点</strong>插值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi = griddata(x, y, z, xi, yi);</span><br></pre></td></tr></table></figure></li></ul><h4 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi = interp3(x, y, z, v, x1, yi, zi, method)</span><br></pre></td></tr></table></figure><ul><li><code>method</code><ul><li><code>nearest</code></li><li><code>linear</code>：默认</li><li><code>spline</code></li><li><code>cubic</code></li></ul></li></ul><h4 id="高维"><a href="#高维" class="headerlink" title="高维"></a>高维</h4><ul><li><code>interpn()</code></li></ul><h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><ul><li><p><code>fminbnd</code>：无约束<strong>单变量</strong>寻优函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fminbnd(fname, x0, x1); <span class="comment">% fname is function name, and [x0, x1] is range.</span></span><br></pre></td></tr></table></figure><ul><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fminbnd(<span class="string">'sin'</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fminsearch</code>：多元函数极小值点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval, exitflag, output] = fminsearch(fun, x0);</span><br></pre></td></tr></table></figure><ul><li><code>exitflag</code>为1表示计算成功</li><li><code>fun</code>可以是外部函数，也可以直接用字符串作参数。</li><li>函数中的变量必须是<code>x(i)</code></li></ul></li></ul><h2 id="代数方程组"><a href="#代数方程组" class="headerlink" title="代数方程组"></a>代数方程组</h2><ul><li>$ax-b=0(a是m*n矩阵)$的方程类型<ul><li>恰定：$m=n$</li><li>超定：$m&gt;n$</li><li>欠定：$m&lt;n$</li></ul></li></ul><h3 id="恰定"><a href="#恰定" class="headerlink" title="恰定"></a>恰定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = inv(a)*b;</span><br><span class="line">x = a/b;</span><br></pre></td></tr></table></figure><ul><li>$x=a^{-1}b$</li><li>除解法的速度<strong>更快</strong></li></ul><h3 id="超定"><a href="#超定" class="headerlink" title="超定"></a>超定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = a/b; <span class="comment">% 最小二乘法求近似解</span></span><br><span class="line">x = (a'*a)^<span class="number">-1</span>*a'*b;</span><br></pre></td></tr></table></figure><ul><li><code>a&#39;</code>：矩阵<code>a</code>的<strong>转置</strong></li></ul><h3 id="欠定"><a href="#欠定" class="headerlink" title="欠定"></a>欠定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = a/b; <span class="comment">% 求出0最多的解</span></span><br><span class="line">x = pinv(a) * b; <span class="comment">% 求出最小范数解</span></span><br></pre></td></tr></table></figure><h2 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h2><p>$\begin{cases} \frac{dy}{dx}=f(x,y) \\ y(x_0)=y_0 \end{cases}$</p><h3 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = dsolve(<span class="string">'eq1, eq2, ...'</span>, <span class="string">'cond1, cond2,...'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>单个方程</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsolve(<span class="string">'Dy=x'</span>, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不指定<code>x</code>时默认为<code>t</code></p></blockquote></li><li><p>方程组</p><p><img src="https://i.loli.net/2020/10/15/zQwahvJC9MHmbLs.png" alt="image-20201015134613691" style="zoom: 67%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[X,Y]=dsolve(<span class="string">'Dx+2*x-Dy=10*cos(t)'</span>, <span class="string">'Dx+Dy+2*y=4*exp(-2*t)'</span>, <span class="string">'x(0)=2, y(0)=0'</span>, <span class="string">'t'</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值解"><a href="#数值解" class="headerlink" title="数值解"></a>数值解</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[t, y] = solver(odefun, tspan, y0);</span><br></pre></td></tr></table></figure><ul><li>在区间<code>tspan</code>上用初始条件<code>y0</code>求解显式常微分方程</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1380&lt;/code&gt;字，推荐阅读时间&lt;code&gt;12~15&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter2-程序设计</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter2-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter2-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-12-04T03:28:44.137Z</published>
    <updated>2020-12-04T03:41:51.747Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>869</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><ul><li><p>输入：<code>input(message, options)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">'What is your name'</span>,<span class="string">'s'</span>);</span><br></pre></td></tr></table></figure><ul><li><code>s</code>：允许用户输入一个字符串</li></ul></li><li><p>输出</p><ul><li><p><code>disp(messages)</code>：message可以是<strong>单独一个</strong>变量，按照默认<code>format</code>输出。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>([<span class="string">'x1='</span>,num2str(x(<span class="number">1</span>)),<span class="string">'x2='</span>,num2str(x(<span class="number">2</span>))]);</span><br></pre></td></tr></table></figure><ul><li>拼接时<strong>不会</strong>添加空格</li></ul></li><li><p><code>fprintf</code>：和C格式相同</p></li><li><p><code>magbox</code>：弹窗展示</p></li></ul></li><li><p>暂停：<code>pause(time)</code></p><ul><li>省略<code>time</code>则等待用户键入后继续执行</li></ul><blockquote><p>强行中止：<code>Ctrl+C</code></p></blockquote></li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">elseif</span> expression</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>expression</code>可以带括号，也可以不带。</li><li>为了<code>if</code>和<code>end</code>对称：<code>Ctrl+I</code>自动对齐</li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> expression</span><br><span class="line"><span class="keyword">case</span> const1</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">otherwise</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>switch</code>后的类型可以为任意类型，包括字符串、矩阵、数组。</li><li><strong>不</strong>需要<code>break</code>语句，每个<code>case</code>执行后会自动跳出。</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li><p><code>for</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=expression1:expression2:expression3</span><br><span class="line"> <span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>没有<code>()</code>和<code>;</code></p></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>步长为<strong>1</strong>时，表达式2可以省略。</p></li><li><p><code>a:b</code><strong>包括</strong>右端点</p></li></ul></li><li><p><code>while</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression)</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p><code>break</code>：跳出循环</p></li><li><code>continue</code>：跳过循环体剩余语句</li><li><code>return</code>：退出脚本或函数</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">lasterr;</span><br></pre></td></tr></table></figure><ul><li><code>lasterr</code>存储上一次错误的信息</li></ul><h2 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h2><ul><li>扩展名为<code>.m</code></li><li>MATLAB在初次运行时会将<code>.m</code>文件装入内存，之后运行的速度会变快。</li></ul><h3 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h3><ul><li><p>也称为命令文件</p></li><li><p>不接受输入参数也不返回输出参数的M文件</p><blockquote><p>这里的参数指的是在命令行中调用时，脚本文件只需要输入文件名，但是函数文件需要使用<code>()</code>传参数。</p></blockquote></li><li><p>脚本文件新建的变量能够保存在MATLAB的内存空间中</p><ul><li><p>所有的变量都是<strong>全局变量</strong></p><blockquote><p>全局变量可以直接被使用，<strong>不需要</strong>预先声明<code>global</code>.</p></blockquote></li><li><p>每个脚本开始前使用<code>clear all;</code></p></li></ul></li></ul><h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><ul><li><p>对用户就是黑盒，只有输入和输出。</p></li><li><p>MATLAB函数和命令实际上都是函数文件</p></li><li><p>产生的变量默认为<strong>局部变量</strong>，存放在函数自身的工作空间中。</p><blockquote><p>在函数文件中使用全局变量需要预先声明<code>global</code></p></blockquote></li><li><p>结构</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">return_var</span>=<span class="title">funcname</span><span class="params">(input_var)</span> % <span class="title">function</span> <span class="title">definition</span></span></span><br><span class="line"><span class="comment">% help info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% annotation</span></span><br><span class="line"><span class="comment">% ...</span></span><br></pre></td></tr></table></figure><ul><li><code>help info</code>：help文档中显示，即第一个非空行前的所有注释。</li></ul></li><li><p>变量检测</p><ul><li><p><code>nargin</code>：输入实参<strong>数目</strong></p></li><li><p><code>nargout</code>：输出实参<strong>数目</strong></p><blockquote><p>在函数体外可以通过<code>nargin(&#39;func&#39;)</code>调用</p></blockquote></li><li><p><code>inputname(n)</code>：第<code>n</code>个输入参数的实际调用变量名（即函数调用出传进的参数的名字）</p><blockquote><p>如果参数本来是常量，则会返回空字符串。</p></blockquote></li><li><p><code>varargin</code>：变长输入参数<strong>列表</strong></p></li><li><p><code>varargout</code>：变长输出参数列表（直接输出则是数目）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varargout</span> = <span class="title">foo</span><span class="params">(varargin)</span></span></span><br><span class="line">fprintf(<span class="string">'How many output arguments? %d\nAnd they are:\n'</span>, nargout);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:nargout</span><br><span class="line">varargout(k) = varargin(k); <span class="comment">% the same as &#123;varargin&#123;k&#125;&#125;;</span></span><br><span class="line">fprintf(<span class="string">'%s '</span>, num2str(varargout&#123;k&#125;));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="调试和优化"><a href="#调试和优化" class="headerlink" title="调试和优化"></a>调试和优化</h2><ul><li><p><code>keyboard</code>：中断程序，用户可以在命令窗口查询内存信息。</p><ul><li>对于函数文件，将函数头注释掉即可使用<code>keyboard</code>.</li></ul></li><li><p>断点</p><ul><li><p>标准断点（小红点）</p></li><li><p>条件断点（小黄点）</p><ul><li><p>使用函数设置</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbstop in filename <span class="keyword">if</span> expression</span><br></pre></td></tr></table></figure></li></ul></li><li><p>错误断点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbstop <span class="keyword">if</span> error</span><br></pre></td></tr></table></figure><p>使程序在错误的地方停下，并且自动进入调试模式。</p></li></ul></li><li><p>优劣分析</p><ul><li><p><code>profile</code>：计算相对耗时和瓶颈</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">profile on;</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line">profile viewer;</span><br></pre></td></tr></table></figure></li><li><p><code>tic</code>/<code>toc</code>：计算绝对耗时</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tic;</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line">toc;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>优化</p><ul><li>向量化操作：使用向量替换循环</li><li>数据的预定义：一次性申请足够大的空间</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;869&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter1-数据类型</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-12-04T03:28:44.129Z</published>
    <updated>2020-12-04T03:41:52.150Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1782</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>每一种类型都以<strong>数组</strong>为基础</li><li>默认类型为<code>double</code>，可以利用转化函数改变类型。</li><li><strong>不用</strong>事先对变量的类型进行定义或说明</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>预定义的特殊变量</p><ul><li><code>ans</code>：<strong>未赋值运算</strong>结果自动赋值给<code>ans</code></li><li><code>eps</code>：容差变量，小于该值时可认为是0.</li><li><code>pi</code></li><li><code>i,j</code>：二者等价，虚数单位。</li><li><code>inf</code>：正无穷大，0作<strong>除数</strong>时出现。</li><li><code>NaN</code>：不合法数值，在$0*∞,0/0$等运算时产生。</li><li><code>version</code></li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li><code>clear name1 name2 name3;</code>：清除用户自定义的变量<ul><li><code>clear all;</code>：清除所有变量</li></ul></li><li>特殊常量的值可以在当前程序中被<strong>临时改变</strong></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>MATLAB中所有变量都以<strong>数组或矩阵</strong>形式保存</li></ul><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul><li>和C一致</li><li>对大小写敏感</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>变量查询<ul><li><code>who</code>：列出所有的变量名</li><li><code>whos</code>：给出所有变量及其大小、类别等性质。</li></ul></li><li><code>clear</code>：删除<strong>自定义</strong>变量，并重置<strong>除<code>eps</code>之外</strong>的常量。<ul><li><code>clear a*</code>：删除所有以<code>a</code>开头的变量</li></ul></li><li><code>pack</code>：重组和压缩已分配的内存碎块，在不影响变量的情况下腾出空间。<ul><li><code>pack filename</code>：自定义中间<code>mat</code>文件名（之后会被自动删掉）</li></ul></li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li><p>局部变量：函数内部定义的变量</p></li><li><p>全局变量：函数之间共享的变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> MAXLEN;MAXLEN=<span class="number">45</span>;</span><br></pre></td></tr></table></figure></li><li><p>永久变量：类似于<code>static</code>，在M文件中定义和使用，只在<code>clear</code>时被清除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">persistent</span> MAXLEN; MAXLEN=<span class="number">45</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><ul><li><p>整型：带符号&amp;无符号</p></li><li><p>浮点型：单精度(single)&amp;双精度(double)</p><blockquote><p>单精度<strong>不是</strong><code>float</code></p></blockquote></li><li><p>比较</p><ul><li><code>~=</code></li><li><code>==</code></li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x1 = int8(<span class="number">11</span>); <span class="comment">% 11</span></span><br><span class="line">x2 = int8(<span class="number">15.49</span>); <span class="comment">% 15</span></span><br><span class="line">x3 = int8(<span class="number">15.5</span>); <span class="comment">% 16</span></span><br><span class="line">x4 = int8(<span class="number">130</span>); <span class="comment">% 127</span></span><br><span class="line">x5 = uint8(<span class="number">-1</span>); <span class="comment">% 0</span></span><br></pre></td></tr></table></figure><ul><li><p>浮点型转换为整型是<strong>四舍五入</strong></p></li><li><p>超过类型边界<strong>则取边界值</strong></p></li><li><p><code>intmax</code>/<code>intmin</code>：查询整型边界</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intmax(<span class="string">'int8'</span>); <span class="comment">% 127</span></span><br></pre></td></tr></table></figure><blockquote><p>类型传入需要<strong>引号</strong></p></blockquote></li><li><p><code>realmax</code>/<code>realmin</code>：查询浮点型边界</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">realmax</span>(<span class="string">'single'</span>);</span><br></pre></td></tr></table></figure></li><li><p>数值默认为双精度浮点数，需要手动转换为<code>single</code>或其它类型.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">35</span>;</span><br><span class="line">y = single(X);</span><br><span class="line">class(x) <span class="comment">% double</span></span><br><span class="line">class(y) <span class="comment">% single</span></span><br></pre></td></tr></table></figure><ul><li><code>;</code>：变量后加<code>;</code>限制变量输出，不会打印到控制台，和C作用不同。</li></ul></li></ul><h4 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h4><ul><li><code>round(x)</code>：四舍五入（负数可能<strong>向下</strong>五入）</li><li><code>fix(x)</code>：向0取整</li><li><code>floor(x)</code>：向<strong>下</strong>取整</li><li><code>ceil(x)</code>：向<strong>上</strong>取整</li></ul><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul><li><p>创建</p><ul><li><p>直接输入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span><span class="number">-3</span><span class="built_in">i</span> <span class="comment">% ans = 2.0000-3.0000i</span></span><br></pre></td></tr></table></figure><blockquote><p><code>format</code>默认设置小数点后保留4位，当数字大于1000时，使用科学计数法。</p></blockquote></li><li><p><code>complex(a, b)</code>：a是实部，b是虚部，且b不指定时默认为0.</p></li></ul></li></ul><h3 id="逻辑型变量"><a href="#逻辑型变量" class="headerlink" title="逻辑型变量"></a>逻辑型变量</h3><ul><li><p><code>true</code>对应1，<code>false</code>对应0.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>] &gt; <span class="number">5</span> <span class="comment">% y = [1, 0, 1]</span></span><br></pre></td></tr></table></figure></li><li><p><code>logical</code>：数值转换为逻辑型</p></li><li><p><code>any</code>/<code>all</code>：矩阵传入一维真值矩阵</p></li><li><p><code>is*(isspace)</code>：测试运算</p></li><li><p>逻辑数组：利用逻辑运算构造矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">rand</span>(<span class="number">3</span>), A(A&lt;<span class="number">0.5</span>)=<span class="number">0</span> <span class="comment">% assign val &lt; 0.5 positions to zero</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h3><ul><li>数组的运算都是<strong>点运算</strong>（逐个元素运算）</li><li>矩阵的乘法、乘方、除法有特殊含义，其他和数组没有区别。</li><li><strong>MATLAB的下标从1开始</strong></li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><p>直接构造法</p><ul><li><code>[]</code></li><li><code>,</code>：间隔<strong>行内</strong>元素，或者使用空格。</li><li><code>;</code>：间隔<strong>行间</strong>元素，或者使用回车。</li><li>元素可以为值/表达式</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">3.8</span>, <span class="number">1e-3</span>, <span class="built_in">sqrt</span>(<span class="number">2</span>)]</span><br><span class="line">b = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>增量法</p><ul><li><p>利用冒号生成向量（包括<strong>右端点</strong>）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">i</span>:<span class="built_in">j</span> <span class="comment">% [i,j] as an array(including j)</span></span><br><span class="line">x = <span class="built_in">i</span>:<span class="built_in">j</span>:k <span class="comment">% j is stride</span></span><br></pre></td></tr></table></figure></li><li><p><code>linspace(a,b)</code>：生成等差向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>) <span class="comment">% from 2 to 8 with 10 numbers(default to 100 numbers)</span></span><br></pre></td></tr></table></figure></li><li><p><code>logspace(a,b)</code>：等比向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = logspace(2, 8) # default to produce 50 numbers</span><br><span class="line">y = <span class="built_in">logspace</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>利用小矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">C = [a, <span class="built_in">eye</span>(<span class="built_in">size</span>(A)); <span class="built_in">ones</span>(<span class="number">3</span>), A*<span class="number">2</span>]</span><br></pre></td></tr></table></figure><ul><li><code>size()</code>：返回行数和列数<ul><li><code>length()</code>：返回行数和列数中的最大值</li></ul></li><li><code>eye(size)</code>：返回单位矩阵</li><li><code>ones(size)</code>：返回全一矩阵</li></ul></li></ul><h4 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h4><ul><li><p>元素赋值</p><ul><li>超过边界时，内存会<strong>自动扩展</strong>。</li></ul></li><li><p>运算</p><ul><li><code>*</code>：数学意义上的<strong>矩阵乘法</strong></li><li><code>.*</code>：<strong>点运算</strong>的数组乘法，对应元素相乘。</li></ul><blockquote><p><code>^</code>等运算符同上</p></blockquote></li><li>拆分：利用冒号表达式获得子矩阵<ul><li><code>A(r,c)</code>：(r,c)位置的元素</li><li><code>A(r,:)</code>：A的第r行的所有元素</li><li><code>A(:,c)</code>：A的第c列的所有元素</li><li><code>A(:)</code>：<strong>列优先</strong>使A变为一维数组</li><li><code>A(i)</code>：访问<code>A(:)</code>中的第<code>i</code>个元素</li><li><code>A(r,c)=Sa</code>：元素赋值</li><li><code>A(:)=D(:)</code></li></ul></li><li><p>删除：利用<code>[]</code>赋值</p><ul><li><p>删除不是清零，而是<strong>改变</strong>矩阵结构。</p><blockquote><p><code>clear</code>后矩阵变量则消失，不能再通过变量名操作。</p></blockquote></li></ul></li><li><p>其他</p><ul><li><p><code>diag</code>：提取矩阵对角线元素生成对角矩阵</p></li><li><p><code>flipud</code>：上下翻转</p></li><li><p><code>fliplr</code>：左右翻转</p></li><li><p><code>reshape(name, length, width)</code>：第一个参数是原矩阵，改变形状。</p><ul><li>注意矩阵<strong>列优先</strong></li></ul></li><li><p><code>rot90</code>：<strong>逆时针</strong>旋转90度</p></li><li><p><code>det</code>：矩阵行列式的值</p></li><li><p><code>rank</code>：矩阵的秩</p></li><li><p><code>trace</code>：矩阵的迹</p></li><li><p><code>max</code>：包含<strong>每一列</strong>最大值的向量</p></li><li><p>数组逆序</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = A(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>); <span class="comment">% end is a special symbol for iteration</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>一维字符数组</li><li>用<strong>单引号</strong>括起</li><li>字符串的<code>class</code>是<code>char</code></li><li>索引访问时应该使用<code>()</code>而不是<code>[]</code></li></ul><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul><li><p>单引号赋值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">'BUAA'</span>;</span><br><span class="line">b = c(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = char(<span class="number">97</span>) <span class="comment">% a</span></span><br><span class="line">c2 = num2str(<span class="number">97</span>) <span class="comment">% 97</span></span><br></pre></td></tr></table></figure><ul><li><p><code>setstr</code>：将ASCII码转换成字符串</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setstr(<span class="built_in">abs</span>(<span class="string">'c'</span>) + <span class="built_in">abs</span>(<span class="string">'a'</span>) - <span class="built_in">abs</span>(<span class="string">'A'</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>abs</code>：将字符串转换为ASCII码</p></li></ul><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><ul><li><p>水平</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="string">'I '</span>, <span class="string">'Love '</span>, <span class="string">'Matlab!'</span>] <span class="comment">% str = I Love Matlab</span></span><br><span class="line">str2 = strcat(<span class="string">'I '</span>, <span class="string">'Love '</span>, <span class="string">'Matlab!'</span>) <span class="comment">% str = ILoveMatlab</span></span><br></pre></td></tr></table></figure><ul><li><code>strcat</code>会自动去掉<strong>结尾处</strong>的空格，头部的<strong>不会被</strong>去掉。</li></ul></li><li><p>垂直</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="string">'Matrix    '</span>;<span class="string">'Lab'</span>]</span><br><span class="line">str2 = strvcat(<span class="string">'Matrix    '</span>,<span class="string">'Lab'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>strvcat</code>自动去掉<strong>结尾</strong>的空格</li></ul></li></ul><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><ul><li><p><code>isstrprop(str, &#39;category&#39;)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isstrprop(pw, <span class="string">'alphanum'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li><code>strcmp</code>：相等返回1</li><li><code>==</code>：逐个字符比较，返回一维数组，相等的位为1.</li></ul><h4 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h4><div class="table-container"><table><thead><tr><th>编码方式</th><th>英文（单位：字节）</th><th>中文（单位：字节）</th></tr></thead><tbody><tr><td><code>ASCII</code></td><td>1</td><td>/</td></tr><tr><td><code>UTF-8</code></td><td>1</td><td>3</td></tr><tr><td><code>UTF-16</code></td><td>2</td><td>2/4</td></tr><tr><td><code>UTF-32</code></td><td>4</td><td>4</td></tr><tr><td><code>GBK</code></td><td>1</td><td>2</td></tr></tbody></table></div><blockquote><p>在<code>R202a</code>中测试，无论是英文还是中文均占用两个字节。</p></blockquote><h3 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h3><ul><li>提供间接调用函数方法的数据类型</li></ul><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><ul><li><p>在已有函数名前加符号<code>@</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1 = @funcname;</span><br></pre></td></tr></table></figure></li><li><p>提供匿名函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqr = @(x)x.^<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><ul><li>将函数句柄看作函数名，和函数调用相同。</li></ul><h3 id="元胞数组"><a href="#元胞数组" class="headerlink" title="元胞数组"></a>元胞数组</h3><ul><li>其中的元素类型、尺寸可以不相同</li><li>创建、访问时用<code>{}</code>表示索引</li></ul><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><ul><li><p><code>cell</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=cell(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li><p><code>deal</code>：<strong>列优先</strong>查看内容，返回一个长向量进行解析。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,b] = deal(a&#123;:&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>[]</code>：赋值，删除元素。</p></li><li><p><code>num2cell</code>/<code>mat2cell</code>：数组、矩阵和元胞的转换。</p></li><li><p><code>celldisp</code>：逐个显示元胞数组内容</p></li></ul><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; stu = struct(<span class="string">'username'</span>, &#123;&#125;, <span class="string">'password'</span>, &#123;&#125;, <span class="string">'name'</span>, &#123;&#125;, <span class="string">'gender'</span>, &#123;&#125;); <span class="comment">% an empty struct array</span></span><br><span class="line">&gt;&gt; stu(<span class="number">1</span>).name=<span class="string">'Silence'</span>;</span><br><span class="line">&gt;&gt; stu(<span class="number">1</span>).course=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  struct with fields:</span><br><span class="line"></span><br><span class="line">      name: <span class="string">'Silence'</span></span><br><span class="line">    course: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>struct</code>函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; student(<span class="number">3</span>)=struct(<span class="string">'name'</span>,<span class="string">'Lex'</span>,<span class="string">'course'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">student = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">3</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br></pre></td></tr></table></figure></li></ul><h4 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; stu(<span class="number">2</span>).name=<span class="string">'Anita'</span></span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br></pre></td></tr></table></figure><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu(<span class="number">2</span>).name</span><br></pre></td></tr></table></figure><h4 id="删除域"><a href="#删除域" class="headerlink" title="删除域"></a>删除域</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; rmfield(stu,&#123;<span class="string">'course'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line"></span><br><span class="line">&gt;&gt; stu</span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>不改变</strong>本来的结构数组</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1782&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
</feed>

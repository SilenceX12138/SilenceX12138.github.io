<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-23T12:37:05.831Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Silence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/C++%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/C++%20Learning%20Note/</id>
    <published>2021-06-23T12:34:24.552Z</published>
    <updated>2021-06-23T12:37:05.831Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全文共<code>2981</code>字，为暑期C++学习记录，推荐按照顺序阅读。</strong></p><a id="more"></a><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li><p>每个<code>.h</code>文件智能定义一个<code>class</code></p></li><li><p>函数主体放在<code>.cpp</code>中</p></li><li><p><code>.h</code>文件需要使用标准头文件格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NAME_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NAME_H_</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul><li>变量是对象自己的</li><li>函数是类的<ul><li>隐藏了<code>this</code>参数将对象传进类的函数</li></ul></li><li>私有变量通过<code>::</code>也<strong>不能</strong>访问</li></ul><h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><p>创建对象时使用</p></li><li><p>和类同名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    A(); <span class="comment">// no return type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A()</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>没有参数</strong>的构造函数<strong>都叫</strong><code>default constructor</code>，不一定是编译器默认创造的。</p></blockquote></li><li><p>参数化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree::Tree(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">t</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass c1;<span class="comment">//表示使用不带参数的构造函数，或者有默认参数值的构造函数。</span></span><br><span class="line"><span class="function">MyClass <span class="title">c2</span><span class="params">()</span></span>;<span class="comment">//不会调用无参构造函数,各种情况下该处是声明一个返回值为MyClass类型的函数而已</span></span><br><span class="line"><span class="function">MyClass <span class="title">c3</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//调用参数为int的构造函数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li><p>销毁对象时使用</p><blockquote><p>对象的生存周期是<strong>大括号</strong></p></blockquote></li><li><p>无参数，在构造函数前加一个<code>~</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> height; <span class="comment">// default to be private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> initialHeight);</span><br><span class="line">    ~Tree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> years)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new&amp;delete"></a>new&amp;delete</h2><ul><li><p>delete不能操作没有new的空间</p></li><li><p>delete对同一个对象不能连续使用两次</p></li><li><p>delete[]和new[]需要<strong>成对</strong>使用</p></li><li><p>在delete之前最好判断一下是否是空指针（是空指针<strong>大多数情况</strong>也安全）</p></li><li><p>new创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------对于new关键字加括号和不加括号的区别---</span></span><br><span class="line"><span class="comment">1.对于自定义类型来说没有区别，都是使用默认构造函数</span></span><br><span class="line"><span class="comment">2.对于内置类型来说加括号会初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">MyClass *c4 = <span class="keyword">new</span> MyClass();</span><br><span class="line">c4-&gt;MyMethod();</span><br><span class="line">MyClass *c5 = <span class="keyword">new</span> MyClass(<span class="number">1</span>);</span><br><span class="line">c5-&gt;MyMethod();</span><br><span class="line">MyClass *c6 = <span class="keyword">new</span> MyClass;</span><br><span class="line">c6-&gt;MyMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *pint1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> *pint2 = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// *pint2 is 0</span></span><br><span class="line"><span class="keyword">int</span> *pint3 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// *pint3 is a random number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*pint1&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint2&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint3&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><code>new</code>创建对象需要<strong>指针</strong>接收</li><li><code>new</code>创建对象需要<code>delete</code>销毁</li><li><code>new</code>创建的对象在<strong>堆</strong>上，不使用<code>new</code>创建的对象在<strong>栈</strong>上。</li></ul></li></ul><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul><li><p><code>private</code>的变量在类的函数中可以被<strong>其他的对象</strong>访问，即同类对象可以相互访问私有变量。</p><blockquote><p><code>private</code>只在编译时有限制</p></blockquote></li><li><p>使用<code>friend</code>授权某些函数访问<strong>私有变量</strong></p></li><li><p>class的访问属性默认为<code>private</code>，struct默认为<code>public</code>.</p></li></ul><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> x, y;</span><br><span class="line">    Point(<span class="keyword">float</span> xa = <span class="number">0.0</span>, <span class="keyword">float</span> ya = <span class="number">0.0</span>): x(xa), y(ya)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>初始化列表在构造函数<strong>之前</strong>执行</p></li><li><p>和构造器赋值的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(String s): name(s)&#123;&#125;</span><br><span class="line">Student::Student(String s) &#123;name = s;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>推荐使用初始化列表进行对象的初始化。</p><p>在构造器赋值时，如果有一个成员变量是自定义类的对象，并且该类没有无参数构造函数，那么在构造函数中对该对象赋值时就会报错。（因为在<strong>构造函数</strong>中，会默认调用无参数构造函数）</p></blockquote></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>名称隐藏：当子类覆写父类函数时，所有的父类函数都会被子类屏蔽。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> ii) : i(ii) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : A(<span class="number">15</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.print(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>b</code><strong>没有</strong>无参数的<code>print</code>方法</p></blockquote></li></ul><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><ul><li><p>只能在<code>.h</code>（函数声明）时设置默认值，<strong>不可以</strong>在函数定义处使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j=<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>和Python不同的是，修改<code>j</code>时直接传数据即可，<strong>不需要</strong>写参数名称。</p></li><li><p>尽量<strong>不使用</strong>默认参数值</p></li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li><p>在调用的地方直接展开，减少调用函数时的栈操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b = f(a); <span class="comment">// int b = a * 2;</span></span><br><span class="line">    <span class="keyword">int</span> c = f(<span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内联函数的定义<strong>不在</strong><code>.cpp</code>文件中，而应该和声明<strong>都放在</strong><code>.h</code>中</p><blockquote><p>因为<code>inline</code>告诉编译器这是个<strong>函数声明</strong>而不是定义，在<strong>使用函数</strong>的地方再进行展开。</p></blockquote></li><li><p>当<code>inline</code>函数太大时（例如递归），编译器可能会拒绝展开。</p></li><li><p>类的<code>.h</code>文件中直接写出函数体的函数<strong>都是</strong>内联函数，在<code>.h</code>中也可以单独声明内联函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is a inline function defined in header file."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环体中的<strong>小函数</strong>推荐使用内联函数</p></li><li><p>和宏相比，内联函数可以做类型检查，更加安全。</p></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li><p><strong>不可修改</strong>机制是在编译时确定的，因此是编译器进行检查。</p><ul><li><p>编译时确定的值可以用来声明数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_size = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> finalGrade[class_size];</span><br></pre></td></tr></table></figure></li><li><p><code>const</code>在<code>*</code>前后对指针的影响</p><ul><li><p>在<code>*</code>前：<strong>对象</strong>是<code>const</code>（<strong>不能</strong>通过该指针改变对象，但是<strong>可以</strong>通过其他指针）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;a;</span><br><span class="line">*p2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person *p = &amp;p1;</span><br><span class="line">Person <span class="keyword">const</span> *p = &amp;p1;</span><br></pre></td></tr></table></figure></li><li><p>在<code>*</code>后：<strong>指针</strong>是<code>const</code>（<strong>不能</strong>改变该指针的指向）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *<span class="keyword">const</span> p = &amp;p1;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>普通指针<strong>不能</strong>指向<code>const</code>变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">3</span>;</span><br><span class="line">ip = &amp;ci; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>不可</strong>修改对象的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::get_day</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    day++; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在声明和定义处要重复<code>const</code></p></li><li><p>便于编译器对<code>const</code>对象调用方法时进行安全检查</p></li><li><p>本质是将<code>this</code>设置为<code>const</code></p></li><li><p><code>const</code>可以实现重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : i(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    ~A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f() with const"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> A a;</span><br><span class="line">    a.f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>const</code>对象<strong>只能</strong>调用<code>const</code>函数</li></ul></li></ul></li><li><p><code>const</code>成员变量必须在<strong>初始化列表</strong>中初始化（<strong>不可以</strong>在构造函数中进行）</p></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p>一种访问对象的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;p = c;</span><br></pre></td></tr></table></figure><ul><li>引用<strong>必须</strong>初始化（成员变量、函数参数除外）</li><li>引用相当于是<strong>别名</strong></li><li>引用的目的就是为了减少代码中的<code>*</code></li></ul></li><li><p>引用和指针的比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">(<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>不同于</strong>指针，引用在执行过程中<strong>不能</strong>改变对象。</p></li><li><p>引用<strong>不能</strong>是<code>NULL</code></p></li><li><p>传入的<code>x</code>在两种情况中<strong>都会</strong>被修改</p></li><li><p>传入函数的参数<strong>不是指针</strong>时，也<strong>可能</strong>被修改。</p></li><li><p>引用是由<code>const</code>指针实现的</p></li><li><p>引用的引用实际上<strong>不存在</strong>，只是改变了引用的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> &amp;a = x;</span><br><span class="line"><span class="keyword">int</span> &amp;b = y; </span><br><span class="line"></span><br><span class="line">b = a; <span class="comment">// y = x, but not b refer to a.</span></span><br></pre></td></tr></table></figure><blockquote><p>Java的引用实际上对应C++的指针</p></blockquote></li><li><p>引用的指针可以存在，但是指针的引用不存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;*p1; <span class="comment">// illegal</span></span><br><span class="line"><span class="keyword">int</span> *&amp;p2; <span class="comment">// reference to pointer</span></span><br></pre></td></tr></table></figure><blockquote><p>引用<strong>没有</strong>地址</p></blockquote></li><li><p><strong>没有</strong>引用数组（因为引用并不是实体，<strong>没有</strong>地址）</p></li></ul></li><li><p>引用作为成员变量时，需要在初始化列表中写上这个引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> &amp;b): a(b) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为返回值时，最好<strong>不是</strong>局部变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> &amp;<span class="title">subscript</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为函数参数传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">int</span>&amp;z)</span></span>&#123;</span><br><span class="line">    z *= <span class="number">5</span>; <span class="comment">// OK</span></span><br><span class="line">    y += <span class="number">8</span>; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>传<strong>非</strong><code>const</code>引用时<strong>不可以</strong>是算式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li><p>动态调用的方法需要使用<code>virtual</code>关键字声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在父类中声明一次<code>virtual</code>后，所有子类中的函数都是虚函数，可以省略<code>virtual</code>，但是推荐加上。</li><li>所有含虚函数的类的对象都会增加一个<code>vptr</code>指针，指向类自己的<code>vtable</code>，存储了<strong>该类</strong>所有的虚函数。</li></ul></li><li><p>继承关系对象的赋值<strong>不改变</strong><code>vtable</code>（与指针赋值不同）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a = b;</span><br><span class="line">a.f(); <span class="comment">// A's f() instead of B's</span></span><br></pre></td></tr></table></figure></li><li><p>析构函数需要是<code>virtual</code>的</p></li><li>多态需要使用指针实现，<strong>不能</strong>通过<code>.</code>实现。</li></ul><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><ul><li><p>编译器默认的拷贝构造是浅拷贝</p><ul><li><p>当字符串是<code>char *</code>时，内存会被<code>delete</code>两次，这样会发生错误。因此Cpp通常使用<code>string</code>类来定义字符串。</p><blockquote><p>尽管是浅拷贝，标准库中的类<strong>也不会</strong>出现内存问题。</p></blockquote></li></ul></li><li><p>拷贝构造和<strong>初始化</strong>的形式相同，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = p;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>一个类必须声明的三个函数</p><ul><li><p>默认构造函数（参数列表为空）</p></li><li><p><code>virtual</code>的析构函数</p></li><li><p>自定义的拷贝构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(<span class="keyword">const</span> ClassName &amp;p) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>Cpp保证对象只被构造一次</li><li><code>static</code>让对象变成全局的</li></ul><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><ul><li><p>通过<code>static</code>成为和对象<strong>无关</strong>的变量</p></li><li><p>类中只是<strong>声明</strong>，需要单独定义后才能使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;i = <span class="number">0</span>;&#125; <span class="comment">// A():i(0) &#123;&#125; is illegal</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::i; <span class="comment">// not static int A::i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a, b;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">    b.print();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化列表只能对<strong>非静态</strong>成员变量使用</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>调用<ul><li>对象：<code>a.f()</code></li><li>类：<code>A::f()</code></li></ul></li><li>在静态函数中<strong>没有</strong><code>this</code>参数</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>在Cpp中，几乎所有的运算符都可以被重载，除了<code>./.*/::/?:</code>.</li><li>重载只能在类/枚举类发生</li><li>优先级、运算格式<strong>不能</strong>改变。</li><li><p>关键字<code>operator</code>+运算符表示重载函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> *(...);</span><br><span class="line"><span class="keyword">const</span> String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String &amp;that);</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp;n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(i + n.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z = x + y; <span class="comment">// OK</span></span><br><span class="line">z = x + <span class="number">3</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + <span class="number">7</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + y; <span class="comment">// Error!</span></span><br><span class="line">z = x + <span class="number">3.5</span> <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li><p>设置全局函数解决<code>z=3+y</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(l.i + r.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一元运算符<strong>不需要</strong>设置参数，应该是成员的。</li><li><code>=/()/[]/-&gt;/-&gt;*</code><strong>必须是</strong>成员的</li><li>其他二元运算符<strong>最好是</strong>全局的</li></ul></li></ul></li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><p><code>+-*/%^&amp;|~</code>:<code>const T operatorX(const T &amp;l, const T&amp;r) const;</code></p></li><li><p><code>!/&amp;&amp;/||/&lt;/&lt;=/==/&gt;=/&gt;</code>:<code>bool operatorX(const T &amp;l, const T &amp;r) const;</code></p></li><li><p><code>[]</code>:<code>T &amp;T::operator[](int index);</code></p></li><li><p><code>++/--</code>：参数填一个占位<code>int</code>表示<strong>后置</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Integer &amp;<span class="keyword">operator</span>++() <span class="comment">// ++a</span></span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>++(<span class="keyword">int</span>) <span class="comment">// a++</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName a = b; <span class="comment">// copy construct</span></span><br><span class="line">a = b; <span class="comment">// assign</span></span><br></pre></td></tr></table></figure><ul><li><p>标准写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T &amp;T::<span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;r) &#123;</span><br><span class="line">        <span class="comment">// assign</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自己和自己相等进行赋值时，若成员中有指针，可能出现指针被改变后导致原来的内容无法访问，从而赋值失败的问题。</li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>禁止<strong>隐式</strong>类型转换：<code>explicit</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Two</span><span class="params">(class One &amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">one = two <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li>定义在<code>Two</code>中</li></ul></li><li><p>强制类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassName::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>定义在<code>One</code>中（不是<code>double</code>）</li><li><strong>没有</strong>返回类型</li></ul><blockquote><ul><li>两者地位相同，有哪种用哪种。</li><li>两种类型转换<strong>只能</strong>存在一种，除非第一种加了<code>explicit</code>.</li></ul></blockquote></li><li><p>不推荐使用默认转换，应该写成显式的转换方法<code>toXXX()</code>.</p></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>重用代码的一种方式，类似于Java中的泛型编程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // &lt;class Key, class Value&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">foo</span>(<span class="title">void</span>) &#123;</span><span class="comment">/* ... */</span>&#125;</span><br><span class="line">foo&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// type for T is int</span></span><br><span class="line">foo&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure></li><li><p>指定其他参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">bounds</span> = 100&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>继承</p><ul><li><p>模板之间不能继承，只能用来指定父类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> List&lt;A&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125; <span class="keyword">catch</span> (VectorIndexError &amp;e) &#123;</span><br><span class="line">    <span class="comment">// throw;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>不带对象的<code>throw</code>就是抛出<strong>原异常</strong></p></li><li><p><code>catch(...)</code>捕捉<strong>所有的</strong>异常，但是没有办法确定具体是哪一种。</p></li><li><p>函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a)</span> : <span class="title">throw</span><span class="params">(MathErr)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数抛异常之前，使用<code>delete this;</code>防止出现内存垃圾。</p></li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li><p>自定义类的输入流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>&gt;&gt;(istream &amp;is, T &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// construct obj</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul><li>包含常见的数据结构和算法<ul><li><code>Vector</code></li><li><code>List</code></li><li><code>Deque</code></li><li><code>Sets &amp; Maps</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;全文共&lt;code&gt;2981&lt;/code&gt;字，为暑期C++学习记录，推荐按照顺序阅读。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm Course Note</title>
    <link href="http://yoursite.com/2021/06/23/Algorithm%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/Algorithm%20Course%20Note/</id>
    <published>2021-06-23T12:31:27.612Z</published>
    <updated>2021-06-23T12:38:44.872Z</updated>
    
    <content type="html"><![CDATA[<p>Learning note of 2020 BUAA Algorithm Course.</p><p>[TOC]</p><a id="more"></a><h1 id="Chapter0-Introduction"><a href="#Chapter0-Introduction" class="headerlink" title="Chapter0 Introduction"></a>Chapter0 Introduction</h1><p>Total Count: <code>161</code> words</p><p>Preferred Reading Time: <code>3~5</code> minutes</p><h2 id="Syllabus"><a href="#Syllabus" class="headerlink" title="Syllabus"></a>Syllabus</h2><ul><li>Basics</li><li>Divide and Conquer</li><li>DP</li><li>Greedy</li><li>Graph</li><li>Hard Problems</li></ul><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ul><li>Design</li><li>Analyze</li></ul><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><ul><li>Computational Problem</li><li>Instance</li><li>Algorithm</li></ul><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><ul><li>Memory</li><li>Running time(focus of course)<ul><li>computer</li><li>implementation details</li><li>input(size etc.)</li></ul></li></ul><h3 id="Machine-independent-running-time"><a href="#Machine-independent-running-time" class="headerlink" title="Machine-independent running time"></a>Machine-independent running time</h3><ul><li>depend on quantity of <strong>primitive operations</strong><ul><li>addition</li><li>multiplication</li><li>comparison</li></ul></li><li>$T(n)$:denote the running time of n-size input<ul><li>n<ul><li>sorting: items to be sorted</li><li>graph: vertices and edges</li></ul></li></ul></li><li>Best Case: an instance for given size <code>n</code> results in the most efficient situation<ul><li>eg. A sorted list for insertion sort</li></ul></li><li>Worst Case<strong>(Mostly Used)</strong>: opposite to Best Case<ul><li>eg. A rev-sorted list for insertion sort</li></ul></li><li>Average Case: based on probability of all situations </li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li><p>$Θ(n)$ notation</p><ul><li><p>a supplement of <code>T(n)</code> notation</p><blockquote><p>$T(n)$ is exact while $Θ(n)$ is approximate</p></blockquote></li><li><p>eg. Mergesort</p><p>$T(n) = 2T(n/2) + Θ(n)\ (n&gt;1)$</p><p>$T(n)=Θ(1)\ (n=1)$</p><blockquote><p>Recursive notation</p></blockquote></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter1-Asymptotic-Notations-And-Recurrence"><a href="#Chapter1-Asymptotic-Notations-And-Recurrence" class="headerlink" title="Chapter1 Asymptotic Notations And Recurrence"></a>Chapter1 Asymptotic Notations And Recurrence</h1><p>Total Count: <code>291</code> words</p><p>Preferred Reading Time: <code>5~10</code> minutes</p><h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><h3 id="Big-Oh"><a href="#Big-Oh" class="headerlink" title="Big-Oh"></a>Big-Oh</h3><ul><li><p><strong>Upper</strong> bounds</p></li><li><p>$f(n)=O(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\leq{c*g(n)}\ (c&gt;0, n&gt;n0)$</p></li><li><p>Example</p><ul><li>$sin(n)=O(1)$</li><li>$log(n!)=O(nlog(n))$</li><li>$\sum{1/n}=O(log(n))$</li></ul></li><li><p>$log_{b_1}(n)=O(log_{b_2}(n))$</p><blockquote><p>Bases in <code>O</code> notation are usually omitted.</p></blockquote></li></ul><h3 id="Big-Omega"><a href="#Big-Omega" class="headerlink" title="Big-Omega"></a>Big-Omega</h3><ul><li><p><strong>Lower</strong> bounds</p></li><li><p>$f(n)=Ω(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\geq{c*g(n)}\ (c&gt;0,n&gt;n0)$</p></li><li><p>Example</p><ul><li><p>$\sum{1/n}=Ω(log(n))$</p><blockquote><p><code>log(n)</code> is both bounds above and below, the difference is coefficient.</p></blockquote></li></ul></li></ul><h3 id="Big-Theta"><a href="#Big-Theta" class="headerlink" title="Big-Theta"></a>Big-Theta</h3><ul><li><strong>Tight</strong> bounds</li><li>$f(n)=Θ(g(n))$ when $f(n)=O(g(n))$ and $f(n)=Ω(g(n))$</li></ul><h2 id="Recurrence"><a href="#Recurrence" class="headerlink" title="Recurrence"></a>Recurrence</h2><script type="math/tex; mode=display">\begin{cases} T(n)=3T(n/4)+n^2&(n>1) \\ 1&(n=1) \tag{1} \end{cases}</script><ul><li>$n^2$ is workload of first level</li></ul><h3 id="Recursion-tree-Method"><a href="#Recursion-tree-Method" class="headerlink" title="Recursion-tree Method"></a>Recursion-tree Method</h3><p>$T(n) \leq n^2+3/16n^2+(3/16)^2n^2 + … =O(n^2)$</p><h3 id="Substitution-Method"><a href="#Substitution-Method" class="headerlink" title="Substitution Method"></a>Substitution Method</h3><p>Prove $T(n) \leq cn^2$.</p><p>$T(n)=3T(n/4)+n^2 \le3c(n/4)^2 =cn^2-(13c/16-1)n^2 \leq cn^2 (c\geq16/13)$</p><p>So when $c\geq16/13$, we can prove $T(n)\leq cn^2$.</p><blockquote><p>Since $T(n) \geq n^2$, then $Θ(n)=Ω(n)=O(n)$.</p></blockquote><h3 id="Master-Method-and-Master-Theorem"><a href="#Master-Method-and-Master-Theorem" class="headerlink" title="Master Method and Master Theorem"></a>Master Method and Master Theorem</h3><p>If $T(n)=aT(upper(\frac{n}{b}))+O(n^d)(a&gt;0,b&gt;1,d\geq0)$, then</p><script type="math/tex; mode=display">T(n)=\begin{cases} O(n^d)&d>lob_ba,b^d>a \\ O(n^dlogn)&d=lob_ba,b^d=a \\ O(n^{log_b{a}})&d<lob_ba,b^d<a \end{cases}</script><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter2-Divide-and-Conquer"><a href="#Chapter2-Divide-and-Conquer" class="headerlink" title="Chapter2 Divide and Conquer"></a>Chapter2 Divide and Conquer</h1><p>Total Count: <code>559</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><h2 id="MCS"><a href="#MCS" class="headerlink" title="MCS"></a>MCS</h2><ul><li>Maximum Contiguous Subarray<ul><li>Find the span of years in which the company earned most</li></ul></li></ul><h3 id="Exhaustive-Search"><a href="#Exhaustive-Search" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_Val</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^3)$</li></ul><h3 id="Data-Reuse"><a href="#Data-Reuse" class="headerlink" title="Data-Reuse"></a>Data-Reuse</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_val</span></span><br></pre></td></tr></table></figure><ul><li>$V(i,j)=V(i,j-1)+A[j]$</li><li>$O(n^2)$</li></ul><h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input A[s...t]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s == t:</span><br><span class="line">    retun A[s] <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    MCS(A, s, mid) <span class="comment"># T(n/2)</span></span><br><span class="line">    MCS(A, mid, t) <span class="comment"># T(n/2)</span></span><br><span class="line">    <span class="comment"># find the max_val of cut position containing A[mid] and A[mid+1]</span></span><br></pre></td></tr></table></figure><ul><li>Be cautious the array may be at the cut position.</li><li>When finding the <code>max_val</code> containing <code>A[mid]</code> and <code>A[mid+1]</code>, we can do it from <code>mid</code> to <code>0</code>.</li><li>$T(n)=2T([n/2])+n$</li><li>$O(nlogn)$</li></ul><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, temp, ans, temp_sum;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">    temp_sum = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// When temp_sum &lt; 0, it means last temp &lt; 0, and last temp has already been compared with ans to decide whether to update the start point of the sub-array.</span></span><br><span class="line">        temp_sum = max(<span class="number">0</span>, temp_sum); </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        temp_sum += temp;</span><br><span class="line">        ans = max(temp_sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Counting-inversions"><a href="#Counting-inversions" class="headerlink" title="Counting inversions"></a>Counting inversions</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># count inversion</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^2)$</li></ul><h3 id="Merge-Sort-Idea"><a href="#Merge-Sort-Idea" class="headerlink" title="Merge Sort Idea"></a>Merge Sort Idea</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(L) == <span class="number">0</span>:</span><br><span class="line">    reutrn <span class="number">0</span>, L</span><br><span class="line">cnt_a, A = sort_and_count(L[l, mid])</span><br><span class="line">cnt_b, B = sort_and_count(L[mid+<span class="number">1</span>, r])</span><br><span class="line">cnt_c, L = merge_and_count(L[l, mid], L[mid+<span class="number">1</span>, r])</span><br><span class="line"><span class="keyword">return</span> cnt_a + cnt_b + cnt_c, L</span><br></pre></td></tr></table></figure><ul><li>Increase inversion count when merging sorted two list.</li><li>$O(nlogn)$</li></ul><h2 id="Polynomial-Multiplication"><a href="#Polynomial-Multiplication" class="headerlink" title="Polynomial Multiplication"></a>Polynomial Multiplication</h2><h3 id="Brute-Force-1"><a href="#Brute-Force-1" class="headerlink" title="Brute Force"></a>Brute Force</h3><ul><li>compute all coefficients and merge them at last<ul><li>multiplications:$O(n^2)$</li><li>addition:$O(n^2)$</li><li>complexity:$O(n^2)$</li></ul></li></ul><h3 id="Divide-and-Conquer-1"><a href="#Divide-and-Conquer-1" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><ul><li>extract $x^{\frac{n}{2}}$ to make size <code>n</code> problem into $2*2$ problem</li><li>$O(n^2)$</li></ul><h4 id="Improve"><a href="#Improve" class="headerlink" title="Improve"></a>Improve</h4><ul><li>We need $A_0B_1+A_1B_0$ instead of $A_0B_1$and$A_1B_0$.<ul><li>$\begin{cases} U=A_0B_0 \\ V=A_0B_1 \\ W=A_1B_0 \\ Z=A_1B_1\end{cases}$</li><li>Take $Y=(A_0+A_1)(B_0+B_1)$, then we can get $A_0B_1+A_1B_0=Y-U-Z$.</li><li>$T(n)=\begin{cases} 3T(n/2) + n&amp;(n&gt;1) \\ 1&amp;(n=1) \end{cases}$</li></ul></li></ul><h2 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h2><ul><li>partition with pivot as a benchmark</li><li>place pivot into right place</li><li>above can be a recursive process</li><li>$O(nlogn)$: the average complexity</li></ul><h3 id="Improve-1"><a href="#Improve-1" class="headerlink" title="Improve"></a>Improve</h3><ul><li><p>The normal complexity of quicksort is $O(n^2)$ because the array may be partially sorted.</p><p>$T(n)=T(0)+T(n-1)+O(n)$</p><blockquote><ul><li>The complexity of quick sort is $O(n^2)$ instead of $O(nlogn)$.</li><li>$O(n)$ comes from the count of key comparisons.</li></ul></blockquote></li><li><p>Adopt random pivot to get randomized partition</p><ul><li>Swap random position with the last position for reuse the partition function</li><li>This action can validly lower the probability to encounter unlucky array partition</li></ul></li></ul><h4 id="Expected-Case"><a href="#Expected-Case" class="headerlink" title="Expected Case"></a>Expected Case</h4><ul><li>Analysis for randomization algorithm</li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter3-Dynamic-Programming"><a href="#Chapter3-Dynamic-Programming" class="headerlink" title="Chapter3 Dynamic Programming"></a>Chapter3 Dynamic Programming</h1><p>Total Count: <code>906</code> words</p><p>Preferred Reading Time: <code>20~25</code> minutes</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><p>Similar to Divide and Conquer, but when subproblems overlap, DP is preferred.</p><blockquote><ul><li>Recurrence is from top to bottom, while DP is from bottom to top.</li><li>Recurrence is efficient when subproblems are independent, while DP requires overlapped subproblems.</li><li>DP trades space for time.</li></ul></blockquote></li><li><p>DP is used for <strong>optimization</strong> problems</p></li><li><p><strong>Core: As long as all subproblems are optimized, the merged problem can be optimized.</strong></p><blockquote><p>Prerequisite: All subproblems cannot be completely individual, and in other words,  they have to affect each other’s solution.</p></blockquote></li></ul><h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ul><li>model subproblems</li><li>establish value connections between subproblems</li><li>bottom-up computation to get result</li><li>trace to get format answer</li></ul><h2 id="0-1-knapsack"><a href="#0-1-knapsack" class="headerlink" title="0-1 knapsack"></a>0-1 knapsack</h2><h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h3><ul><li>try all $2^n$ methods and compare them.</li></ul><h4 id="Simple-Recursion"><a href="#Simple-Recursion" class="headerlink" title="Simple Recursion"></a>Simple Recursion</h4><ul><li><p>$V[i,w]=max(V[i-1,w], v_i+V[i-1,w-w_i])$</p><ul><li><p>$V[i,w]$ denote any subset of items $\{1, 2, 3, …i\}$ value sum with <strong>at most</strong> weight $w$.</p><blockquote><p>Real weight may be smaller than $w$.</p></blockquote></li></ul></li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li>State of subproblems<ul><li>establish formal description for problem requirements</li></ul></li><li><p>Relate a problem to its subproblems</p><ul><li>establish recurrence equation</li><li>set boundary cases</li></ul></li><li><strong>Bottom-up</strong> computation of $V[i,w]$</li><li>initialize boundary cases<ul><li>Save trace when calculating $V[i,j]$, and till the end we can use recorded result to get $V[i,w]$.</li></ul></li><li>Add <code>keep[i,w]</code> to record for a specific w, whether an item is taken.</li></ul><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>DP save duplicate computation.</li><li>DP trades space for time.</li><li>Strategy<ul><li>Structure</li><li>Recursion</li><li>Bottom-up computation</li><li>Construct optimal solution: trace the table</li></ul></li></ul><h2 id="Rod-Cutting"><a href="#Rod-Cutting" class="headerlink" title="Rod Cutting"></a>Rod Cutting</h2><h3 id="brute-force-1"><a href="#brute-force-1" class="headerlink" title="brute force"></a>brute force</h3><ul><li>$r_n=max(p_n,r_1+r_{n-1},…,r_{n-1}+r_1)$<ul><li>$r_n$ is the optimal revenue of length <code>n</code> rod.</li><li>$p_n$ is the price of length <code>n</code> rod.</li><li>simpler definition:  $r_n=max_{1\leq i \leq n}(p_i+r_{n-i})$</li></ul></li><li>Even recurrence equation is established, the recursive method still contains duplicate computation.</li></ul><h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><ul><li>one-dimension array <code>r[]</code> to store max revenue of length from 0 to n.</li><li><code>r[i] = max(r[i], p[j] + r[i - j])</code></li></ul><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>$O(n^2)$</li></ul><h2 id="Chain-Matrix-Multiplication"><a href="#Chain-Matrix-Multiplication" class="headerlink" title="Chain Matrix Multiplication"></a>Chain Matrix Multiplication</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>C(<code>p*q</code> and <code>q*r</code> matrix to multiply, each entry takes $O(q)$ to calculate): $O(pqr)$</p></li><li><p>$A_1A_2A_3=(A_1A_2)A_3=A_1(A_2A_3)$</p><blockquote><p>cause of different complexity</p></blockquote></li></ul><h3 id="Exhaustive-Search-1"><a href="#Exhaustive-Search-1" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><ul><li>$\Omega(\frac{4^n}{n^{\frac{3}{2}}})$</li></ul><h3 id="DP-2"><a href="#DP-2" class="headerlink" title="DP"></a>DP</h3><p>for matrix $A_i$, it has dimension of $p_{i-1}*p_i$.</p><ul><li><p>model subproblems</p></li><li><p>establish <strong>value</strong> connection between subproblems</p><p>$m[i,j]=\begin{cases}0, &amp; i=j\\min_{i\leq k&lt;j}(m[i,k]+m[k+1,j])+p_{i-1}p_kp_j, &amp; i&lt;j\end{cases}$</p></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$<ul><li>Outlying loop layer is for traverse multiply-array’s length from 2 to n.</li></ul></li><li>space: $O(n^2)$</li></ul><h2 id="Longest-Common-Subsequence-Problem"><a href="#Longest-Common-Subsequence-Problem" class="headerlink" title="Longest Common Subsequence Problem"></a>Longest Common Subsequence Problem</h2><h3 id="Basic-Concepts-1"><a href="#Basic-Concepts-1" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>subsequence: not necessarily continuous</li><li>substring: <strong>must</strong> be continuous</li></ul><h3 id="DP-3"><a href="#DP-3" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ the length of LCS in $A[1..i]$ of $A[1..m]$ and $B[1..j]$ of $B[1..n]$</p><ul><li>$d_{i,j}=\begin{cases} 0, &amp; i,j=0 \\ d_{i-1,j-1}+1, &amp; x_i=y_j \\ max(d_{i-1.j},d_{i,j-1}), &amp; x_i\neq y_j\end{cases}$</li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(mn)$</p></li><li><p>space: $O(n^2)$</p><ul><li><p>optimization for solution matrix: only save two rows</p><blockquote><p>The trace matrix needs totally preserving.</p></blockquote></li></ul></li><li><p>Different trace may lead to different subsequence.</p></li></ul><h2 id="Longest-Common-Substring-Problem"><a href="#Longest-Common-Substring-Problem" class="headerlink" title="Longest Common Substring Problem"></a>Longest Common Substring Problem</h2><h3 id="Basic-Concepts-2"><a href="#Basic-Concepts-2" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>Different from subsequence, substring must be contiguous.</li></ul><h3 id="DP-4"><a href="#DP-4" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ to be the length of the longest common substring of $X[1..i]$ and $Y[1..j]$</p><ul><li>$d_{i,j}=\begin{cases} d_{i-1,j-1}+1, &amp;x_i=y_j\\ 0, &amp;x_i\neq y_j\end{cases}$</li><li>$maxSubstring(X,Y)=max(d_{i,j})$</li></ul><h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Without saving DP direction, we can still trace the whole substring by knowing the <strong>end index</strong> of substring $(X_i|Y_j)$ and its length $d_{i,j}$.</li><li>time: $O(mn)$</li><li>Subsequence algorithm can be used to solve this problem by only outputting diagonal $LU$ elements.</li></ul><h2 id="Minimum-Edit-Distance"><a href="#Minimum-Edit-Distance" class="headerlink" title="Minimum Edit Distance"></a>Minimum Edit Distance</h2><h3 id="Basic-Concepts-3"><a href="#Basic-Concepts-3" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><ul><li>“Spell Correction” in search engine</li><li>Computational Biology such as comparing DNA</li><li>Machine Translation, Information Extraction, Speech Recognition etc.</li></ul><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>calculate the smallest number of edit operations</p><ul><li><p>edit operations</p><ul><li>insertion: add a letter</li><li>deletion: delete a letter</li><li>substitution: replace a character</li></ul><blockquote><p>All operations’ cost is usually (throughout the course) counted as <code>1</code>, but the cost can be adjusted.</p></blockquote></li></ul><h3 id="DP-5"><a href="#DP-5" class="headerlink" title="DP"></a>DP</h3><p>define $D[i,j]$ the edit distance of $X[1..i]$ and $Y[1..j]$</p><ul><li>$D[i,j]=min\begin{cases} D[i-1,j]+1, &amp;delete\ X[i] \\ D[i,j-1]+1, &amp;insert\ Y[j] \\ D[i-1,j-1] +0, &amp;X[i]=Y[j] \\ D[i-1,j-1]+1, &amp;X[i] \neq Y[j] \end{cases}$</li></ul><blockquote><ul><li>All edit operations take place on $X[1..i]$.</li><li>When operation cost changes, the constant in equation will be changed as well.</li><li>When the problem can be depicted as a state graph, <strong>shortest path algorithm</strong> can be used to solve the problem. In other words, the problems degrades to shortest path problem.</li></ul></blockquote><h3 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>When tracing the edit process, <code>L</code>/<code>U</code>/<code>LR</code> stand for four different operations(<strong>including doing nothing</strong>).</li><li>time: $O(mn)$</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>multi-stage strategy problem</li><li>DP is not a specific method but a way of thinking.</li><li>Key to DP: basic equations and boundary conditions</li><li>DP’s effect is also called Markova effect for there’s no effect on future events. </li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter4-Mid-term-Review"><a href="#Chapter4-Mid-term-Review" class="headerlink" title="Chapter4 Mid-term Review"></a>Chapter4 Mid-term Review</h1><p>Total Count: <code>413</code> words</p><p>Preferred Reading Time: <code>15~20</code> minutes</p><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2><h3 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h3><ul><li><p>Any comparison-based sorting algorithm requires $\Omega(nlogn)$ comparisons.</p><blockquote><p>proved by binary decision tree</p></blockquote></li><li><p>Thus, in order to break the lower bound, we should take other methods except comparison.</p></li><li><p>counting sort isn’t based on comparison.</p></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>When inputting numbers, count occurrences of all numbers.</p><blockquote><p>counting array’s length is based on boundary value of inputting array.</p></blockquote></li><li><p>Fill sorted array with the counting array.</p></li></ul><h3 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n)$</li><li>counting sort is a <strong>stable</strong> sort as long as the final filling loop is from raw array’s <strong>end</strong> to its <strong>head</strong>.</li></ul><h2 id="Randomized-Selection-Problem"><a href="#Randomized-Selection-Problem" class="headerlink" title="Randomized Selection Problem"></a>Randomized Selection Problem</h2><h3 id="Basic-Concepts-4"><a href="#Basic-Concepts-4" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>find the <code>i-th</code> smallest element in a given array</li></ul><h3 id="brute-force-2"><a href="#brute-force-2" class="headerlink" title="brute force"></a>brute force</h3><ul><li>sort the array and index specific element</li></ul><h3 id="Partition-and-Selection"><a href="#Partition-and-Selection" class="headerlink" title="Partition and Selection"></a>Partition and Selection</h3><ul><li>The same as quick sort, part the array into two subarrays, and then make sure the index of selected separator number.</li><li>When the index is greater than <code>i</code>, handle another branch and abandon this one, vice versa.</li></ul><h3 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(n)$</p><blockquote><p>Different from quick sort’s $O(nlogn)$, this algorithm only deals with one branch of subproblems, while quick sort handles both branches.</p></blockquote></li></ul><h2 id="Optimal-Binary-Search-Tree"><a href="#Optimal-Binary-Search-Tree" class="headerlink" title="Optimal Binary Search Tree"></a>Optimal Binary Search Tree</h2><h3 id="Basic-Concepts-5"><a href="#Basic-Concepts-5" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>construct a BST with smallest search cost</p></li><li><p>height</p><ul><li>$node_height=max(children_height + 1)$</li><li>$leave_ height=0$</li><li>$tree_height=root_height$</li><li>$empty_tree_height = -1$</li></ul><blockquote><p><code>root_height</code> is the <strong>biggest</strong> one.</p></blockquote></li><li><p>$depth=H(root)-H(n)+1$</p><ul><li>$root_depth=1$</li></ul></li><li><p>balanced binary tree: the height difference of two subtrees cannot go beyond 1.</p><ul><li>$balance_factor = H(right)-H(left)$</li></ul></li><li><p>AVL tree: besides balanced binary tree, every node will store the height of two subtrees.</p></li></ul><h3 id="DP-6"><a href="#DP-6" class="headerlink" title="DP"></a>DP</h3><ul><li><p>subproblem: find an optimal BST containing $keys<a href="1 \leq i \leq j \leq n">i..j</a>$</p></li><li><p>$e[i,j]$: the expected search cost of a subtree with $k[i..j]$.</p><ul><li>$e[i, j] =\begin{cases} q_{i-1}, &amp;j=i-1 \\ min_{i\leq r\leq j}(e[i, r-1]+e[r+1, j]+w[i, j]), &amp;i\leq j\end{cases}$</li><li>$w[i,j]=E_r=w[i,r-1]+p_r+w[r+1,j]=w[i,j-1]+p_j+q_j$</li></ul></li><li><p>diagonal traverse template</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>): <span class="comment"># length of fixed diagnals</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n-l+<span class="number">1</span>):</span><br><span class="line">        j = i + l - <span class="number">1</span> <span class="comment"># (n-l+1, n) is always on f(i, j)</span></span><br></pre></td></tr></table></figure><blockquote><p>Due to $i\leq j$, then the traverse should be diagonal.</p></blockquote></li></ul><h3 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$</li><li>space: $O(n^2)$</li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter5-Greedy-Algorithms"><a href="#Chapter5-Greedy-Algorithms" class="headerlink" title="Chapter5 Greedy Algorithms"></a>Chapter5 Greedy Algorithms</h1><p>Total Count: <code>522</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li><p>Greedy algorithms don’t always produce the optimal solution.</p></li><li><p>As a result, if the result is optimal, we need to prove its correctness.</p><blockquote><p>The usual way is to prove that any other optimal solution can be converted into the greedy one.</p></blockquote></li></ul><h2 id="Fraction-Knapsack-Problem"><a href="#Fraction-Knapsack-Problem" class="headerlink" title="Fraction Knapsack Problem"></a>Fraction Knapsack Problem</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Different from 0-1 problem, knapsack can take only a fraction of an item.</li></ul><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><ul><li>calculate value-per-pound of every item</li><li>sort items by <strong>decreasing</strong> value-per-pound</li><li>put as much as possible weight of an item into knapsack from the starting point to the end of the sorted array</li></ul><h3 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$, the time complexity of sort process.</li><li>Different from DP, all subproblems of greedy algorithms are optimal no matter whether they are connected with each other.</li></ul><h2 id="Huffman-Coding-Problem"><a href="#Huffman-Coding-Problem" class="headerlink" title="Huffman Coding Problem"></a>Huffman Coding Problem</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>Encode characters according to its frequency so that the variable length can save the memory space compared with fixed length.</p><blockquote><p>especially useful when storing images</p></blockquote></li><li><p>Uniquely Decodable: In order to decode correctly, the encoding method should avoid one character’s code being the prefix of another character, and then the code can be named after <strong>prefix (free) code</strong>.</p></li><li><p>Huffman coding targets at the <strong>minimized binary prefix code</strong>.</p></li></ul><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><ul><li>pick two least-occur characters from alphabet and build a subtree</li><li>the subtree’s frequency is the sum of its sub-subtrees</li><li><strong>note that the Huffman tree can be a complete binary tree as well</strong></li></ul><h3 id="Analysis-10"><a href="#Analysis-10" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$<ul><li>Every update of the priority queue is $O(logn)$ and the total operation count is $n$.</li></ul></li></ul><h2 id="Activity-Selection-Problem"><a href="#Activity-Selection-Problem" class="headerlink" title="Activity Selection Problem"></a>Activity Selection Problem</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Given activities that may overlap with each other, take part in as many activities as possible.</li><li>core: find a maximized compatible activity set</li></ul><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>sort activities list in ascending order of finishing time</p></li><li><p>select the first activity: the one <strong>finishes at the earliest time</strong></p><blockquote><p>not the one starting earliest or the shortest one</p></blockquote></li><li><p>advance the time and update sort activities until the head activity’s starting time is still valid</p></li><li><p>select next activity</p></li></ul><h3 id="Analysis-11"><a href="#Analysis-11" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>Time: $O(nlogn)$ to sort activity list.</p></li><li><p>The correctness can be proved that greedy algorithms produce the optimal solution of this problem.</p><blockquote><p>Proof: we can convert any other optimal solution($P’$) to the greedy algorithm solution($P$) by replacing different elements in $P’$ with corresponding elements in $P$.</p></blockquote></li></ul><h2 id="Weighted-Activity-Selection-Problem"><a href="#Weighted-Activity-Selection-Problem" class="headerlink" title="Weighted Activity Selection Problem"></a>Weighted Activity Selection Problem</h2><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Every activity is given a weight, and the goal is to construct the set with maximized weight sum.</li></ul><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>Greedy algorithm is correct when weight are all equal.</p></li><li><p>DP can still work in this weight-varied scenario.</p><ul><li><p><strong>First of all, sort activity with its finishing time.</strong></p></li><li><p>$p(j)$ : the largest index $i&lt;j$ guaranteeing $a_i$ compatible with $a_j$.</p><blockquote><p><strong>index</strong> is the one of <strong>sorted</strong> activity array.</p></blockquote></li><li><p>$OPT(j)$: the max weight sum of any subset in $a[1..j]$</p><script type="math/tex; mode=display">OPT(j)=\begin{cases} 0,& j=0 \\ max(OPT(i-1), w_j+OPT(p(j)), & j>0\end{cases}</script></li></ul></li></ul><h3 id="Analysis-12"><a href="#Analysis-12" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$ to sort the activity list</li><li>Greedy algorithms never reconsider its previous choices, while DP construct its solution by comparing all possible previous choices.</li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter6-Graph-Algorithms"><a href="#Chapter6-Graph-Algorithms" class="headerlink" title="Chapter6 Graph Algorithms"></a>Chapter6 Graph Algorithms</h1><p>Total Count: <code>1887</code> words</p><p>Preferred Reading Time: <code>30~45</code> minutes</p><h2 id="Basic-Concepts-6"><a href="#Basic-Concepts-6" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><ul><li><p>complete graph</p><ul><li>undirected: $|E|=n(n-1)/2$</li><li>directed: $|E|=n(n-1)$</li></ul></li><li><p>dense &amp; sparse graph: not quantitative defined</p></li><li><p>degree: number of edges incident on a vertex</p><ul><li>degree of a graph is the sum of degrees of all vertices</li></ul></li><li><p>leave node</p><ul><li>directed graph: no out degree</li><li>undirected graph: degree is <code>1</code></li></ul></li><li><p>path length: <strong>edges’</strong> count(not vertex)</p></li><li><p>simple path: all <strong>vertices</strong> are distinct on the path(no cycle, acyclic)</p></li><li><p>cycle: requires all <strong>edges</strong> are distinct with multi-exist vertices</p><blockquote><ul><li><p>an edge cannot be used twice in a cycle</p></li><li><p>Q: self-to-self edge can produce cycle?</p><p>A: Yes, that’s why a legal tree <strong>cannot</strong> have self-to-self edge.</p></li></ul></blockquote></li><li><p>connected component</p><ul><li><p><strong>disconnected</strong> graph’s biggest connected subgraph</p><blockquote><p>a disconnected graph can have <strong>more than one</strong> connected components</p></blockquote></li><li><p>connected graph itself</p></li></ul></li><li><p>included subgraph: As long as <strong>both</strong> endpoints are preserved, the edges should be preserved.</p></li><li><p>leaf</p><ul><li>directed graph: out-degree is zero</li><li>undirected graph: degree is one</li></ul></li></ul><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><ul><li>Adjacency List<ul><li>space complexity: $O(V+E)$</li><li>$adj[u]$: hold all vertices adjacent to $u$, usually a linked list.</li><li>mostly for sparse graph</li></ul></li><li>Adjacency Matrix<ul><li>space complexity: $O(V^2)$</li><li>undirected graphs always have <strong>symmetric</strong> adjacency matrix</li><li>mostly for dense graph</li></ul></li></ul><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul><li><p>data structure</p><ul><li><code>color[u]</code>: state of vertex <code>u</code><ul><li><code>undiscovered</code></li><li><code>discovered but not finishing processing</code></li><li><code>finished processing</code></li></ul></li><li><code>pred[u]</code>: the predecessor of vertex <code>u</code></li><li><code>d[u]</code>: distance from starting point to <code>u</code></li></ul></li><li><p>end-loop condition: the vertex queue is empty</p></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><blockquote><p>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</p></blockquote></li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li><p>tree-like traverse process</p></li><li><p>data structure</p><ul><li><code>color[u]</code></li><li><code>pred[u]</code></li><li><code>d[u]</code>: discovery time of vertex <code>u</code></li><li><code>f[u]</code>: finishing time of vertex <code>u</code></li></ul></li><li><p><code>u</code> is a descendant of <code>v</code> if and only if $[d[u],f[u]]\subset[d[v],f[v]]$</p><ul><li><p>tree edge$(u,v)$: $u$ is the predecessor in a DFS path</p></li><li><p>back edge$(u,v)$: $v$ is the predecessor in a DFS path</p><blockquote><p>As long as the graph is acyclic, there is no back edge.</p></blockquote></li><li><p>cross edge$(u,v)$: both vertices are endpoints of a DFS path</p></li></ul></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><ul><li>Different from normal complexity calculation, we can think it in this way: as for each vertex, $O(1)$ is needed to update the timestamp, and $O(degree(u))$ is required to run the for loop. Therefore, the total time complexity is the sum of every single time complexity.</li></ul><blockquote><ul><li>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</li><li>The time complexity is the same as the one of BFS under adjacency list.</li></ul></blockquote></li><li><p>White-path theorem: As long as $v$ is a descendant(direct or indirect) of $u$, then there is a white path between them in DFS algorithm.</p></li></ul><h2 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h2><h3 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Topological sort is adopted for <strong>directed acyclic graph(DAG)</strong>.<ul><li>$G$ doesn’t need to be connected, for the order of disconnected parts won’t break the rule.</li></ul></li><li>find a sequence based on edge $(u,v)$ that $u$ must be ahead of $v$</li><li>If no “zero in-degree” vertex is found, the graph must contain cycle.</li></ul><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><ul><li>BFS<ul><li>find all vertices with in-degree as 0</li><li>delete them and their outgoing edges(decrease in-degree of its direct descendants)</li><li>repeat above steps</li></ul></li><li>DFS<ul><li>traverse all vertices and build a DFS tree</li><li>Once a vertex cannot span the tree anymore, add it into $L$.<ul><li>all direct descendants are added into $L$</li><li>no direct descendant exists</li></ul></li><li>next DFS tree traverse won’t reach vertices in $L$</li><li>Tasks with <strong>later</strong> finishing time should be down <strong>earlier</strong>, so $L$ needs reversing to be correct order.</li></ul></li></ul><h3 id="Analysis-13"><a href="#Analysis-13" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>BFS<ul><li>time: $O(|V|+|E|)$</li></ul></li><li>DFS<ul><li>time: $O(|V|+|E|)$</li></ul></li></ul><h2 id="Strongly-Connected-Components"><a href="#Strongly-Connected-Components" class="headerlink" title="Strongly Connected Components"></a>Strongly Connected Components</h2><h3 id="Definition-6"><a href="#Definition-6" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>SCC is a subset of a <strong>directed</strong> graph, in which all vertices can reach each other, <strong>and</strong> the subset should be <strong>maximal</strong>(no more vertex can be added).</p><ul><li>SCC can contain <strong>only one</strong> vertex.</li></ul></li><li><p>Theorem: Suppose $S_1$ and $S_2$ are both SCCs of $G$, then the intersection must be $\Phi$.</p><blockquote><p>Proof: Any vertex in intersection can make $S_1\cup S_2$ a bigger SCC.</p><ul><li>After finding a SCC, all vertices within can be taken as a single vertex.</li></ul></blockquote></li><li><p>Finding all SCC of $G$ is to find a partition with all subset are SCC.</p></li><li><p>Sink SCC: SCC with no outgoing edge</p><ul><li><p>$G^{SCC}$ is a graph taking all SCC as a single vertex.</p></li><li><p>$G^{SCC}$ is a DAG</p><blockquote><p>Proof: As long as there is a cycle, the element of $SCC$ can be merged.</p></blockquote></li><li><p>$G^{SCC}$ must contain at least one <strong>SSCC</strong>.</p><blockquote><p>Proof: The DAG graph can be topological sorted, so the last vertex in the topological order has no outgoing edge, which means the vertex is a SSCC.</p></blockquote></li></ul></li></ul><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><ul><li>generate reverse graph $G^R$</li><li>Operate topological sort on $G^R$, and the result is $L^R$.</li><li>reverse $L^R$ to get $L$</li><li>execute DFS on $G$ with starting point as white ones in $L$</li><li>Every DFS on $G$ can produce a SCC, and corresponding vertices should be marked black.<ul><li>Starting from a SSCC, then the component won’t contain vertices of other SCC.</li></ul></li></ul><h3 id="Analysis-14"><a href="#Analysis-14" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(V+E)$</li></ul><h2 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a>Spanning Tree</h2><h3 id="Definition-7"><a href="#Definition-7" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>An <strong>undirected</strong> graph’s subgraph containing all vertices.</p><blockquote><p>Q: Can spanning tree has cycle?</p><p>A: No,  tree is an <strong>acyclic</strong> graph.</p></blockquote></li><li><p>Every connected graph has at least one spanning tree.</p></li><li><p>Minimum Spanning Tree: the subgraph with smallest weight sum in a weighted undirected graph</p><ul><li><p>minimum spanning tree may <strong>not</strong> be unique</p><blockquote><p>Only when weight varies from one to another, the minimum spanning tree is unique.</p></blockquote></li></ul></li><li><p>safe edge: After adding safe edge to a subset of MST, the new set is still a subset of MST.</p><ul><li><p>Find the light edge of a cut respecting subset A, and then the light edge is the sage edge.</p><blockquote><p>Subset contains only edges, which means <strong>not all</strong> edges needs selecting even though their endpoints are with in the subset.</p></blockquote></li></ul></li><li><p>min heap</p><ul><li>root has min value</li><li>any vertex’s sons have <strong>greater</strong> value than its own value.</li></ul></li></ul><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><ul><li><p><strong>focus on vertex</strong></p></li><li><p>start with a randomly picked up <strong>vertex</strong></p></li><li><p>iterate to find the <strong>lightest</strong> edge outside the tree and add it (and its <strong>endpoint</strong>) into tree</p><ul><li><p>priority queue</p><ul><li><p>insert: insert at tail and <strong>reverse up</strong></p></li><li><p>extract min</p><ul><li><p>After extracting the first element, the last element needs swapping to the first.</p><blockquote><p>Only the last element won’t influence the tree structure.</p></blockquote></li><li><p><strong>roll down</strong> new first element to construct a new heap</p></li><li><p>time complexity is $O(logn)$</p></li></ul></li><li><p>update value: <strong>reverse up</strong> to respect the heap</p></li></ul></li></ul></li><li><p>When adding an new edge and its vertex into SMT, loop over its adjacent vertices to update key values.</p></li></ul><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><ul><li><strong>focus on edges</strong></li><li>Construct many forests, and finally they will be merged.<ul><li>When selecting edges, be cautious there cannot be cycles.<ul><li>disjoint set</li></ul></li></ul></li></ul><h3 id="Analysis-15"><a href="#Analysis-15" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time</p><ul><li><p>Prim: $O(VlogV+ElogV)=O(ElogV)$</p><ul><li>Usually, $E$ is greater than $V$ and sometimes may be $V^2$, which means $E=O(V^2)$.</li></ul><blockquote><p>As for loops like <code>while Q.size() &gt; 0</code>, and <code>Q</code> is changed within, we can consider it based on every single operation instead of every loop.</p></blockquote></li><li><p>Kruskal: $O(ElogE)=O(ElogV)$</p><blockquote><p>$logE\leq logV^2 \leq 2logV \leq O(logV)$</p><ul><li>Usually place $E$ outside $log$, and $V$ is placed inside.</li></ul></blockquote></li></ul></li></ul><h2 id="Shortest-Path"><a href="#Shortest-Path" class="headerlink" title="Shortest Path"></a>Shortest Path</h2><h3 id="Definition-8"><a href="#Definition-8" class="headerlink" title="Definition"></a>Definition</h3><ul><li>distance is the <strong>minimal</strong> length between two vertices</li><li>lemma: Any sub-path of a shortest path must also be a shortest path.</li></ul><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><ul><li><p>single source problem</p></li><li><p>can only handle <strong>no-negative-edge</strong> graph</p></li><li><p>greedy algorithm</p></li><li><p>maintain <code>d[v]</code> and <code>S</code></p><ul><li><p><code>d[v]</code>: upper bound of length <code>l(source, v)</code></p><ul><li><p>can be optimized by priority queue</p></li><li><p>relax</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[v] &lt;- min(d[v], d[u] + w(u, v));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>S</code>: set of distance-settled vertices</p></li></ul></li></ul><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><ul><li><p>single source problem</p></li><li><p>relax according to <strong>edges</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to <span class="params">|V|</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> E <span class="keyword">do</span></span><br><span class="line">        relax(e.p1, e.p2, e.w);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>Every iteration will settle an edge in the shortest paths.</p></li><li><p>The shortest path can at <strong>most</strong> contain <code>(|V|-1)</code> edges.</p></li><li><p>Iteration at most runs for <code>(|V|-1)</code> times.</p><blockquote><p><code>ith</code> iteration settle the paths containing <code>i</code> edges</p></blockquote></li></ul></li><li><p>If relaxation still happens after <code>(|V|-1)</code> iterations, there must be negative cycles in graph.</p></li></ul><h4 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h4><ul><li><p>all-pairs problem</p></li><li><p>dynamic programming algorithm</p><ul><li><p>$f[k][i][j]=min\{f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j]\}$</p><ul><li><p>using rolling array to optimize</p><p>$f[i][j]=min\{f[i][j],f[i][k]+f[k][j]\}$</p></li></ul></li></ul></li><li><p>The sequence to traverse <code>k</code>(intermediate vertex) isn’t important.</p><blockquote><p>Proof: Mathematics Induction(<a href="https://blog.csdn.net/dypdypdyp123/article/details/50492894" target="_blank" rel="noopener">https://blog.csdn.net/dypdypdyp123/article/details/50492894</a>)</p></blockquote></li></ul><h3 id="Analysis-16"><a href="#Analysis-16" class="headerlink" title="Analysis"></a>Analysis</h3><p>time</p><ul><li><p>Dijkstra: $O(VlogV+ElogV)=O(ElogV)$</p></li><li><p>Bellman-Ford: $O(EV)$</p></li><li><p>Floyd-Warshall: $O(V^3)$</p><blockquote><p>Apart from data structure, Floyd’s traversal decides the $n^3$ complexity.</p></blockquote></li></ul><h2 id="Maximum-Flow-amp-Minimum-Cut"><a href="#Maximum-Flow-amp-Minimum-Cut" class="headerlink" title="Maximum Flow &amp; Minimum Cut"></a>Maximum Flow &amp; Minimum Cut</h2><h3 id="Definition-9"><a href="#Definition-9" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>a flow network <code>G</code> with source <code>s</code>, sink <code>t</code> and no parallel edges.</p></li><li><p>capacity is nonnegative: $c(e) \geq 0$</p></li><li><p>cut’s capacity: $cap(A, B)=\sum_{e\ out\ of\ A}c(e)$</p><ul><li>a cut requires $s \in A$ and $t \in B$</li></ul></li><li><p>minimum cut: output a cut of minimum capacity</p></li><li><p>maximum flow: output a flow of maximum value</p></li><li><p>Except <code>s</code> and <code>t</code>, every vertex’s <code>out</code> equals <code>in</code>, which means it cannot store any water.</p></li><li><p>flow value: $val(f)=\sum_{e\ out\ of\ s}f(e)$, and <code>s</code> is the source.</p><blockquote><p><code>value</code> may not be the sum of capacity</p></blockquote></li></ul><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Heuristic-Algorithm"><a href="#Heuristic-Algorithm" class="headerlink" title="Heuristic Algorithm"></a>Heuristic Algorithm</h4><ul><li>initialize all <code>f(e)</code> to zero</li><li>find a <code>s-t</code> path where each edge meets $f(e)&lt;c(e)$</li><li>augment flow along <code>s-t</code> path</li><li>iterate above steps until no <code>s-t</code> path can be found</li></ul><blockquote><p><code>Heuristic Algorithm</code> <strong>cannot</strong> guarantee the optimal answer</p></blockquote><h4 id="Ford-Fulkerson-Method"><a href="#Ford-Fulkerson-Method" class="headerlink" title="Ford-Fulkerson Method"></a>Ford-Fulkerson Method</h4><ul><li><p>residual network: add reverse edges to dynamically adjust the flow of an edge</p><ul><li>residual capacity: $c_f(e)=\begin{cases} c(e)-f(e), &amp; c(e)&gt;f(e) \\ f(e), &amp;f(e)&gt;0 \end{cases}$</li></ul><blockquote><p>Once and residual capacity is zero, there is <strong>only one</strong> edge between two vertices.(even no edge at all)</p></blockquote></li><li><p>augment(ing) path: a simple <code>s-t</code> path in $G_f$</p><ul><li><p>bottleneck capacity: minimum residual capacity of any edge in augment path</p></li><li><p>key property: $val(f’)=val(f)+bottoleneck(G_f, P)$</p><ul><li>As for specific edge, the flow may decrease. However, the overall flow will increase.</li></ul></li><li><p>$val(f’)&gt;val(f)$</p><blockquote><p>the out edges of <code>s</code> must have the <strong>same</strong> direction as that in augment path</p></blockquote></li></ul></li><li><p>Process</p><ul><li>start with all <code>f(u, v) = 0</code></li><li>randomly choose an augment path to update <code>f</code> and $G_f$.</li><li>iterate until there is <strong>no</strong> augment path $\Leftrightarrow$ no <code>s-t</code> path in $G_f$</li></ul></li></ul><h3 id="Analysis-17"><a href="#Analysis-17" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(|E||f^<em>|)$, $f^</em>$ is the max flow of graph $G$.</p><ul><li><p>BFS/DFS: $O(|V| + 2|E|)=O(|E|)$</p><blockquote><p>the worst case: one edge in $G$ has two corresponding edges in $G_f$</p></blockquote></li><li><p>The time complexity is determined by $|f^*|$, so the method to pick up an augment path is important.</p><ul><li>EK Algorithm: ignore all edges’ weight and find a shortest path</li><li>In a flow network, EK’s time complexity is $O(|V||E|)$.<ul><li>an edge <strong>at most</strong> can be critical for $|V|/2$ times</li></ul></li><li>new time complexity of Ford-Fulkerson Algorithm: $O(|V||E|^2)$</li></ul></li></ul></li><li><p>Augmenting Path Theorem: A flow of $f$ is a max-flow $\Leftrightarrow$ <strong>no</strong> augment path in $G_f$</p></li><li><p>Max Flow &amp; Min Cut Theorem</p><ul><li>$val(f)=cap(min_cut)$</li><li>$f$ is the max flow</li><li>$f$ has no augmenting path</li></ul></li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li><li>BUAA Algorithm MOOC, Autumn of 2020.</li><li>OI Wiki</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Learning note of 2020 BUAA Algorithm Course.&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-03T10:51:40.632Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Silence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Optimization-Chapter6-整数规划</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter6-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter6-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/</id>
    <published>2021-01-03T10:46:53.760Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>311</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>和普通规划模型不同，整数规划中的<strong>某些</strong>变量只能是整数。</li><li>纯整数规划：所有变量都是整数</li><li>混合整数规划：部分变量是整数</li><li>0-1规划：所有变量的取值只能为0或1<ul><li>常见模型：选择问题（投资项目）</li></ul></li><li>整数规划的最优解<strong>不一定</strong>出现在连续规划最优解的附近</li></ul><h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2><ul><li>求出连续情况下的最优解，例如$x_1=3.75$.</li><li>对$x_1$进行分支限界，在原问题增加约束$x1\leq 3$或$x_1\geq 4$，分别再求一次可行解。</li><li>例如在$x_1\geq 4$的分支上$x_2$不能求出整数解，则对$x_2$进行分支限界。</li><li>在限界过程中<ul><li>出现无解则抛弃该分支</li><li>出现之前被限界的变量$x_1$可行解为小数的情况，则需要对$x_1$再次进行分支限界。</li></ul></li><li>迭代上述过程，直到求出所有的可行解。</li><li>比较所有可行解，确定最优解。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;311&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter7-动态规划</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-01-03T10:46:53.760Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>428</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>动态规划的递归性质：将一个问题的最优解作为下一个问题的输入</p><ul><li><p>前向递归：把起点设在<strong>左边</strong>，然后进行递推。</p></li><li><p>后向递归：把起点设在<strong>右边</strong>，然后进行递推。</p></li><li><p>阶段划分：<code>n</code>层节点对应<code>(n-1)</code>个阶段</p></li><li><p>格式：设有<code>1-3</code>共<code>3</code>个阶段</p><ul><li><p>前向：<script type="math/tex">\begin{cases} f_i(x_i)=min\{f_{i-1}(x_{i-1})+d(x_{i-1},x_i)\} \\ f_0(x_0)=0\end{cases}</script></p></li><li><p>后向：<script type="math/tex">\begin{cases} f_i(x_i)=min\{f_{i+1}(x_{i+1})+d(x_{i},x_{i+1})\} \\ f_4(x_4)=0\end{cases}</script></p></li><li><p>每个阶段求解时，列出分类讨论的情况，并在最优值后用括号括出路径。</p><p>$f_3(1)=formula=min\{…\}=10$（节点<code>(i+1)</code>出发）</p></li></ul></li></ul></li><li><p>基本要素</p><ul><li>阶段：<code>i</code></li><li>各个阶段的可选方案（从阶段<strong>起点</strong>到阶段<strong>终点</strong>可以采用的方案）：<code>min/max</code>中对应的算法</li><li>各个阶段的状态（从整个模型的起点到该状态的累计）：<code>xi</code></li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><p>背包模型</p><p><img src="https://i.loli.net/2020/11/30/LbmSFM7Vc1J6GhX.png" alt="image-20201130114716371" style="zoom: 33%;" /></p><ul><li>当前阶段<strong>部分</strong>的解由<strong>当前状态</strong>决定</li></ul></li><li><p>劳动力规模模型</p><p><img src="https://i.loli.net/2020/11/30/JIA7ZEHw9QUKhra.png" alt="image-20201130114918767" style="zoom: 67%;" /></p><ul><li>当前阶段<strong>部分</strong>的解由<strong>前一阶段</strong>的状态决定</li></ul></li><li><p>设备更新模型</p><p><img src="https://i.loli.net/2020/11/30/EBsF5vDXRi1SoZj.png" alt="image-20201130115204212" style="zoom: 67%;" /></p><ul><li><p>当前阶段的解由不同的算法决定</p><blockquote><p>前两个模型不同的情况对应<strong>同样的</strong>算法</p></blockquote></li><li><p>通过画图确定不同阶段状态的可能取值</p><p><img src="https://i.loli.net/2020/11/30/43lSb1przDjTkRw.png" alt="image-20201130115505833" style="zoom:50%;" /></p></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;428&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter2-单纯形算法</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter2-%E5%8D%95%E7%BA%AF%E5%BD%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter2-%E5%8D%95%E7%BA%AF%E5%BD%A2%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2162</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="等式形式"><a href="#等式形式" class="headerlink" title="等式形式"></a>等式形式</h2><ul><li>把约束全部转换为等式，且右端<strong>非负</strong>。</li><li>所有<strong>变量</strong>都是非负的（<strong>包括松弛变量</strong>）</li><li>解空间由<code>m</code>个同时成立的<strong>线性方程</strong>和<code>n</code>个<strong>非负变量</strong>表示</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>将不等式转换为等式</p><ul><li><p>增加<strong>松弛变量</strong></p><p>$x+y\leq24\rightarrow x+y+s=24(s\geq0)$</p></li><li><p>将右端项变为<strong>非负</strong>的（同乘<code>-1</code>）</p><p>$x+y\leq-19 \rightarrow x+y+s=-19(s\geq0) \rightarrow -x-y-s=19(s\geq0)$</p></li></ul><blockquote><p>如果是<strong>大于等于</strong></p><ul><li>先转换为<strong>小于等于</strong>再进行转换，但是如果右端无法非负，则只能使用改进单纯形方法。</li><li>使用$-s$作为松弛项</li></ul></blockquote></li></ul><h2 id="图形解和代数解"><a href="#图形解和代数解" class="headerlink" title="图形解和代数解"></a>图形解和代数解</h2><h3 id="图形解"><a href="#图形解" class="headerlink" title="图形解"></a>图形解</h3><ul><li>二维：线性规划</li><li>解空间有无穷个<strong>可行点</strong>，最优解的候选解通常是有限的。</li></ul><h3 id="代数解"><a href="#代数解" class="headerlink" title="代数解"></a>代数解</h3><ul><li>方程组有无穷个<strong>可行解</strong>，最优解的候选解对应的基本可行解通常是有限的。</li></ul><h3 id="角点"><a href="#角点" class="headerlink" title="角点"></a>角点</h3><ul><li>基本解一定对应解空间的一个（<strong>可行或不可行</strong>）的角点<ul><li>基本解：在方程组中选<code>m</code>个变量为0求解其他变量的方程得到的解<ul><li>变量包括新增的<strong>松弛变量</strong></li><li>方程组<strong>不包括</strong>非负约束（只计算加入了松弛变量的<strong>等式方程</strong>）</li><li>通过非负约束条件判断基本解是否可行（有一些角点不在可行域内）</li></ul></li></ul></li><li>角点的最大数目：$C_n^m$</li></ul><h2 id="单纯形方法"><a href="#单纯形方法" class="headerlink" title="单纯形方法"></a>单纯形方法</h2><ul><li>利用一个智能的搜索过程找到最优解</li><li>在搜素过程中，只能在可行域的边缘上移动，不能够“抄近路”。</li><li><strong>单纯形方法中求出的基本解都是可行的</strong></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><p>以<strong>最大化</strong>问题为例</p><ul><li><p>从原点<code>(0,0,...,0)</code>开始，即除松弛变量<strong>之外</strong>都作为<strong>非基变量</strong>（值为0）。</p><blockquote><p>单纯形法的选出的非基变量的组数和角点的最大数目不同，因为单纯形方法中的基变量组<strong>都是可行的</strong>。</p></blockquote></li><li><p><strong>最优性条件</strong>：每次增加一个变量，选择<strong>系数更大</strong>的变量作为<strong>进基变量</strong>。</p><blockquote><p>选择总是理性的</p></blockquote></li><li><p><strong>可行性条件</strong>：将进基变量带入，找到使进基变量取得<strong>最小非负值</strong>的方程选择<strong>离基变量</strong>。</p><blockquote><ul><li>最小的非负值保证了求到的解一定是在可行域中的，其他点并不在可行域中。</li><li>不是最小值，是<strong>最小非负值</strong>。</li><li>相当于求方程在进基变量维度的<strong>截距</strong></li></ul></blockquote></li><li><p>在离基变量方程中将进基变量系数化为1，然后把其他方程中该进基变量的系数化为0，包括目标函数。</p></li><li><p>求出进基变量的值对目标函数进行优化</p></li><li><p>当近基变量不能再被优化时，依次选择下一个进基变量。</p></li><li><p>$z=ax+by+…$形式中系数为负的非基变量<strong>不会被</strong>优化</p></li></ul><blockquote><p>最小化问题</p><ul><li>最优性条件和最大化相反，即选择系数更小（为<strong>负</strong>）的变量进行优化。最后确定最优解的表也要求所有的非基变量系数为<strong>负</strong>，表示不能够再向小优化了。</li><li>可行性条件<strong>相同</strong></li><li>系数全为正且没有添加松弛变量时求最小值，此时可能出现初始值就是最优解的情况，即不需要再进行优化。</li></ul></blockquote><h3 id="单纯形表"><a href="#单纯形表" class="headerlink" title="单纯形表"></a>单纯形表</h3><p>Gauss-Jordan运算</p><ul><li>一张单纯形表对应一组基变量</li><li><strong>基变量矩阵</strong>需要维持是<code>0-1</code>对角矩阵<ul><li>此时右侧的解列才<strong>直接等于</strong>基变量的值</li></ul></li><li>基变量所在的其他行（包括目标函数行），全部都利用<strong>枢轴行</strong>置为0.</li><li>当非基变量<strong>在表中</strong>系数都为正（即不能够再进行<strong>最大</strong>优化）时，单纯形表对应最优解。</li><li>进基变量可能在<strong>下一个</strong>变量进基时<strong>改变原有值</strong></li></ul><h2 id="改进单纯形方法"><a href="#改进单纯形方法" class="headerlink" title="改进单纯形方法"></a>改进单纯形方法</h2><ul><li>朴素单纯形方法只能够解决全是<code>&lt;=</code>约束条件和非负右端项的线性规划，因为增加松弛变量后并不影响初始解，即$Z-ax-by-0s_0-0s_1=0$仍成立。</li><li>对于存在<code>&gt;=</code>和<code>=</code>约束的最优化问题，则不能够直接增加松弛变量。<ul><li><code>&gt;=</code>：在右端本来为负数时，可以直接乘<code>-1</code>进行转换。但是右端为正时，增加$-s$松弛变量只能够起到变为<code>=</code>号的作用，并不能保证解空间依然合法。</li><li><code>=</code>：<strong>不需要</strong>增加松弛变量</li></ul></li></ul><h3 id="大M方法"><a href="#大M方法" class="headerlink" title="大M方法"></a>大M方法</h3><ul><li><p>对于不满足朴素单纯形的的约束条件（不能增加松弛变量/加了松弛变量不能保证解空间合法），将<strong>人工变量</strong>$R_i$加入<strong>初始解（人工变量非负）</strong>。</p><p>$min\ Z=4x+3y=4x+3y+0s_1+0s_2+M_1R_1+M_2R_2$</p><ul><li>$4x+3y\geq 6 \Rightarrow 4x+3y-s+MR=6$</li></ul></li><li><p>在<strong>目标函数</strong>中，对人工变量施加高惩罚使它在求解过程中变为零。</p><ul><li>将$M_1,M_2$的值设置的非常大，通常是其他系数的两个数量级。</li><li>$M\geq0$恒成立，故$MR\geq0$恒成立。</li><li>$M$可以<strong>全部</strong>取同一个值，只要满足“大”即可。</li></ul></li><li><p>在加入人工变量后，选择人工变量和松弛变量组为基变量，目标函数初始解不一定得到0，需要重新进行计算，以保证“<strong>基变量在目标函数中的系数为0</strong>”。</p></li><li><p>最后的单纯形表中的<strong>基变量数量</strong>可能<strong>大于</strong>原有的变量数，例如<code>x</code>/<code>y</code>/<code>s0</code>都是基变量。但是<code>s0</code>不影响最优解，此时<code>x</code>，<code>y</code>的值就是取得最优解时的值。</p><blockquote><p>作为最终解的基变量中</p><ul><li>有松弛变量，则松弛变量可以为任意值。</li><li>有人工变量，则人工变量必须为0，否则说明约束条件有问题。</li></ul></blockquote></li><li><p><strong>如果可行解存在，人工变量最后一定会等于0.</strong></p><blockquote><p>基变量数是由秩决定的，相当于在高维空间求出了低维空间的目标函数的最小值，这个最小值在低维空间<strong>依然是</strong>成立的。</p></blockquote></li></ul><h3 id="两阶段方法"><a href="#两阶段方法" class="headerlink" title="两阶段方法"></a>两阶段方法</h3><ul><li><p>在计算机中，大M方法可能会造成计算精度误差。</p></li><li><p>两阶段法采用<strong>不引入</strong>常数$M$的办法消除误差</p><ul><li><p>阶段一</p><ul><li><p>以是<strong>人工变量之和取最小值</strong>($min\ r=R_1+R_2$)来进行规划问题求解</p></li><li><p>判断是否有解空间，没有的话就结束，否则将人工变量列去除后，进入阶段二。</p></li></ul></li></ul></li><li>阶段二：使用阶段一得到的可行解作为原始问题的初始可行解，然后使用朴素单纯形算法计算。<ul><li>即将阶段一单纯形表中的<code>R1</code>，<code>R2</code>两列去掉后直接作为新的单纯形表，<strong>根据目标函数的系数</strong>重新对解进行计算。</li><li>之后就是朴素单纯形法工作</li></ul></li></ul><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><h3 id="退化"><a href="#退化" class="headerlink" title="退化"></a>退化</h3><ul><li>可行性条件中存在冗余（最小非负比循环出现），此时称新的基变量解为<strong>退化的</strong>。例如有一个约束条件的范围过大，没有对可行域起到任何限制作用。</li><li>表现：某个<strong>进基变量</strong>的<strong>最小非负比</strong>为0，对目标函数不能起到改善作用。</li></ul><h3 id="可选择最优解"><a href="#可选择最优解" class="headerlink" title="可选择最优解"></a>可选择最优解</h3><ul><li><p>目标函数平行于<strong>非冗余</strong>的紧约束，<strong>可能会</strong>有多个最优值。</p><blockquote><p>当变量是<strong>离散</strong>的时候，最优值可能只会有一个。</p></blockquote></li><li><p>表现：目标函数中<strong>非基变量</strong>的<strong>系数</strong>为0，对目标函数不能起到改善作用，但是会<strong>引起变量值的改变</strong>。</p></li><li><p>作用：从多个最优解中选择，但不会损害目标值。（现实意义大）</p></li></ul><h3 id="无界解"><a href="#无界解" class="headerlink" title="无界解"></a>无界解</h3><ul><li>某个变量可以无限大，但是<strong>不会</strong>影响约束条件。</li><li>表现：进基变量的最小非负比是无穷大</li></ul><h3 id="不可行解"><a href="#不可行解" class="headerlink" title="不可行解"></a>不可行解</h3><ul><li>具有不相容约束的线性规划模型没有可行解<ul><li><strong>人工变量不为零</strong>时取得最优解，说明原模型有问题。</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2162&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter1-概论</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter1-%E6%A6%82%E8%AE%BA/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter1-%E6%A6%82%E8%AE%BA/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:37.860Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>363</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><ul><li>基本模型</li><li>基本步骤<ul><li>指定变量</li><li>确定可行域</li><li>寻找最优解</li></ul></li><li>线性规划模型</li><li>图解法</li><li>工程应用</li></ul><h2 id="线性规划图解法"><a href="#线性规划图解法" class="headerlink" title="线性规划图解法"></a>线性规划图解法</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>确定可行解空间</li><li>在可行点中确定最优解</li></ul><blockquote><p>求极大或极小的目标函数</p></blockquote><h2 id="工程应用"><a href="#工程应用" class="headerlink" title="工程应用"></a>工程应用</h2><ul><li>多元线性规划<ul><li><strong>不能</strong>使用图解法，应该使用算术进行求解。</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;363&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter4-运输问题</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter4-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter4-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1277</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><strong>最小化</strong>问题：路线等条件确定，目标是使运输费用最低。</li><li>一般的运输问题使用<strong>网络图</strong>表示</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>使用单纯形方法可以求解，但是较为复杂。</li><li>通常使用<strong>运输表</strong>求解</li><li>平衡问题（供应量和需求量关系）：当模型<strong>不平衡</strong>时，可以增加一个<strong>虚设起点</strong>或<strong>虚设终点</strong>使模型平衡。<ul><li>虚设起点或终点的运输成本应该<strong>设为0</strong>，保证不影响真实模型的最优解。</li><li><strong>不存在</strong>起点和终点同时增加的情况</li></ul></li></ul><h2 id="非传统运输问题"><a href="#非传统运输问题" class="headerlink" title="非传统运输问题"></a>非传统运输问题</h2><p>例如多方式供货问题，每个月的需求量和供应量不等，月份之间的货物可以<strong>交叉供应</strong>。</p><ul><li>起点：不同的月份的生产</li><li>终点：不同的月份的需求</li><li>运费：当月生产费及发生交叉供应时对应的存储费或延期费</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li><p>依然采用单纯形法的步骤，只是使用运输表替代单纯形表。</p></li><li><p>设<code>m</code>个起点和<code>n</code>个终点，则共有<code>(m+n)</code>个等式约束，对应<code>(m+n)</code>个基变量。</p><ul><li><p>在供需平衡的前提下，仅需要<code>(m+n-1)</code>个等式约束，及初始基本解由<code>(m+n-1)</code>个基变量组成，也就是说<strong>最优解中，最多有<code>(m+n-1)</code>个非0变量。</strong></p><blockquote><p>基变量<strong>可以为零</strong>，非基变量<strong>一定为零</strong>。</p></blockquote></li></ul></li><li><p><strong>初始解</strong>确定（不是最优解）</p><ul><li><p>西北角法：找到一个<strong>相对较优</strong>的初始解</p><ul><li><p>从西北角元素开始，选择<code>min(需求，供应)</code>，并更新行列需求。</p></li><li><p>对于更新后为0的行<strong>或</strong>列，可以直接从表中删去。</p></li><li><p>对于更新后同时为0的行<strong>和</strong>列，在行和列中任意选择一个删除。</p><blockquote><p>只能删除一个元素时，下一个元素在下方和右方任意选择，只要不跨斜角即可。</p></blockquote></li></ul></li><li><p>最小费用法：找到<strong>相对西北角法更优</strong>的初始解</p><ul><li><p>选择费用最小的结点，并更新行列需求。</p><blockquote><ul><li>出现费用相等的结点时，任意选择一个即可。</li><li>对于为供应量取值为0的<strong>最小费用路径点</strong>，<strong>不能够省略</strong>，因为它依然是一个<strong>基变量</strong>。</li></ul></blockquote></li><li><p>删除方法和西北角法相同</p></li></ul></li><li><p>Vogel（沃格尔）近似法：在最小费用法上进一步优化，避免删除过多行列后造成很高的费用被选择。</p><ul><li><p>设置惩罚量=<strong>同行/列</strong>的次小费用-最小费用</p></li><li><p>找出惩罚量<strong>最大</strong>的行或列，为<strong>最小费用单元</strong>分配尽可能多的供应量（即$min(供应，需求)$）。</p><blockquote><p>思想是为了能够把费用较大的结点借最小费用单元置零来删除</p></blockquote></li><li><p>在删除某一<strong>列</strong>后，需要更新<strong>行惩罚量</strong>，反之亦然。</p></li></ul></li></ul></li><li><p><strong>最优解</strong>确定：使用初始解作为基变量，然后使用单纯形法。</p><ul><li><p>通常使用西北角法确定初始解</p></li><li><p>乘子法：用$u_i$和$v_j$表示第$i$行和第$j$列的乘子，用于确定$Z$行非基变量的系数。（基变量系数为0）</p><ul><li><p>对任意<strong>基变量</strong>：$u_i+v_j=c_{i,j}$</p></li><li><p>初始设$u_0=0$，然后导出所有的乘子。</p></li><li><p>$Z$行中<strong>非基变量</strong>的系数=$u_i+v_j-c_{i,j}$</p><blockquote><p>通常在非基变量表格框的<strong>右下角</strong>写出系数</p></blockquote></li></ul></li><li><p>单纯形法直接在运输表上进行，不需要使用单纯形表。</p><ul><li><p>将进基变量设置为$\theta$，然后通过供需平衡调整各个基变量的值，利用<strong>非负条件</strong>求出$\theta$最大值。</p><blockquote><p>规律：需要被调整的基变量可以构成<strong>直角封闭多边形</strong></p></blockquote></li><li><p>利用$\theta_{max}$任意选择一个新值为0的<strong>原基变量</strong>作为<strong>离基变量</strong></p></li><li><p>更新乘子后重复迭代，直到$Z$行不能再被优化，即所有非基变量的系数都为小于等于0。（<strong>必要条件</strong>）</p><blockquote><p>尽管某些非基变量的系数大于0，但是求出的$\theta=0$，也就是说此时选择该非基变量进基不能够对问题的解产生优化效果，故<strong>系数大于0不是能产生优化效果的充分条件，而是一个必要条件。</strong></p><p>例如以下运输表格在使用西北角法+令<code>x11</code>作为离基变量时就会出现<code>x31</code>系数为正但是$\theta=0$的情况。</p><p>| 2    | 3    | 3    | 9         |<br>| —— | —— | —— | ————- |<br>| 1    | 2    | 4    | 15        |<br>| 3    | 4    | 5    | 6         |<br>| 5    | 10   | 15   | 需求/供给 |</p></blockquote></li></ul></li><li><p>在迭代后求最优解时，可以直接利用上一个$Z$值减去（改善量$\theta_{max}$*非基变量系数）得到改善后的$Z$值。</p></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1277&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter5-目标规划</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter5-%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter5-%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>363</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>线性规划模型是对<strong>单个</strong>目标函数进行优化</li><li>目标规划情景下，多个约束通常<strong>不能</strong>够构成<strong>解空间</strong>，只能够根据不同目标的重要程度，得到折中的解。</li><li><p>将目标变为弹性的，然后根据实际情况确定是增加还是减少。</p><ul><li><p>添加$+S^-$和$-S^+$两个变量表示偏离程度，最终有一个必定为0（不可能同时既多又少）。</p><ul><li>$S^-$表示实际情况相比约束条件缺少的部分，因此<code>&gt;=</code>约束中要减少。</li><li>$S^+$表示实际情况相比约束条件多余的部分，因此<code>&lt;=</code>约束中要减少。</li></ul></li><li><p>优化目标是让各个约束的偏离程度最小化</p></li><li><p>实例</p><p><img src="https://i.loli.net/2020/11/16/vZ2GCbBdEsqKp6X.png" alt="image-20201116114612320" style="zoom:50%;" /></p><p><img src="https://i.loli.net/2020/11/16/LJ7BluCFyIf5GSZ.png" alt="image-20201116115451654" style="zoom:50%;" /></p></li></ul></li></ul><h2 id="权和法"><a href="#权和法" class="headerlink" title="权和法"></a>权和法</h2><ul><li><p>为多个$S_i$的最小化目标函数指定权值，然后合并为一个目标函数。</p><ul><li><p>权重需要<strong>归一化</strong></p><p>$minZ=2G_1+2G_2\to \frac{2}{3}S_1^-+\frac{1}{3}S_2^+$</p></li></ul></li><li><p>权和法找到的是<strong>有效解</strong>，而不一定是最优解。</p></li><li><p>求出偏离程度不为0，实际上是两阶段方法人工变量不为0的一种特殊情况。</p></li><li><p>拓展：设定优先权法</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;363&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter3-对偶理论与灵敏度分析</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter3-%E5%AF%B9%E5%81%B6%E7%90%86%E8%AE%BA%E4%B8%8E%E7%81%B5%E6%95%8F%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter3-%E5%AF%B9%E5%81%B6%E7%90%86%E8%AE%BA%E4%B8%8E%E7%81%B5%E6%95%8F%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2021-01-03T10:46:53.745Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>820</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>图形（二维）<ul><li>右端项（约束条件）变化：最优解对<strong>资源的可利用性</strong>的灵敏度<ul><li>改变约束条件的截距</li></ul></li><li>目标系数（目标函数）变化：最优解对<strong>单位利润和单位费用</strong>的灵敏度<ul><li>改变目标函数的斜率</li><li>最优性区域：改变斜率但是最优解<strong>不变</strong>的斜率取值范围</li></ul></li></ul></li><li>代数（高维）<ul><li>右端项变化</li><li>目标系数变化</li></ul></li></ul><h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul><li><strong>线性规划</strong>中目标函数改善的灵敏度是<strong>均匀的</strong></li></ul><h3 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h3><ul><li><p>对偶价格：松弛变量在最优方程中的系数（一定大于0，否则说明仍<strong>不是</strong>最优解）</p><ul><li>当系数大于0时，说明<strong>减小松弛变量</strong>就能带来收益，即增大原变量的左值，也即<strong>右端项</strong>的值。</li></ul></li><li><p>可行性区域：使对偶价格有效的区域，即对偶价格的变化的目标函数的影响<strong>保持线性</strong>的区域。</p><ul><li><strong>可行域</strong>对应的系数矩阵和<strong>松弛变量</strong>的系数矩阵相同，但是可行域在<strong>右端</strong>。</li><li>利用决策变量和松弛变量的约束条件反解可行域<ul><li>求解某个可行域时将其他可行域的值设为0</li></ul></li></ul></li><li><p>最优性区域：将改变松弛量加在目标函数系数上</p><p>$max\ z=(3+d1)x_1+(2+d_2)x_2+(5+d_3)x_3$</p></li></ul><h2 id="对偶理论"><a href="#对偶理论" class="headerlink" title="对偶理论"></a>对偶理论</h2><ul><li><p>将原模型转换为对偶模型后进行最优解计算，然后再对最优解进行<strong>特定矩阵操作</strong>即可得到原模型的最优解。</p><blockquote><p>对偶问题的解和原问题解需要特殊矩阵运算进行转化</p></blockquote></li></ul><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul><li><p>约束$\Longleftrightarrow$变量（所有变量，包括剩余变量、松弛变量、人工变量）</p><ul><li><strong>一条</strong>约束对应<strong>一个</strong>对偶变量</li></ul></li><li><p>右端项$\Longleftrightarrow$决策系数</p></li><li><p>约束方向、求解目标（最大/最小）反向</p><p>| 原问题目标 | 对偶问题目标 | 对偶问题约束方向 |<br>| ————— | —————— | ———————— |<br>| 极大化     | 极小化       | <code>&gt;=</code>             |<br>| 极小化     | 极大化       | <code>&lt;=</code>             |</p><ul><li>不论原问题中的约束是什么方向，对偶问题中约束方向<strong>只和原问题的目标</strong>有关。</li></ul></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对于等式约束<strong>不需要</strong>增加松弛、人工变量（不需要求最优解，只要转换成等式形式即可）</li><li>为每个约束条件定义一个对偶变量</li><li>约束条件中的系数<strong>列</strong>$\Rightarrow$对偶约束条件系数<strong>行</strong></li><li>约束条件的目标函数系数$\Rightarrow$对偶约束的<strong>右端项</strong></li><li>约束条件的右端项$\Rightarrow$对偶目标函数系数</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li><p>对偶变量的最优值=最优原始基变量的原目标系数行向量*最优原始逆矩阵</p></li><li><p>对偶变量<strong>不一定</strong>满足非负条件，因此对偶问题<strong>不可以</strong>直接使用单纯形方法求解。</p><blockquote><p>对于不满足的情况，可以分类讨论，每次分类设置新变量满足非负条件。</p></blockquote></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;820&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter6-图像处理</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter6-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter6-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</id>
    <published>2020-12-04T03:28:44.164Z</published>
    <updated>2020-12-04T03:41:47.630Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>3427</code>字，推荐阅读时间<code>25~30</code>分钟。</p><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><p>采样（空间离散）：将连续图像变化为离散点的操作，即将图像划分为$M * N$网格，每个网格只提取出一个值。</p><blockquote><ul><li>上采样（图像插值、放大）：放大原图像，从而可以显示在更高分辨率的显示设备上。</li><li>下采样（池化、缩小）：使得图像符合显示区域的大小；生成对应图像的缩略图；降低特征的维度并保留有效信息，一定程度上避免过拟合，保持旋转、平移、伸缩不变形。</li></ul></blockquote></li><li><p>分辨率：采样划分网格矩阵的形状尺寸</p></li><li><p>量化（灰度离散）：确定离散点数值表示的位数，反映了采样的质量。</p><ul><li><p>灰度图：1个通道，每个离散点8bit(0-255).</p><blockquote><ul><li>256个值对应的是从黑到白的不同<strong>亮度</strong>等级，<code>0</code>是纯黑，<code>255</code>是纯白。</li><li>彩色图中的RGB值也并不是各个颜色的“浓度”，只是三个分量的灰度值，分别命名为R，G，B.也就是说，RGB图各分量<strong>并不是</strong>彩色的，而是三张灰度图，RGB只是一种来自三原色的命名。</li><li>当三色灰度”效果“相同时，产生不同灰度值的灰色调。<ul><li><code>Gray = R*0.299 + G*0.587 + B*0.114</code>（心理学公式）</li><li><code>Gray = (R*299 + G*587 + B*114 + 500) / 1000</code></li></ul></li></ul></blockquote></li><li><p>二值图：1个通道，每个离散点1bit(0-1).</p></li><li><p>彩色图：3个通道（3张灰度图），各个通道每个离散点8bit(0-255)，合成为24bit.</p><ul><li><p>以红色椅子的显示为例。</p><p>R分量的图上，椅子对应的部分比较浅（灰度值高），而在G分量和了B分量上很深。<br>随便在椅子上取一个样点，其灰度值分别是（R:179,G:45,B:9）。所以在显示的时候，红色通道里灰度值大，绿色通道和蓝色通道里的灰度值小，显示出来的就是红色。</p><blockquote><p>用灰度图的<strong>亮暗</strong>来表示三种颜色的浓度，每个通道就是指定了颜色的”颜料“，然后合并出不同的颜色，和自然界中的光的合成<strong>并不相同</strong>。</p></blockquote></li></ul></li></ul><blockquote><p>视频尺寸：时域离散*空域（空间）离散*灰度离散=<u>FPS</u>*<u>1080*720</u>*<u>3*8</u></p></blockquote></li><li><p>矢量图（图形）：一般由轮廓线构成，是用软件绘制的。不易失真，但是颜色相对没有那么丰富。</p></li><li><p>点阵图（位图，图像）：设备捕捉实际画面产生的数字矩阵，存储空间大，颜色丰富。</p></li></ul><h2 id="类型及转换"><a href="#类型及转换" class="headerlink" title="类型及转换"></a>类型及转换</h2><ul><li><p>格式</p><ul><li><p><code>double</code>：亮度值范围是<code>[0,1]</code></p><blockquote><p>通常使用<code>double</code>减少图像失真</p></blockquote></li><li><p><code>uint8</code>：亮度值范围是<code>[0,255]</code></p></li></ul></li><li><p>真彩色图像</p><ul><li>大小：<code>m*n*3</code></li><li>红色分量：<code>(:,:,1)</code>（绿色，蓝色同理）</li></ul></li><li><p>索引图像：创建调色板及对应的索引图，使用索引下标表示图像的每个像素点。</p><ul><li>调色板中色彩强度范围是<code>[0,1]</code>，大小和亮度成正比。</li><li>使用索引可以有效节省存储空间</li></ul></li><li><p>图像序列</p><ul><li><p>合并</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">cat</span> (<span class="number">1</span>，A1，A2，A3，A4，A5) <span class="comment">%按列连接（列数相同）</span></span><br><span class="line">A = <span class="built_in">cat</span> (<span class="number">2</span>，A1，A2，A3，A4，A5) <span class="comment">%按行连接（行数相同）</span></span><br><span class="line">A = <span class="built_in">cat</span> (<span class="number">3</span>，A1，A2，A3，A4，A5) <span class="comment">%按矩阵连接（行列数相同）</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cat</code>的参数是几就是<strong>改变</strong>第几维</p></blockquote></li></ul></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p><code>imread</code>：读入图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=imread(filename, fmt) <span class="comment">% imread('filename.fmt')</span></span><br><span class="line">[A, map]=imread(filename, fmt) <span class="comment">% index image</span></span><br></pre></td></tr></table></figure><ul><li>读入的图像大多数为<code>uint8</code>，对于索引图则将颜色映象表存储为双精度浮点型矩阵。</li><li>如果将<code>filename</code>和<code>fmt</code>合并，则需要保证<code>filename.fmt</code>后缀的合法性。</li></ul></li><li><p><code>imwrite</code>：输出图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imwrite(A, filename, fmt) <span class="comment">% imwrite(A, 'filename.fmt')</span></span><br><span class="line">imwrite(A, map, filename, fmt)</span><br></pre></td></tr></table></figure></li><li><p><code>imfinfo</code>：获取图片信息</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imfinfo(<span class="string">'filename.fmt'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>load/save</code>：使用<code>.mat</code>文件管理图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lena=imread(<span class="string">'lena.jpg'</span>); </span><br><span class="line">imshow(lena);</span><br><span class="line">save lena; <span class="comment">%保存图像数据，生成lena.mat</span></span><br><span class="line">clear;</span><br><span class="line">load lena;</span><br><span class="line"><span class="built_in">figure</span>, imshow(lena);</span><br></pre></td></tr></table></figure></li></ul><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><ul><li><p>灰度图</p><ul><li><p>格式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imshow(I)</span><br><span class="line">imshow(I, n) <span class="comment">% n为显示灰度级数目，缺省值为256.</span></span><br><span class="line">imshow(I, [low high]) <span class="comment">% [low high]为图像数据的值域，范围外的取0或255.</span></span><br><span class="line">imshow(I, []) <span class="comment">% 默认显示范围为[min(I(:);), max(I(:);)]</span></span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(I);</span><br><span class="line"><span class="comment">%设置显示的范围，低于100的全黑，高于200的全白</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,[<span class="number">100</span> <span class="number">200</span>]);</span><br><span class="line"><span class="comment">%设置灰度级别为2; 部分版本不支持</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%设置灰度级别为8 ; 同上</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">8</span>);</span><br><span class="line"><span class="comment">%设置灰度级别为全256 ; 同上</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二值图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BW=imread(<span class="string">'circles.png'</span>);</span><br><span class="line">imshow(BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(~BW);</span><br></pre></td></tr></table></figure></li><li><p>索引图像</p><ul><li><p>格式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imshow(X, map);</span><br></pre></td></tr></table></figure><ul><li><code>map</code>是一个p×3的矩阵，元素值均为[0, 1]之间双精度浮点型数据。每一行分别表示红、绿、蓝的颜色值。</li><li>如一幅包含256色的uint8<strong>索引图像</strong>，使用一个仅有16色的调色板显示，则所有索引值大于或等于15的像素都将被显示为调色板的最后一个颜色。</li><li>常用后缀名：<code>.tiff</code>/<code>.tif</code></li></ul></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X=imread(<span class="string">'cameraman.tif'</span>); </span><br><span class="line">imshow(X); </span><br><span class="line">colorbar;</span><br><span class="line">map=pink(<span class="number">256</span>); <span class="comment">%借助不同的调色板显示图像</span></span><br><span class="line"><span class="built_in">figure</span>, imshow(X,map); colorbar; <span class="comment">%显示颜色条</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>彩色图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%调整RGB的显示顺序</span></span><br><span class="line">img=imread(<span class="string">'i.png'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(img);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(img(:,:,[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]));</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>), imshow(img(:,:,[<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]));</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>), imshow(img(:,:,[<span class="number">3</span> <span class="number">1</span> <span class="number">2</span>]));</span><br></pre></td></tr></table></figure><blockquote><p>Q：RGB的顺序为什么对显示效果有影响</p><p>A：不同通道对应的”颜料“不同，成像时根据放进该通道的<strong>灰度图分量</strong>的灰度值，来决定显示的颜色。</p></blockquote></li></ul><h2 id="代数运算"><a href="#代数运算" class="headerlink" title="代数运算"></a>代数运算</h2><ul><li><p><code>imadd</code>：加法，数值变大。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line"><span class="comment">%图像整体亮度增加</span></span><br><span class="line">J=imadd(I, <span class="number">50</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(J);</span><br></pre></td></tr></table></figure><ul><li>超出范围的部分<strong>不会</strong>溢出，而是取<strong>边界值</strong>。</li></ul><blockquote><ul><li>图像增强</li><li>图像重叠</li><li>水印加密</li><li>图像去噪</li></ul></blockquote></li><li><p><code>imsubtract</code>：减法，数值变小。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line">J=imsubtract(I, <span class="number">50</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(J);</span><br></pre></td></tr></table></figure></li><li><p><code>immultiply</code></p><ul><li><p><code>immultiply(I, n)</code>：亮度缩放</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line">J = immultiply(I,<span class="number">0.5</span>);</span><br><span class="line">K = immultiply(I,<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>), imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>), imshow(J)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>), imshow(K)</span><br></pre></td></tr></table></figure></li><li><p><code>immultiply(I, mask)</code>：掩模</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Img=imread(<span class="string">'pears.png'</span>);</span><br><span class="line">subplot(<span class="number">131</span>), imshow(Img);</span><br><span class="line">Mask=imread(<span class="string">'PearMask.bmp'</span>);</span><br><span class="line">subplot(<span class="number">132</span>), imshow(Mask);</span><br><span class="line">PearR=immultiply(Img(:,:,<span class="number">1</span>),Mask);</span><br><span class="line">PearG=immultiply(Img(:,:,<span class="number">2</span>),Mask);</span><br><span class="line">PearB=immultiply(Img(:,:,<span class="number">3</span>),Mask);</span><br><span class="line">Pear=<span class="built_in">cat</span>(<span class="number">3</span>,PearR,PearG,PearB);</span><br><span class="line">subplot(<span class="number">133</span>), imshow(Pear);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>imdivide</code></p><ul><li><p><code>imdivide(I, n)</code>：亮度缩放</p></li><li><p><code>imdivide(I, J)</code>：去除背景</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'rice.png'</span>);</span><br><span class="line">subplot(<span class="number">131</span>),imshow(I);</span><br><span class="line">background = imopen(I,strel(<span class="string">'disk'</span>,<span class="number">15</span>));</span><br><span class="line">subplot(<span class="number">132</span>), imshow(background);</span><br><span class="line">Ip = imdivide(I,background);</span><br><span class="line">subplot(<span class="number">133</span>),imshow(Ip,[])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>直接线性运算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I)</span><br><span class="line">J=(double(I))*<span class="number">1.5</span>+<span class="number">30</span>;</span><br><span class="line"><span class="built_in">figure</span>, imshow(uint8(J))</span><br><span class="line">K=(double(I))*<span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">figure</span>, imshow(uint8(K));</span><br></pre></td></tr></table></figure></li></ul><h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><ul><li><p><code>imtransform(I, T, Interp)</code>：二维空间</p><ul><li><code>T</code>：变换结构，由<code>maketform</code>产生。</li><li><code>Interp</code>：插值方法</li></ul></li><li><p>仿射变换</p><p><img src="https://i.loli.net/2020/11/19/E5Sm6GgzvuiwZOn.png" alt="image-20201119133406026" style="zoom:50%;" /></p><ul><li><p>平移</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[height,width,dim]=<span class="built_in">size</span>(A);</span><br><span class="line">tform=maketform(<span class="string">'affine'</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">20</span> <span class="number">30</span> <span class="number">1</span>]); <span class="comment">% downward</span></span><br><span class="line">B = imtransform(A,tform,<span class="string">'nearest'</span>,<span class="string">'XData'</span>,[<span class="number">1</span></span><br><span class="line"><span class="built_in">size</span>(A,<span class="number">2</span>)],<span class="string">'YData'</span>,[<span class="number">1</span> <span class="built_in">size</span>(A,<span class="number">1</span>)])</span><br><span class="line">subplot(<span class="number">121</span>);imshow(A);</span><br><span class="line">subplot(<span class="number">122</span>); imshow(B);</span><br></pre></td></tr></table></figure></li><li><p>镜像</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[height,width,dim]=<span class="built_in">size</span>(A);</span><br><span class="line">tform=maketform(<span class="string">'affine'</span>,[<span class="number">-1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]); <span class="comment">% horizontal</span></span><br><span class="line">B=imtransform(A,tform,<span class="string">'nearest'</span>);</span><br><span class="line">tform2=maketform(<span class="string">'affine'</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]); <span class="comment">% vertical</span></span><br><span class="line">C=imtransform(A,tform2,<span class="string">'nearest'</span>);</span><br><span class="line">subplot(<span class="number">131</span>); imshow(A);</span><br><span class="line">subplot(<span class="number">132</span>); imshow(B);</span><br><span class="line">subplot(<span class="number">133</span>); imshow(C);</span><br></pre></td></tr></table></figure></li><li><p>旋转</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">transformtype = <span class="string">'affine'</span>;</span><br><span class="line">transformmatrix = [<span class="built_in">cos</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="number">0</span>;</span><br><span class="line">   -<span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="built_in">cos</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="number">0</span>;</span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]; <span class="comment">% rotate 30 degrees</span></span><br><span class="line">T = maketform(transformtype,transformmatrix);</span><br><span class="line">nI = imtransform(I,T);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(nI)</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>imrotate(A, angle)</code>，指定<code>crop</code>参数后会裁剪新图以维持画布大小不变，</p></blockquote></li><li><p>缩放</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>); <span class="built_in">figure</span>, imshow(I)</span><br><span class="line">transformtype = <span class="string">'affine'</span>;</span><br><span class="line">transformmatrix1 = [<span class="number">0.5</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0.5</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">transformmatrix2 = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">2</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">T1 = maketform(transformtype,transformmatrix1);</span><br><span class="line">T2 = maketform(transformtype,transformmatrix2);</span><br><span class="line">nI1 = imtransform(I,T1);</span><br><span class="line">nI2 = imtransform(I,T2);</span><br><span class="line"><span class="built_in">figure</span>,imshow(nI1)</span><br><span class="line"><span class="built_in">figure</span>,imshow(nI2)</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>imresize(A, times)</code>，默认等比例缩放。</p></blockquote></li></ul></li><li><p>投影变换：将二维图像按照“近大远小”的规则投影到一个平面，追求立体感。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">transformtype = <span class="string">'projective'</span>;</span><br><span class="line">transformmatrix1 =[<span class="number">0.8</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">-0.2</span> <span class="number">0.8</span> <span class="number">-0.003</span>; <span class="number">3.5</span> <span class="number">1.5</span> <span class="number">1.5</span>];</span><br><span class="line">T = maketform(transformtype,transformmatrix1);</span><br><span class="line">nI = imtransform(I,T);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(nI);</span><br></pre></td></tr></table></figure><blockquote><ul><li>对失真图像进行逆变换，就可以得到正常比例的图像。</li><li>仿射变换可看作是一种特殊的投影变换。它要求变换矩阵的最后一列除最后一个元素为<code>1</code>之外，其它的均为<code>0</code>。</li></ul></blockquote></li><li><p><code>imcrop</code>：图像裁剪</p><ul><li><p>指定区域</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = imread(<span class="string">'liftingbody.png'</span>);</span><br><span class="line">pc = imcrop(p,[<span class="number">80</span> <span class="number">180</span> <span class="number">260</span> <span class="number">220</span>]); <span class="comment">%输入矩形尺度进行选取</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>); imshow(p);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>); imshow(pc);</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>参数格式：<code>[left, bottom, width, height]</code></p></blockquote><ul><li><p><code>roipoly</code>：多边形裁剪</p><ul><li><p>人工选区</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Img=imread(<span class="string">'pears.png'</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(Img)</span><br><span class="line">bw=roipoly(Img); <span class="comment">%设定区域，用鼠标选择多边形区域</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(bw) <span class="comment">%用二值色彩显示多边形区域</span></span><br><span class="line">r=Img (:,:,<span class="number">1</span>); g=Img (:,:,<span class="number">2</span>);b=Img (:,:,<span class="number">3</span>);</span><br><span class="line">cr=bw.*double(r); cg=bw.*double(g);cb=bw.*double(b);</span><br><span class="line">J=<span class="built_in">cat</span>(<span class="number">3</span>,uint8(cr),uint8(cg),uint8(cb)); <span class="comment">%联结数组作为图像色彩</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(J)</span><br></pre></td></tr></table></figure></li><li><p>指定顶点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'eight.tif'</span>);</span><br><span class="line">c = [<span class="number">222</span> <span class="number">272</span> <span class="number">300</span> <span class="number">270</span> <span class="number">221</span> <span class="number">194</span>];</span><br><span class="line">r = [<span class="number">21</span> <span class="number">21</span> <span class="number">75</span> <span class="number">121</span> <span class="number">121</span> <span class="number">75</span>];</span><br><span class="line">BW = roipoly(I,c,r);</span><br><span class="line">Ic=immultiply(I, BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I)</span><br><span class="line"><span class="built_in">figure</span>, imshow(BW)</span><br><span class="line"><span class="built_in">figure</span>, imshow(Ic)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h2><ul><li><p><code>imadjust</code>：对某一区间内的灰度值进行变换，从而符合人眼的非线性特征。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'pout.tif'</span>); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>); imshow(I);</span><br><span class="line">J=imadjust(I); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>); imshow(J); <span class="comment">% default gamma = 1</span></span><br><span class="line">K=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>); imshow(K);</span><br><span class="line">L=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>], <span class="number">2</span>); <span class="comment">% gamma = 2</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); imshow(L);</span><br><span class="line">M=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>], <span class="number">0.3</span>); <span class="comment">% gamma = 0.3</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>); imshow(M);</span><br><span class="line">N=imadjust(I,[<span class="number">0</span> <span class="number">1</span>],[<span class="number">1</span> <span class="number">0</span>]); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>); imshow(N);</span><br></pre></td></tr></table></figure><ul><li>不指定参数时，默认处理最高和最低的<code>1%</code>，从而提高图像饱和度。</li><li><code>gamma</code>越大，图像亮度越大。</li></ul></li><li><p><code>imhist</code>：灰度分布直方图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), imhist(I);</span><br></pre></td></tr></table></figure><ul><li>可以通过参数指定灰度等级数</li><li>占满整个区间的图像通常质量更高</li></ul></li><li><p><code>histeq</code>：直方图均衡化</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'pout.tif'</span>);</span><br><span class="line">subplot(<span class="number">221</span>),imshow(I);title(<span class="string">'原图'</span>);</span><br><span class="line">subplot(<span class="number">222</span>),imhist(I);title(<span class="string">'原图直方图'</span>);</span><br><span class="line">hI=histeq(I);</span><br><span class="line">subplot(<span class="number">223</span>),imshow(hI);</span><br><span class="line">title(<span class="string">'原图均衡化处理'</span>);</span><br><span class="line">subplot(<span class="number">224</span>),imhist(hI);</span><br><span class="line">title(<span class="string">'均衡处理后直方图'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h2><ul><li><p>平滑</p><ul><li>低通滤波：低频段保留</li><li>均值滤波</li><li>中值滤波</li></ul></li><li><p>锐化</p><ul><li>高通滤波：高频段保留</li></ul></li><li><p><code>imnoise</code>：模拟图像噪声</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'coins.png'</span>);</span><br><span class="line">J=imnoise(I, <span class="string">'salt &amp; pepper'</span>,<span class="number">0.06</span>); <span class="comment">%添加椒盐噪声</span></span><br><span class="line">subplot(<span class="number">221</span>),imshow(I),title(<span class="string">'原图'</span>)</span><br><span class="line">subplot(<span class="number">222</span>),imshow(J),title(<span class="string">'含椒盐噪声图'</span>)</span><br><span class="line">H = fspecial(<span class="string">'average'</span>,[<span class="number">3</span> <span class="number">4</span>]); <span class="comment">%设计均值滤波器H</span></span><br><span class="line">am = imfilter(J,H);<span class="comment">%均值滤波</span></span><br><span class="line">subplot(<span class="number">223</span>),imshow(am),title(<span class="string">'均值滤波'</span>)</span><br><span class="line">zm=medfilt2(J);<span class="comment">%中值滤波</span></span><br><span class="line">subplot(<span class="number">224</span>),imshow(zm),title(<span class="string">'中值滤波‘)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="边缘检测与分割"><a href="#边缘检测与分割" class="headerlink" title="边缘检测与分割"></a>边缘检测与分割</h2><ul><li><p><code>edge</code>：边缘处值为1，否则为0.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[e1,s1] = edge(p,<span class="string">'sobel'</span>,<span class="number">0.03</span>,<span class="string">'both'</span>); <span class="comment">% sobel算子</span></span><br><span class="line">[e2,s2] = edge(p,<span class="string">'roberts'</span>,<span class="number">0.03</span>,<span class="string">'both'</span>); <span class="comment">% roberts算子</span></span><br><span class="line">[e3,s3] = edge(p,<span class="string">'prewitt'</span>,<span class="number">0.04</span>,<span class="string">'both'</span>); <span class="comment">% prewitt算子</span></span><br><span class="line">[e4,s4] = edge(p, <span class="string">'log'</span>,<span class="number">0.003</span>,<span class="number">2.10</span>); <span class="comment">% LoG算子</span></span><br><span class="line">[e5,s5] = edge(p, <span class="string">'canny'</span>,[<span class="number">0.05</span> <span class="number">0.12</span>],<span class="number">1.6</span>); <span class="comment">%canny算子</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>),imshow(p);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>),imshow(e1);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),imshow(e2);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);imshow(e3);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>),imshow(e4);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>),imshow(e5);</span><br></pre></td></tr></table></figure></li><li><p><code>imcontour</code>：轮廓提取函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">subplot(<span class="number">131</span>), imcontour(I,<span class="number">1</span>)</span><br><span class="line">subplot(<span class="number">132</span>), imcontour(I,<span class="number">2</span>)</span><br><span class="line">subplot(<span class="number">133</span>), imcontour(I,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>阈值分割</p><ul><li><p>极小值点</p></li><li><p>迭代</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p= imread(<span class="string">'bugs.bmp'</span>);</span><br><span class="line">p=rgb2gray(p); p=im2double(p); <span class="comment">%转换为double</span></span><br><span class="line">thresh = <span class="number">0.5</span>*(<span class="built_in">min</span>(p(:)) + <span class="built_in">max</span>(p(:))); <span class="comment">%初值为中间值</span></span><br><span class="line">flag = <span class="built_in">false</span>; <span class="comment">%迭代步长控制</span></span><br><span class="line"><span class="keyword">while</span> ~flag</span><br><span class="line">g = p&gt;=thresh; <span class="comment">%按当前阈值划分</span></span><br><span class="line">thresh_1= <span class="number">0.5</span>*(<span class="built_in">mean</span>(p(g)) + <span class="built_in">mean</span>(p(~g))); <span class="comment">%新阈值</span></span><br><span class="line">flag = <span class="built_in">abs</span>(thresh - thresh_1)&lt;<span class="number">0.5</span>; <span class="comment">%更新迭代标志</span></span><br><span class="line">thresh = thresh_1; <span class="comment">%更新阈值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>最大方差</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p= imread(<span class="string">'bugs.bmp'</span>);</span><br><span class="line">p1=rgb2gray(p);</span><br><span class="line">thresh = graythresh(p1); <span class="comment">%使用Ostu算法求得新阈值</span></span><br><span class="line">g = im2bw(p1,thresh); <span class="comment">%使用thresh对图像进行分割</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>), imshow(p);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>roifilt2</code>：特定区域增强</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'pout.tif'</span>);</span><br><span class="line">imshow(I)</span><br><span class="line">BW = roipoly(I);</span><br><span class="line">H = fspecial(<span class="string">'unsharp'</span>);</span><br><span class="line">J = roifilt2(H,I,BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(J)</span><br></pre></td></tr></table></figure></li><li><p><code>roifill</code>：区域填充</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I=ind2gray(X,map);</span><br><span class="line"><span class="built_in">figure</span>,imshow(I)</span><br><span class="line">J=roifill;</span><br><span class="line"><span class="built_in">figure</span>,imshow(J)</span><br></pre></td></tr></table></figure></li></ul><h2 id="直线检测"><a href="#直线检测" class="headerlink" title="直线检测"></a>直线检测</h2><ul><li><p>基本思想：点-线对偶性，<code>xy</code>平面上直线，对应参数<code>ab</code>平面上的一个点。</p><ul><li>过<code>xy</code>平面一个点<code>(x,y)</code>的所有直线，构成参数<code>ab</code>平面上的一条直线。</li><li>如果点<code>(x1,y1)</code>与点<code>(x2,y2)</code>共线，那么这两点在参数<code>ab</code>平面上的直线将有一个交点。</li><li>在参数<code>ab</code>平面上相交直线最多的点，对应的<code>xy</code>平面上的直线就是需要的解。</li></ul></li><li><p><code>hough</code>：霍夫变换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'circuit.tif'</span>);</span><br><span class="line">I = imrotate(I,<span class="number">33</span>,<span class="string">'crop'</span>);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I), <span class="built_in">hold</span> on</span><br><span class="line">BW = edge(I,<span class="string">'canny'</span>);</span><br><span class="line">[H,T,R] = hough(BW);</span><br><span class="line"><span class="built_in">figure</span>; imshow(H,[],<span class="string">'XData'</span>,T,<span class="string">'YData'</span>,R,<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);</span><br><span class="line">xlabel(<span class="string">'\theta'</span>), ylabel(<span class="string">'\rho'</span>);</span><br><span class="line">axis on, axis normal, <span class="built_in">hold</span> on;</span><br></pre></td></tr></table></figure></li><li><p><code>houghpeaks</code>：霍夫变换矩阵中的极值点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P = houghpeaks(H,<span class="number">3</span>,<span class="string">'threshold'</span>,<span class="built_in">ceil</span>(<span class="number">0.3</span>*<span class="built_in">max</span>(H(:))));</span><br><span class="line">x = T(P(:,<span class="number">2</span>));</span><br><span class="line">y = R(P(:,<span class="number">1</span>));</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">'s'</span>,<span class="string">'color'</span>,<span class="string">'white'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>houghlines</code>：从霍夫变换矩阵中提取线段</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lines = houghlines(BW,T,R,P,<span class="string">'FillGap'</span>,<span class="number">25</span>,<span class="string">'MinLength'</span>,<span class="number">40</span>);</span><br><span class="line">max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">length</span>(lines)</span><br><span class="line">xy = [lines(k).point1; lines(k).point2];</span><br><span class="line"><span class="built_in">plot</span>(xy(:,<span class="number">1</span>),xy(:,<span class="number">2</span>),<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'green'</span>);</span><br><span class="line"><span class="comment">% Plot beginnings and ends of lines</span></span><br><span class="line"><span class="built_in">plot</span>(xy(<span class="number">1</span>,<span class="number">1</span>),xy(<span class="number">1</span>,<span class="number">2</span>),<span class="string">'x'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'yellow'</span>);</span><br><span class="line"><span class="built_in">plot</span>(xy(<span class="number">2</span>,<span class="number">1</span>),xy(<span class="number">2</span>,<span class="number">2</span>),<span class="string">'x'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'red'</span>);</span><br><span class="line"><span class="comment">% Determine the endpoints of the longest line segment</span></span><br><span class="line">len = norm(lines(k).point1 - lines(k).point2);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; max_len)</span><br><span class="line">max_len = len; xy_long = xy;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% highlight the longest line segment</span></span><br><span class="line"><span class="built_in">plot</span>(xy_long(:,<span class="number">1</span>),xy_long(:,<span class="number">2</span>),<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'blue'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>拓展：霍夫变换同样可以适用于圆的检测，此时需要三个参数的参数空间。</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;3427&lt;/code&gt;字，推荐阅读时间&lt;code&gt;25~30&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter5-图形绘制</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter5-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter5-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/</id>
    <published>2020-12-04T03:28:44.157Z</published>
    <updated>2020-12-04T03:41:50.640Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2134</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="二维图形"><a href="#二维图形" class="headerlink" title="二维图形"></a>二维图形</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p><code>plot</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(Y) <span class="comment">% 以Y的索引/向量实部为横坐标</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y) <span class="comment">% X和Y的维度需要相同</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y, s) <span class="comment">% s设置线形 颜色 标记</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y, <span class="string">'PropName'</span>, PropVal) <span class="comment">% 设置图形属性</span></span><br><span class="line"><span class="built_in">plot</span>(X1, Y1, s1, X2, Y2, s2)</span><br></pre></td></tr></table></figure><ul><li><p>默认按照<strong>蓝色实线</strong>绘制，并做<strong>平滑</strong>处理。</p></li><li><p>统一<code>x</code>轴绘制</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(t,[y',y1',y2',y3',y4',y5'])</span><br></pre></td></tr></table></figure><blockquote><p>纵坐标<strong>行</strong>向量需要<strong>转置</strong>变成<strong>列</strong>向量</p></blockquote></li></ul></li><li><p><code>plotyy</code>：双<code>y</code>轴绘图，绘制横坐标相同，但是纵坐标对应的变量量纲、范围等不同的图形。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plotyy(X1, Y1, X2, Y2)</span><br><span class="line">plotyy(X1, Y1, X2, Y2, FUN) <span class="comment">% FUN指定绘图函数如@plot/@semilogx/@semilogy@loglog</span></span><br><span class="line">plotyy(X1, Y1, X2, Y2, fun1, fun2)</span><br></pre></td></tr></table></figure><ul><li><p><code>Y1</code>默认在左侧，<code>Y2</code>默认在右侧。</p></li><li><p><code>plotyy</code><strong>不能够</strong>直接对曲线属性进行设置，需要使用<strong>句柄图形</strong>控制完成。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">  y1 = <span class="number">200</span> * <span class="built_in">exp</span>(<span class="number">-0.05</span> * x) .* <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="number">0.8</span> * <span class="built_in">exp</span>(<span class="number">-0.5</span> * x) .* <span class="built_in">sin</span>(<span class="number">10</span> * x);</span><br><span class="line">  [AX, H1, H2] = plotyy(x, y1, x, y2, <span class="string">'plot'</span>);</span><br><span class="line">pause;</span><br><span class="line">  set(H1, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>AX(1)</code>和<code>AX(2)</code>对应两侧坐标轴的句柄，表示坐标轴属性。</p></li><li><p><code>H1</code>和<code>H2</code>是对应的曲线的句柄，可以根据函数的返回值进行操作。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(H1, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>)</span><br><span class="line">set(H2, <span class="string">'LineStyle'</span>, <span class="string">':'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>semilogx</code>：<code>x</code>轴取对数（<strong>10</strong>为底）的绘图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semilogx(x, y, <span class="string">'-*'</span>)</span><br><span class="line">semilogy(x, <span class="number">10.</span>^x)</span><br></pre></td></tr></table></figure></li><li><p><code>semilogy</code></p></li><li><p><code>loglog</code>：两个维度上都取对数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">logspace</span>(<span class="number">-1</span>,<span class="number">2</span>); <span class="comment">% 10^-1 ~ 10^2</span></span><br><span class="line">loglog(x,<span class="built_in">exp</span>(x),<span class="string">'-s'</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><ul><li><code>logspace</code>：对数空间中，以10为底数生成值（和<code>linspace</code>对应）。</li></ul></li><li><p><code>polar</code>：极坐标图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polar(theta, rho)</span><br><span class="line">polar(theta, rho, s)</span><br></pre></td></tr></table></figure><ul><li><p><code>theta</code>是<strong>弧度制</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="number">2</span> * <span class="built_in">pi</span> / <span class="number">90</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(<span class="number">4</span> * t);</span><br><span class="line">polar(t, y);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h3><h4 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h4><ul><li><code>-</code>：实线</li><li><code>--</code>：虚线</li><li><code>:</code>：点线</li><li><code>-.</code>：点划线</li><li><code>none</code>：无线</li></ul><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><ul><li><code>b</code>：蓝色</li><li><code>g</code>：绿色</li><li><code>m</code>：红紫色</li><li><code>w</code>：白色</li><li><code>c</code>：蓝绿色</li><li><code>k</code>：黑色</li><li><code>r</code>：红色</li><li><code>y</code>：黄色</li></ul><h4 id="标记符号"><a href="#标记符号" class="headerlink" title="标记符号"></a>标记符号</h4><p>对曲线上有值的点进行标记</p><ul><li><code>*</code>：星号</li><li><code>x</code>：叉号</li><li><code>s</code>：方块</li><li><code>p</code>：五角星</li><li><code>^</code>/<code>&gt;</code>/<code>.</code>/<code>O</code>/<code>d</code>/<code>h</code>/<code>v</code>/<code>&lt;</code></li></ul><h4 id="图形属性"><a href="#图形属性" class="headerlink" title="图形属性"></a>图形属性</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">tan</span>(<span class="built_in">sin</span>(x)) - <span class="built_in">cos</span>(<span class="built_in">tan</span>(x));</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">'--rp'</span>, <span class="string">'LineWidth'</span>, <span class="number">3</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'k'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'m'</span>, <span class="string">'MarkerSize'</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure><ul><li><code>LineStyle</code></li><li><code>LineWidth</code></li><li><code>Marker</code>：数据点标记符号</li><li><code>MarkerSize</code>：标记符大小</li><li><code>MarkerEdgeColor</code>：标记符<strong>边缘</strong>颜色</li><li><code>MarkerFaceColor</code>：标记符<strong>填充</strong>颜色</li></ul><h4 id="文字标注"><a href="#文字标注" class="headerlink" title="文字标注"></a>文字标注</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">y1 = <span class="built_in">sin</span>(t); y2 = <span class="built_in">cos</span>(t); <span class="built_in">plot</span>(t, y1, <span class="string">'r'</span>, t, y2, <span class="string">'b--'</span>);</span><br><span class="line">x = [<span class="number">1.7</span> * <span class="built_in">pi</span>; <span class="number">1.6</span> * <span class="built_in">pi</span>];</span><br><span class="line">y = [<span class="number">-0.3</span>; <span class="number">0.8</span>];</span><br><span class="line">s = [<span class="string">'sin(t)'</span>; <span class="string">'cos(t)'</span>];</span><br><span class="line">text(x, y, s);</span><br><span class="line">title(<span class="string">'正弦和余弦曲线'</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'正弦'</span>, <span class="string">'余弦'</span>)</span><br><span class="line">xlabel(<span class="string">'时间t'</span>), ylabel(<span class="string">'正弦、余弦'</span>)</span><br><span class="line">grid</span><br><span class="line">axis square</span><br></pre></td></tr></table></figure><ul><li><p><code>title(s)</code>：图标题</p></li><li><p><code>xlabel(s)</code>：横坐标名</p></li><li><p><code>ylabel(s)</code></p></li><li><p><code>legend(s, position)</code>：在指定位置建立<strong>图例</strong>，按照绘图函数的<strong>参数顺序</strong>生成。</p><ul><li><code>s</code>：图例中的文字注释，可用<code>s1,s2,...</code>表示。</li><li><code>position</code>：指定图例位置<ul><li><code>0</code>：自动最佳位置（<strong>不</strong>覆盖原图）</li><li><code>1</code>：右上角<strong>（默认）</strong></li><li><code>2</code>：左上角</li><li><code>3</code>：左下角</li><li><code>4</code>：右下角</li><li><code>-1</code>：图<strong>右侧</strong></li></ul></li></ul></li><li><p><code>text(x, y, s)</code>：在<code>x</code>轴和<code>y</code>轴的指定位置添加<strong>文字注释</strong></p><blockquote><p><code>x</code>和<code>y</code>是值列表</p></blockquote></li></ul><h4 id="重叠绘图"><a href="#重叠绘图" class="headerlink" title="重叠绘图"></a>重叠绘图</h4><ul><li><code>hold on</code>：保持当前图形</li><li><code>hold off</code>：<strong>取消</strong>当前图形的保持功能</li><li><code>hold</code>：<strong>双向</strong>切换开关（对当前状态取反）</li></ul><h4 id="多子图绘制"><a href="#多子图绘制" class="headerlink" title="多子图绘制"></a>多子图绘制</h4><ul><li><p><code>subplot</code>：在一图形中同时显示<strong>多幅独立</strong>的子图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplot(m, n, k) <span class="comment">% m行n列个子图 k是子图编号</span></span><br><span class="line">subplot(<span class="string">'Position'</span>, [left bottom width height]) <span class="comment">% 在指定位置上分割子图 并成为当前图</span></span><br></pre></td></tr></table></figure><ul><li><p>所有子图<strong>彼此独立</strong>，绘图命令可以在子图中使用。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">y0 = <span class="built_in">sin</span>(t); y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t); y3 = <span class="built_in">cos</span>(<span class="number">2</span> * t);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">% 左上</span></span><br><span class="line"><span class="built_in">plot</span>(t, y0)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">% 右上</span></span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">% 左下</span></span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">% 右下</span></span><br><span class="line"><span class="built_in">plot</span>(t, y3)</span><br></pre></td></tr></table></figure><blockquote><p>注意和<code>legend</code>中的位置进行区分</p></blockquote></li><li><p>非等比例子图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">y0 = <span class="built_in">sin</span>(t); y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t); y3 = <span class="built_in">cos</span>(<span class="number">2</span> * t);</span><br><span class="line">positionVector1 = [<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">0.3</span>];</span><br><span class="line">subplot(<span class="string">'Position'</span>, positionVector1)</span><br><span class="line"><span class="built_in">plot</span>(t, y0)</span><br><span class="line">positionVector2 = [<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.3</span>];</span><br><span class="line">subplot(<span class="string">'Position'</span>, positionVector2)</span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line">subplot(<span class="string">'Position'</span>, [<span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>])</span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="多窗口绘图"><a href="#多窗口绘图" class="headerlink" title="多窗口绘图"></a>多窗口绘图</h4><ul><li><p><code>figure(n)</code>：创建绘图窗口，<code>n</code>是窗口顺序号。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(t);</span><br><span class="line">y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(t, y)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br></pre></td></tr></table></figure><blockquote><p><code>figure1</code><strong>不需要</strong>单独指定</p></blockquote></li></ul><h4 id="坐标轴控制"><a href="#坐标轴控制" class="headerlink" title="坐标轴控制"></a>坐标轴控制</h4><ul><li><p><code>axis</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">x = <span class="built_in">cos</span>(t);</span><br><span class="line">y = <span class="number">2</span> * <span class="built_in">sin</span>(t);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="built_in">plot</span>(x, y); title(<span class="string">'nomal'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="built_in">plot</span>(x, y); axis equal; title(<span class="string">'equal'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="built_in">plot</span>(x, y); axis square; title(<span class="string">'square'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="built_in">plot</span>(x, y); axis image; title(<span class="string">'image'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="built_in">plot</span>(x, y); axis tight; title(<span class="string">'tight'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>); <span class="built_in">plot</span>(x, y); axis off; title(<span class="string">'axis off'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="网格线与坐标框"><a href="#网格线与坐标框" class="headerlink" title="网格线与坐标框"></a>网格线与坐标框</h4><ul><li><code>grid</code><ul><li><code>grid on</code></li><li><code>grid off</code></li><li><code>grid</code></li></ul></li><li><code>box</code>：确定当前坐标框是否呈封闭形式（省略上框线和右框线）<ul><li><code>box on</code></li><li><code>box off</code></li><li><code>box</code></li></ul></li></ul><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul><li><p><code>bar</code>：垂直条形图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Y = <span class="built_in">round</span>(<span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">3</span>)*<span class="number">10</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">bar(Y,<span class="string">'grouped'</span>)</span><br><span class="line">title <span class="string">'Group'</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">bar(Y,<span class="string">'stacked'</span>)</span><br><span class="line">title <span class="string">'Stack'</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">bar(Y,<span class="number">2.0</span>)</span><br><span class="line">title <span class="string">'Width = 2.0’</span></span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>和<code>.*</code>的区别</p><ul><li><p>对于矩阵运算来说，<code>*</code>是标准的矩阵点乘。</p></li><li><p>对于矩阵和数字的运算来说，二者<strong>没有</strong>区别。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[a b c d]</span><br><span class="line"><span class="number">2.</span>*A=[<span class="number">2</span>*a  <span class="number">2</span>*b  <span class="number">2</span>*c  <span class="number">2</span>*d]</span><br><span class="line"><span class="number">2</span>*A=[<span class="number">2</span>*a  <span class="number">2</span>*b  <span class="number">2</span>*c  <span class="number">2</span>*d]</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p><code>barh</code>：水平条形图（横向是<code>Y</code>轴）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">barh(x, y, <span class="string">'grouped'</span>); <span class="comment">% groups by row</span></span><br><span class="line">title(<span class="string">'Grouped Style'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">barh(x, y, <span class="string">'stacked'</span>); <span class="comment">% stacks values in each row together</span></span><br><span class="line">title(<span class="string">'Stacked Style'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">barh(x, y, <span class="string">'hist'</span>); <span class="comment">% centers bars over x values</span></span><br><span class="line">title(<span class="string">'hist Style'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>errorbar</code>：误差图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="built_in">pi</span>;</span><br><span class="line">Y = <span class="built_in">sin</span>(X);</span><br><span class="line">E = std(Y) * <span class="built_in">ones</span>(<span class="built_in">size</span>(X));</span><br><span class="line">errorbar(X, Y, E)</span><br></pre></td></tr></table></figure></li><li><p><code>area</code>：面积图，即填充曲线的积分面积。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="number">2</span> * <span class="built_in">sin</span>(t);</span><br><span class="line">area(t, y)</span><br></pre></td></tr></table></figure></li><li><p><code>hist</code>：柱形图，用于显示数据分布情况。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = <span class="built_in">randn</span>(<span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line">hist(y, x)</span><br><span class="line"><span class="comment">% 设置柱形图的效果</span></span><br><span class="line">h = findobj(gca, <span class="string">'Type'</span>, <span class="string">'patch'</span>);</span><br><span class="line">set(h, <span class="string">'FaceColor'</span>, <span class="string">'r'</span>, <span class="string">'EdgeColor'</span>, <span class="string">'w'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>柱形图和条形图的区别</p><ul><li>条形图用来表达数据间的比较关系，例如不同产品的销售情况。（自变量是产品种类）</li><li>柱形图用来展示数据的分布或趋势变化，自变量通常是<strong>量化数据</strong>。</li><li>柱形图不同柱一般<strong>不能</strong>重新排序，而条形图不同条<strong>可以任意</strong>重新排序。</li><li>柱形图各个柱之间通常<strong>没有</strong>空隙</li><li>柱形图的<strong>纵轴</strong>通常是横轴元素的<strong>计数结果</strong></li></ul></blockquote></li><li><p><code>stem</code>：火柴杆图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">25</span>;</span><br><span class="line">y = [<span class="built_in">exp</span>(<span class="number">-.07</span> * x) .* <span class="built_in">cos</span>(x); <span class="built_in">exp</span>(<span class="number">.05</span> * x) .* <span class="built_in">cos</span>(x)]';</span><br><span class="line">h = stem(x, y);</span><br><span class="line">set(h(<span class="number">1</span>), <span class="string">'MarkerFaceColor'</span>, <span class="string">'blue'</span>)</span><br><span class="line">set(h(<span class="number">2</span>), <span class="string">'MarkerFaceColor'</span>, <span class="string">'red'</span>, <span class="string">'Marker'</span>, <span class="string">'square'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>stairs</code>：阶梯图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-2</span> * <span class="built_in">pi</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(x);</span><br><span class="line">stairs(x, y);</span><br></pre></td></tr></table></figure></li><li><p><code>pie</code>：扇形图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2.5</span> <span class="number">4.5</span> <span class="number">1.5</span> <span class="number">0.5</span>];</span><br><span class="line">explode = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">pie(x, explode);</span><br><span class="line">colormap jet</span><br></pre></td></tr></table></figure></li><li><p><code>compass</code>：罗盘图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">randn</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">%实部对应的数据</span></span><br><span class="line">v = <span class="built_in">randn</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">%虚部对应的数据</span></span><br><span class="line">z = <span class="built_in">exp</span>(<span class="built_in">i</span> * <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">6</span>)); <span class="comment">%复数数组</span></span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">compass(u, v)<span class="comment">%利用实部与虚部绘制罗盘图</span></span><br><span class="line">xlabel(<span class="string">'(a) 利用实部与虚部绘制罗盘图'</span>);</span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">compass(z); <span class="comment">%利用复数绘制罗盘图</span></span><br><span class="line">xlabel(<span class="string">'(b) 利用复数绘制罗盘图'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>feather</code>：羽毛图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">theta = (<span class="number">-90</span>:<span class="number">10</span>:<span class="number">90</span>) * <span class="built_in">pi</span> / <span class="number">180</span>;</span><br><span class="line">r = <span class="number">2</span> * <span class="built_in">ones</span>(<span class="built_in">size</span>(theta));</span><br><span class="line"><span class="comment">%将极坐标系转换为笛卡儿坐标系</span></span><br><span class="line">[u, v] = <span class="built_in">pol2cart</span>(theta, r);</span><br><span class="line">feather(u, v);</span><br></pre></td></tr></table></figure></li></ul><h2 id="三维图形"><a href="#三维图形" class="headerlink" title="三维图形"></a>三维图形</h2><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p><code>plot3</code>：调用格式和<code>plot</code>一致</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot3</span>(x, y, z, <span class="string">'r*-'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>ezplot3</code>：对符号函数进行绘制</li></ul></li><li><p><code>mesh</code>：网格图函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x, y, z] = peaks(<span class="number">30</span>);</span><br><span class="line">mesh(x, y, z)</span><br></pre></td></tr></table></figure><ul><li><code>ezmesh</code>：符号函数的网格图绘制</li></ul></li><li><p><code>surf</code>：对网格进行填充</p><ul><li><code>ezsurf</code></li></ul></li><li><p><code>meshgrid</code>：生成二元函数$z=f(x,y)$中$X-Y$平面上的句型定义域中的数据点矩阵$X$和$Y$.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[X, Y] = <span class="built_in">meshgrid</span>(<span class="number">-2</span>:<span class="number">.2</span>:<span class="number">2</span>, <span class="number">-2</span>:<span class="number">.2</span>:<span class="number">2</span>);</span><br><span class="line">Z = X .* <span class="built_in">exp</span>(-X.^<span class="number">2</span> - Y.^<span class="number">2</span>);</span><br><span class="line">surf(X, Y, Z)</span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊情况-1"><a href="#特殊情况-1" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul><li><code>bar3</code></li><li><code>bar3h</code></li><li><code>cylinder</code></li><li><code>sphere</code></li><li><code>stem3</code></li><li><code>contour3</code></li><li><code>waterfall</code></li><li><code>pie3</code></li><li><code>surfnorm</code></li></ul><h3 id="修饰-1"><a href="#修饰-1" class="headerlink" title="修饰"></a>修饰</h3><ul><li><p><code>view</code>：控制三维图形的观察点和视角</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view(AZ, EL)</span><br></pre></td></tr></table></figure><ul><li><p><code>AZ</code>：方位角，<strong>角度制</strong>。</p><blockquote><p>绕<code>Z</code>轴<strong>顺时针为正</strong>，逆时针为负。</p></blockquote></li><li><p><code>EL</code>：仰角</p></li></ul></li><li><p><code>colormap</code>：图形颜色</p></li><li><p><code>alpha</code>：透明度</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha(v) <span class="comment">% v介于0和1之间 表示透明度大小</span></span><br><span class="line">alpha(<span class="string">'x'</span>) <span class="comment">% 随x变大透明度值变大</span></span><br><span class="line">alpha(<span class="string">'rand'</span>) <span class="comment">% 随机设置透明度</span></span><br></pre></td></tr></table></figure><ul><li>透明度值<strong>越大</strong>，图像越<strong>不透明</strong>。</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2134&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter4-符号运算</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter4-%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter4-%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97/</id>
    <published>2020-12-04T03:28:44.150Z</published>
    <updated>2020-12-04T03:41:50.855Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1986</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>和数值运算对应，使用<strong>符号</strong>表示计算结果（不给未知数赋值）。</p><ul><li><p>求解方程：$ax^2+bx+c=0$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms a b c x;</span><br><span class="line">solve(a*x^<span class="number">2</span>+b*x+c); <span class="comment">% note there is no single quote</span></span><br><span class="line">solve(a*x^<span class="number">2</span>+b*x+c==<span class="number">0</span>); <span class="comment">% note '==' instead of '='</span></span><br></pre></td></tr></table></figure></li><li><p>辨析</p><p>以$2/5+1/3$为例，数值运算的结果为$0.7333$；而$sym(2)/sym(5)+sym(1)/sym(3)$的结果为$11/15$，且这里$11/15$仍然是属于<code>sym</code>类型, 是<strong>符号数</strong>。</p><blockquote><p>符号运算只会化简到<strong>没有误差</strong>的最简形式</p></blockquote></li></ul></li><li><p>支持可变精度运算，以指定精度返回数值结果。</p></li><li><p>相比数值运算，符号运算所需运行时间较长。</p></li></ul><h2 id="符号对象"><a href="#符号对象" class="headerlink" title="符号对象"></a>符号对象</h2><ul><li><p>符号对象是一种数据结构</p></li><li><p>分类</p><ul><li><p>符号常量</p></li><li><p>符号变量</p></li><li><p>符号表达式：含有符号对象的表达式</p><blockquote><p>在MATLAB中将其存储为<strong>字符串</strong></p></blockquote></li></ul></li><li><p>符号矩阵/数组：元素是符号表达式的矩阵/数组</p></li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p><code>sym</code>：创建<strong>单个</strong>符号对象</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = sym(A, flag);</span><br></pre></td></tr></table></figure><ul><li><p><code>A</code>：常量、变量、函数、表达式</p></li><li><p><code>flag</code>：缺省为有理数<code>r</code></p><ul><li><code>d</code>：最接近的十进制数值</li><li><code>f</code>：最接近的浮点数值</li><li><code>r</code>：最接近的有理表示</li></ul></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = sym(<span class="string">'q'</span>)      <span class="comment">% 符号变量，指定a在表达式字符串中的形式。</span></span><br><span class="line">a_1 = sym(<span class="string">'pi'</span>)  <span class="comment">% 符号变量，指定a_1在表达式字符串中的形式。</span></span><br><span class="line">b = sym(<span class="number">1</span>/<span class="number">3</span>)      <span class="comment">% 符号常量，指定b在表达式中的取值。</span></span><br><span class="line">b_1 = sym(<span class="built_in">pi</span>)  <span class="comment">% 符号常量，指定b_1在表达式中的取值。</span></span><br><span class="line">c = sym(<span class="number">2</span>*a+b)    <span class="comment">% 符号表达式</span></span><br><span class="line">d = sym(<span class="built_in">sin</span>(<span class="number">1</span>))   <span class="comment">% 符号函数</span></span><br></pre></td></tr></table></figure><ul><li><p>用<code>&#39;pi&#39;</code>创建的符号变量在<code>sin(pi)</code>时不会得到0；但是<code>sym(&#39;4&#39;)</code>和<code>sym(4)</code>没有区别，都可以运算。</p></li><li><p>符号表达式和符号函数<strong>不能够</strong>使用字符串参数，因此在构造符号表达式之前需要构造好所有的符号常量和符号变量。</p><ul><li><p>如果想要直接通过字符串创建符号表达式，则应该使用<code>str2sym</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = str2sym(<span class="string">'a*x^4+b*x^3+c*x^2+d*x+e'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>str2sym</code>对<strong>所有</strong>用字符串构造符号表达式的方式<strong>都适用</strong></p></blockquote></li></ul></li><li><p>使用符号对象创建符号对象（拷贝构造）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = sym(<span class="number">10</span>);</span><br><span class="line">b = sym(a);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>syms</code>：一次性创建多个符号对象</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syms a b c; <span class="comment">% 只能用空格分隔</span></span><br><span class="line"><span class="comment">% equals to</span></span><br><span class="line">a = sym(<span class="string">'a'</span>);</span><br><span class="line">b = sym(<span class="string">'b'</span>);</span><br><span class="line">c = sym(<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></li><li><p>符号表达式</p><ul><li><p>单引号（不推荐）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="string">'sin(x)+cos(x)'</span>;</span><br></pre></td></tr></table></figure><blockquote><ul><li>字符间<strong>不能</strong>添加空格</li><li>在2020版本中不能够创建表达式，只能够表示单纯的字符串。</li></ul></blockquote></li><li><p><code>sym</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = sym(<span class="string">'sin(x)+cos(x)'</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用已经定义的符号变量组（推荐）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syms x</span><br><span class="line">f = <span class="number">3</span>*<span class="built_in">sin</span>(x)+<span class="built_in">cos</span>(x)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>符号矩阵</p><ul><li><p><code>sym</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = sym(<span class="string">'[1+x,sin(x);5,exp(x)]'</span>);</span><br></pre></td></tr></table></figure></li><li><p>数值矩阵转换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = [<span class="number">2</span>/<span class="number">3</span>, <span class="built_in">sqrt</span>(<span class="number">2</span>); <span class="number">5.2</span>, <span class="built_in">log</span>(<span class="number">3</span>)];</span><br><span class="line">C = sym(B);</span><br></pre></td></tr></table></figure></li><li><p>符号矩阵的引用和修改和数值矩阵相同</p></li></ul></li></ul><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>和数值运算中的规则、符号都相同。</p><h3 id="符号表达式"><a href="#符号表达式" class="headerlink" title="符号表达式"></a>符号表达式</h3><ul><li><p><code>numden</code>：通分并提取符号表达式的分子和分母</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N, D] = numden(f);</span><br></pre></td></tr></table></figure><ul><li><code>N</code>：通分后的<strong>分子</strong></li><li><code>D</code>：通分后的<strong>分母</strong></li></ul></li><li><p><code>factor</code>：因式分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = x^<span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">factor</span>(f);</span><br></pre></td></tr></table></figure><ul><li><p>可以用于<strong>正整数</strong>的分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">factor</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">% s = 2 2 5 5</span></span><br></pre></td></tr></table></figure></li><li><p>可以用于<strong>大正整数符号变量</strong>的分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">factor</span>(sym(<span class="string">'1234567891011121314'</span>));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>expand</code>：符号表达式展开</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = (x+<span class="number">1</span>)^<span class="number">6</span>;</span><br><span class="line">expand(f);</span><br></pre></td></tr></table></figure></li><li><p><code>collect</code>：合并同类项</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collect(s); <span class="comment">% 对符号表达式默认变量合并</span></span><br><span class="line">collect(s, v); <span class="comment">% 对符号表达式s按变量v合并</span></span><br></pre></td></tr></table></figure></li><li><p>化简</p><ul><li><p><code>simplify(f)</code></p><ul><li><p>获取最短的化简结果</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simplify(f, <span class="string">'IgnoreAnalyticConstraints'</span>, <span class="built_in">true</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>simple</code>：多种规则返回最少数目字符的字符</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[How, y] = simple(f);</span><br></pre></td></tr></table></figure><ul><li><code>How</code>：记录使用的方法</li><li><code>y</code>：最简短形式</li></ul></li></ul></li><li><p><code>horner</code>：求多项式的嵌套形式（秦九韶算法）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = x^<span class="number">4</span> + <span class="number">2</span>*x^<span class="number">3</span> + <span class="number">4</span>*x^<span class="number">2</span> + x + <span class="number">1</span>;</span><br><span class="line">g = horner(f);</span><br><span class="line"><span class="comment">% g = x*(x*(x*(x+2)+4)+1)+1</span></span><br></pre></td></tr></table></figure></li><li><p><code>pretty</code>：格式美化，转换为手写格式。</p></li><li><p>多项式转换</p><ul><li><p><code>sym2poly</code>：将符号表达式转换为<strong>降幂排列</strong>的<strong>系数行向量</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = sym(<span class="string">'2*x+3*x^2+1'</span>);</span><br><span class="line">sym2poly(f);</span><br></pre></td></tr></table></figure></li><li><p><code>poly2sym</code>：将行向量按<strong>幂降序</strong>转换为符号表达式，变量默认为<code>x</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = poly2sym([<span class="number">1</span> <span class="number">3</span> <span class="number">2</span>])</span><br><span class="line"><span class="comment">% x^2 + 3*x + 2</span></span><br></pre></td></tr></table></figure></li><li><p>只能对<strong>单符号</strong>表达式进行转换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">c = sym(<span class="number">1</span>);</span><br><span class="line">f = str2sym(<span class="string">'x+c'</span>);</span><br><span class="line">sym2poly(f);</span><br></pre></td></tr></table></figure><ul><li>尽管<code>c</code>是符号常量，但是依然不能够转换。</li></ul></li></ul></li><li><p><code>findsym</code>：查找符号<strong>变量</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findsym(s, n); <span class="comment">% 返回符号表达式s中的n个符号变量</span></span><br></pre></td></tr></table></figure><ul><li><p>当<code>n</code>不指定时，<strong>无序</strong>返回所有符号变量。</p></li><li><p>默认符号变量的选取：先选择<code>x</code>，如果<code>x</code>不存在，则选择在字母顺序中<strong>最接近</strong><code>x</code>的字符变量；如果距离相等，则选择<code>x</code><strong>后面</strong>的字符变量。</p><blockquote><p>注意：<strong>大写</strong>字母比<strong>小写</strong>字母都靠后（和ASCII码<strong>相反</strong>）</p></blockquote></li><li><p>符号常量<strong>不会</strong>被返回</p></li></ul></li><li><p><code>subs</code>：符号变量的替换</p><ul><li><code>subs(f, a)</code>：用<code>a</code>替换表达式<code>f</code>中的（第一）自由变量</li><li><code>subs(f, x, a)</code>：用<code>a</code>替换<code>f</code>中的指定符号变量<code>x</code></li></ul><blockquote><p>在数字信号处理中，进行移位、反褶、尺度变换。</p></blockquote></li><li><p><code>compose</code>：复合函数运算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compose(f, g); <span class="comment">% f(g(X))</span></span><br><span class="line">compose(f, g, z); <span class="comment">% f(g(z))</span></span><br></pre></td></tr></table></figure></li><li><p><code>finverse</code>：反函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = finverse(f);</span><br><span class="line">g = finverse(f, v); <span class="comment">% 指定默认变量</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h3><h4 id="运算方式"><a href="#运算方式" class="headerlink" title="运算方式"></a>运算方式</h4><ul><li>数值型</li><li>有理数型</li><li><code>VPA</code>型：Maple的任意精度运算</li></ul><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="number">2</span>/<span class="number">3</span>; <span class="comment">% 0.6667</span></span><br><span class="line">a2 = sym(<span class="number">2</span>/<span class="number">3</span>); <span class="comment">% 2/3</span></span><br><span class="line">a3 = vpa(<span class="string">'2/3'</span>, <span class="number">32</span>); <span class="comment">% 0.66666666666666666666666666666667</span></span><br></pre></td></tr></table></figure><ul><li><code>digits</code>：显示当前计算精度</li><li><code>digits(n)</code>：设置数值型计算精度</li><li><code>xr = vpa(x)</code>：在<code>digits</code>精度下的数值型结果<code>xr</code></li><li><code>xr = vpa(x, n)</code>：在指定精度<code>n</code>下的数值型结果<code>xr</code></li></ul><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><ul><li><code>sym</code>：数值型转换为有理数型的符号对象</li><li><code>vpa(x, n)</code>：转换为VPA型符号对象</li><li><code>double</code>：转换为数值对象</li></ul><h2 id="符号微积分"><a href="#符号微积分" class="headerlink" title="符号微积分"></a>符号微积分</h2><ul><li><p><code>limit</code>：符号极限</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">limit(f); <span class="comment">% 函数在x=0的极限值</span></span><br><span class="line">limit(f, x, a); <span class="comment">% 函数在x趋于a的极限值</span></span><br><span class="line">limit(f, x, a, <span class="string">'left'</span>); <span class="comment">% 左极限</span></span><br><span class="line">limit(f, x, a, <span class="string">'right'</span>); <span class="comment">% 右极限</span></span><br></pre></td></tr></table></figure></li><li><p><code>diff</code>：符号导数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = diff(f);</span><br><span class="line">g = diff(f, v);</span><br><span class="line">g = diff(f, n); <span class="comment">% 对默认变量求n阶导</span></span><br><span class="line">g = diff(f, v, n); <span class="comment">% 对指定变量v求n阶导</span></span><br></pre></td></tr></table></figure></li><li><p><code>int</code>：符号积分</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int(f);</span><br><span class="line">int(f, v);</span><br><span class="line">int(f, a, b); <span class="comment">% 定积分</span></span><br><span class="line">int(f, v, a, b);</span><br></pre></td></tr></table></figure><ul><li><p>与数值积分辨析</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">digits(<span class="number">128</span>);</span><br><span class="line">fun = inline(<span class="string">'-x.^2+115'</span>, <span class="string">'x'</span>);</span><br><span class="line"><span class="comment">% numerical</span></span><br><span class="line">rn_1 = polyint([<span class="number">-1</span>, <span class="number">0</span>, <span class="number">115</span>]);</span><br><span class="line">fn_2 = quad(fun, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">fn_3 = quadl(fun, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">% symbolic</span></span><br><span class="line">rs = int(str2sym(<span class="string">'-x^2+115'</span>), <span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fourier</code>：傅里叶变换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fourier(ft, t, w);</span><br><span class="line">ifourier(Fw, w, t)</span><br></pre></td></tr></table></figure></li><li><p><code>symsum</code>：级数求和</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">symsum(f, v, a, b);</span><br><span class="line">symsum(f, a, b);</span><br></pre></td></tr></table></figure></li><li><p><code>laplace</code></p></li><li><p><code>taylor</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taylor(f); <span class="comment">% 默认为6阶麦克劳林多项式</span></span><br><span class="line">taylor(f, n, v); <span class="comment">% (n-1)阶麦克劳林多项式</span></span><br><span class="line">taylor(f, n, v, a); <span class="comment">% 在a附近的(n-1)阶展开式</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="符号方程"><a href="#符号方程" class="headerlink" title="符号方程"></a>符号方程</h2><ul><li><p><code>solve</code>：解析解</p><ul><li><code>solve(f)</code></li></ul></li><li><p><code>solve(&#39;eq1&#39;, &#39;eq2&#39;, ..., &#39;v1&#39;, &#39;v2&#39;, ...)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">eq1 = str2sym(<span class="string">'x^2+2*x+1=0'</span>);</span><br><span class="line">solve(eql);</span><br><span class="line">solve(x^<span class="number">2</span>+<span class="number">2</span>*x+<span class="number">1</span>==<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p>如果用<code>=</code>则必须传入符号表达式对象，如果是现场构造则是<code>==</code>.</p><blockquote><p>如果是<code>=0/==0</code>则可以直接省略</p></blockquote></li></ul></li><li><p><code>dsolve</code>：微分方程解析解</p></li></ul><h2 id="符号函数可视化"><a href="#符号函数可视化" class="headerlink" title="符号函数可视化"></a>符号函数可视化</h2><ul><li><p><code>ezplot()</code>：绘制符号表达式的函数曲线</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ezplot(<span class="string">'x^2*y+y+2'</span>);</span><br></pre></td></tr></table></figure><ul><li><code>ezplot(3)</code>：三维曲线</li></ul></li><li><p><code>ezcontour</code>：绘制带填充颜色的等高线</p></li><li><p><code>ezmesh</code>：绘制带等位线的<strong>三维网格图</strong></p></li><li><p><code>ezsurf</code>：绘制带等位线的<strong>曲面图</strong></p></li><li><p><code>ezploar</code>：绘制极坐标曲线</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1986&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter3-数值计算</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter3-%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter3-%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</id>
    <published>2020-12-04T03:28:44.143Z</published>
    <updated>2020-12-04T03:41:51.383Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1380</code>字，推荐阅读时间<code>12~15</code>分钟。</p><a id="more"></a><h2 id="数据统计处理"><a href="#数据统计处理" class="headerlink" title="数据统计处理"></a>数据统计处理</h2><h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><p>以<code>max()</code>为例，<code>min()</code>用法相同。</p><ul><li><p>向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">max</span>(A);</span><br><span class="line">[c, idx] = <span class="built_in">max</span>(A); <span class="comment">% idx is the index of max value</span></span><br></pre></td></tr></table></figure></li><li><p>矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A); <span class="comment">% return a row vector of max values in every column</span></span><br><span class="line">c = <span class="built_in">max</span>(A, [], dim); <span class="comment">% dim can be 1 or 2, default to 1(column max).</span></span><br><span class="line"> <span class="comment">% [] cannot be neglected for overloading of max(A, n).</span></span><br><span class="line">[c, idx] = <span class="built_in">max</span>(A);</span><br></pre></td></tr></table></figure><ul><li><p>求矩阵的最大元素（降维）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A(:));</span><br></pre></td></tr></table></figure></li><li><p>比较</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">max</span>(A, B); <span class="comment">% u is matrix with all max values</span></span><br><span class="line">u = <span class="built_in">max</span>(A, n); <span class="comment">% n is scalar, and u's elements are all &gt;= n.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">mean</span>(A);</span><br><span class="line">m = <span class="built_in">mean</span>(A, dim);</span><br></pre></td></tr></table></figure><h3 id="中值"><a href="#中值" class="headerlink" title="中值"></a>中值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = median(A);</span><br><span class="line">m - median(A, dim);</span><br></pre></td></tr></table></figure><h3 id="加和"><a href="#加和" class="headerlink" title="加和"></a>加和</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = sum(A); <span class="comment">% return a row vector of production of column</span></span><br><span class="line">b = aum(A, dim);</span><br></pre></td></tr></table></figure><ul><li><p>累加和</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = cumsum(A); <span class="comment">% return a row vector of cumulative sum of column</span></span><br><span class="line">b = cumsum(A, dim);</span><br></pre></td></tr></table></figure></li></ul><h3 id="乘积"><a href="#乘积" class="headerlink" title="乘积"></a>乘积</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = prod(A); <span class="comment">% return a row vector of production of column</span></span><br><span class="line">b = prod(A, dim);</span><br></pre></td></tr></table></figure><ul><li><p>累乘积</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = cumprod(A);</span><br><span class="line">b = cumprod(A, dim);</span><br></pre></td></tr></table></figure></li></ul><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = std(A);</span><br><span class="line">s = std(A, flag, dim); <span class="comment">% flag can be 0 or 1, and 0 is (N-1) normal std while 1 is (N).</span></span><br></pre></td></tr></table></figure><h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = corrcoef(A); <span class="comment">% take every column as a variable to caculate correlate coefficient</span></span><br><span class="line">r = corrcoef(x, y)；</span><br><span class="line">r = corrcoef([x, y]);</span><br></pre></td></tr></table></figure><ul><li>相关系数矩阵的大小和原矩阵是相同的，其他时候则根据向量数确定，例如<code>corrcoef([x, y])</code>的结果是<code>2*2</code>矩阵。</li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">sort</span>(A);</span><br><span class="line">[b, idx] = <span class="built_in">sort</span>(A, dim); <span class="comment">% idx contains the positions of B's elements in A.</span></span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><ul><li>虚部使用<code>i</code>或者<code>j</code>表示</li><li>构造<ul><li>直接表示</li><li><code>complex(a, b)</code></li></ul></li></ul><h3 id="特殊运算"><a href="#特殊运算" class="headerlink" title="特殊运算"></a>特殊运算</h3><ul><li>提取实部和虚部<ul><li><code>real</code></li><li><code>imag</code></li></ul></li><li>计算模<ul><li><code>abs</code></li></ul></li><li>计算辐角<ul><li><code>angle</code></li></ul></li><li>复数共轭<ul><li><code>conj</code></li></ul></li></ul><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>直角坐标绘图和其他相同，特殊的在于<strong>极坐标</strong>绘图。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polar(theta, rho);</span><br><span class="line">polar(theta, tho, LineSpec);</span><br></pre></td></tr></table></figure><ul><li><code>theta</code>：极角</li><li><code>rho</code>：极轴</li></ul><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>多项式表达为一个<strong>系数</strong>行向量，并且其元素是降幂排列的。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = [an, ..., a2, a1, a0];</span><br></pre></td></tr></table></figure><ul><li>指数为0的项的系数<strong>不能</strong>省略</li></ul></li><li><p><code>poly</code>：根据<strong>解向量</strong>产生<strong>特征多项式</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = poly(a);</span><br></pre></td></tr></table></figure><ul><li><p><code>roots</code>：逆函数，根据<strong>系数向量</strong>求<strong>解向量</strong>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = roots(p);</span><br></pre></td></tr></table></figure><blockquote><p>系数（<strong>行</strong>向量）：<code>1 * n</code></p><p>根（<strong>列</strong>向量）：<code>n * 1</code></p></blockquote></li></ul></li><li><p><code>poly2str</code>：把多项式系数转换为<strong>字符形式</strong>的函数，省略一些不影响阅读的运算符，例如<code>2*x</code>会被表示为<code>2x</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = poly2str(p, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>poly2sym</code>：把系数数组转换为<strong>符号多项式</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = poly2sym(p, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;a =[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]; p = poly(a)</span><br><span class="line">p = <span class="number">1</span> <span class="number">-6</span> <span class="number">11</span> <span class="number">-6</span></span><br><span class="line">&gt;&gt; p1 = poly2str(p, <span class="string">'x'</span>) p2 = poly2sym(p, <span class="string">'x'</span>)</span><br><span class="line">p1 = x^<span class="number">3</span> - <span class="number">6</span> x^<span class="number">2</span> + <span class="number">11</span> x – <span class="number">6</span></span><br><span class="line">P2 = x^<span class="number">3</span> - <span class="number">6</span>*x^<span class="number">2</span> + <span class="number">11</span>*x - <span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="算数运算与求导"><a href="#算数运算与求导" class="headerlink" title="算数运算与求导"></a>算数运算与求导</h3><h4 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h4><ul><li>阶次不同时，<strong>低阶多项式</strong>必须用0填补系数数组，使其与高阶多项式有相同的阶次。</li></ul><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = conv(a, b);</span><br></pre></td></tr></table></figure><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = deconv(c, a);</span><br><span class="line">[d, r] = deconv(c, a);</span><br></pre></td></tr></table></figure><ul><li><code>d</code>：整数部分</li><li><code>r</code>：余数</li></ul><h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><ul><li><p>数组变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = polyval(p, x);</span><br></pre></td></tr></table></figure></li><li><p>矩阵变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = polyvalm(p, x);</span><br></pre></td></tr></table></figure><ul><li>变量<code>x</code>是一个<strong>方阵</strong></li></ul></li></ul><h3 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k = polyder(p);</span><br><span class="line">k = polyder(a, b); <span class="comment">% differentiate a * b</span></span><br><span class="line">[p, q] = polyder(a, b); <span class="comment">% differentiate a / b, and result is q(x)/p(x)</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/15/bPF6VulXij3ZUrz.png" alt="image-20201015133030937" style="zoom:50%;" /></p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polyint(p, k); <span class="comment">% p is coef vector, and k is const item.</span></span><br><span class="line">polyint(p); <span class="comment">% k is default to 0.</span></span><br></pre></td></tr></table></figure><h4 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I,n]=quad(<span class="string">'fname'</span>,a,b,tol,trace);</span><br><span class="line">[I,n]=quadl(<span class="string">'fname'</span>,a,b,tol,trace);</span><br></pre></td></tr></table></figure><ul><li><p><code>fname</code>可以是内联函数名</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun = inline(<span class="string">'-x.^2+115'</span>, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure><ul><li>此时如果x不是矩阵，次方需要使用<code>.^</code>.</li></ul></li><li><p><code>tol</code>用来控制积分精度，缺省时取<code>tol=0.001</code>.</p></li><li><p><code>trace</code>控制是否展现积分过程，若取非0则展现积分过程，取0则不展现，缺省时取<code>trace=0</code>.</p></li></ul><h3 id="部分分式展开"><a href="#部分分式展开" class="headerlink" title="部分分式展开"></a>部分分式展开</h3><p><img src="https://i.loli.net/2020/10/15/8k6I7hp54mGlRDT.png" alt="image-20201015115600614" style="zoom:50%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[r, p, k] = residue(b, a);</span><br></pre></td></tr></table></figure><ul><li>求<code>b/a</code>的分式展开<ul><li><code>r</code>：留数行向量</li><li><code>p</code>：部分分式极点</li><li><code>k</code>：常数项</li></ul></li><li>当多项式分母有重根时，使用<code>resi2</code>函数。</li></ul><h2 id="曲线拟合与插值"><a href="#曲线拟合与插值" class="headerlink" title="曲线拟合与插值"></a>曲线拟合与插值</h2><h3 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h3><ul><li><p><code>polyfit</code>：最小二乘拟合</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = polyfit(x, y, n);</span><br></pre></td></tr></table></figure></li></ul><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ul><li>利用已知点确定未知点</li><li>常用于图像旋转、缩放</li></ul><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yi = interp1(x, y, xi, method)</span><br></pre></td></tr></table></figure><ul><li><code>method</code><ul><li><code>nearest</code>：最近邻内插</li><li><code>linear</code>：线性内插（默认）</li><li><code>spline</code>：三次样条内插</li><li><code>cubic</code>：三次多项式内插</li></ul></li></ul><h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi = interp2(x, y, z, xi, yi, method);</span><br></pre></td></tr></table></figure><ul><li><p><code>method</code></p><ul><li><code>nearest</code></li><li><code>bilinear</code>：二维线性内插法（默认）</li><li><code>spline</code>：二维样条内插法</li><li><code>bicubic</code>：二维三次多项式内插法</li></ul></li><li><p>二维<strong>散布点</strong>插值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi = griddata(x, y, z, xi, yi);</span><br></pre></td></tr></table></figure></li></ul><h4 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi = interp3(x, y, z, v, x1, yi, zi, method)</span><br></pre></td></tr></table></figure><ul><li><code>method</code><ul><li><code>nearest</code></li><li><code>linear</code>：默认</li><li><code>spline</code></li><li><code>cubic</code></li></ul></li></ul><h4 id="高维"><a href="#高维" class="headerlink" title="高维"></a>高维</h4><ul><li><code>interpn()</code></li></ul><h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><ul><li><p><code>fminbnd</code>：无约束<strong>单变量</strong>寻优函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fminbnd(fname, x0, x1); <span class="comment">% fname is function name, and [x0, x1] is range.</span></span><br></pre></td></tr></table></figure><ul><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fminbnd(<span class="string">'sin'</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fminsearch</code>：多元函数极小值点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval, exitflag, output] = fminsearch(fun, x0);</span><br></pre></td></tr></table></figure><ul><li><code>exitflag</code>为1表示计算成功</li><li><code>fun</code>可以是外部函数，也可以直接用字符串作参数。</li><li>函数中的变量必须是<code>x(i)</code></li></ul></li></ul><h2 id="代数方程组"><a href="#代数方程组" class="headerlink" title="代数方程组"></a>代数方程组</h2><ul><li>$ax-b=0(a是m*n矩阵)$的方程类型<ul><li>恰定：$m=n$</li><li>超定：$m&gt;n$</li><li>欠定：$m&lt;n$</li></ul></li></ul><h3 id="恰定"><a href="#恰定" class="headerlink" title="恰定"></a>恰定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = inv(a)*b;</span><br><span class="line">x = a/b;</span><br></pre></td></tr></table></figure><ul><li>$x=a^{-1}b$</li><li>除解法的速度<strong>更快</strong></li></ul><h3 id="超定"><a href="#超定" class="headerlink" title="超定"></a>超定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = a/b; <span class="comment">% 最小二乘法求近似解</span></span><br><span class="line">x = (a'*a)^<span class="number">-1</span>*a'*b;</span><br></pre></td></tr></table></figure><ul><li><code>a&#39;</code>：矩阵<code>a</code>的<strong>转置</strong></li></ul><h3 id="欠定"><a href="#欠定" class="headerlink" title="欠定"></a>欠定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = a/b; <span class="comment">% 求出0最多的解</span></span><br><span class="line">x = pinv(a) * b; <span class="comment">% 求出最小范数解</span></span><br></pre></td></tr></table></figure><h2 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h2><p>$\begin{cases} \frac{dy}{dx}=f(x,y) \\ y(x_0)=y_0 \end{cases}$</p><h3 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = dsolve(<span class="string">'eq1, eq2, ...'</span>, <span class="string">'cond1, cond2,...'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>单个方程</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsolve(<span class="string">'Dy=x'</span>, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不指定<code>x</code>时默认为<code>t</code></p></blockquote></li><li><p>方程组</p><p><img src="https://i.loli.net/2020/10/15/zQwahvJC9MHmbLs.png" alt="image-20201015134613691" style="zoom: 67%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[X,Y]=dsolve(<span class="string">'Dx+2*x-Dy=10*cos(t)'</span>, <span class="string">'Dx+Dy+2*y=4*exp(-2*t)'</span>, <span class="string">'x(0)=2, y(0)=0'</span>, <span class="string">'t'</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值解"><a href="#数值解" class="headerlink" title="数值解"></a>数值解</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[t, y] = solver(odefun, tspan, y0);</span><br></pre></td></tr></table></figure><ul><li>在区间<code>tspan</code>上用初始条件<code>y0</code>求解显式常微分方程</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1380&lt;/code&gt;字，推荐阅读时间&lt;code&gt;12~15&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter2-程序设计</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter2-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter2-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-12-04T03:28:44.137Z</published>
    <updated>2020-12-04T03:41:51.747Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>869</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><ul><li><p>输入：<code>input(message, options)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">'What is your name'</span>,<span class="string">'s'</span>);</span><br></pre></td></tr></table></figure><ul><li><code>s</code>：允许用户输入一个字符串</li></ul></li><li><p>输出</p><ul><li><p><code>disp(messages)</code>：message可以是<strong>单独一个</strong>变量，按照默认<code>format</code>输出。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>([<span class="string">'x1='</span>,num2str(x(<span class="number">1</span>)),<span class="string">'x2='</span>,num2str(x(<span class="number">2</span>))]);</span><br></pre></td></tr></table></figure><ul><li>拼接时<strong>不会</strong>添加空格</li></ul></li><li><p><code>fprintf</code>：和C格式相同</p></li><li><p><code>magbox</code>：弹窗展示</p></li></ul></li><li><p>暂停：<code>pause(time)</code></p><ul><li>省略<code>time</code>则等待用户键入后继续执行</li></ul><blockquote><p>强行中止：<code>Ctrl+C</code></p></blockquote></li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">elseif</span> expression</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>expression</code>可以带括号，也可以不带。</li><li>为了<code>if</code>和<code>end</code>对称：<code>Ctrl+I</code>自动对齐</li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> expression</span><br><span class="line"><span class="keyword">case</span> const1</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">otherwise</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>switch</code>后的类型可以为任意类型，包括字符串、矩阵、数组。</li><li><strong>不</strong>需要<code>break</code>语句，每个<code>case</code>执行后会自动跳出。</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li><p><code>for</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=expression1:expression2:expression3</span><br><span class="line"> <span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>没有<code>()</code>和<code>;</code></p></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>步长为<strong>1</strong>时，表达式2可以省略。</p></li><li><p><code>a:b</code><strong>包括</strong>右端点</p></li></ul></li><li><p><code>while</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression)</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p><code>break</code>：跳出循环</p></li><li><code>continue</code>：跳过循环体剩余语句</li><li><code>return</code>：退出脚本或函数</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">lasterr;</span><br></pre></td></tr></table></figure><ul><li><code>lasterr</code>存储上一次错误的信息</li></ul><h2 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h2><ul><li>扩展名为<code>.m</code></li><li>MATLAB在初次运行时会将<code>.m</code>文件装入内存，之后运行的速度会变快。</li></ul><h3 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h3><ul><li><p>也称为命令文件</p></li><li><p>不接受输入参数也不返回输出参数的M文件</p><blockquote><p>这里的参数指的是在命令行中调用时，脚本文件只需要输入文件名，但是函数文件需要使用<code>()</code>传参数。</p></blockquote></li><li><p>脚本文件新建的变量能够保存在MATLAB的内存空间中</p><ul><li><p>所有的变量都是<strong>全局变量</strong></p><blockquote><p>全局变量可以直接被使用，<strong>不需要</strong>预先声明<code>global</code>.</p></blockquote></li><li><p>每个脚本开始前使用<code>clear all;</code></p></li></ul></li></ul><h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><ul><li><p>对用户就是黑盒，只有输入和输出。</p></li><li><p>MATLAB函数和命令实际上都是函数文件</p></li><li><p>产生的变量默认为<strong>局部变量</strong>，存放在函数自身的工作空间中。</p><blockquote><p>在函数文件中使用全局变量需要预先声明<code>global</code></p></blockquote></li><li><p>结构</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">return_var</span>=<span class="title">funcname</span><span class="params">(input_var)</span> % <span class="title">function</span> <span class="title">definition</span></span></span><br><span class="line"><span class="comment">% help info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% annotation</span></span><br><span class="line"><span class="comment">% ...</span></span><br></pre></td></tr></table></figure><ul><li><code>help info</code>：help文档中显示，即第一个非空行前的所有注释。</li></ul></li><li><p>变量检测</p><ul><li><p><code>nargin</code>：输入实参<strong>数目</strong></p></li><li><p><code>nargout</code>：输出实参<strong>数目</strong></p><blockquote><p>在函数体外可以通过<code>nargin(&#39;func&#39;)</code>调用</p></blockquote></li><li><p><code>inputname(n)</code>：第<code>n</code>个输入参数的实际调用变量名（即函数调用出传进的参数的名字）</p><blockquote><p>如果参数本来是常量，则会返回空字符串。</p></blockquote></li><li><p><code>varargin</code>：变长输入参数<strong>列表</strong></p></li><li><p><code>varargout</code>：变长输出参数列表（直接输出则是数目）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varargout</span> = <span class="title">foo</span><span class="params">(varargin)</span></span></span><br><span class="line">fprintf(<span class="string">'How many output arguments? %d\nAnd they are:\n'</span>, nargout);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:nargout</span><br><span class="line">varargout(k) = varargin(k); <span class="comment">% the same as &#123;varargin&#123;k&#125;&#125;;</span></span><br><span class="line">fprintf(<span class="string">'%s '</span>, num2str(varargout&#123;k&#125;));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="调试和优化"><a href="#调试和优化" class="headerlink" title="调试和优化"></a>调试和优化</h2><ul><li><p><code>keyboard</code>：中断程序，用户可以在命令窗口查询内存信息。</p><ul><li>对于函数文件，将函数头注释掉即可使用<code>keyboard</code>.</li></ul></li><li><p>断点</p><ul><li><p>标准断点（小红点）</p></li><li><p>条件断点（小黄点）</p><ul><li><p>使用函数设置</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbstop in filename <span class="keyword">if</span> expression</span><br></pre></td></tr></table></figure></li></ul></li><li><p>错误断点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbstop <span class="keyword">if</span> error</span><br></pre></td></tr></table></figure><p>使程序在错误的地方停下，并且自动进入调试模式。</p></li></ul></li><li><p>优劣分析</p><ul><li><p><code>profile</code>：计算相对耗时和瓶颈</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">profile on;</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line">profile viewer;</span><br></pre></td></tr></table></figure></li><li><p><code>tic</code>/<code>toc</code>：计算绝对耗时</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tic;</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line">toc;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>优化</p><ul><li>向量化操作：使用向量替换循环</li><li>数据的预定义：一次性申请足够大的空间</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;869&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter1-数据类型</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-12-04T03:28:44.129Z</published>
    <updated>2020-12-04T03:41:52.150Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1782</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>每一种类型都以<strong>数组</strong>为基础</li><li>默认类型为<code>double</code>，可以利用转化函数改变类型。</li><li><strong>不用</strong>事先对变量的类型进行定义或说明</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>预定义的特殊变量</p><ul><li><code>ans</code>：<strong>未赋值运算</strong>结果自动赋值给<code>ans</code></li><li><code>eps</code>：容差变量，小于该值时可认为是0.</li><li><code>pi</code></li><li><code>i,j</code>：二者等价，虚数单位。</li><li><code>inf</code>：正无穷大，0作<strong>除数</strong>时出现。</li><li><code>NaN</code>：不合法数值，在$0*∞,0/0$等运算时产生。</li><li><code>version</code></li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li><code>clear name1 name2 name3;</code>：清除用户自定义的变量<ul><li><code>clear all;</code>：清除所有变量</li></ul></li><li>特殊常量的值可以在当前程序中被<strong>临时改变</strong></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>MATLAB中所有变量都以<strong>数组或矩阵</strong>形式保存</li></ul><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul><li>和C一致</li><li>对大小写敏感</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>变量查询<ul><li><code>who</code>：列出所有的变量名</li><li><code>whos</code>：给出所有变量及其大小、类别等性质。</li></ul></li><li><code>clear</code>：删除<strong>自定义</strong>变量，并重置<strong>除<code>eps</code>之外</strong>的常量。<ul><li><code>clear a*</code>：删除所有以<code>a</code>开头的变量</li></ul></li><li><code>pack</code>：重组和压缩已分配的内存碎块，在不影响变量的情况下腾出空间。<ul><li><code>pack filename</code>：自定义中间<code>mat</code>文件名（之后会被自动删掉）</li></ul></li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li><p>局部变量：函数内部定义的变量</p></li><li><p>全局变量：函数之间共享的变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> MAXLEN;MAXLEN=<span class="number">45</span>;</span><br></pre></td></tr></table></figure></li><li><p>永久变量：类似于<code>static</code>，在M文件中定义和使用，只在<code>clear</code>时被清除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">persistent</span> MAXLEN; MAXLEN=<span class="number">45</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><ul><li><p>整型：带符号&amp;无符号</p></li><li><p>浮点型：单精度(single)&amp;双精度(double)</p><blockquote><p>单精度<strong>不是</strong><code>float</code></p></blockquote></li><li><p>比较</p><ul><li><code>~=</code></li><li><code>==</code></li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x1 = int8(<span class="number">11</span>); <span class="comment">% 11</span></span><br><span class="line">x2 = int8(<span class="number">15.49</span>); <span class="comment">% 15</span></span><br><span class="line">x3 = int8(<span class="number">15.5</span>); <span class="comment">% 16</span></span><br><span class="line">x4 = int8(<span class="number">130</span>); <span class="comment">% 127</span></span><br><span class="line">x5 = uint8(<span class="number">-1</span>); <span class="comment">% 0</span></span><br></pre></td></tr></table></figure><ul><li><p>浮点型转换为整型是<strong>四舍五入</strong></p></li><li><p>超过类型边界<strong>则取边界值</strong></p></li><li><p><code>intmax</code>/<code>intmin</code>：查询整型边界</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intmax(<span class="string">'int8'</span>); <span class="comment">% 127</span></span><br></pre></td></tr></table></figure><blockquote><p>类型传入需要<strong>引号</strong></p></blockquote></li><li><p><code>realmax</code>/<code>realmin</code>：查询浮点型边界</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">realmax</span>(<span class="string">'single'</span>);</span><br></pre></td></tr></table></figure></li><li><p>数值默认为双精度浮点数，需要手动转换为<code>single</code>或其它类型.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">35</span>;</span><br><span class="line">y = single(X);</span><br><span class="line">class(x) <span class="comment">% double</span></span><br><span class="line">class(y) <span class="comment">% single</span></span><br></pre></td></tr></table></figure><ul><li><code>;</code>：变量后加<code>;</code>限制变量输出，不会打印到控制台，和C作用不同。</li></ul></li></ul><h4 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h4><ul><li><code>round(x)</code>：四舍五入（负数可能<strong>向下</strong>五入）</li><li><code>fix(x)</code>：向0取整</li><li><code>floor(x)</code>：向<strong>下</strong>取整</li><li><code>ceil(x)</code>：向<strong>上</strong>取整</li></ul><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul><li><p>创建</p><ul><li><p>直接输入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span><span class="number">-3</span><span class="built_in">i</span> <span class="comment">% ans = 2.0000-3.0000i</span></span><br></pre></td></tr></table></figure><blockquote><p><code>format</code>默认设置小数点后保留4位，当数字大于1000时，使用科学计数法。</p></blockquote></li><li><p><code>complex(a, b)</code>：a是实部，b是虚部，且b不指定时默认为0.</p></li></ul></li></ul><h3 id="逻辑型变量"><a href="#逻辑型变量" class="headerlink" title="逻辑型变量"></a>逻辑型变量</h3><ul><li><p><code>true</code>对应1，<code>false</code>对应0.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>] &gt; <span class="number">5</span> <span class="comment">% y = [1, 0, 1]</span></span><br></pre></td></tr></table></figure></li><li><p><code>logical</code>：数值转换为逻辑型</p></li><li><p><code>any</code>/<code>all</code>：矩阵传入一维真值矩阵</p></li><li><p><code>is*(isspace)</code>：测试运算</p></li><li><p>逻辑数组：利用逻辑运算构造矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">rand</span>(<span class="number">3</span>), A(A&lt;<span class="number">0.5</span>)=<span class="number">0</span> <span class="comment">% assign val &lt; 0.5 positions to zero</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h3><ul><li>数组的运算都是<strong>点运算</strong>（逐个元素运算）</li><li>矩阵的乘法、乘方、除法有特殊含义，其他和数组没有区别。</li><li><strong>MATLAB的下标从1开始</strong></li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><p>直接构造法</p><ul><li><code>[]</code></li><li><code>,</code>：间隔<strong>行内</strong>元素，或者使用空格。</li><li><code>;</code>：间隔<strong>行间</strong>元素，或者使用回车。</li><li>元素可以为值/表达式</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">3.8</span>, <span class="number">1e-3</span>, <span class="built_in">sqrt</span>(<span class="number">2</span>)]</span><br><span class="line">b = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>增量法</p><ul><li><p>利用冒号生成向量（包括<strong>右端点</strong>）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">i</span>:<span class="built_in">j</span> <span class="comment">% [i,j] as an array(including j)</span></span><br><span class="line">x = <span class="built_in">i</span>:<span class="built_in">j</span>:k <span class="comment">% j is stride</span></span><br></pre></td></tr></table></figure></li><li><p><code>linspace(a,b)</code>：生成等差向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>) <span class="comment">% from 2 to 8 with 10 numbers(default to 100 numbers)</span></span><br></pre></td></tr></table></figure></li><li><p><code>logspace(a,b)</code>：等比向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = logspace(2, 8) # default to produce 50 numbers</span><br><span class="line">y = <span class="built_in">logspace</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>利用小矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">C = [a, <span class="built_in">eye</span>(<span class="built_in">size</span>(A)); <span class="built_in">ones</span>(<span class="number">3</span>), A*<span class="number">2</span>]</span><br></pre></td></tr></table></figure><ul><li><code>size()</code>：返回行数和列数<ul><li><code>length()</code>：返回行数和列数中的最大值</li></ul></li><li><code>eye(size)</code>：返回单位矩阵</li><li><code>ones(size)</code>：返回全一矩阵</li></ul></li></ul><h4 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h4><ul><li><p>元素赋值</p><ul><li>超过边界时，内存会<strong>自动扩展</strong>。</li></ul></li><li><p>运算</p><ul><li><code>*</code>：数学意义上的<strong>矩阵乘法</strong></li><li><code>.*</code>：<strong>点运算</strong>的数组乘法，对应元素相乘。</li></ul><blockquote><p><code>^</code>等运算符同上</p></blockquote></li><li>拆分：利用冒号表达式获得子矩阵<ul><li><code>A(r,c)</code>：(r,c)位置的元素</li><li><code>A(r,:)</code>：A的第r行的所有元素</li><li><code>A(:,c)</code>：A的第c列的所有元素</li><li><code>A(:)</code>：<strong>列优先</strong>使A变为一维数组</li><li><code>A(i)</code>：访问<code>A(:)</code>中的第<code>i</code>个元素</li><li><code>A(r,c)=Sa</code>：元素赋值</li><li><code>A(:)=D(:)</code></li></ul></li><li><p>删除：利用<code>[]</code>赋值</p><ul><li><p>删除不是清零，而是<strong>改变</strong>矩阵结构。</p><blockquote><p><code>clear</code>后矩阵变量则消失，不能再通过变量名操作。</p></blockquote></li></ul></li><li><p>其他</p><ul><li><p><code>diag</code>：提取矩阵对角线元素生成对角矩阵</p></li><li><p><code>flipud</code>：上下翻转</p></li><li><p><code>fliplr</code>：左右翻转</p></li><li><p><code>reshape(name, length, width)</code>：第一个参数是原矩阵，改变形状。</p><ul><li>注意矩阵<strong>列优先</strong></li></ul></li><li><p><code>rot90</code>：<strong>逆时针</strong>旋转90度</p></li><li><p><code>det</code>：矩阵行列式的值</p></li><li><p><code>rank</code>：矩阵的秩</p></li><li><p><code>trace</code>：矩阵的迹</p></li><li><p><code>max</code>：包含<strong>每一列</strong>最大值的向量</p></li><li><p>数组逆序</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = A(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>); <span class="comment">% end is a special symbol for iteration</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>一维字符数组</li><li>用<strong>单引号</strong>括起</li><li>字符串的<code>class</code>是<code>char</code></li><li>索引访问时应该使用<code>()</code>而不是<code>[]</code></li></ul><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul><li><p>单引号赋值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">'BUAA'</span>;</span><br><span class="line">b = c(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = char(<span class="number">97</span>) <span class="comment">% a</span></span><br><span class="line">c2 = num2str(<span class="number">97</span>) <span class="comment">% 97</span></span><br></pre></td></tr></table></figure><ul><li><p><code>setstr</code>：将ASCII码转换成字符串</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setstr(<span class="built_in">abs</span>(<span class="string">'c'</span>) + <span class="built_in">abs</span>(<span class="string">'a'</span>) - <span class="built_in">abs</span>(<span class="string">'A'</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>abs</code>：将字符串转换为ASCII码</p></li></ul><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><ul><li><p>水平</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="string">'I '</span>, <span class="string">'Love '</span>, <span class="string">'Matlab!'</span>] <span class="comment">% str = I Love Matlab</span></span><br><span class="line">str2 = strcat(<span class="string">'I '</span>, <span class="string">'Love '</span>, <span class="string">'Matlab!'</span>) <span class="comment">% str = ILoveMatlab</span></span><br></pre></td></tr></table></figure><ul><li><code>strcat</code>会自动去掉<strong>结尾处</strong>的空格，头部的<strong>不会被</strong>去掉。</li></ul></li><li><p>垂直</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="string">'Matrix    '</span>;<span class="string">'Lab'</span>]</span><br><span class="line">str2 = strvcat(<span class="string">'Matrix    '</span>,<span class="string">'Lab'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>strvcat</code>自动去掉<strong>结尾</strong>的空格</li></ul></li></ul><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><ul><li><p><code>isstrprop(str, &#39;category&#39;)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isstrprop(pw, <span class="string">'alphanum'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li><code>strcmp</code>：相等返回1</li><li><code>==</code>：逐个字符比较，返回一维数组，相等的位为1.</li></ul><h4 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h4><div class="table-container"><table><thead><tr><th>编码方式</th><th>英文（单位：字节）</th><th>中文（单位：字节）</th></tr></thead><tbody><tr><td><code>ASCII</code></td><td>1</td><td>/</td></tr><tr><td><code>UTF-8</code></td><td>1</td><td>3</td></tr><tr><td><code>UTF-16</code></td><td>2</td><td>2/4</td></tr><tr><td><code>UTF-32</code></td><td>4</td><td>4</td></tr><tr><td><code>GBK</code></td><td>1</td><td>2</td></tr></tbody></table></div><blockquote><p>在<code>R202a</code>中测试，无论是英文还是中文均占用两个字节。</p></blockquote><h3 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h3><ul><li>提供间接调用函数方法的数据类型</li></ul><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><ul><li><p>在已有函数名前加符号<code>@</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1 = @funcname;</span><br></pre></td></tr></table></figure></li><li><p>提供匿名函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqr = @(x)x.^<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><ul><li>将函数句柄看作函数名，和函数调用相同。</li></ul><h3 id="元胞数组"><a href="#元胞数组" class="headerlink" title="元胞数组"></a>元胞数组</h3><ul><li>其中的元素类型、尺寸可以不相同</li><li>创建、访问时用<code>{}</code>表示索引</li></ul><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><ul><li><p><code>cell</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=cell(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li><p><code>deal</code>：<strong>列优先</strong>查看内容，返回一个长向量进行解析。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,b] = deal(a&#123;:&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>[]</code>：赋值，删除元素。</p></li><li><p><code>num2cell</code>/<code>mat2cell</code>：数组、矩阵和元胞的转换。</p></li><li><p><code>celldisp</code>：逐个显示元胞数组内容</p></li></ul><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; stu = struct(<span class="string">'username'</span>, &#123;&#125;, <span class="string">'password'</span>, &#123;&#125;, <span class="string">'name'</span>, &#123;&#125;, <span class="string">'gender'</span>, &#123;&#125;); <span class="comment">% an empty struct array</span></span><br><span class="line">&gt;&gt; stu(<span class="number">1</span>).name=<span class="string">'Silence'</span>;</span><br><span class="line">&gt;&gt; stu(<span class="number">1</span>).course=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  struct with fields:</span><br><span class="line"></span><br><span class="line">      name: <span class="string">'Silence'</span></span><br><span class="line">    course: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>struct</code>函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; student(<span class="number">3</span>)=struct(<span class="string">'name'</span>,<span class="string">'Lex'</span>,<span class="string">'course'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">student = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">3</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br></pre></td></tr></table></figure></li></ul><h4 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; stu(<span class="number">2</span>).name=<span class="string">'Anita'</span></span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br></pre></td></tr></table></figure><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu(<span class="number">2</span>).name</span><br></pre></td></tr></table></figure><h4 id="删除域"><a href="#删除域" class="headerlink" title="删除域"></a>删除域</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; rmfield(stu,&#123;<span class="string">'course'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line"></span><br><span class="line">&gt;&gt; stu</span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>不改变</strong>本来的结构数组</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1782&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB-Chapter0-概论</title>
    <link href="http://yoursite.com/2020/12/04/MATLAB-Chapter0-%E6%A6%82%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/12/04/MATLAB-Chapter0-%E6%A6%82%E8%AE%BA/</id>
    <published>2020-12-04T03:28:44.116Z</published>
    <updated>2020-12-04T03:41:58.166Z</updated>
    
    <content type="html"><![CDATA[<p>全文<code>135</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>MATLAB<strong>最初</strong>强调矩阵的运算</li></ul><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><ul><li><p><code>.m</code>：M文件</p><ul><li>命令文件：主程序/主函数</li><li>函数文件：子程序/被调函数</li></ul><blockquote><p>工具箱中所有的文件基本上是<strong>函数文件</strong></p></blockquote></li><li><p><code>.mat</code>：数据文件，保存了workspace中的变量数据</p></li><li><p><code>.fig</code>：图形文件，依然<strong>可以</strong>被修改。</p></li><li><p><code>.mex</code>/<code>.dll</code>：MATLAB的可执行文件</p></li><li><p><code>.mdl</code>：模型和仿真文件</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文&lt;code&gt;135&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>CPP-C++学习笔记</title>
    <link href="http://yoursite.com/2020/09/06/CPP-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/09/06/CPP-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-06T15:01:22.688Z</published>
    <updated>2020-09-07T01:34:07.017Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2981</code>字，为暑期C++学习记录，推荐按照顺序阅读。</p><a id="more"></a><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li><p>每个<code>.h</code>文件智能定义一个<code>class</code></p></li><li><p>函数主体放在<code>.cpp</code>中</p></li><li><p><code>.h</code>文件需要使用标准头文件格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NAME_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NAME_H_</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul><li>变量是对象自己的</li><li>函数是类的<ul><li>隐藏了<code>this</code>参数将对象传进类的函数</li></ul></li><li>私有变量通过<code>::</code>也<strong>不能</strong>访问</li></ul><h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><p>创建对象时使用</p></li><li><p>和类同名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    A(); <span class="comment">// no return type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A()</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>没有参数</strong>的构造函数<strong>都叫</strong><code>default constructor</code>，不一定是编译器默认创造的。</p></blockquote></li><li><p>参数化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree::Tree(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">t</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass c1;<span class="comment">//表示使用不带参数的构造函数，或者有默认参数值的构造函数。</span></span><br><span class="line"><span class="function">MyClass <span class="title">c2</span><span class="params">()</span></span>;<span class="comment">//不会调用无参构造函数,各种情况下该处是声明一个返回值为MyClass类型的函数而已</span></span><br><span class="line"><span class="function">MyClass <span class="title">c3</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//调用参数为int的构造函数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li><p>销毁对象时使用</p><blockquote><p>对象的生存周期是<strong>大括号</strong></p></blockquote></li><li><p>无参数，在构造函数前加一个<code>~</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> height; <span class="comment">// default to be private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> initialHeight);</span><br><span class="line">    ~Tree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> years)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new&amp;delete"></a>new&amp;delete</h2><ul><li><p>delete不能操作没有new的空间</p></li><li><p>delete对同一个对象不能连续使用两次</p></li><li><p>delete[]和new[]需要<strong>成对</strong>使用</p></li><li><p>在delete之前最好判断一下是否是空指针（是空指针<strong>大多数情况</strong>也安全）</p></li><li><p>new创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------对于new关键字加括号和不加括号的区别---</span></span><br><span class="line"><span class="comment">1.对于自定义类型来说没有区别，都是使用默认构造函数</span></span><br><span class="line"><span class="comment">2.对于内置类型来说加括号会初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">MyClass *c4 = <span class="keyword">new</span> MyClass();</span><br><span class="line">c4-&gt;MyMethod();</span><br><span class="line">MyClass *c5 = <span class="keyword">new</span> MyClass(<span class="number">1</span>);</span><br><span class="line">c5-&gt;MyMethod();</span><br><span class="line">MyClass *c6 = <span class="keyword">new</span> MyClass;</span><br><span class="line">c6-&gt;MyMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *pint1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> *pint2 = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// *pint2 is 0</span></span><br><span class="line"><span class="keyword">int</span> *pint3 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// *pint3 is a random number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*pint1&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint2&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint3&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><code>new</code>创建对象需要<strong>指针</strong>接收</li><li><code>new</code>创建对象需要<code>delete</code>销毁</li><li><code>new</code>创建的对象在<strong>堆</strong>上，不使用<code>new</code>创建的对象在<strong>栈</strong>上。</li></ul></li></ul><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul><li><p><code>private</code>的变量在类的函数中可以被<strong>其他的对象</strong>访问，即同类对象可以相互访问私有变量。</p><blockquote><p><code>private</code>只在编译时有限制</p></blockquote></li><li><p>使用<code>friend</code>授权某些函数访问<strong>私有变量</strong></p></li><li><p>class的访问属性默认为<code>private</code>，struct默认为<code>public</code>.</p></li></ul><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> x, y;</span><br><span class="line">    Point(<span class="keyword">float</span> xa = <span class="number">0.0</span>, <span class="keyword">float</span> ya = <span class="number">0.0</span>): x(xa), y(ya)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>初始化列表在构造函数<strong>之前</strong>执行</p></li><li><p>和构造器赋值的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(String s): name(s)&#123;&#125;</span><br><span class="line">Student::Student(String s) &#123;name = s;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>推荐使用初始化列表进行对象的初始化。</p><p>在构造器赋值时，如果有一个成员变量是自定义类的对象，并且该类没有无参数构造函数，那么在构造函数中对该对象赋值时就会报错。（因为在<strong>构造函数</strong>中，会默认调用无参数构造函数）</p></blockquote></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>名称隐藏：当子类覆写父类函数时，所有的父类函数都会被子类屏蔽。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> ii) : i(ii) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : A(<span class="number">15</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.print(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>b</code><strong>没有</strong>无参数的<code>print</code>方法</p></blockquote></li></ul><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><ul><li><p>只能在<code>.h</code>（函数声明）时设置默认值，<strong>不可以</strong>在函数定义处使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j=<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>和Python不同的是，修改<code>j</code>时直接传数据即可，<strong>不需要</strong>写参数名称。</p></li><li><p>尽量<strong>不使用</strong>默认参数值</p></li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li><p>在调用的地方直接展开，减少调用函数时的栈操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b = f(a); <span class="comment">// int b = a * 2;</span></span><br><span class="line">    <span class="keyword">int</span> c = f(<span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内联函数的定义<strong>不在</strong><code>.cpp</code>文件中，而应该和声明<strong>都放在</strong><code>.h</code>中</p><blockquote><p>因为<code>inline</code>告诉编译器这是个<strong>函数声明</strong>而不是定义，在<strong>使用函数</strong>的地方再进行展开。</p></blockquote></li><li><p>当<code>inline</code>函数太大时（例如递归），编译器可能会拒绝展开。</p></li><li><p>类的<code>.h</code>文件中直接写出函数体的函数<strong>都是</strong>内联函数，在<code>.h</code>中也可以单独声明内联函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is a inline function defined in header file."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环体中的<strong>小函数</strong>推荐使用内联函数</p></li><li><p>和宏相比，内联函数可以做类型检查，更加安全。</p></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li><p><strong>不可修改</strong>机制是在编译时确定的，因此是编译器进行检查。</p><ul><li><p>编译时确定的值可以用来声明数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_size = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> finalGrade[class_size];</span><br></pre></td></tr></table></figure></li><li><p><code>const</code>在<code>*</code>前后对指针的影响</p><ul><li><p>在<code>*</code>前：<strong>对象</strong>是<code>const</code>（<strong>不能</strong>通过该指针改变对象，但是<strong>可以</strong>通过其他指针）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;a;</span><br><span class="line">*p2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person *p = &amp;p1;</span><br><span class="line">Person <span class="keyword">const</span> *p = &amp;p1;</span><br></pre></td></tr></table></figure></li><li><p>在<code>*</code>后：<strong>指针</strong>是<code>const</code>（<strong>不能</strong>改变该指针的指向）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *<span class="keyword">const</span> p = &amp;p1;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>普通指针<strong>不能</strong>指向<code>const</code>变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">3</span>;</span><br><span class="line">ip = &amp;ci; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>不可</strong>修改对象的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::get_day</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    day++; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在声明和定义处要重复<code>const</code></p></li><li><p>便于编译器对<code>const</code>对象调用方法时进行安全检查</p></li><li><p>本质是将<code>this</code>设置为<code>const</code></p></li><li><p><code>const</code>可以实现重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : i(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    ~A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f() with const"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> A a;</span><br><span class="line">    a.f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>const</code>对象<strong>只能</strong>调用<code>const</code>函数</li></ul></li></ul></li><li><p><code>const</code>成员变量必须在<strong>初始化列表</strong>中初始化（<strong>不可以</strong>在构造函数中进行）</p></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p>一种访问对象的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;p = c;</span><br></pre></td></tr></table></figure><ul><li>引用<strong>必须</strong>初始化（成员变量、函数参数除外）</li><li>引用相当于是<strong>别名</strong></li><li>引用的目的就是为了减少代码中的<code>*</code></li></ul></li><li><p>引用和指针的比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">(<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>不同于</strong>指针，引用在执行过程中<strong>不能</strong>改变对象。</p></li><li><p>引用<strong>不能</strong>是<code>NULL</code></p></li><li><p>传入的<code>x</code>在两种情况中<strong>都会</strong>被修改</p></li><li><p>传入函数的参数<strong>不是指针</strong>时，也<strong>可能</strong>被修改。</p></li><li><p>引用是由<code>const</code>指针实现的</p></li><li><p>引用的引用实际上<strong>不存在</strong>，只是改变了引用的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> &amp;a = x;</span><br><span class="line"><span class="keyword">int</span> &amp;b = y; </span><br><span class="line"></span><br><span class="line">b = a; <span class="comment">// y = x, but not b refer to a.</span></span><br></pre></td></tr></table></figure><blockquote><p>Java的引用实际上对应C++的指针</p></blockquote></li><li><p>引用的指针可以存在，但是指针的引用不存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;*p1; <span class="comment">// illegal</span></span><br><span class="line"><span class="keyword">int</span> *&amp;p2; <span class="comment">// reference to pointer</span></span><br></pre></td></tr></table></figure><blockquote><p>引用<strong>没有</strong>地址</p></blockquote></li><li><p><strong>没有</strong>引用数组（因为引用并不是实体，<strong>没有</strong>地址）</p></li></ul></li><li><p>引用作为成员变量时，需要在初始化列表中写上这个引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> &amp;b): a(b) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为返回值时，最好<strong>不是</strong>局部变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> &amp;<span class="title">subscript</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为函数参数传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">int</span>&amp;z)</span></span>&#123;</span><br><span class="line">    z *= <span class="number">5</span>; <span class="comment">// OK</span></span><br><span class="line">    y += <span class="number">8</span>; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>传<strong>非</strong><code>const</code>引用时<strong>不可以</strong>是算式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li><p>动态调用的方法需要使用<code>virtual</code>关键字声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在父类中声明一次<code>virtual</code>后，所有子类中的函数都是虚函数，可以省略<code>virtual</code>，但是推荐加上。</li><li>所有含虚函数的类的对象都会增加一个<code>vptr</code>指针，指向类自己的<code>vtable</code>，存储了<strong>该类</strong>所有的虚函数。</li></ul></li><li><p>继承关系对象的赋值<strong>不改变</strong><code>vtable</code>（与指针赋值不同）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a = b;</span><br><span class="line">a.f(); <span class="comment">// A's f() instead of B's</span></span><br></pre></td></tr></table></figure></li><li><p>析构函数需要是<code>virtual</code>的</p></li><li>多态需要使用指针实现，<strong>不能</strong>通过<code>.</code>实现。</li></ul><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><ul><li><p>编译器默认的拷贝构造是浅拷贝</p><ul><li><p>当字符串是<code>char *</code>时，内存会被<code>delete</code>两次，这样会发生错误。因此Cpp通常使用<code>string</code>类来定义字符串。</p><blockquote><p>尽管是浅拷贝，标准库中的类<strong>也不会</strong>出现内存问题。</p></blockquote></li></ul></li><li><p>拷贝构造和<strong>初始化</strong>的形式相同，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = p;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>一个类必须声明的三个函数</p><ul><li><p>默认构造函数（参数列表为空）</p></li><li><p><code>virtual</code>的析构函数</p></li><li><p>自定义的拷贝构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(<span class="keyword">const</span> ClassName &amp;p) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>Cpp保证对象只被构造一次</li><li><code>static</code>让对象变成全局的</li></ul><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><ul><li><p>通过<code>static</code>成为和对象<strong>无关</strong>的变量</p></li><li><p>类中只是<strong>声明</strong>，需要单独定义后才能使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;i = <span class="number">0</span>;&#125; <span class="comment">// A():i(0) &#123;&#125; is illegal</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::i; <span class="comment">// not static int A::i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a, b;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">    b.print();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化列表只能对<strong>非静态</strong>成员变量使用</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>调用<ul><li>对象：<code>a.f()</code></li><li>类：<code>A::f()</code></li></ul></li><li>在静态函数中<strong>没有</strong><code>this</code>参数</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>在Cpp中，几乎所有的运算符都可以被重载，除了<code>./.*/::/?:</code>.</li><li>重载只能在类/枚举类发生</li><li>优先级、运算格式<strong>不能</strong>改变。</li><li><p>关键字<code>operator</code>+运算符表示重载函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> *(...);</span><br><span class="line"><span class="keyword">const</span> String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String &amp;that);</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp;n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(i + n.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z = x + y; <span class="comment">// OK</span></span><br><span class="line">z = x + <span class="number">3</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + <span class="number">7</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + y; <span class="comment">// Error!</span></span><br><span class="line">z = x + <span class="number">3.5</span> <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li><p>设置全局函数解决<code>z=3+y</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(l.i + r.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一元运算符<strong>不需要</strong>设置参数，应该是成员的。</li><li><code>=/()/[]/-&gt;/-&gt;*</code><strong>必须是</strong>成员的</li><li>其他二元运算符<strong>最好是</strong>全局的</li></ul></li></ul></li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><p><code>+-*/%^&amp;|~</code>:<code>const T operatorX(const T &amp;l, const T&amp;r) const;</code></p></li><li><p><code>!/&amp;&amp;/||/&lt;/&lt;=/==/&gt;=/&gt;</code>:<code>bool operatorX(const T &amp;l, const T &amp;r) const;</code></p></li><li><p><code>[]</code>:<code>T &amp;T::operator[](int index);</code></p></li><li><p><code>++/--</code>：参数填一个占位<code>int</code>表示<strong>后置</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Integer &amp;<span class="keyword">operator</span>++() <span class="comment">// ++a</span></span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>++(<span class="keyword">int</span>) <span class="comment">// a++</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName a = b; <span class="comment">// copy construct</span></span><br><span class="line">a = b; <span class="comment">// assign</span></span><br></pre></td></tr></table></figure><ul><li><p>标准写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T &amp;T::<span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;r) &#123;</span><br><span class="line">        <span class="comment">// assign</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自己和自己相等进行赋值时，若成员中有指针，可能出现指针被改变后导致原来的内容无法访问，从而赋值失败的问题。</li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>禁止<strong>隐式</strong>类型转换：<code>explicit</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Two</span><span class="params">(class One &amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">one = two <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li>定义在<code>Two</code>中</li></ul></li><li><p>强制类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassName::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>定义在<code>One</code>中（不是<code>double</code>）</li><li><strong>没有</strong>返回类型</li></ul><blockquote><ul><li>两者地位相同，有哪种用哪种。</li><li>两种类型转换<strong>只能</strong>存在一种，除非第一种加了<code>explicit</code>.</li></ul></blockquote></li><li><p>不推荐使用默认转换，应该写成显式的转换方法<code>toXXX()</code>.</p></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>重用代码的一种方式，类似于Java中的泛型编程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // &lt;class Key, class Value&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">foo</span>(<span class="title">void</span>) &#123;</span><span class="comment">/* ... */</span>&#125;</span><br><span class="line">foo&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// type for T is int</span></span><br><span class="line">foo&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure></li><li><p>指定其他参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">bounds</span> = 100&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>继承</p><ul><li><p>模板之间不能继承，只能用来指定父类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> List&lt;A&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125; <span class="keyword">catch</span> (VectorIndexError &amp;e) &#123;</span><br><span class="line">    <span class="comment">// throw;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>不带对象的<code>throw</code>就是抛出<strong>原异常</strong></p></li><li><p><code>catch(...)</code>捕捉<strong>所有的</strong>异常，但是没有办法确定具体是哪一种。</p></li><li><p>函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a)</span> : <span class="title">throw</span><span class="params">(MathErr)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数抛异常之前，使用<code>delete this;</code>防止出现内存垃圾。</p></li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li><p>自定义类的输入流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>&gt;&gt;(istream &amp;is, T &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// construct obj</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul><li>包含常见的数据结构和算法<ul><li><code>Vector</code></li><li><code>List</code></li><li><code>Deque</code></li><li><code>Sets &amp; Maps</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2981&lt;/code&gt;字，为暑期C++学习记录，推荐按照顺序阅读。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CPP" scheme="http://yoursite.com/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-TensorFlow笔记</title>
    <link href="http://yoursite.com/2020/09/06/AI-TensorFlow%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/09/06/AI-TensorFlow%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-06T08:03:31.896Z</published>
    <updated>2020-09-06T08:04:47.977Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>3487</code>字，是暑期学习TensorFlow的记录，推荐按照顺序进行阅读。</p><a id="more"></a><h2 id="张量、计算图、会话"><a href="#张量、计算图、会话" class="headerlink" title="张量、计算图、会话"></a>张量、计算图、会话</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>用<strong>张量</strong>表示数据，用<strong>计算图</strong>搭建神经网络，用<strong>会话</strong>执行计算图，优化线上的权重（参数），得到模型。</li></ul><h3 id="张量-tensor"><a href="#张量-tensor" class="headerlink" title="张量(tensor)"></a>张量(tensor)</h3><ul><li><p>多维数组（列表）</p></li><li><p>根据中括号数判断维数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scalar = <span class="number">1</span></span><br><span class="line">vector = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">tensor = [[[...]...]...]</span><br></pre></td></tr></table></figure></li><li><p>常量的声明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">a = tf.constant([[<span class="number">1.0</span>, <span class="number">2.0</span>]]) <span class="comment"># a matrix instead of a vector</span></span><br><span class="line">b = tf.constant([[<span class="number">3.0</span>], [<span class="number">4.0</span>]])</span><br><span class="line"></span><br><span class="line">result = tf.matmul(a, b)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></li></ul><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><ul><li>只搭建，不计算。</li></ul><h3 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话(Session)"></a>会话(Session)</h3><ul><li><p>执行运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(y)</span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li><p>在TensorFlow1中，需要先建立计算图才能够计算。但是TensowFlow2中默认将两步合并，即<code>matmul</code>操作时就直接计算结果。</p></li><li><p>在2中调用1的方法/类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.compat.v1.Session() <span class="comment"># tf.compat.v1.xxx</span></span><br></pre></td></tr></table></figure></li><li><p>运行时屏蔽TensorFlow的警告信息：在文件<strong>最前面</strong>（先于<code>import tensorflow</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>]=<span class="string">'2'</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p>神经网络线上的权重W</p></li><li><p>生成</p><ul><li><code>random_normal</code>：正态分布</li><li><code>truncated_normal</code>：去掉$2σ$以外的数据的正态分布</li><li><code>random_uniform</code>：平均分布</li><li><code>zeros</code></li><li><code>ones</code></li><li><code>fill</code>：全定值</li><li><code>constant</code>：直接给值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w = tf.Variable(tf.compat.v1.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">2</span>, mean=<span class="number">0</span>, seed=<span class="number">1</span>))</span><br><span class="line">tf.zeros([<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">tf.fill([<span class="number">3</span>, <span class="number">2</span>], <span class="number">6</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="神经网络搭建"><a href="#神经网络搭建" class="headerlink" title="神经网络搭建"></a>神经网络搭建</h3><ul><li>准备数据集</li><li>搭建NN结构，从输入到输出。<ul><li>搭建计算图</li><li>绘画执行</li></ul></li><li>迭代优化NN参数</li><li>使用训练好的模型进行预测和分类</li></ul><h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p>模型搭建，实现推理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''两层简单全连接神经网络'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入和参数</span></span><br><span class="line">x = tf.constant([[<span class="number">0.7</span>, <span class="number">0.5</span>]])</span><br><span class="line">w1 = tf.Variable(tf.compat.v1.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line">w2 = tf.Variable(tf.compat.v1.random_normal([<span class="number">3</span>, <span class="number">1</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义前向传播过程</span></span><br><span class="line">a = tf.matmul(x, w1)</span><br><span class="line">y = tf.matmul(a, w2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用会话计算结果</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op= tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    print(sess.run(y))</span><br></pre></td></tr></table></figure><ul><li><p><code>global_variables_initializer</code>返回<strong>初始化</strong>所有的<strong>全局变量</strong>(<code>Variable</code>)的操作，使用会话进行执行。</p><ul><li><p>全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.Variable(<span class="number">1</span>, name=<span class="string">'var_z'</span>)</span><br></pre></td></tr></table></figure></li><li><p>局部变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e = tf.Variable(<span class="number">6</span>, name=<span class="string">'var_e'</span>, collections=[tf.GraphKeys.LOCAL_VARIABLES])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用<code>placeholder</code>实现<strong>输入</strong>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = tf.compat.v1.placeholder(tf.float32, shape=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">print(sess.run(y, feed_dict=&#123;x: [[<span class="number">0.7</span>, <span class="number">0.5</span>]]&#125;))</span><br></pre></td></tr></table></figure><ul><li><p>输入多组数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">2</span>))</span><br><span class="line">sess.run(y, feed_dict=&#123;x: [[<span class="number">0.7</span>, <span class="number">0.5</span>], [<span class="number">0.2</span>, <span class="number">0.3</span>], [<span class="number">0.3</span>, <span class="number">0.4</span>]]&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong>多组</strong>计算值（不只一个<code>y</code>）</p></blockquote></li></ul></li></ul><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>训练模型参数，在所有参数上使用梯度下降，使NN模型在训练数据上的<strong>损失函数</strong>最小。</p><ul><li><p>损失函数：预测值(<code>y</code>)和已知答案(<code>y_</code>)之间的差距</p></li><li><p>均方差(MSE)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = tf.reduce_mean(tf.square(y_ - y))</span><br></pre></td></tr></table></figure></li><li><p>训练方法：减小loss值为优化目标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tf.compat.v1.train.GradientDescentOptimizer(learning_rate).minimize(loss)</span><br><span class="line">tf.compat.v1.train.MomentumOptimizer(learning_rate, momentum).minimize(loss)</span><br><span class="line">tf.compat.v1.train.AdamOptimizer(learning_rate).minimize(loss)</span><br></pre></td></tr></table></figure><ul><li><code>learning_rate</code>：学习率，决定参数每次更新的幅度</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''两层简单全连接神经网络'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line">BATCH_SIZE = <span class="number">8</span></span><br><span class="line">seed = <span class="number">23455</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机矩阵对象</span></span><br><span class="line">rng = np.random.RandomState(seed)</span><br><span class="line"><span class="comment"># 返回随机的 32 * 2 矩阵</span></span><br><span class="line">X = rng.rand(<span class="number">32</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 将合法数据的结果置为1 否则为0</span></span><br><span class="line">Y = [[int(x0 + x1 &lt; <span class="number">1</span>)] <span class="keyword">for</span> (x0, x1) <span class="keyword">in</span> X]</span><br><span class="line">print(<span class="string">"X:"</span> + str(X))</span><br><span class="line">print(<span class="string">"Y:"</span> + str(Y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入和参数</span></span><br><span class="line">x = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">2</span>))</span><br><span class="line">w1 = tf.Variable(tf.compat.v1.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line">w2 = tf.Variable(tf.compat.v1.random_normal([<span class="number">3</span>, <span class="number">1</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义标准输出</span></span><br><span class="line">y_ = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义前向传播过程</span></span><br><span class="line">a = tf.matmul(x, w1)</span><br><span class="line">y = tf.matmul(a, w2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数和反向传播的方法</span></span><br><span class="line">loss = tf.compat.v1.reduce_mean(tf.square(y - y_))</span><br><span class="line">train_step = tf.compat.v1.train.GradientDescentOptimizer(<span class="number">0.001</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    <span class="comment"># 未经训练的参数值</span></span><br><span class="line">    print(<span class="string">'initial w1: '</span> + str(sess.run(w1)))</span><br><span class="line">    print(<span class="string">'initial w2: '</span> + str(sess.run(w2)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    <span class="comment"># 使用同一数据集的不同数据组合训练3000轮</span></span><br><span class="line">    STEPS = <span class="number">3000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">        start = (i * BATCH_SIZE) % <span class="number">32</span></span><br><span class="line">        end = start + BATCH_SIZE</span><br><span class="line">        <span class="comment"># 传入y_指定标准输出</span></span><br><span class="line">        sess.run(train_step, feed_dict=&#123;x: X[start:end], y_: Y[start:end]&#125;)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'final w1: '</span> + str(sess.run(w1)))</span><br><span class="line">    print(<span class="string">'final w2: '</span> + str(sess.run(w2)))</span><br></pre></td></tr></table></figure><h3 id="神经网络八股"><a href="#神经网络八股" class="headerlink" title="神经网络八股"></a>神经网络八股</h3><ul><li><p>准备</p><ul><li><code>import</code></li><li>常量定义</li><li>生成数据集</li></ul></li><li><p>前传</p><ul><li>定义输入、参数、标准输出</li></ul></li><li><p>反传</p><ul><li>定义损失函数和反传优化方法</li></ul></li><li><p>迭代</p><ul><li><p>生成会话，训练<code>STEPS</code>轮。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line"></span><br><span class="line">    STEPS = <span class="number">3000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">        start = ...</span><br><span class="line">        end = ...</span><br><span class="line">        sess.run(train_step, feed_dict=&#123;...&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><ul><li><code>relu</code>:<code>tf.nn.relu()</code></li><li><code>sigmoid</code>:<code>tf.nn.sigmoid()</code></li><li><code>tanh</code>:<code>tf.nn.tanh()</code></li></ul><h3 id="NN复杂度"><a href="#NN复杂度" class="headerlink" title="NN复杂度"></a>NN复杂度</h3><ul><li>层数=隐藏层+输出层</li><li>总参数=总W+总b<ul><li><code>b</code>是偏置值，计算层一个结果神经元对应一个偏置。</li></ul></li></ul><h3 id="自定义损失函数"><a href="#自定义损失函数" class="headerlink" title="自定义损失函数"></a>自定义损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COST = <span class="number">1</span></span><br><span class="line">PROFIT = <span class="number">9</span></span><br><span class="line">loss = tf.reduce_sum(tf.where(tf.greater(y, y_), COST * (y - y_), PROFIT * (y_ - y)))</span><br></pre></td></tr></table></figure><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><ul><li><p>表征两个概率分布之间的<strong>距离</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ce = -tf.reduce_mean(y_ * tf.log(clip_by_value(y, <span class="number">1e-12</span>, <span class="number">1.0</span>)))</span><br></pre></td></tr></table></figure><ul><li><p>将<code>n</code>分类的<code>n</code>个输出通过<code>softmax()</code>函数处理使其满足概率和为1的分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ce = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y, labels=tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">cem = tf.reduce_mean(ce) <span class="comment"># loss function</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h2><ul><li>每次更新的幅度</li></ul><h3 id="指数衰减学习率"><a href="#指数衰减学习率" class="headerlink" title="指数衰减学习率"></a>指数衰减学习率</h3><ul><li><p>根据训练情况动态更新学习率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line">LEARNING_RATE_BASE = <span class="number">0.1</span>  <span class="comment"># 初始学习率</span></span><br><span class="line">LEARNING_RATE_DECAY = <span class="number">0.99</span>  <span class="comment"># 学习率衰减律</span></span><br><span class="line">LEARNING_RATE_STEP = <span class="number">1</span>  <span class="comment"># 学习率更新频度 一般为总样本数/BATCH_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 轮数计数器 初值为0 设置为不被训练</span></span><br><span class="line">global_step = tf.Variable(<span class="number">0</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 定义指数下降学习率</span></span><br><span class="line">learning_rate = tf.compat.v1.train.exponential_decay(</span><br><span class="line">    LEARNING_RATE_BASE,</span><br><span class="line">    global_step,</span><br><span class="line">    LEARNING_RATE_STEP,</span><br><span class="line">    LEARNING_RATE_DECAY,</span><br><span class="line">    staircase=<span class="literal">True</span>)  <span class="comment"># 为True表示学习率的下降是梯度曲线</span></span><br><span class="line"><span class="comment"># 定义待优化参数</span></span><br><span class="line">w = tf.Variable(tf.constant(<span class="number">5</span>, dtype=tf.float32))</span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss = tf.square(w + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 反向传播方法</span></span><br><span class="line">train_step = tf.compat.v1.train.GradientDescentOptimizer(</span><br><span class="line">    learning_rate).minimize(loss, global_step=global_step)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">40</span>):</span><br><span class="line">        sess.run(train_step)</span><br><span class="line">        learning_rate_val = sess.run(learning_rate)</span><br><span class="line">        global_step_val = sess.run(global_step)</span><br><span class="line">        w_val = sess.run(w)</span><br><span class="line">        loss_val = sess.run(loss)</span><br><span class="line">        print(w_val)</span><br></pre></td></tr></table></figure></li></ul><h2 id="滑动平均（影子值）"><a href="#滑动平均（影子值）" class="headerlink" title="滑动平均（影子值）"></a>滑动平均（影子值）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ema = tf.compat.v1.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step) <span class="comment"># 衰减率和当前轮数</span></span><br><span class="line">ema_op = ema.apply(tf.compat.v1.trainable_variables()) <span class="comment"># 对所有的待优化参数求平均值</span></span><br><span class="line"><span class="keyword">with</span> tf.control_dependencies([train_step, ema_op]):</span><br><span class="line">    train_op = tf.no_op(name=<span class="string">'train'</span>) <span class="comment"># 将训练和滑动平均操作绑定</span></span><br></pre></td></tr></table></figure><blockquote><p><code>ema.average(arg)</code>：查看参数的滑动平均值</p></blockquote><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><ul><li>缓解过拟合：通过给某些参数权值，弱化训练数据的噪声，将其正则化。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line">BATCH_SIZE = <span class="number">30</span></span><br><span class="line">seed = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于seed产生随机数</span></span><br><span class="line">rdm = np.random.RandomState(seed)</span><br><span class="line"><span class="comment"># 产生300组2维坐标</span></span><br><span class="line">X = rdm.randn(<span class="number">300</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 根据是否在园内为每个点设置颜色</span></span><br><span class="line">Y_ = [int(x0**<span class="number">2</span> + x1**<span class="number">2</span> &lt; <span class="number">2</span>) <span class="keyword">for</span> (x0, x1) <span class="keyword">in</span> X]</span><br><span class="line">Y_c = [[<span class="string">'red'</span> <span class="keyword">if</span> y <span class="keyword">else</span> <span class="string">'blue'</span>] <span class="keyword">for</span> y <span class="keyword">in</span> Y_]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据集X和标签Y进行shape整理为矩阵</span></span><br><span class="line"><span class="comment"># 第一个参数-1表示属性值由第二个参数决定</span></span><br><span class="line"><span class="comment"># 第二个参数表示有多少列 即X为n行2列 Y为n行1列</span></span><br><span class="line">X = np.vstack(X).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">Y_ = np.vstack(Y_).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取X所有坐标的第0/1列元素并指定颜色进行绘制</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=np.squeeze(Y_c))</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入 参数 输出 和前向传播过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight</span><span class="params">(shape, regularizer)</span>:</span></span><br><span class="line">    w = tf.Variable(tf.compat.v1.random_normal(shape), dtype=tf.float32)</span><br><span class="line">    tf.compat.v1.add_to_collection(</span><br><span class="line">        <span class="string">'losses'</span>,</span><br><span class="line">        tf.keras.regularizers.l2(regularizer)(w))</span><br><span class="line">        <span class="comment"># tf.contrib.layers.l2_regularizer(regularizer)(w))</span></span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bias</span><span class="params">(shape)</span>:</span></span><br><span class="line">    b = tf.Variable(tf.constant(<span class="number">0.01</span>, shape=shape))</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">2</span>))</span><br><span class="line">y_ = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">w1 = get_weight([<span class="number">2</span>, <span class="number">11</span>], <span class="number">0.01</span>)</span><br><span class="line">b1 = get_bias([<span class="number">11</span>])</span><br><span class="line">y1 = tf.nn.relu(tf.matmul(x, w1) + b1)  <span class="comment"># 激活隐藏层</span></span><br><span class="line"></span><br><span class="line">w2 = get_weight([<span class="number">11</span>, <span class="number">1</span>], <span class="number">0.01</span>)</span><br><span class="line">b2 = get_bias([<span class="number">1</span>])</span><br><span class="line">y = tf.matmul(y1, w2) + b2  <span class="comment"># 输出层不激活</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss_mse = tf.reduce_mean(tf.square(y - y_))</span><br><span class="line">loss_total = loss_mse + tf.compat.v1.add_n(</span><br><span class="line">    tf.compat.v1.get_collection(<span class="string">'losses'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不含正则化的反向传播</span></span><br><span class="line">train_step = tf.compat.v1.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(loss_mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含正则化的反向传播</span></span><br><span class="line">train_step = tf.compat.v1.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(loss_total)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    STEPS = <span class="number">40000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">        start = (i * BATCH_SIZE) % <span class="number">300</span></span><br><span class="line">        end = start + BATCH_SIZE</span><br><span class="line">        sess.run(train_step, feed_dict=&#123;x: X[start:end], y_: Y_[start:end]&#125;)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2000</span> == <span class="number">0</span>:</span><br><span class="line">            loss_mse_v = sess.run(loss_mse, feed_dict=&#123;x: X, y_: Y_&#125;)</span><br><span class="line">    <span class="comment"># 在[-3,3]上以0.01为步长生成二维网格坐标点</span></span><br><span class="line">    xx, yy = np.mgrid[<span class="number">-3</span>:<span class="number">3</span>:<span class="number">.01</span>, <span class="number">-3</span>:<span class="number">3</span>:<span class="number">.01</span>]</span><br><span class="line">    <span class="comment"># 将xx, yy拉直，合并成2列的矩阵</span></span><br><span class="line">    grid = np.c_[xx.ravel(), yy.ravel()]</span><br><span class="line">    <span class="comment"># 将点喂入神经网络</span></span><br><span class="line">    probs = sess.run(y, feed_dict=&#123;x: grid&#125;)</span><br><span class="line">    <span class="comment"># 调成probs的shape为和xx相同</span></span><br><span class="line">    probs = probs.reshape(xx.shape)</span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=np.squeeze(Y_c))</span><br><span class="line">plt.contour(xx, yy, probs, levels=[<span class="number">.5</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="搭建八股"><a href="#搭建八股" class="headerlink" title="搭建八股"></a>搭建八股</h2><ul><li><p>生成数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">()</span>:</span></span><br><span class="line">    rdm = np.random.RandomState(seed)</span><br><span class="line">    X = </span><br><span class="line">    Y_ = </span><br><span class="line">    Y_c = </span><br><span class="line">    </span><br><span class="line">    X = np.vstack(X).reshape()</span><br><span class="line">    Y = np.vstack(Y).reshape()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X, Y_, Y_c</span><br></pre></td></tr></table></figure></li><li><p>前向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''forward.py'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(x, regularizer)</span>:</span></span><br><span class="line">    w = </span><br><span class="line">    b = </span><br><span class="line">    y = </span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight</span><span class="params">(shape, regularizer)</span>:</span></span><br><span class="line">    w = tf.Variable()</span><br><span class="line">    tf.add_to_collection(<span class="string">'losses'</span>, tf,contrib.layers.l2_regularizer(regularizer)(w))</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bias</span><span class="params">(shape)</span>:</span></span><br><span class="line">    b = tf.Variable()</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure></li><li><p>反向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''backward.py'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">()</span>:</span></span><br><span class="line">    x = tf.palceholer()</span><br><span class="line">    y_ = tf.palceholer()</span><br><span class="line">    y = forward.firward(x, REGULARIZER)</span><br><span class="line">    global_step = tf.Variable(<span class="number">0</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">    loss = </span><br><span class="line"></span><br><span class="line">    train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        init_op = tf.global_variables_initializer()</span><br><span class="line">        sess.run(init_op)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">            sess.run(train_step, feed_dict=&#123;x:, y_:&#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    backward()</span><br></pre></td></tr></table></figure></li></ul><h2 id="MNIST数据集"><a href="#MNIST数据集" class="headerlink" title="MNIST数据集"></a>MNIST数据集</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><code>tf.get_collection(&#39;&#39;)</code>：取<code>collection</code>中的所有变量并生成一个列表</li><li><code>tf.add_n([])</code>：将列表中对应的元素相加</li><li><code>tf.cast(x, dtype)</code>：将<code>x</code>的类型转换为<code>dtype</code></li><li><code>tf.argmax(x, axis)</code>：返回最大值所在的索引号</li><li><code>os.path.join(&#39;home&#39;, &#39;name&#39;)</code>：返回<code>home/name</code></li><li><code>with tf.Graph().as_default() as g:</code>：语句块中的节点在计算图<code>g</code>中（多用于<strong>复现</strong>神经网络）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''mnist_forward.py'''</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">INPUT_NODE = <span class="number">784</span></span><br><span class="line">OUTPUT_NODE = <span class="number">10</span></span><br><span class="line">LAYER_NODE = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight</span><span class="params">(shape, regularizer)</span>:</span></span><br><span class="line">    <span class="comment">#beijieduande biaozhuncha buhuichaoguo liangge biaozhuncha</span></span><br><span class="line">    w = tf.Variable(tf.compat.v1.truncated_normal(shape, stddev=<span class="number">0.1</span>))</span><br><span class="line">    <span class="keyword">if</span> regularizer != <span class="literal">None</span>:</span><br><span class="line">        tf.compat.v1.add_to_collection(</span><br><span class="line">            <span class="string">"losses"</span>,</span><br><span class="line">            tf.keras.regularizers.l2(regularizer)(w))</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bias</span><span class="params">(shape)</span>:</span></span><br><span class="line">    b = tf.Variable(tf.zeros(shape))</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(x, regularizer)</span>:</span></span><br><span class="line">    w1 = get_weight((INPUT_NODE, LAYER_NODE), regularizer)</span><br><span class="line">    b1 = get_bias(LAYER_NODE)</span><br><span class="line">    y1 = tf.nn.relu(tf.matmul(x, w1) + b1)</span><br><span class="line"></span><br><span class="line">    w2 = get_weight((LAYER_NODE, OUTPUT_NODE), regularizer)</span><br><span class="line">    b2 = get_bias(OUTPUT_NODE)</span><br><span class="line">    y2 = tf.matmul(y1, w2) + b2</span><br><span class="line">    <span class="keyword">return</span> y2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.random.random((<span class="number">3</span>, <span class="number">784</span>))</span><br><span class="line">    x = x.astype(np.float32)</span><br><span class="line">    print(<span class="string">"x.shape:"</span>, x.shape)</span><br><span class="line">    regularizer = <span class="number">0.001</span></span><br><span class="line">    print(x.dtype)</span><br><span class="line"></span><br><span class="line">    pred_y = forward(x, regularizer)</span><br><span class="line">    print(<span class="string">"pred_y:"</span>, pred_y[:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''mnist_backward.py'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> mnist_forward</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">LEARNING_RATE_BASE = <span class="number">0.1</span></span><br><span class="line">LEARNING_RATE_DECAY = <span class="number">0.99</span></span><br><span class="line">REGULARIZER = <span class="number">0.0001</span></span><br><span class="line">STEPS = <span class="number">50000</span></span><br><span class="line">MOVING_AVERAGE_DECAY = <span class="number">0.99</span></span><br><span class="line">MODEL_SAVE_PATH = <span class="string">"./model/"</span></span><br><span class="line">MODEL_NAME = <span class="string">'mnist_model'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(mnist)</span>:</span></span><br><span class="line"></span><br><span class="line">    x = tf.compat.v1.placeholder(tf.float32, [<span class="literal">None</span>, mnist_forward.INPUT_NODE])</span><br><span class="line">    y_ = tf.compat.v1.placeholder(tf.float32,</span><br><span class="line">                                  [<span class="literal">None</span>, mnist_forward.OUTPUT_NODE])</span><br><span class="line">    y = mnist_forward.forward(x, REGULARIZER)</span><br><span class="line">    global_step = tf.Variable(<span class="number">0</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    ce = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y,</span><br><span class="line">                                                        labels=tf.argmax(</span><br><span class="line">                                                            y_, <span class="number">1</span>))</span><br><span class="line">    cem = tf.reduce_mean(ce)</span><br><span class="line">    loss = cem + tf.add_n(tf.compat.v1.get_collection(<span class="string">"losses"</span>))</span><br><span class="line"></span><br><span class="line">    learning_rate = tf.compat.v1.train.exponential_decay(LEARNING_RATE_BASE,</span><br><span class="line">                                               global_step,</span><br><span class="line">                                               mnist.train.num_examples /</span><br><span class="line">                                               BATCH_SIZE,</span><br><span class="line">                                               LEARNING_RATE_DECAY,</span><br><span class="line">                                               staircase=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    train_step = tf.compat.v1.train.GradientDescentOptimizer(learning_rate).minimize(</span><br><span class="line">        loss, global_step=global_step)</span><br><span class="line"></span><br><span class="line">    ema = tf.compat.v1.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step)</span><br><span class="line">    ema_op = ema.apply(tf.compat.v1.trainable_variables())</span><br><span class="line">    <span class="keyword">with</span> tf.control_dependencies([train_step, ema_op]):</span><br><span class="line">        train_op = tf.no_op(name=<span class="string">"train"</span>)</span><br><span class="line"></span><br><span class="line">    saver = tf.compat.v1.train.Saver()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">        sess.run(init_op)</span><br><span class="line">        ckpt = tf.compat.v1.train.get_checkpoint_state(MODEL_SAVE_PATH)</span><br><span class="line">        exclude = [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">            saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">            xs, ys = mnist.train.next_batch(BATCH_SIZE)</span><br><span class="line">            _, loss_value, step = sess.run([train_op, loss, global_step],</span><br><span class="line">                                           feed_dict=&#123;</span><br><span class="line">                                               x: xs,</span><br><span class="line">                                               y_: ys</span><br><span class="line">                                           &#125;)</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                print(</span><br><span class="line">                    <span class="string">"After %d training step(s), losses on trianing batch is %f. "</span></span><br><span class="line">                    % (step, loss_value))</span><br><span class="line">                saver.save(sess,</span><br><span class="line">                           os.path.join(MODEL_SAVE_PATH, MODEL_NAME),</span><br><span class="line">                           global_step=global_step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    mnist = input_data.read_data_sets(<span class="string">"./MNIST_data/"</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line">    backward(mnist)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''mnist_test.py'''</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> mnist_forward</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"><span class="keyword">import</span> mnist_forward</span><br><span class="line"><span class="keyword">import</span> mnist_backward</span><br><span class="line">TEST_INTERVAL_SECS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(mnist)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.Graph().as_default() <span class="keyword">as</span> g:</span><br><span class="line">        x = tf.compat.v1.placeholder(tf.float32, [<span class="literal">None</span>, mnist_forward.INPUT_NODE])</span><br><span class="line">        y_ = tf.compat.v1.placeholder(tf.float32, [<span class="literal">None</span>, mnist_forward.OUTPUT_NODE])</span><br><span class="line">        y = mnist_forward.forward(x, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        ema = tf.compat.v1.train.ExponentialMovingAverage(</span><br><span class="line">            mnist_backward.MOVING_AVERAGE_DECAY)</span><br><span class="line">        ema_restore = ema.variables_to_restore()</span><br><span class="line">        saver = tf.compat.v1.train.Saver(ema_restore)</span><br><span class="line"></span><br><span class="line">        correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">#qiupingjun</span></span><br><span class="line">        accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="number">20</span>:</span><br><span class="line">            <span class="comment">#gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=0.333)</span></span><br><span class="line">            <span class="comment">#with tf.Session(config=tf.ConfigProto(gpu_options=gpu_options)) as sess:</span></span><br><span class="line">            <span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">                ckpt = tf.compat.v1.train.get_checkpoint_state(</span><br><span class="line">                    mnist_backward.MODEL_SAVE_PATH)</span><br><span class="line">                <span class="comment">#                print("----")</span></span><br><span class="line">                <span class="comment">#                print(ckpt)</span></span><br><span class="line">                <span class="comment">#                print("----")</span></span><br><span class="line">                <span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">                    <span class="comment">#                    print("ok?")</span></span><br><span class="line">                    saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line">                    global_step = ckpt.model_checkpoint_path.split(</span><br><span class="line">                        <span class="string">'/'</span>)[<span class="number">-1</span>].split(<span class="string">'-'</span>)[<span class="number">-1</span>]</span><br><span class="line">                    <span class="comment">#                    print("global_step:",global_step)</span></span><br><span class="line">                    accuracy_score = sess.run(accuracy,</span><br><span class="line">                                              feed_dict=&#123;</span><br><span class="line">                                                  x: mnist.test.images[:<span class="number">256</span>],</span><br><span class="line">                                                  y_: mnist.test.labels[:<span class="number">256</span>]</span><br><span class="line">                                              &#125;)</span><br><span class="line">                    print(<span class="string">"After %s training step(s). test accuracy = %f"</span> %</span><br><span class="line">                          (global_step, accuracy_score))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"No checkpoint file found"</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                time.sleep(TEST_INTERVAL_SECS)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    mnist = input_data.read_data_sets(<span class="string">"./MNIST_data/"</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line">    test(mnist)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''mnist_app.py'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Wed Nov 28 22:37:56 2018</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: lele</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> mnist_backward</span><br><span class="line"><span class="keyword">import</span> mnist_forward</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restore_model</span><span class="params">(testPicArr)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.Graph().as_default() <span class="keyword">as</span> g:</span><br><span class="line">        x = tf.compat.v1.placeholder(tf.float32, [<span class="literal">None</span>, mnist_forward.INPUT_NODE])</span><br><span class="line">        y = mnist_forward.forward(x, <span class="literal">None</span>)</span><br><span class="line">        preValue = tf.compat.v1.arg_max(y, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        variable_averages = tf.compat.v1.train.ExponentialMovingAverage(</span><br><span class="line">            mnist_backward.MOVING_AVERAGE_DECAY)</span><br><span class="line">        variable_to_restore = variable_averages.variables_to_restore()</span><br><span class="line">        saver = tf.compat.v1.train.Saver(variable_to_restore)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">            ckpt = tf.compat.v1.train.get_checkpoint_state(</span><br><span class="line">                mnist_backward.MODEL_SAVE_PATH)</span><br><span class="line">            <span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">                saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line"></span><br><span class="line">                preValue = sess.run(preValue, feed_dict=&#123;x: testPicArr&#125;)</span><br><span class="line">                <span class="keyword">return</span> preValue</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"No checkpoint file found"</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_pic</span><span class="params">(picName)</span>:</span></span><br><span class="line">    fp = open(picName, <span class="string">'rb'</span>)</span><br><span class="line">    img = Image.open(fp)</span><br><span class="line">    reIm = img.resize((<span class="number">28</span>, <span class="number">28</span>), Image.ANTIALIAS)</span><br><span class="line">    im_arr = np.array(reIm.convert(<span class="string">'L'</span>))</span><br><span class="line">    threshold = <span class="number">50</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">28</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">28</span>):</span><br><span class="line">            im_arr[i][j] = <span class="number">255</span> - im_arr[i][j]</span><br><span class="line">            <span class="keyword">if</span> (im_arr[i][j] &lt; threshold):</span><br><span class="line">                im_arr[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                im_arr[i][j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    nm_arr = im_arr.reshape([<span class="number">1</span>, <span class="number">784</span>])</span><br><span class="line">    nm_arr = nm_arr.astype(np.float32)</span><br><span class="line">    img_ready = np.multiply(nm_arr, <span class="number">1.0</span> / <span class="number">255.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img_ready</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">()</span>:</span></span><br><span class="line">    testNum = int(input(<span class="string">"input the num of the test pictures:"</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(testNum):</span><br><span class="line">        testPic = input(<span class="string">"the path of test picture:"</span>)</span><br><span class="line">        testPicArr = pre_pic(testPic)</span><br><span class="line">        preValue = restore_model(testPicArr)</span><br><span class="line">        print(<span class="string">"the prediction num is:"</span>, preValue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    application()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><p>待优化参数过多会导致过拟合</p></li><li><p>为了避免过拟合，通常先将图片进行预处理（提取特征）。</p></li><li><p>卷积是一种有效的<strong>提取图像特征</strong>的方法</p></li><li><p>$输出图片边长=(输入图片边长-卷积核长+1)/步长(向上取整)$</p><blockquote><p>为了将输出图片和输入图片的边长保持一致，可以对输入图片进行<strong>全零填充(Padding)</strong>。</p></blockquote></li></ul><h3 id="卷积计算"><a href="#卷积计算" class="headerlink" title="卷积计算"></a>卷积计算</h3><ul><li><p><code>tf.nn.conv2d</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.nn.conv2d([batch, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">16</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>padding</code><ul><li><code>VALID</code>：不进行填充</li><li><code>SAME</code>：进行填充</li></ul></li><li>核个数指定<strong>输出</strong>的通道数</li></ul></li></ul><h3 id="池化-Pooling"><a href="#池化-Pooling" class="headerlink" title="池化(Pooling)"></a>池化(Pooling)</h3><ul><li><p>减少特征数量（模糊处理）</p></li><li><p>最大值池化：提取图片纹理</p></li><li><p>均值池化：保留背景特征</p></li><li><p>计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool = tf.nn.max_pool([batch, <span class="number">28</span>, <span class="number">28</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>) <span class="comment"># tf.nn.avg_pool</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="舍弃-Dropout"><a href="#舍弃-Dropout" class="headerlink" title="舍弃(Dropout)"></a>舍弃(Dropout)</h3><ul><li><p>训练时随机舍弃一些神经元，但是在使用时<strong>会恢复</strong>。</p></li><li><p>实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.nn.dropout(上层输出， 舍弃的概率)</span><br></pre></td></tr></table></figure><blockquote><p>一般放在<strong>全连接</strong>网络中</p></blockquote></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>卷积</li><li>激活</li><li>池化</li><li>全连接</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>TensorFlow Notebook, Peking University, 2018.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;3487&lt;/code&gt;字，是暑期学习TensorFlow的记录，推荐按照顺序进行阅读。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-Python变量</title>
    <link href="http://yoursite.com/2020/08/30/Python-Python%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2020/08/30/Python-Python%E5%8F%98%E9%87%8F/</id>
    <published>2020-08-30T14:40:49.404Z</published>
    <updated>2020-08-30T14:41:36.148Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2007</code>字，推荐阅读时间<code>10~15</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Python里的变量是什么？是一个代号还是具体的内存中存储的值？还是另有它意？</p><p>最近在看《Fluent Python》时受到作者启发，想要记录一些目前关于Python最基础的变量部分的理解，同时也是为了小仙女能把这里搞明白。</p><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><ul><li><p>变量名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><code>a</code>就是我们所说的变量名</li></ul></li><li><p><strong>数据</strong>类型（仅涉及常见类型）</p><ul><li>数字(int/long/float/complex)</li><li>字符串(str)</li><li>列表(list)</li><li>元组(tuple)</li><li>字典(dict)</li></ul><blockquote><p>Q：为什么不是<strong>变量</strong>类型？</p><p>A：在笔者看来，Python是一种<strong>弱类型</strong>语言，变量<strong>没有</strong>固定的类型——今天是数字，明天可能就变成了列表。因此，说<strong>数据类型</strong>分为哪些类相比于<strong>变量类型</strong>更为准确。</p></blockquote></li></ul><p>以上是最常见的关于Python变量的描述，它们具体应该怎么使用并不是本文探讨的重点。因此接下来我们从变量本身的一些性质出发，理解Python中相关的一些特殊情况。</p><h2 id="可变与不可变"><a href="#可变与不可变" class="headerlink" title="可变与不可变"></a>可变与不可变</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>可变：list/dict</li><li>不可变：tuple/str/int/long/float/complex</li></ul><h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>什么叫可变？就是单纯的可以被改变吗？</p><p>什么是不可变？不可以被改变就叫不可变吗？</p><p>显然，这可能是正确答案，但是一定不是一个准确的答案。</p><p>为了介绍清楚这两者的区别，我们首先介绍一个函数：<code>id()</code>.</p><blockquote><p><code>id()</code>这个函数的作用和它的名字一样简单粗暴：获取<strong>对象</strong>唯一的<strong>标识符</strong>。</p></blockquote><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>首先我们先讲讲什么叫做标识符：可以把它理解成身份证号，一个对象<strong>有且仅有</strong>一个的编号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">id(a) <span class="comment"># 140709554144928</span></span><br></pre></td></tr></table></figure><blockquote><p>不同的电脑和不同版本的Python解释器可能会返回不同的<code>id()</code>结果</p></blockquote><p>接下来就是本文的重点了，什么是对象？</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>这是一个现代编程领域及其复杂的概念，想要通过简单的几句话说清楚并不太现实。但是我们可以抓住主要矛盾进行剖析：<strong>对象的定义在不同的语言中是不同的</strong>。有了这个基本共识之后，我们就可以开始认识Python的对象了。</p><p><strong>Python是一门可以问心无愧地说“一切都是对象”的语言。<del>（至少相比于Java是这样）</del></strong></p><blockquote><p>在Python中，小到<code>int</code>都是一个对象。<del>（Java你倒是看看啊）</del></p></blockquote><p>因此，在Python里，我们可以把<strong>变量</strong>理解成一个我们可以随便取名字的<strong>对象索引</strong>。</p><blockquote><ul><li>刚才就提到了，对象在不同语言里的定义是不同的，因此变量的定义<strong>也是不同的</strong>。</li><li>这仅仅是一个笔者认为简单的理解，不一定严密，如果有不同意见欢迎分享。</li></ul></blockquote><p>那么，什么叫做索引呢？</p><p>我们在生活中看见过书籍索引、楼层索引等等。说白了，它们的作用就是书/房子这个大容器的<strong>路牌</strong>。</p><p>在Python中，变量就是对象的路牌，帮助我们找到对象的具体位置。因此，我们把变量作为参数传递给<code>id()</code>函数后，就可以得到这个变量所对应的对象的身份证号了呢！是不是好神奇~</p><p>说了这么久，请问我们为什么要找对象呢？</p><p><strong>因为对象里存着我们需要的信息啊！</strong></p><p>忙活半天不就是为了处理数据嘛？勿忘初心哦~</p><p>如果看到这里有一点晕，可以把对象这一小节反复读一读，相信聪明的你一定能够理解我想要表达的意思。</p><h3 id="变or不变"><a href="#变or不变" class="headerlink" title="变or不变"></a>变or不变</h3><p>有了前面的铺垫，我们终于可以开始讲什么是可变与不可变了，我们先分析下面的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">l[<span class="number">0</span>] = <span class="number">3</span> <span class="comment"># l: [3, 2, 3]</span></span><br><span class="line">t[<span class="number">0</span>] = <span class="number">3</span> <span class="comment"># Error!</span></span><br></pre></td></tr></table></figure><p>为什么不能进行<code>t[0]</code>的赋值操作呢？相信了解元组最基本特性的您一定知道：<strong>元组不可变！</strong>这是正解没错，那么我们来看看下面的例子呢：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">t[<span class="number">2</span>].append(<span class="number">4</span>) <span class="comment"># t: (1, 2, [1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure><p>咦？为啥这里元组被修改了？难道元组可变了？</p><p>其实背后的原理就在我们之前讲到的<strong>对象</strong>中：Python的可变和不可变都是针对<strong>对象</strong>而言的，而<strong>不是变量</strong>。</p><p>在第一个例子中，<code>t[0]</code>变量是一个<code>int</code>对象的索引。因为<code>int</code>是不可变的，所以我们如果要改变<code>t[0]</code>，就必须为它<strong>换一个对象</strong>。而这里的换对象，就是改变这个路牌的指向，让它指向另外一个地方。</p><p>刚才我们讲到<code>id()</code>可以获得对象的身份证号，那么我们就来做这样一个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">id(a) <span class="comment"># 140709554144928</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">id(a) <span class="comment"># 140709554144960</span></span><br></pre></td></tr></table></figure><blockquote><p>这说明，<code>a</code>这个路牌的箭头确实被改了，对<code>a</code>值得修改<strong>并没有</strong>在原来存储1的内存位置上发生。</p></blockquote><p>综上，此时我们对元组中的<code>t[0]</code>变量进行修改，就得改变<code>id(t[0])</code>，这触犯了<strong>元组不可变</strong>的特性，因此是不被允许的。</p><p>那么我们现在来看第二个例子：为啥元组又被修改了呢？</p><p>看看<code>t[2]</code>对应的是啥？是<code>[1, 2, 3]</code>这个列表(list)！</p><p>列表是什么类型？可变类型！</p><p>不可变类型<strong>不允许</strong>对象的<code>id</code>发生变化，那么可变类型自然就……<strong>允许</strong>呢！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">2</span>].append(<span class="number">4</span>) <span class="comment"># t: (1, 2, [1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure><p>这一条语句可以被拆成以下的行为：</p><ul><li>获取元组<code>t</code>中的第三个元素<code>t[2]</code>，发现是个可变的列表。</li><li>列表类型的尾部增加元素操作<code>append</code></li></ul><p>这两步中涉及到的变量和对象有：</p><ul><li>变量：指向列表的<code>t[2]</code></li><li>对象：<code>[1, 2, 3]</code>这个<strong>列表</strong>，我们给他起个名字叫<code>a</code>好了。</li></ul><p><code>a</code>列表是可变的，<code>a[0]</code>/<code>a[1]</code>这些都是<strong>变量</strong>，所以我们可以使用<code>append</code>为它增加一个<code>a[3]</code><strong>变量</strong>，并且让它指向数字<code>4</code>这个<strong>对象</strong>。</p><p>因为<code>a</code>是可变的，所以我们对它的修改不需要“另觅新欢”，<strong>只需要在原来的内存位置进行就好了</strong>。</p><p>所以，<code>t[2]</code>这个变量对应对象的<code>id</code>在过程中发生过变化吗？没有！也就是说<code>id(t[2])</code>在增加元素的前后没有变化。以下是控制台的运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">id(t[<span class="number">2</span>]) <span class="comment"># 1590806815744</span></span><br><span class="line">t[<span class="number">2</span>].append(<span class="number">4</span>) <span class="comment"># t: (1, 2, [1, 2, 3, 4])</span></span><br><span class="line">id(t[<span class="number">2</span>]) <span class="comment"># 1590806815744</span></span><br></pre></td></tr></table></figure><p>只要<code>id(t[2])</code>没有发生变化，那么元组的不可改变特性<strong>就没有</strong>被破坏，自然就可以这么操作啊！</p><p>但是这是个好现象吗，显然不是的，因此我们要避免在不可变类型中塞进可变的对象，这里使用这个例子只是为了强调Python中变量和对象的关系。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>Python中，一切都是对象。<del>（是真的一切！）</del></li><li>用对象来理解变量，才能更清楚地知道自己使用的变量究竟是什么。</li><li>可变和不可变不要记概念，判断对象的<code>id</code>是否改变最准确。</li><li>希望小仙女看懂了。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Fluent Python, Luciano Ramalho.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2007&lt;/code&gt;字，推荐阅读时间&lt;code&gt;10~15&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Django-Chapter4-Query Expressions</title>
    <link href="http://yoursite.com/2020/08/17/Django-Chapter4-Query%20Expressions/"/>
    <id>http://yoursite.com/2020/08/17/Django-Chapter4-Query%20Expressions/</id>
    <published>2020-08-17T03:22:49.731Z</published>
    <updated>2020-08-17T03:27:12.652Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>857</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>Django支持Python的常见运算类型</p></li><li><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count, F, Value</span><br><span class="line"><span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Length, Upper</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find companies that have more employees than chairs.</span></span><br><span class="line">Company.objects.filter(num_employees__gt=F(<span class="string">'num_chairs'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find companies that have at least twice as many employees</span></span><br><span class="line"><span class="comment"># as chairs. Both the querysets below are equivalent.</span></span><br><span class="line">Company.objects.filter(num_employees__gt=F(<span class="string">'num_chairs'</span>) * <span class="number">2</span>)</span><br><span class="line">Company.objects.filter(</span><br><span class="line">    num_employees__gt=F(<span class="string">'num_chairs'</span>) + F(<span class="string">'num_chairs'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># How many chairs are needed for each company to seat all employees?</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>company = Company.objects.filter(</span><br><span class="line"><span class="meta">... </span>   num_employees__gt=F(<span class="string">'num_chairs'</span>)).annotate(</span><br><span class="line"><span class="meta">... </span>   chairs_needed=F(<span class="string">'num_employees'</span>) - F(<span class="string">'num_chairs'</span>)).first()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>company.num_employees</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>company.num_chairs</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>company.chairs_needed</span><br><span class="line"><span class="number">70</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new company using expressions.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>company = Company.objects.create(name=<span class="string">'Google'</span>, ticker=Upper(Value(<span class="string">'goog'</span>)))</span><br><span class="line"><span class="comment"># Be sure to refresh it if you need to access the field.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>company.refresh_from_db()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>company.ticker</span><br><span class="line"><span class="string">'GOOG'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Annotate models with an aggregated value. Both forms</span></span><br><span class="line"><span class="comment"># below are equivalent.</span></span><br><span class="line">Company.objects.annotate(num_products=Count(<span class="string">'products'</span>))</span><br><span class="line">Company.objects.annotate(num_products=Count(F(<span class="string">'products'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Aggregates can contain complex computations also</span></span><br><span class="line">Company.objects.annotate(num_offerings=Count(F(<span class="string">'products'</span>) + F(<span class="string">'services'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expressions can also be used in order_by(), either directly</span></span><br><span class="line">Company.objects.order_by(Length(<span class="string">'name'</span>).asc())</span><br><span class="line">Company.objects.order_by(Length(<span class="string">'name'</span>).desc())</span><br><span class="line"><span class="comment"># or using the double underscore lookup syntax.</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> CharField</span><br><span class="line"><span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Length</span><br><span class="line">CharField.register_lookup(Length)</span><br><span class="line">Company.objects.order_by(<span class="string">'name__length'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Boolean expression can be used directly in filters.</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Exists</span><br><span class="line">Company.objects.filter(</span><br><span class="line">    Exists(Employee.objects.filter(company=OuterRef(<span class="string">'pk'</span>), salary__gt=<span class="number">10</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="内置表达式"><a href="#内置表达式" class="headerlink" title="内置表达式"></a>内置表达式</h2><h3 id="F"><a href="#F" class="headerlink" title="F()"></a>F()</h3><ul><li><p>直接访问数据库而不是让Python来操作</p><blockquote><p>可以<strong>避免竞争</strong></p></blockquote></li><li><p>减少检索语句</p></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"></span><br><span class="line">reporter = Reporters.objects.get(name=<span class="string">'Tintin'</span>)</span><br><span class="line">reporter.stories_filed = F(<span class="string">'stories_filed'</span>) + <span class="number">1</span></span><br><span class="line">reporter.save()</span><br><span class="line">reporter = Reporters.objects.get(pk=reporter.pk)</span><br><span class="line"><span class="comment"># Or, more succinctly:</span></span><br><span class="line">reporter.refresh_from_db()</span><br></pre></td></tr></table></figure><ul><li><p>想要获取正确的新值，需要调用<code>refresh_from_db</code>.</p><ul><li><p><code>F</code>语句造成的更新在所有的<code>save</code>中都会生效，因此需要每次<code>save</code>后调用<code>refresh_from_db</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reporter = Reporters.objects.get(name=<span class="string">'Tintin'</span>)</span><br><span class="line">reporter.stories_filed = F(<span class="string">'stories_filed'</span>) + <span class="number">1</span></span><br><span class="line">reporter.save()</span><br><span class="line"></span><br><span class="line">reporter.name = <span class="string">'Tintin Jr.'</span></span><br><span class="line">reporter.save()</span><br></pre></td></tr></table></figure><blockquote><p><code>stories_filed</code>的终值是3</p></blockquote></li></ul></li><li><p>使用<code>update</code>简化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reporter = Reporters.objects.filter(name=<span class="string">'Tintin'</span>)</span><br><span class="line">reporter.update(stories_filed=F(<span class="string">'stories_filed'</span>) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="F-amp-Other-Query-Expressions"><a href="#F-amp-Other-Query-Expressions" class="headerlink" title="F()&amp;Other Query Expressions"></a>F()&amp;Other Query Expressions</h4><ul><li><p><code>filter</code></p></li><li><p><code>annotate</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">company = Company.objects.annotate(</span><br><span class="line">    chairs_needed=F(<span class="string">'num_employees'</span>) - F(<span class="string">'num_chairs'</span>))</span><br></pre></td></tr></table></figure><ul><li><p>当返回类型不确定时，需要使用<strong>包装器</strong>进行指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> DateTimeField, ExpressionWrapper, F</span><br><span class="line"></span><br><span class="line">Ticket.objects.annotate(</span><br><span class="line">    expires=ExpressionWrapper(</span><br><span class="line">        F(<span class="string">'active_at'</span>) + F(<span class="string">'duration'</span>), output_field=DateTimeField()))</span><br></pre></td></tr></table></figure></li><li><p>访问外键域时，<code>F()</code>返回的是<strong>主键值</strong>，而<strong>不是实例</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; car = Company.objects.annotate(built_by=F(<span class="string">'manufacturer'</span>))[<span class="number">0</span>]</span><br><span class="line">&gt;&gt; car.manufacturer</span><br><span class="line">&lt;Manufacturer: Toyota&gt;</span><br><span class="line">&gt;&gt; car.built_by</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>对<code>null</code>排序</p><p>通过<code>asc()</code>和<code>desc()</code>实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line">Company.objects.order_by(F(<span class="string">'last_contacted'</span>).desc(nulls_last=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="Func"><a href="#Func" class="headerlink" title="Func()"></a>Func()</h3><ul><li><code>Func()</code>是所有数据库函数的基础函数</li></ul><h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate()"></a>Aggregate()</h3><ul><li><code>Aggregate()</code>是所有聚集函数的基础函数，例如<code>Sum()</code>/<code>Count()</code>.</li></ul><h3 id="Value"><a href="#Value" class="headerlink" title="Value()"></a>Value()</h3><ul><li>很少直接使用，但是在底层很重要。</li></ul><h3 id="ExpressionWrapper"><a href="#ExpressionWrapper" class="headerlink" title="ExpressionWrapper()"></a>ExpressionWrapper()</h3><ul><li>在使用<code>F()</code>时常常辅助使用</li></ul><h3 id="Subquery"><a href="#Subquery" class="headerlink" title="Subquery()"></a>Subquery()</h3><ul><li><p><code>class Subquery(queryset, output_field=None)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> OuterRef, Subquery</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newest = Comment.objects.filter(post=OuterRef(<span class="string">'pk'</span>)).order_by(<span class="string">'-created_at'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Post.objects.annotate(newest_commenter_email=Subquery(newest.values(<span class="string">'email'</span>)[:<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li><li><p><code>OuterRef(field)</code>：在<code>Subquery</code>内部的<code>QuerySet</code>需要查询<strong>外部域</strong>时使用</p></li><li><p>限制<code>Subquery()</code>为<strong>一列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_day_ago = timezone.now() - timedelta(days=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>posts = Post.objects.filter(published_at__gte=one_day_ago)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Comment.objects.filter(post__in=Subquery(posts.values(<span class="string">'pk'</span>)))</span><br></pre></td></tr></table></figure></li><li><p>限制<code>Subquery()</code>为一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>subquery = Subquery(newest.values(<span class="string">'email'</span>)[:<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Post.objects.annotate(newest_commenter_email=subquery)</span><br></pre></td></tr></table></figure><blockquote><p>不能使用<code>get()</code>，因为<code>OuterRef</code>只有在<code>Subquery</code>内才会被解析。</p></blockquote></li><li><p><code>Exists()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Exists, OuterRef</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_day_ago = timezone.now() - timedelta(days=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>recent_comments = Comment.objects.filter(</span><br><span class="line"><span class="meta">... </span>    post=OuterRef(<span class="string">'pk'</span>),</span><br><span class="line"><span class="meta">... </span>    created_at__gte=one_day_ago,</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Post.objects.annotate(recent_comment=Exists(recent_comments))</span><br></pre></td></tr></table></figure><ul><li><code>~Exists()</code>即不存在</li></ul></li><li><p>在<code>Subquery</code>内使用<code>aggregation</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> OuterRef, Subquery, Sum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>comments = Comment.objects.filter(post=OuterRef(<span class="string">'pk'</span>)).order_by().values(<span class="string">'post'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>total_comments = comments.annotate(total=Sum(<span class="string">'length'</span>)).values(<span class="string">'total'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Post.objects.filter(length__gt=Subquery(total_comments))</span><br></pre></td></tr></table></figure></li></ul><h2 id="Expression-API"><a href="#Expression-API" class="headerlink" title="Expression API"></a>Expression API</h2><ul><li><p><code>get_source_expressions()</code>：返回内部表达式的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Sum(F(<span class="string">'foo'</span>)).get_source_expressions()</span><br><span class="line">[F(<span class="string">'foo'</span>)]</span><br></pre></td></tr></table></figure><ul><li><code>set_source_expressions()</code>是逆操作</li></ul></li><li><p><code>asc(nulls_first=False, nulls_last=False)</code>：返回访问后<strong>升序</strong>表达式</p></li><li><p><code>desc(nulls_first=False, nulls_last=False)</code>：返回访问后<strong>降序</strong>表达式</p></li><li><p><code>reverse_ordering()</code></p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://docs.djangoproject.com/en/3.1/ref/models/expressions/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.1/ref/models/expressions/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;857&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django-Chapter5-Conditional Expressions</title>
    <link href="http://yoursite.com/2020/08/17/Django-Chapter5-Conditional%20Expressions/"/>
    <id>http://yoursite.com/2020/08/17/Django-Chapter5-Conditional%20Expressions/</id>
    <published>2020-08-17T03:22:49.731Z</published>
    <updated>2020-08-17T03:25:36.413Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>620</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>条件表达式用于在<code>filter</code>/<code>annotate</code>/<code>aggregate</code>/<code>update</code>中实现<code>if</code>逻辑。</p></li><li><p>取以下模型为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    REGULAR = <span class="string">'R'</span></span><br><span class="line">    GOLD = <span class="string">'G'</span></span><br><span class="line">    PLATINUM = <span class="string">'P'</span></span><br><span class="line">    ACCOUNT_TYPE_CHOICES = [</span><br><span class="line">        (REGULAR, <span class="string">'Regular'</span>),</span><br><span class="line">        (GOLD, <span class="string">'Gold'</span>),</span><br><span class="line">        (PLATINUM, <span class="string">'Platinum'</span>),</span><br><span class="line">    ]</span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    registered_on = models.DateField()</span><br><span class="line">    account_type = models.CharField(</span><br><span class="line">        max_length=<span class="number">1</span>,</span><br><span class="line">        choices=ACCOUNT_TYPE_CHOICES,</span><br><span class="line">        default=REGULAR,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li></ul><h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><ul><li><p><code>class When(condition=None, then=None, **lookups)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F, Q, When</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># String arguments refer to fields; the following two examples are equivalent:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>When(account_type=Client.GOLD, then=<span class="string">'name'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>When(account_type=Client.GOLD, then=F(<span class="string">'name'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># You can use field lookups in the condition</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>When(registered_on__gt=date(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"><span class="meta">... </span>     registered_on__lt=date(<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"><span class="meta">... </span>     then=<span class="string">'account_type'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Complex conditions can be created using Q objects</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>When(Q(name__startswith=<span class="string">"John"</span>) | Q(name__startswith=<span class="string">"Paul"</span>),</span><br><span class="line"><span class="meta">... </span>     then=<span class="string">'name'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Condition can be created using boolean expressions.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Exists, OuterRef</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>non_unique_account_type = Client.objects.filter(</span><br><span class="line"><span class="meta">... </span>    account_type=OuterRef(<span class="string">'account_type'</span>),</span><br><span class="line"><span class="meta">... </span>).exclude(pk=OuterRef(<span class="string">'pk'</span>)).values(<span class="string">'pk'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>When(Exists(non_unique_account_type), then=Value(<span class="string">'non unique'</span>))</span><br></pre></td></tr></table></figure><ul><li><code>When</code>接收返回布尔值的表达式，根据<code>then</code><strong>确定</strong>返回值。</li></ul></li></ul><h2 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h2><ul><li><p><code>class Case(*cases, **extra)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> date, timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Case, Value, When</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.create(</span><br><span class="line"><span class="meta">... </span>    name=<span class="string">'Jane Doe'</span>,</span><br><span class="line"><span class="meta">... </span>    account_type=Client.REGULAR,</span><br><span class="line"><span class="meta">... </span>    registered_on=date.today() - timedelta(days=<span class="number">36</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.create(</span><br><span class="line"><span class="meta">... </span>    name=<span class="string">'James Smith'</span>,</span><br><span class="line"><span class="meta">... </span>    account_type=Client.GOLD,</span><br><span class="line"><span class="meta">... </span>    registered_on=date.today() - timedelta(days=<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.create(</span><br><span class="line"><span class="meta">... </span>    name=<span class="string">'Jack Black'</span>,</span><br><span class="line"><span class="meta">... </span>    account_type=Client.PLATINUM,</span><br><span class="line"><span class="meta">... </span>    registered_on=date.today() - timedelta(days=<span class="number">10</span> * <span class="number">365</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Get the discount for each Client based on the account type</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.annotate(</span><br><span class="line"><span class="meta">... </span>    discount=Case(</span><br><span class="line"><span class="meta">... </span>        When(account_type=Client.GOLD, then=Value(<span class="string">'5%'</span>)),</span><br><span class="line"><span class="meta">... </span>        When(account_type=Client.PLATINUM, then=Value(<span class="string">'10%'</span>)),</span><br><span class="line"><span class="meta">... </span>        default=Value(<span class="string">'0%'</span>),</span><br><span class="line"><span class="meta">... </span>    ),</span><br><span class="line"><span class="meta">... </span>).values_list(<span class="string">'name'</span>, <span class="string">'discount'</span>)</span><br><span class="line">&lt;QuerySet [(<span class="string">'Jane Doe'</span>, <span class="string">'0%'</span>), (<span class="string">'James Smith'</span>, <span class="string">'5%'</span>), (<span class="string">'Jack Black'</span>, <span class="string">'10%'</span>)]&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>Case</code>根据传入的<code>When</code>表达式选择返回值（类似<code>switich-case</code>语句）</p><blockquote><p><code>Case</code>实际上就是在组织多个<code>When</code></p></blockquote></li></ul></li><li><p><code>Case</code>&amp;<code>filter</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_month_ago = date.today() - timedelta(days=<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_year_ago = date.today() - timedelta(days=<span class="number">365</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.filter(</span><br><span class="line"><span class="meta">... </span>    registered_on__lte=Case(</span><br><span class="line"><span class="meta">... </span>        When(account_type=Client.GOLD, then=a_month_ago),</span><br><span class="line"><span class="meta">... </span>        When(account_type=Client.PLATINUM, then=a_year_ago),</span><br><span class="line"><span class="meta">... </span>    ),</span><br><span class="line"><span class="meta">... </span>).values_list(<span class="string">'name'</span>, <span class="string">'account_type'</span>)</span><br><span class="line">&lt;QuerySet [(<span class="string">'Jack Black'</span>, <span class="string">'P'</span>)]&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><h3 id="条件更新"><a href="#条件更新" class="headerlink" title="条件更新"></a>条件更新</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_month_ago = date.today() - timedelta(days=<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_year_ago = date.today() - timedelta(days=<span class="number">365</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Update the account_type for each Client from the registration date</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.update(</span><br><span class="line"><span class="meta">... </span>    account_type=Case(</span><br><span class="line"><span class="meta">... </span>        When(registered_on__lte=a_year_ago,</span><br><span class="line"><span class="meta">... </span>             then=Value(Client.PLATINUM)),</span><br><span class="line"><span class="meta">... </span>        When(registered_on__lte=a_month_ago,</span><br><span class="line"><span class="meta">... </span>             then=Value(Client.GOLD)),</span><br><span class="line"><span class="meta">... </span>        default=Value(Client.REGULAR)</span><br><span class="line"><span class="meta">... </span>    ),</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.values_list(<span class="string">'name'</span>, <span class="string">'account_type'</span>)</span><br><span class="line">&lt;QuerySet [(<span class="string">'Jane Doe'</span>, <span class="string">'G'</span>), (<span class="string">'James Smith'</span>, <span class="string">'R'</span>), (<span class="string">'Jack Black'</span>, <span class="string">'P'</span>)]&gt;</span><br></pre></td></tr></table></figure><h3 id="条件聚合"><a href="#条件聚合" class="headerlink" title="条件聚合"></a>条件聚合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Create some more Clients first so we can have something to count</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.create(</span><br><span class="line"><span class="meta">... </span>    name=<span class="string">'Jean Grey'</span>,</span><br><span class="line"><span class="meta">... </span>    account_type=Client.REGULAR,</span><br><span class="line"><span class="meta">... </span>    registered_on=date.today())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.create(</span><br><span class="line"><span class="meta">... </span>    name=<span class="string">'James Bond'</span>,</span><br><span class="line"><span class="meta">... </span>    account_type=Client.PLATINUM,</span><br><span class="line"><span class="meta">... </span>    registered_on=date.today())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.create(</span><br><span class="line"><span class="meta">... </span>    name=<span class="string">'Jane Porter'</span>,</span><br><span class="line"><span class="meta">... </span>    account_type=Client.PLATINUM,</span><br><span class="line"><span class="meta">... </span>    registered_on=date.today())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Get counts for each value of account_type</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.aggregate(</span><br><span class="line"><span class="meta">... </span>    regular=Count(<span class="string">'pk'</span>, filter=Q(account_type=Client.REGULAR)),</span><br><span class="line"><span class="meta">... </span>    gold=Count(<span class="string">'pk'</span>, filter=Q(account_type=Client.GOLD)),</span><br><span class="line"><span class="meta">... </span>    platinum=Count(<span class="string">'pk'</span>, filter=Q(account_type=Client.PLATINUM)),</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line">&#123;<span class="string">'regular'</span>: <span class="number">2</span>, <span class="string">'gold'</span>: <span class="number">1</span>, <span class="string">'platinum'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>non_unique_account_type = Client.objects.filter(</span><br><span class="line"><span class="meta">... </span>    account_type=OuterRef(<span class="string">'account_type'</span>),</span><br><span class="line"><span class="meta">... </span>).exclude(pk=OuterRef(<span class="string">'pk'</span>)).values(<span class="string">'pk'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Client.objects.filter(~Exists(non_unique_account_type))</span><br></pre></td></tr></table></figure><ul><li><code>OuterRef()</code>的作用类似于<code>F()</code></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://docs.djangoproject.com/en/dev/ref/models/conditional-expressions/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/dev/ref/models/conditional-expressions/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;620&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django-Chapter3-Aggregation</title>
    <link href="http://yoursite.com/2020/08/16/Django-Chapter3-Aggregation/"/>
    <id>http://yoursite.com/2020/08/16/Django-Chapter3-Aggregation/</id>
    <published>2020-08-16T07:18:24.832Z</published>
    <updated>2020-08-16T07:18:58.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>934</code>字，推荐阅读时间<code>10~15</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>用于不同对象的<strong>组合信息</strong>查询</p></li><li><p>小节基础模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line">    pages = models.IntegerField()</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">10</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    rating = models.FloatField()</span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br><span class="line">    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)</span><br><span class="line">    pubdate = models.DateField()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line">    books = models.ManyToManyField(Book)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Cheat-sheet"><a href="#Cheat-sheet" class="headerlink" title="Cheat sheet"></a>Cheat sheet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Total number of books.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.count()</span><br><span class="line"><span class="number">2452</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Total number of books with publisher=BaloneyPress</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.filter(publisher__name=<span class="string">'BaloneyPress'</span>).count()</span><br><span class="line"><span class="number">73</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Average price across all books.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.all().aggregate(Avg(<span class="string">'price'</span>))</span><br><span class="line">&#123;<span class="string">'price__avg'</span>: <span class="number">34.35</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Max price across all books.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Max</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.all().aggregate(Max(<span class="string">'price'</span>))</span><br><span class="line">&#123;<span class="string">'price__max'</span>: Decimal(<span class="string">'81.20'</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Difference between the highest priced book and the average price of all books.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> FloatField</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.aggregate(</span><br><span class="line"><span class="meta">... </span>    price_diff=Max(<span class="string">'price'</span>, output_field=FloatField()) - Avg(<span class="string">'price'</span>))</span><br><span class="line">&#123;<span class="string">'price_diff'</span>: <span class="number">46.85</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># All the following queries involve traversing the Book&lt;-&gt;Publisher</span></span><br><span class="line"><span class="comment"># foreign key relationship backwards.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Each publisher, each with a count of books as a "num_books" attribute.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="string">'book'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs</span><br><span class="line">&lt;QuerySet [&lt;Publisher: BaloneyPress&gt;, &lt;Publisher: SalamiPress&gt;, ...]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].num_books</span><br><span class="line"><span class="number">73</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Each publisher, with a separate count of books with a rating above and below 5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>above_5 = Count(<span class="string">'book'</span>, filter=Q(book__rating__gt=<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>below_5 = Count(<span class="string">'book'</span>, filter=Q(book__rating__lte=<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(below_5=below_5).annotate(above_5=above_5)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].above_5</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].below_5</span><br><span class="line"><span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The top 5 publishers, in order by number of books.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="string">'book'</span>)).order_by(<span class="string">'-num_books'</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].num_books</span><br><span class="line"><span class="number">1323</span></span><br></pre></td></tr></table></figure><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ul><li><p>对<code>QuerySet</code>使用<code>.aggregate()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.all().aggregate(Avg(<span class="string">'price'</span>))</span><br><span class="line">&#123;<span class="string">'price__avg'</span>: <span class="number">34.35</span>&#125;</span><br><span class="line"><span class="comment"># identical</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.aggregate(Avg(<span class="string">'price'</span>))</span><br><span class="line">&#123;<span class="string">'price__avg'</span>: <span class="number">34.35</span>&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以自定义返回的域名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.aggregate(average_price=Avg(<span class="string">'price'</span>))</span><br><span class="line">&#123;<span class="string">'average_price'</span>: <span class="number">34.35</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回多个组合结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg, Max, Min</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.aggregate(Avg(<span class="string">'price'</span>), Max(<span class="string">'price'</span>), Min(<span class="string">'price'</span>))</span><br><span class="line">&#123;<span class="string">'price__avg'</span>: <span class="number">34.35</span>, <span class="string">'price__max'</span>: Decimal(<span class="string">'81.20'</span>), <span class="string">'price__min'</span>: Decimal(<span class="string">'12.99'</span>)&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对<code>QuerySet</code>使用<code>.annotate()</code>作用在<strong>每个实例</strong>上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Build an annotated queryset</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Book.objects.annotate(Count(<span class="string">'authors'</span>))</span><br><span class="line"><span class="comment"># Interrogate the first object in the queryset</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>]</span><br><span class="line">&lt;Book: The Definitive Guide to Django&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].authors__count</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># Interrogate the second object in the queryset</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">1</span>]</span><br><span class="line">&lt;Book: Practical Django Projects&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">1</span>].authors__count</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><p>域名可以自定义，否则默认为<code>FOO_function</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Book.objects.annotate(num_authors=Count(<span class="string">'authors'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].num_authors</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">1</span>].num_authors</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><code>annotate()</code>支持<strong>链式</strong>调用，但是<code>aggregate()</code><strong>不支持</strong>。</p></li><li><p><code>annotate()</code><strong>传入多个参数</strong>时，由于结果叠加，可能会造成错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>book = Book.objects.first()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book.authors.count()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book.store_set.count()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Book.objects.annotate(Count(<span class="string">'authors'</span>), Count(<span class="string">'store'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].authors__count</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].store__count</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Book.objects.annotate(Count(<span class="string">'authors'</span>, distinct=<span class="literal">True</span>), Count(<span class="string">'store'</span>, distinct=<span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].authors__count</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].store__count</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>可以进行域扩展</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Store.objects.aggregate(min_price=Min(<span class="string">'books__price'</span>), max_price=Max(<span class="string">'books__price'</span>))</span><br></pre></td></tr></table></figure></li><li><p>逆向查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg, Count, Min, Sum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Publisher.objects.annotate(Count(<span class="string">'book'</span>))</span><br></pre></td></tr></table></figure><ul><li><p><code>Count()</code>的参数是<strong>小写</strong>Model名</p></li><li><p>可以进行域扩展</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Author.objects.annotate(total_pages=Sum(<span class="string">'book__pages'</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>aggregate</code>/<code>annotate</code>&amp;other functions</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.filter(name__startswith=<span class="string">"Django"</span>).aggregate(Avg(<span class="string">'price'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.annotate(num_authors=Count(<span class="string">'authors'</span>)).filter(num_authors__gt=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>highly_rated = Count(<span class="string">'book'</span>, filter=Q(book__rating__gte=<span class="number">7</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Author.objects.annotate(num_books=Count(<span class="string">'book'</span>), highly_rated_books=highly_rated)</span><br></pre></td></tr></table></figure><ul><li><code>Author</code>查询集中的元素都会有<code>num_books</code>和<code>highly_rated_books</code>两个元素</li></ul></li><li><p><code>order_by()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.annotate(num_authors=Count(<span class="string">'authors'</span>)).order_by(<span class="string">'num_authors'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>values()</code>：返回包含<strong>数据字典</strong>对象的<code>QuerySet</code>，<strong>不是</strong>实例。（相当于从数据库中查到了所有的数据并缓存在<code>QuerySet</code>中）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.filter(name__startswith=<span class="string">'Beatles'</span>)</span><br><span class="line">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.filter(name__startswith=<span class="string">'Beatles'</span>).values()</span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'Beatles Blog'</span>, <span class="string">'tagline'</span>: <span class="string">'All the latest Beatles news.'</span>&#125;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">'id'</span>, <span class="string">'name'</span>)</span><br><span class="line">&lt;QuerySet [&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'Beatles Blog'</span>&#125;]&gt;</span><br></pre></td></tr></table></figure><ul><li>将<code>Author</code>中<code>name</code>相同的对象合并为一组进行<code>annotate</code>操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Author.objects.values(<span class="string">'name'</span>).annotate(average_rating=Avg(<span class="string">'book__rating'</span>))</span><br></pre></td></tr></table></figure><blockquote><p>尽管<code>values</code>没有取<code>book</code>域，但是<code>annotate</code>依然可以使用<strong>其他域</strong>的内容。</p></blockquote><ul><li><code>values</code>在<code>annotate</code>之后则需要<strong>手动增加</strong>选择的域</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Author.objects.annotate(average_rating=Avg(<span class="string">'book__rating'</span>)).values(<span class="string">'name'</span>, <span class="string">'average_rating'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>每个<code>Author</code>对象都会增加<code>average_rating</code>域，但是返回的对象中<strong>只有</strong><code>name</code>/<code>average_rating</code>两个域。</p></blockquote></li><li><p>当对象已经默认有排序元素时，需要重新调用<code>order_by</code>避免出现<strong>多要素排序</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Warning: not quite correct!</span></span><br><span class="line">Item.objects.values(<span class="string">"data"</span>).annotate(Count(<span class="string">"id"</span>))</span><br><span class="line"><span class="comment"># correct</span></span><br><span class="line">Item.objects.values(<span class="string">"data"</span>).annotate(Count(<span class="string">"id"</span>)).order_by()</span><br></pre></td></tr></table></figure></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://docs.djangoproject.com/en/dev/topics/db/aggregation/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/dev/topics/db/aggregation/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;934&lt;/code&gt;字，推荐阅读时间&lt;code&gt;10~15&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
  </entry>
  
</feed>

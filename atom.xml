<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-23T12:02:33.435Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Silence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ML-Machine Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/ML-Machine%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/ML-Machine%20Learning%20Note/</id>
    <published>2021-06-23T12:01:39.414Z</published>
    <updated>2021-06-23T12:02:33.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><ul><li><p>当训练集loss小而测试集loss大时，<strong>不一定是</strong>过拟合，也有可能是因为训练集和测试集数据<strong>分布不同</strong>而造成的mismatch.</p></li><li><p>神经网络在训练时会有随机因素影响参数的更新，但是在训练结束后应当具有稳定的输出。</p></li><li><p>数据增强需要根据数据本身的特性进行，例如图像通常会进行左右翻转而<strong>不是</strong>上下翻转。</p></li><li><p>模型训练时遇到的梯度为0的点成为critical point，分为局部最小值、局部最大值和鞍点，其中<strong>鞍点最为常见</strong>。</p><blockquote><p>出现鞍点时，理论上可以通过计算Hessian矩阵的特征值，根据特征值为负的向量来更新参数，但实际操作时由于计算量较大而<strong>不采用</strong>。</p></blockquote></li><li><p><strong>最小化</strong>交叉熵等价于<strong>最大化</strong>似然函数</p><ul><li>交叉熵：衡量两个分布之间的差异</li><li>似然：模型对样本分布的解释力度</li></ul></li></ul><h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><ul><li><p>Naïve Bayes</p><ul><li><p>判别模型&amp;生成模型：<a href="https://www.zhihu.com/question/20446337/answer/256466823" target="_blank" rel="noopener">https://www.zhihu.com/question/20446337/answer/256466823</a></p><blockquote><ul><li>判别模型学习区别，生成模型学习本质。</li><li>判别模型直接对$P(C|x)$进行建模，而生成模型先求$P(C,x)$.</li><li>判别模型力求<strong>经验误差最小化</strong>，生成模型强调<strong>出现概率最大化</strong>。</li></ul></blockquote></li><li><p>“拉普拉斯修正”平滑操作可以避免信息被训练集中未出现的属性值“抹去”</p><blockquote><p>假设属性值与类别均匀分布</p></blockquote></li><li><p>联合概率：包含多个条件且<strong>所有条件同时成立</strong>的概率，记作$P(X=a,Y=b)$或$P(a,b)$.</p></li></ul></li><li><p>参数估计：设$p(x)=f(\theta)$即$x$的概率分布与$\theta$相关</p><ul><li><p>极大似然：$argmax\{P(x|\theta)\}$，取能够使概率值最大的参数$\theta$.</p><blockquote><p>$P(x|\theta)$实际上就是将$\theta$代入假设的分布后得到的函数</p></blockquote></li><li><p>贝叶斯：在$p(x)$分布的基础上，设出第二个参数的分布$g(\theta)$.通过贝叶斯公式估计$g(\theta)$，然后求出期望平均作为$\theta$的估计值，然后再求出$p(x)$</p></li><li><p>最大后验概率：$argmax\{P(x|\theta)P(\theta)\}$，即在极大似然的基础上增加对参数本身概率的考量。（$P(\theta)$是对数据的<strong>主观认识</strong>，即人为设置其概率分布）</p></li></ul></li><li><p>$\hat{y}$在李宏毅老师MOOC中表示<strong>真实值</strong>，而西瓜书中是<strong>预测值</strong>。</p></li></ul><h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><ul><li><p>Logistic Regression是在线性回归的基础上增加了<code>sigmoid</code>函数，解决的是<strong>分类问题</strong>。</p></li><li><p>偏置项用于增强模型的拟合能力：<a href="https://www.zhihu.com/question/305340182/answer/721739423" target="_blank" rel="noopener">https://www.zhihu.com/question/305340182/answer/721739423</a></p><blockquote><p>偏置也可以理解成<strong>阈值</strong>，只有当计算出的值足够大时（大过阈值），才表示决策更加笃定。</p></blockquote></li><li><p>Logistic Regression使用的误差表示方法是<strong>交叉熵</strong>，因为MSE会出现label处梯度为0的情况，不能保证优化参数。</p></li><li><p>$y=w^Tx+b$越大越好的原因：损失函数中想要使$f(y)$在正样本时尽量向<code>1</code>靠近，也就是要求$y$的值尽量大，所以$y$越大则表示样本分类为正的可能性越大。</p><blockquote><p>如果正样本时要求$f(y)$向<code>-1</code>靠近，则$y$的值就应该越小越好。</p></blockquote></li><li><p>通过多个Logistic Regressor的拼接，可以构成神经网络。</p><blockquote><ul><li>本质上是用Logistic Regression来寻找<strong>最好</strong>的特征</li><li>最后的输出层实际上是<code>OvR</code>模型</li></ul></blockquote></li><li><p>softmax的作用：将不同类别的预测值归一化，同时将差异<strong>放大</strong>。</p><p><img src="https://img-blog.csdn.net/20160823161538236" alt="img" style="zoom: 50%;" /></p><blockquote><p>同时将<strong>负</strong>预测值转换为<strong>正值</strong></p></blockquote></li><li><p>梯度下降方法是<strong>提前</strong>将偏微分公式求出，然后带入实际的参数（权值、偏置）进行计算得到梯度值，然后更新参数，例子如下。</p><p><img src="https://www.zhihu.com/equation?tex=%28x_2%29%3D%28x_1%29-%5Ceta+%5Cnabla+f%28x_1%29%3D%286%29-0.2%5Ctimes%2812%29+%3D+%283.6%29%5C%5C" alt="[公式]"></p></li></ul><h2 id="Backpropagation"><a href="#Backpropagation" class="headerlink" title="Backpropagation"></a>Backpropagation</h2><ul><li><p>反向传播是一种高效的计算<strong>损失函数</strong>相对于参数<strong>梯度</strong>的办法</p></li><li><p>参数更新方程：<script type="math/tex">\cases {w_i^2=w_i^1-\Delta w_i \\ \Delta w_i=\eta*\frac{\partial L}{\partial w_i}}</script></p><blockquote><ul><li>更新方向和梯度方向<strong>相反</strong></li><li>存在多种不同的更新方式（优化器）</li></ul></blockquote></li><li><p>$\frac{\partial C}{\partial w_n}=\frac{\partial C}{\partial z}*\frac{\partial z}{\partial w_n}$</p><ul><li>$C$(cost)是某一个样本的预测值和真实值的<strong>距离</strong></li><li>$z$是$w_n$对应神经元的输入值线性回归（<strong>没有</strong>经过激活函数）</li><li>损失函数是多个$C$的累加</li></ul></li><li><p>$\frac{\partial z}{\partial w_n}=x_n$：<code>Forward Pass</code>中，单层神经元的输出对<strong>权重</strong>求导是对应的<strong>输入特征</strong>的值。</p></li><li><p>$\frac{\partial C}{\partial z}$：<code>Backward Pass</code>本质上和正向的<code>Forward Pass</code>相同，即建立一个反向的神经网络进行正常的<strong>预测</strong>计算。</p><ul><li>反向网络中神经元的激活函数是原激活函数的<strong>导函数</strong></li><li>反向网络的激活函数直接和线性回归方程<strong>相乘</strong>，而<strong>不是复合</strong>。</li></ul></li><li><p><code>Sigmoid</code>函数可能导致梯度消失：<strong>输出端</strong>参数收敛，<strong>输入端</strong>参数依然处在随机态。</p></li></ul><h2 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h2><ul><li><p>SVM对噪声敏感</p></li><li><p>硬间隔：$\hat{y}^if(x_i)\geq 1$</p></li><li><p>软间隔：</p><ul><li><p>目标函数：$min\ \frac{||w||_2}{2}+C\Sigma l(\hat{y}^if(x^i)-1)$</p><ul><li><p>$C$：常数，无穷大时<strong>不允许</strong>错误出现，软间隔变为硬间隔。</p></li><li><p>$l(x)$：<code>0/1</code>损失函数，当$x&lt;0$时，取值为1.通常使用<code>hinge loss</code>函数($l(z)=max\{0,1-z\}$)代替</p><blockquote><p><code>hinge loss</code>是$l(x)$的<strong>紧凑上界</strong></p></blockquote></li></ul></li><li><p>约束：$\hat{y}^if(x^i)\geq 1-\epsilon^i(\epsilon^i \geq 0)$</p></li><li>求解<ul><li>拉格朗日乘子法+SMO</li><li>线性SVM：<strong>梯度下降</strong>（间断函数如<code>hinge loss</code>也是可以使用梯度下降进行优化的）</li></ul></li></ul><blockquote><p>在使用<code>hinge loss</code>函数时，$\epsilon ^i=max\{0,1-\hat{y}^if(y^i)\}$，即满足非负约束和大于$1-\hat{y}^if(x^i)$的条件下，令$\Sigma \epsilon^i$尽量小，从而使目标函数最小。</p></blockquote></li><li><p>核函数</p><ul><li>让特征在高维空间<strong>线性可分</strong>，从而得到一个非线性SVM.（普通支持向量机<strong>只能解决线性可分</strong>问题，此时SVM可以处理低维空间线性不可分的数据）</li><li>降低运算量，在计算高维空间的目标函数时不需要真正做变换，只需要计算核函数即可。</li></ul></li><li><p>SVM/SVR学习出的模型都可以表示成<strong>核函数的线性组合</strong>：$h^*(x)=\Sigma\alpha_i K(x,x_i)$</p><ul><li>模型仅与支持向量有关，<strong>不用记录</strong>其他样本。</li><li>偏置项被合并进了支持向量</li></ul></li></ul><h2 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h2><ul><li><p>同样的参数量，深层神经网络比只有一层的感知机性能更好。</p><ul><li>深层神经网络蕴含了“模块化”的思想，例如各层网络进行不同维度的分类。</li><li>因为每个模块的分类功能并不复杂，神经网络需要的训练数据实际上是<strong>更少</strong>的。</li></ul></li><li><p>End-to-end Learning：让流水线上每一个函数自己学习相应的特征</p></li><li><p>训练指南</p><ul><li><p>过拟合的<strong>前提</strong>是训练集的表现很好，如果训练集就没有高性能，那么不叫过拟合。</p></li><li><p>训练集</p><ul><li>更换激活函数<ul><li>ReLU函数可以<strong>防止</strong>梯度消失：有效的神经元是线性的，不会出现极小的梯度。</li></ul></li><li>调整学习率</li></ul></li><li><p>测试集</p><ul><li><p>及时停止训练：根据<strong>验证集</strong>确定时机</p><ul><li><p>验证集(fold 5)&amp;测试集</p><p><img src="https://img-blog.csdn.net/20180206150941131?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hhb2xlaTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><ul><li>验证集用于模型筛选、调优和消融实验</li></ul></li></ul></li><li><p>测试集<strong>仅</strong>用于评估模型性能</p></li><li><p>正则化：正则项有多种形式，例如L1/L2.</p><blockquote><ul><li>正则项中通常<strong>不含</strong>偏置项</li><li>正则化目的是让参数尽量靠近零，某些情况下效果<strong>不如</strong>停止训练显著。</li></ul></blockquote></li><li><p>Dropout：在<strong>训练</strong>过程中<strong>每次</strong>更新参数时，以概率值$p$随机<strong>舍弃</strong>一些神经元。（激活函数以概率$p$输出0）</p><ul><li>rescale：预测时<strong>所有神经元</strong>都会参与，输出是朴素情况$\frac{1}{1-p}$倍，因此需要乘$(1-p)$保证规模正常。</li></ul></li><li><p>inverted dropout：在训练时将<strong>输出缩小</strong>为$(1-p)$，测试时就<strong>不需要</strong>rescale了。</p></li><li><p>Batch Normalization：在激励函数前对数据特征值进行标准化，可以提高模型和性能和学习速度。</p><p><img src="https://pic2.zhimg.com/80/v2-d3ccd01453f215cf3357192debd14489_1440w.png" alt="img" style="zoom:33%;" /></p><ul><li><p>在BN操作外还需要添加<strong>反标准化</strong>，从而使神经网络自行对BN有效性进行判断，即学习参数$\gamma$和$\beta$.</p><p><img src="https://pic3.zhimg.com/80/v2-083ca0bcd0749fd0f236a690b50442e6_1440w.png" alt="img" style="zoom:33%;" /></p></li><li><p>BN操作本质上是使<strong>error surface平滑</strong>，避免模型困在critical point.</p></li></ul></li></ul></li></ul></li><li><p>SGD&amp;标准GD$\Leftrightarrow$标准BP&amp;累计BP，即单个样本&amp;batch中的样本。</p></li></ul><h2 id="Convolutional-Neural-Network"><a href="#Convolutional-Neural-Network" class="headerlink" title="Convolutional Neural Network"></a>Convolutional Neural Network</h2><ul><li>卷积的作用<ul><li>特征的位置对特征的识别没有影响</li><li>特征可能只在原图中的很小一部分</li></ul></li><li>池化的作用<ul><li>缩放原图不影响特征的信息</li></ul></li><li>卷积的本质<ul><li>权重是卷积的<strong>参数</strong></li><li>全连接网络<strong>舍弃</strong>一部分权重</li><li>卷积层之后的神经元<strong>共享</strong>权重</li></ul></li><li>卷积核的叠加：10个$1<em>3</em>3$的卷积核将图像升维到后，下一个卷积核实际上是<strong>三维</strong>的，即$10<em>3</em>3$.此时如果再将图像升维，则需要<strong>多个</strong>三维卷积核。</li><li>特征图中的<strong>一个像素</strong>实际上就是<strong>一个神经元</strong>（<strong>不包括</strong>激活函数）</li><li>二维卷积&amp;三维卷积<ul><li><code>conv2D</code>：可以具有多个通道，但是每个通道是<strong>二维</strong>的，例如图像处理。</li><li><code>conv3D</code>：每个通道是<strong>三维</strong>的，例如CT影像和视频处理。</li></ul></li><li>感受野(receptive field)可以是<strong>长方形</strong>的</li></ul><h2 id="Self-attention"><a href="#Self-attention" class="headerlink" title="Self-attention"></a>Self-attention</h2><ul><li><p>作用：在输入为<strong>序列</strong>时对其进行预处理，即通过考虑整个输入的上下文信息对输入进行处理。</p><blockquote><ul><li>将图片某个像素的多个通道抽象为一个vector，也可以把整张图当作m*n个向量的序列。</li><li>可以在神经网络<strong>隐层</strong>中使用</li><li>现在通常使用self-attention替代RNN</li></ul></blockquote></li><li><p>卷积实际上就是简化的self-attention</p></li><li><p>positional encoding：弥补self-attention没有考虑位置信息的问题</p></li></ul><h2 id="Recurrent-Neural-Network"><a href="#Recurrent-Neural-Network" class="headerlink" title="Recurrent Neural Network"></a>Recurrent Neural Network</h2><ul><li><p>LSTM是采用RNN思想的另一种<strong>网络架构</strong>（并不是神经元）</p></li><li><p>RNN通常<strong>不使用</strong><code>ReLu</code>作为激活函数</p></li><li><p>LSTM中记忆单元存储的值在遗忘门没有打开时，更新操作适合输入流相加，而不是RNN的直接替换，所以能够保证：所有对记忆单元造成了影响的值不会被完全遗忘，从而解决了RNN的梯度消失问题。</p><blockquote><ul><li>梯度消失的本质：距离较远的时间序列的信息难以在参数更新拥有话语权</li><li>LSTM仍然可能出现梯度爆炸，因此学习率通常设置的很小。</li></ul></blockquote></li><li><p>GRU将输入门和遗忘门联系起来（只剩下两个门），降低了参数量。</p></li><li><p>RNN下一状态隐层输出：$h_t = \tanh(W_{ih} x_t + b_{ih} + W_{hh} h_{(t-1)} + b_{hh}) $</p><ul><li><p>需要学习的参数：输入和记忆单元传递使用的权值$W$，两个偏置。</p><p><img src="https://i.loli.net/2021/05/18/1VFZxoh5P6EGjBN.png" alt="image-20210518110154693" style="zoom: 50%;" /></p></li></ul></li></ul><h2 id="Semi-supervised-Learning"><a href="#Semi-supervised-Learning" class="headerlink" title="Semi-supervised Learning"></a>Semi-supervised Learning</h2><ul><li><p>纯半监督学习的测试数据<strong>不是</strong>未标注数据，直推学习(transductive)的<strong>测试数据</strong>就是<strong>未标注数据</strong>。</p></li><li><p>主动学习：逐步扩展有标注数据集（专家协助），力求使用最小的数据量进行训练。</p><blockquote><p>增加了标注数据量，<strong>不属于</strong>半监督学习。</p></blockquote></li><li><p>生成式模型：基于极大似然思想，代表方法为$EM$法.</p><ul><li><p><strong>似然</strong>是用样本推测分布（参数），<strong>概率</strong>是用分布（参数）对样本进行预测。</p></li><li><p><strong>需要先对样本的分布做出假设</strong></p></li><li><p>每个样本既可以是正类，也可以是负类。</p></li><li><p>优化函数：$argmax\ \Sigma (P(x|C1)P(C1)+P(x|C2)P(C2))$</p><blockquote><p>概率值与参数$\theta$有关</p></blockquote></li></ul></li><li><p><code>Low Density</code>假设：在不同类别的分界处出现样本的概率是很小的（非黑即白）</p><ul><li>self-learning：不同于主动学习，模型使用<code>pseudo label</code>进行更新。</li><li>S3VM</li><li>正则化：无标注数据交叉熵（使预测是一个偏态分布）</li></ul><blockquote><p><strong>不</strong>适用于<strong>回归</strong>问题：回归问题的输出是确定值而不是概率，即重新输入模型的值和模型的原输出值相同，因此生成的pseudo value被加入标注数据集<strong>并不能</strong>优化原有参数。</p></blockquote></li><li><p><code>Smoothness</code>假设：相同类别的样本的模型输出应该是相近的</p><ul><li>Cluster</li><li>Graph based</li><li>正则化：无标注数据平滑度（保证联系够紧密的才能分为一类）</li></ul></li></ul><h2 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h2><p>无监督学习通常应用在数据挖掘领域，在没有标签的数据中找寻内在规律并解决问题。</p><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><ul><li><p>聚类可以单独解决一个问题，也可以作为其他方法的<strong>预处理</strong>手段。</p></li><li><p>聚类最常使用的方法：k-means</p><blockquote><p><code>kNN</code>（k近邻）算法：懒惰监督学习，根据输入计算出距离最近的<code>k</code>个训练样本，然后取最多的标签作为预测结果。</p></blockquote></li></ul><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><ul><li><p>通过提取主成分，在丢失<strong>少量信息</strong>的情况下，<strong>大幅度降低</strong>运算复杂度。</p></li><li><p>线性降维方法：通过<strong>线性变换</strong>（矩阵运算）减少特征维数</p></li><li><p>主成分本质上就是原成分构成的一组新基</p><ul><li><p>范数（模长）为1</p></li><li><p>相互正交（协方差为零/不相关）</p></li><li><p>新基是原特征间协方差矩阵的特征向量和原特征的内积，按照特征值大小<strong>降序排列</strong>。</p><blockquote><p>特征值越大，说明该成分对样本特征影响越大（越重要）。</p></blockquote></li></ul></li><li><p>PCA运算在以构造误差$L=||(x-\bar{x})-\hat{x}||_2$<strong>最小化</strong>为目标时，是<strong>线性单隐层</strong>神经网络的<strong>最优解</strong>。(Autoencoder)</p><blockquote><p>PCA的最优解对应<strong>最大特征值</strong>，因此可以使用<strong>梯度下降</strong>求解。（但神经网络中通常无法求得最优解）</p></blockquote></li></ul><h3 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h3><ul><li>也是一种降维压缩的办法，使用不同秩的奇异值矩阵保留不同密度的信息。（秩越大保存的信息越多）</li></ul><p><img src="https://pic2.zhimg.com/80/v2-74f7d2430ace69c9cd6b963eb58a5079_1440w.jpg" alt="img" style="zoom: 25%;" /></p><h3 id="Word-Enbedding"><a href="#Word-Enbedding" class="headerlink" title="Word Enbedding"></a>Word Enbedding</h3><ul><li><p>词向量</p><ul><li><p>基于统计：阅读大量文章，经常一起出现的词所对应的词向量应该有<strong>较高相似度</strong>。</p></li><li><p>基于预测：使用词的上下文信息建立神经网络，例如前一个单词的<strong>独热编码</strong>作为输入来预测下一个单词。此时神经网络的输出是下一个单词各个类别的概率，通过训练使某个词对应的概率最大化，然后将改神经网络的第一个隐层的<strong>输入</strong>作为词向量。</p><blockquote><p>因为相似的词需要得到相似的输出，所以第一个隐层的输入作为词向量可以保证它们的相似度。</p></blockquote></li></ul></li><li><p>涉及到共享权值时，梯度下降更新时需要<strong>减去所有</strong>共享的权值的偏微分与学习率的乘积。</p><blockquote><ul><li>卷积反向传播更新参数<strong>同理</strong></li><li>不可导/多微分反向传播：<a href="https://blog.csdn.net/qq_21190081/article/details/72871704" target="_blank" rel="noopener">https://blog.csdn.net/qq_21190081/article/details/72871704</a></li></ul></blockquote></li><li><p>共享权值的作用</p><ul><li><strong>上下文相同</strong>的单词具有<strong>同样的编码</strong>（即相同的权重）</li><li>减小模型参数量</li></ul></li></ul><h2 id="Explainable-Machine-Learning"><a href="#Explainable-Machine-Learning" class="headerlink" title="Explainable Machine Learning"></a>Explainable Machine Learning</h2><ul><li>Local Explanation：找出数据中对预测起到关键作用的部分<ul><li>设置一个自定义大小、颜色的蒙版，根据不同的摆放位置判断某区域是否关键。</li><li>随机扰动某个pixel，根据结果改变的梯度判断其重要性高低，最终得到salience map.</li></ul></li></ul><h2 id="Attack-ML-Model"><a href="#Attack-ML-Model" class="headerlink" title="Attack ML Model"></a>Attack ML Model</h2><ul><li><p>损失函数&amp;目标函数&amp;性能表现</p><ul><li>Loss Function：目标函数在有约束的条件下<strong>需要最小化</strong>的函数</li><li>Object Function：需要被优化的函数（最大/最小化均可）</li><li>Accuracy/IoU/F1 etc.：供比较的模型的性能指标</li></ul><blockquote><p><strong>Q：为什么不用性能表现作为目标函数？</strong></p><p>A：性能表现是<strong>以数据项为单位</strong>的，粒度过粗。例如100张图片分类任务，模型多次迭代后正确率均在90%左右，实际上这90个正确标签<strong>不一定</strong>是相同的，但是准确率不变，<strong>无法通过</strong>梯度下降对模型进行优化。</p></blockquote></li><li><p>攻击时模型的参数固定，改变的是<strong>输入的样本</strong>。</p><ul><li>通常由梯度下降进行优化<ul><li>损失函数：$L\left(x^{\prime}\right)=-C\left(y^{\prime}, y^{\text {true }}\right)+C\left(y^{\prime}, y^{\text {false }}\right)$<ul><li>$x’$：输入样本</li><li>$y’$：输出结果</li><li>$C$：交叉熵损失函数</li></ul></li><li>目标函数：$x^{*}=\arg \min _{d\left(x^{0}, x^{\prime}\right) \leq \varepsilon} L\left(x^{\prime}\right)$</li></ul></li></ul></li><li>白盒攻击：已知模型结构和参数<ul><li>FGSM(Fast Gradient Sign Method)<ul><li>$x^{*} \leftarrow x^{0}-\varepsilon \Delta x$</li><li>$\Delta x=\left[\begin{array}{c}\operatorname{sign}\left(\partial L / \partial x_{1}\right) \\ \operatorname{sign}\left(\partial L / \partial x_{2}\right) \\ \operatorname{sign}\left(\partial L / \partial x_{3}\right) \\ \vdots\end{array}\right]$only have $+1$ or $-1$</li></ul></li></ul></li><li>黑盒攻击：训练proxy model进行攻击（白盒攻击），然后使用得到的样本攻击黑盒模型。</li><li>被动防御：不修改原始模型，通常在输入模型前增加filter(eg. smoothing/padding/reshape)</li><li>主动防御：类似数据增强，在训练时对模型进行攻击，把有害样本加入训练集对模型进行再次训练。</li></ul><h2 id="Network-Compression"><a href="#Network-Compression" class="headerlink" title="Network Compression"></a>Network Compression</h2><ul><li><p>网络剪枝：在给定数据集上将模型计算过程中多次为0的权值和神经元进行删除，然后将小网络再次训练。（以上过程可迭代）</p><ul><li>实践中，“删除”操作通过将其置为恒0实现。</li></ul><blockquote><p><strong>Q：为什么不直接训练较小的网络？</strong></p><p>A：</p><ul><li>剪枝后的网络结构通常不规则，很难直接构造。</li><li>工程经验表明：小网络很难通过优化取得和大网络剪枝相同的效果。</li></ul></blockquote></li><li><p>知识蒸馏：用小网络去学习大网络的<strong>完整输出</strong>（eg. 各个label的概率分布），和直接用数据训练小网络不同。</p><ul><li>使用<strong>集成学习模型</strong>作为大网络可以有效提高小网络的性能</li><li>在输入softmax层前将概率值除以$T(Temperature)$，避免大网络的输出变为one-hot，即需要和正确标签保持一定的差异。</li></ul></li><li><p>参数量化</p><ul><li>改变数据类型，eg. float32 to float16.</li><li>权值聚类，最终所有的同类权值均取平均值。（类似colormap）<ul><li>可以使用Huffman Coding进一步优化</li></ul></li></ul></li><li><p>调整网络结构（最有效）</p><ul><li><p>在隐层间插入含$K$个神经元的全连接层，通过控制$K$来减少参数量。</p><p><img src="https://i.loli.net/2021/05/18/cq1yjMaveILkTzd.png" alt="image-20210518105034732" style="zoom:50%;" /></p></li><li><p>卷积分解：depthwise+pointerwise</p><p><img src="https://i.loli.net/2021/05/18/WXJ4PCbVIctwEsS.png" alt="image-20210518105117502" style="zoom:50%;" /></p></li><li><p>动态计算</p><ul><li><p>根据环境限制从存储的多个model中选择（内存开销大）</p></li><li><p>在中间层增加分类器直接进行预测（也可以是其他操作）</p><blockquote><p>要求<strong>浅层</strong>网络也要提取<strong>深层</strong>信息，可能对<strong>模型整体性能</strong>造成影响。</p></blockquote></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Basic-Concepts&quot;&gt;&lt;a href=&quot;#Basic-Concepts&quot; class=&quot;headerlink&quot; title=&quot;Basic Concepts&quot;&gt;&lt;/a&gt;Basic Concepts&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当训练集loss小而测试集
      
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter9-数据库新技术</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter9-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter9-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B0%E6%8A%80%E6%9C%AF/</id>
    <published>2021-01-12T10:09:10.953Z</published>
    <updated>2021-01-12T10:12:59.034Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2031</code>字，推荐阅读时间<code>10~15</code>分钟。</p><a id="more"></a><h2 id="数据仓库-Data-Warehouse"><a href="#数据仓库-Data-Warehouse" class="headerlink" title="数据仓库(Data Warehouse)"></a>数据仓库(<code>Data Warehouse</code>)</h2><ul><li><p>支持管理决策过程</p><blockquote><p>不同于数据库提供的<strong>日常业务查询</strong>服务</p></blockquote></li><li><p>面向主题</p><ul><li>从大量的历史数据中提取</li></ul></li><li><p>持久数据集合</p></li><li><p>业务</p><ul><li>OLAP：数据<strong>仓库</strong>联机<strong>分析</strong>处理</li><li>OLTP：数据<strong>库</strong>联机<strong>事务</strong>处理</li></ul></li><li><p>数据仓库系统</p><ul><li><p>数据源</p><ul><li>数据库</li><li>数据文件</li></ul></li><li><p>数据仓库管理工具</p><ul><li><p>数据建模工具：根据主题确定，例如学生就业情况。</p></li><li><p>抽取、转换、装载(<code>ETL</code>)</p></li><li><p>元数据库：描述数据的数据</p><blockquote><p>类似数据库中的数据字典</p></blockquote></li></ul></li><li><p>数据仓库</p><ul><li>高度综合数据：准决策数据</li><li>轻度综合数据：来自近期基本数据</li><li>当前数据：最近时期业务数据</li><li>历史数据：早期基本数据</li></ul></li><li><p>分析工具</p><ul><li>用户查询工具</li><li>OLAP工具</li><li>DM工具</li></ul></li><li><p>比较</p><ul><li><p>数据库</p><p><img src="https://pic4.zhimg.com/80/v2-bdc235fbdd1825c1b67ef7d609f81adb_1440w.jpg?source=1940ef5c" alt="img" style="zoom: 33%;" /></p><ul><li>一种事务处理技术</li><li>表格结构复杂，存储结构紧致，冗余数据少。</li><li>读写均进行优化</li><li>查询要求较简单，单次作用的数据量小。</li><li>常见：MySQL, Oracle, SqlServer.</li></ul></li><li><p>数据仓库</p><p><img src="https://pic4.zhimg.com/80/v2-ccefb7a678de237560cc4df80c11cca3_1440w.jpg?source=1940ef5c" alt="img" style="zoom:33%;" /></p><ul><li>一种体系结构</li><li>表格结构简单，存储结构松散，冗余数据多。</li><li>通常只优化读</li><li>查询要求较复杂，单次作用的数据量大。</li><li>常见：AWS Redshift, Hive.</li></ul><blockquote><ul><li>数据仓库是为某种特定的查询而设置的，是对数据库中多张表的整合，因此可以承担相应的分析工作。</li><li>数据仓库来自于“分析型数据库”，但也因此不满足数据库的一些规范，所以被改叫“数据仓库”。</li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="分布式数据库系统"><a href="#分布式数据库系统" class="headerlink" title="分布式数据库系统"></a>分布式数据库系统</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>基础：网络+数据库</p></li><li><p>结构</p><ul><li>全局应用=局部应用+网络，操作<strong>两个及以上</strong>节点中的数据库。</li><li>局部应用=数据库+服务器，操作<strong>一个</strong>节点中的数据库。</li></ul><blockquote><p>结构必须完整，缺一不可。</p></blockquote></li><li><p>前提：数据分布存储</p><ul><li>场地自治性</li><li>场地协作性</li></ul></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>数据独立性<ul><li>逻辑</li><li>物理</li><li><strong>分布</strong>（分布透明性）：数据的存储特征（分片、位置等）和用户/应用程序无关</li></ul></li><li>控制结构：集中和自治相结合<ul><li>共享<ul><li>局部</li><li>全局</li></ul></li></ul></li><li>适当增加数据冗余：在不同节点存储同一数据的多个副本<ul><li>提高系统可靠性、可用性</li><li>提高系统性能</li><li>不利于更新，增大了系统维护代价。</li></ul></li><li>全局一致性、可串行性、可恢复性</li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">全局外模式--&gt;|映象1|全局概念模式</span><br><span class="line">全局概念模式--&gt;|映象2|分片模式</span><br><span class="line">分片模式--&gt;|映象3|分布模式</span><br><span class="line">分布模式--&gt;|映象4|局部概念模式</span><br></pre></td></tr></table></figure><ul><li>全局概念模式定义了数据库的整体逻辑结构</li><li>分片模式定义了数据库关系的全局关系的分片方式</li><li>分布模式定义了各片段的存储位置，进而决定了数据库是否冗余。</li><li>各级映像中存储了上级模式到下级模式的映射关系</li></ul><blockquote><p>映象的作用类似虚拟地址和物理地址的转换。例如，映象1为外模式在概念模式中选取合适的部分进行构造；映象2的作用就是为每个关系指定合适的分片方式；映象3则是为每个分片方式确定合适的存储位置（虚拟，类似数据库1、2、3…）；映象4将分布模式中的虚拟存储位置映射到现实中的物理存储位置。</p><p>综上，模式是<strong>“原则/方法/定义”</strong>的集合，映象是集合间的映射关系，通常是在下级映象中进行选择，然后返回结果由上级映象使用。</p></blockquote><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul><li><p>水平：关系模式不变，将元组进行分割。</p></li><li><p>垂直：对属性集合进行划分</p><blockquote><p>为了具有可复原性，<strong>通常</strong>让各个片段都具有原关系的码。（不是必要条件）</p></blockquote></li><li><p>导出：利用其他关系模式的属性对某一关系进行水平分片。</p><blockquote><p>连表后选择，然后再去掉多余属性。</p></blockquote></li><li><p>混合</p></li></ul><h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5><ul><li>完全性：各个片段的并需要涵盖全局关系的所有信息</li><li>不相交性</li><li>可重构性：片段可以重构全局关系<ul><li>水平：并</li><li>垂直：自然连接</li></ul></li></ul><h4 id="分布透明性"><a href="#分布透明性" class="headerlink" title="分布透明性"></a>分布透明性</h4><ul><li><strong>分片</strong>透明性（分片模式）</li><li><strong>位置</strong>透明性（分布模式）</li><li>局部数据模型透明性（局部概念模式）：用户/应用程序不关心节点的DBMS类型（使用统一的查询语言）</li></ul><h4 id="DDBMS"><a href="#DDBMS" class="headerlink" title="DDBMS"></a>DDBMS</h4><ul><li>LDBMS：场地自治，执行局部应用及全局查询的<strong>子查询</strong></li><li>GDBMS：提供分布透明性，保证数据库的全局一致性。<ul><li>协调全局事务的执行</li><li>协调局部DBMS</li><li>并发控制</li><li>更新同步</li><li>全局恢复</li></ul></li><li>GDD<ul><li>全局概念模式、分片模式、分布模式、各级映象</li><li>用户权限定义</li><li>完整性约束条件</li></ul></li><li>CM：通信管理</li></ul><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li>全局控制<strong>集中</strong>：GDD和GDBMS集成在一起<ul><li>控制简单</li><li>易形成<strong>性能</strong>瓶颈</li><li>可靠性低</li></ul></li><li>全局控制<strong>分散</strong><ul><li>完全：GDBMS和GDD分布在<strong>每个</strong>节点上<ul><li>节点独立</li><li>自治性强</li><li>控制复杂</li></ul></li><li>部分：GDBMS和GDD分布在<strong>某些</strong>节点上</li></ul></li><li>同构型：各个节点的DBMS相同</li><li>异构型：各个节点的DBMS不同</li></ul><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5><ul><li>局部</li><li>远程</li><li>全局</li></ul><blockquote><p>局部和远程查询<strong>只</strong>涉及<strong>单个</strong>节点，全局查询涉及<strong>多个</strong>节点。</p></blockquote><h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">查询分解--&gt;确定操作次序</span><br><span class="line">确定操作次序--&gt;选择操作执行方法</span><br></pre></td></tr></table></figure><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>查询开销=I/O代价+CPU代价+通信代价（主要）</p><ul><li><p>分类</p><ul><li><p>分布优化（<strong>更重要</strong>）</p><ul><li><p>传送时间T=总传输延迟（由网络本身决定）+总数据量/传输速度</p><blockquote><p>问答方式中通常会<strong>忽略</strong>传送时间而<strong>只考虑</strong>传输延迟</p></blockquote></li></ul></li><li><p>局部优化</p></li></ul></li><li><p>目标：减小通信代价</p><blockquote><p>通信代价通常来自于不同节点间的<strong>连接和并</strong>操作</p></blockquote></li><li><p>技术</p><ul><li><p>半连接：在连接之前，先对其中某个关系进行所需属性的投影，然后再进行连接。</p><p>$R_3=R_1{\ltimes}_{A=B} R_2=R_1{\bowtie}_{A=B}(\Pi_B(R_2))$</p><ul><li><p>得到的结果是<strong>没有投影</strong>的关系$R_1$的子集</p><blockquote><p>从$R_1$中提取出了<strong>有用</strong>的元组</p></blockquote></li><li><p>$R_1\bowtie R_2=(R_1\ltimes R_2)\bowtie R_2$</p><blockquote><p>连接=半连接+连接=投影+连接+连接</p></blockquote></li><li><p>在使用优化技术之前，需要进行估算。</p></li></ul></li></ul></li><li><p>分布事务处理</p><ul><li><p><code>NewSQL</code></p></li><li><p>原子性：全局事务的子事务要么一起提交，要么全部回滚。</p></li><li><p>可串行性：多用户系统</p></li><li><p>恢复：两段提交协议</p><ul><li>局部事务管理<ul><li>协调者（一个）</li><li>参与者（多个）</li></ul></li><li>第一阶段：协调者征求意见做决定</li><li>第二阶段：参与者执行决定</li></ul></li><li><p>并发控制：封锁技术</p><ul><li><p>写操作需要申请<strong>所有</strong>副本的<code>X</code>锁，读操作<strong>只要</strong>申请一个副本的<code>S</code>锁。</p></li><li><p>读/写操作均对<strong>大多数</strong>副本申请<code>X</code>和<code>S</code>锁</p><blockquote><p>大多数指“<strong>大于</strong>一半”，所以上锁时一定会出现相交情况。</p></blockquote></li><li><p>设置主副本，所有读/写都需要对主副本上锁。</p></li><li><p>全局死锁解决（<strong>两个及以上</strong>场地发生死锁）</p><ul><li>检测及解除</li><li>预防</li></ul></li></ul></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2031&lt;/code&gt;字，推荐阅读时间&lt;code&gt;10~15&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter8-数据库保护</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter8-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E6%8A%A4/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter8-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E6%8A%A4/</id>
    <published>2021-01-12T10:09:10.950Z</published>
    <updated>2021-01-12T10:12:54.182Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>732</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>安全性(<code>security</code>)：防止不合法的使用造成的<strong>数据泄露</strong>、<strong>更改</strong>、<strong>破坏</strong>。</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul><li><p>用户标识和认证（最外层）</p><ul><li>常用：用户名和密码（口令）</li></ul></li><li><p>存取控制</p><ul><li><p>权限定义</p></li><li><p>权限检查</p></li><li><p>方法</p><ul><li><p>自主(<code>DAC</code>)：用户可以将权限转授</p><ul><li><p>权限=数据对象+操作类型</p></li><li><p>SQL</p><ul><li>用户级：操作数据库，例如创建外模式、创建会话、创建表等。</li><li>关系级：操作某个关系和视图，针对具体的对象，例如在某个表中进行CRUD操作。</li></ul></li><li><p>角色：一组权限的集合，可以授给<strong>用户或其他角色</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT CREATE SESSION to xxx; # 用户级</span><br><span class="line">GRANT CREATE TABLE to xxx; # 用户级</span><br><span class="line">REVOKE CREATE TABLE FROM xxx; # 用户级</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>强制(<code>MAC</code>)：不同数据对象有不同的加密等价，每个用户的许可证级别决定了能够访问哪些数据，由系统<strong>直接指定</strong>级别。</p><ul><li>实体=主体+客体</li><li>主体：实际用户</li><li>客体：系统中的被动实体，包括文件、基本表、索引、视图等。</li><li>许可证级别(<code>Label</code>，敏感度标记)<ul><li>主体<strong>大于等于</strong>客体：读</li><li>主体<strong>等于</strong>客体：写</li></ul></li></ul></li></ul></li><li><p>操作系统/网络安全保护</p></li><li><p>数据加密</p></li><li><p>其他</p><ul><li>视图：不同用户有不同的视图</li><li>审计：将用户对数据库的操作记录在审计日志中，出现安全问题时进行审查。</li></ul></li></ul><h3 id="可信系统评测"><a href="#可信系统评测" class="headerlink" title="可信系统评测"></a>可信系统评测</h3><ul><li>TCSEC</li><li>TDI</li></ul><h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>完整性=正确性+相容性<ul><li>正确性：类型、取值范围</li><li>相容性：同一个事实的值应该相同</li></ul></li><li>确保数据库语义正确</li></ul><h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><ul><li>作用对象<ul><li>列：对属性进行约束</li><li>元组：元组间的<strong>字段</strong>约束（属性间约束）</li><li>关系：元组之间、关系之间的约束，例如实体完整性、参照完整性。</li></ul></li><li>时机<ul><li>静态：数据库在每一确定状态应该满足的约束</li><li>动态：新、旧值之间的约束，例如年龄只能上升不能下降。</li></ul></li></ul><blockquote><p>总共可以组合出3*2=6种约束条件</p></blockquote><h3 id="控制-1"><a href="#控制-1" class="headerlink" title="控制"></a>控制</h3><ul><li><p>定义</p></li><li><p>检查</p><ul><li>立即执行：<strong>语句</strong>执行完后立即检查</li><li>延迟执行：<strong>事务</strong>执行完毕后再进行检查</li></ul></li><li><p>违约相应</p></li><li><p>规则：$(D,O,A,C,P)$</p><ul><li><code>D</code>：数据本身</li><li><code>O</code>：操作</li><li><code>A</code>：断言</li><li><p><code>C</code>：<code>A</code>指定的谓词（自然语言约束的主语）</p></li><li><p><code>P</code>：违反规则时触发的过程</p></li></ul></li><li><p>SQL</p><ul><li><p><code>CREATE TABLE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NULL</span><br><span class="line">NOT NULL</span><br><span class="line">UNIQUE</span><br><span class="line">PRIMARY KEY</span><br><span class="line">FOREIGN KEY</span><br><span class="line">CHECK</span><br></pre></td></tr></table></figure></li><li><p><code>CREATE ASSERTION</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSERTION ASSE_NAME</span><br><span class="line">CHECK (60 &gt;&#x3D; ALL(SELECT COUNT(*) FROM SD GROUP BY C));</span><br></pre></td></tr></table></figure></li><li><p><code>CREATE TRIGGER</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;732&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter7-事务处理技术</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter7-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter7-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</id>
    <published>2021-01-12T10:09:10.948Z</published>
    <updated>2021-01-12T10:12:51.194Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2870</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>事务(Transaction)：用户定义的数据库操作序列，这些操作要么一起做，要么都不做，是一个不可分割的<strong>工作单位</strong>。<ul><li>应用程序可以包含<strong>多个</strong>事务</li><li>事务的开始和结束可以由用户显式控制（DBMS也会缺省定义一部分事务划分），从而保证数据的<strong>完整性</strong>。</li></ul></li><li>事务是<strong>数据库恢复</strong>及<strong>并发控制</strong>的基本单位</li></ul><h3 id="特性-ACID"><a href="#特性-ACID" class="headerlink" title="特性(ACID)"></a>特性(ACID)</h3><ul><li><p>原子性</p><ul><li>基础：恢复机制<ul><li>回退，将已经执行的部分进行撤销。</li></ul></li></ul></li><li><p>一致性：事务执行前后数据库均为一致性状态</p><ul><li>基础：原子性</li></ul><blockquote><p>Q：什么是一致性状态</p><p>A：满足数据库约束的状态</p></blockquote></li><li><p>隔离性：并发事务之间不能相互影响</p><ul><li>基础：并发控制机制</li></ul></li><li><p>持久性：事务<strong>提交后</strong>对数据库的改变应该是永久的，故障等情况不应该有影响。</p><ul><li>基础：恢复机制</li></ul></li></ul><blockquote><p><code>ACID</code>里的<code>AID</code>都是数据库的特征,也就是<strong>依赖数据库的具体实现</strong>。而唯独这个C，实际上它依赖于<strong>应用层</strong>，也就是依赖于开发者。做个比喻事务就好比一个保镖，我们提到事务就会说ACID，而我们提到保镖会说强壮、保护安全、好功夫、踏实。这里强壮、好功夫和踏实都是保镖自己的特征，而安全是属于你的，即你通过保镖的特征来保护你的安全。</p></blockquote><h4 id="破坏"><a href="#破坏" class="headerlink" title="破坏"></a>破坏</h4><ul><li><p>事务并行时，不同事务的操作交叉进行。（隔离性）</p><blockquote><p>交叉是指<strong>完整</strong>事务间，而<strong>不是</strong>在某个事务中进行切换。</p></blockquote></li><li><p>事务运行时被强行停止（持久性）</p></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li><p>开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br></pre></td></tr></table></figure></li><li><p>结束</p><ul><li><p>正常结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT</span><br></pre></td></tr></table></figure></li><li><p>非正常结束：撤销全部更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h2><ul><li>从<strong>错误</strong>状态恢复到某一已知<strong>正确</strong>状态</li><li>通过DBMS的<strong>恢复子系统</strong>完成</li></ul><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><ul><li>事务<ul><li>可预期：事务根据<strong>内部</strong>测试条件而触发的回滚</li><li>不可预期：不能由应用程序处理</li></ul></li><li><p>系统</p><ul><li><p>事务异常中断：数据库本身不会受到破坏。</p><blockquote><p>指数据不会丢失，而<strong>不是数据的正确性</strong>。</p></blockquote></li></ul></li><li><p>介质</p><ul><li>数据库本身受到破坏及正在使用这部分数据的相关事务</li></ul></li><li><p>病毒</p><ul><li>对数据进行非法修改</li></ul></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>基本原理：冗余</p></li><li><p>建立冗余</p><ul><li><p>数据转储（备份）</p><ul><li>静态：保证一致性，但是可用性低。</li><li>动态：不影响可用性，不能保证一致性。<ul><li>建立日志文件，在使用副本进行数据库恢复时，需要经过一遍日志处理。</li></ul></li><li>海量：每次转储全部数据库</li><li>增量：每次只转储上一次转储后更新的部分</li></ul></li><li><p>登录日志文件：记录事务对数据库的更新操作</p><ul><li>记录单位：事务驱动</li><li>数据块单位：数据驱动</li></ul><blockquote><ul><li>事务、系统故障必须使用日志文件</li><li>写入规则<ul><li>按照并发事务的时间顺序</li><li><strong>先写</strong>日志文件，<strong>再写</strong>数据库。</li></ul></li></ul></blockquote></li></ul></li></ul><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>事务：UNDO<ul><li><strong>反向</strong>扫描日志，对更新执行逆操作，直到事务开始标志。</li></ul></li><li>系统：UNDO+REDO<ul><li>未完成的事务已经修改了数据库，此时采取<strong>撤销</strong>操作。</li><li>已经提交的事务还留在缓冲区中，没有写入数据库，此时采取<strong>重做</strong>操作。<ul><li><strong>正向</strong>扫描日志，获得撤销队列和重做队列。</li><li>对队列中的事务分别执行<strong>撤销</strong>和<strong>重做</strong>操作</li></ul></li></ul></li><li>介质：REDO<ul><li>装入最新数据库的后备副本</li><li>装入日志文件副本，重做已完成的事务。</li></ul></li></ul><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><ul><li><p>缩小日志文件的检查范围</p></li><li><p>新增“重新开始”文件记录检查点在日志的位置</p></li><li><p>在日志文件增加检查点记录</p><ul><li><p>存储检查点时正在运行的事务清单</p></li><li><p>维护</p><ul><li><p>将<strong>日志缓存</strong>写入磁盘，同时增加一个检查点记录。</p></li><li><p>将<strong>数据缓存</strong>写入磁盘</p><blockquote><p>由此，检查点<strong>之前</strong>的提交的缓存事务<strong>不需要</strong>被加入正在执行的事务清单。</p></blockquote></li><li><p>将检查点记录的地址写入“重新开始”文件</p></li></ul></li><li><p>恢复</p><ul><li><p>从检查点开始进行日志扫描，从而对事务清单进行分类，得到撤销列表和重做列表。</p><blockquote><p>在正向扫描的过程中，可能会存在检查点之后才开始的事务。对于这些事务，一样需要把它们加入<strong>正在执行</strong>的事务清单。</p></blockquote></li><li><p>对两个列表中的事务采取不同操作</p></li></ul></li></ul></li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul><li>利用镜像来维护原始数据库</li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul><li>并发(Concurrency)：<strong>单</strong>处理器，<strong>逻辑</strong>并列。</li><li>并行(Parallel)：<strong>多</strong>处理器，<strong>物理</strong>并列。</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>主要：数据不一致</p><ul><li>丢失更新(Lost Update)：并发事务的结果出现了“不正常”覆盖</li><li>脏数据读出(Dirty Read)：数据处理未完成时被读出</li><li>不能重复读(Non-Repeatable Read)：数据在相邻读之间被更新，导致读操作无法复现。</li></ul><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li>合理调度并发事务，避免事务之间的互相干扰造成数据的不一致。</li></ul><h3 id="基本手段"><a href="#基本手段" class="headerlink" title="基本手段"></a>基本手段</h3><ul><li><p>封锁（上锁）</p></li><li><p>分类</p><ul><li><p>排它锁（<code>X</code>锁、独占锁）：<strong>只允许</strong>上锁事务<strong>读取和修改</strong>数据对象</p></li><li><p>共享锁（<code>S</code>锁）：上锁事务<strong>只能读</strong>数据对象，其他事务能够继续上<code>S</code>锁，但是不能上<code>X</code>锁。</p><blockquote><p>同一个数据对象可以有多个<code>S</code>锁，但是只能有一个<code>X</code>锁，并且两个锁不能同时出现。</p></blockquote></li></ul></li><li><p>相容矩阵</p><p><img src="https://i.loli.net/2020/11/20/VgGK16P2QrdtBqf.png" alt="image-20201120114606476" style="zoom:50%;" /></p></li><li><p>封锁协议：各级协议间是<strong>包含关系</strong>，<strong>不是并列</strong>。</p><ul><li><p>一级：事务在修改数据对象之前必须上<code>X</code>锁，等到<strong>事务结束</strong>后再释放锁。</p><blockquote><ul><li><p>事务结束$\neq$修改完成，因为可能是<strong>非正常结束(ROLLBACK)</strong>。</p></li><li><p>限制写，解决<strong>写间冲突</strong><code>Lost Update</code>；因为没有限制读操作，所以没有解决<strong>读写冲突</strong><code>Dirty Read</code>和<code>Non-Repeatable Read</code>.</p></li><li><p>Q：上了<code>X</code>锁不也限制了其他事务的读吗？</p><p>A：上<code>X</code>锁<strong>并不是不允许</strong>其他事务读，而是限制了其他事务上<code>S</code>锁。因此如果读之前不进行上锁操作，则不会受到<code>X</code>锁的限制，一样能够读到脏数据。</p></li></ul></blockquote></li><li><p>二级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>读完之后</strong>释放。</p><blockquote><p>解决了<code>Dirty Read</code>，但是由于<strong>上锁时间较短</strong>，所以依然可能出现<code>Non-Repeatable Read</code>.</p></blockquote></li><li><p>三级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>事务结束之后</strong>释放。</p><blockquote><p>解决了三种数据不一致问题</p></blockquote></li></ul></li><li><p>粒度：封锁对象的大小（被上锁的对象的大小）</p><ul><li><p>常见封锁对象：属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库、物理页、块等。</p></li><li><p>多粒度封锁：一个系统的封锁机制可以提供多种粒度</p><ul><li><p>多粒度树：根据数据对象及其之间的关系构造的树</p><ul><li><p>显式：锁<strong>直接</strong>加在事务需要的数据对象上 </p></li><li><p>隐式：锁加在事务需要的<strong>数据对象的上级结点</strong>上</p></li><li><p>上锁检查：显式锁和隐式锁都需要检查</p><ul><li>隐式锁需要检查<strong>所有</strong>的上级节点</li></ul><blockquote><p>包括<strong>下级结点的显式锁</strong>（下级结点的隐式锁在对当前结点的检查中就已经被判断了）</p></blockquote></li></ul></li></ul></li></ul></li><li><p>意向锁：表示<strong>下级节点</strong>被上了相应类型的锁（优化多粒度树上锁检查）</p><ul><li><p>在为对象上锁时，需要先对其<strong>所有</strong>上级节点添加意向锁。</p></li><li><p>在为对象解锁时，需要向上逐级为上级节点释放锁。</p><blockquote><p><strong>不能</strong>优化当前结点的<strong>隐式锁</strong>检查</p></blockquote></li><li><p>分类</p><ul><li><p>意向共享锁(<code>IS</code>, Intent Share Lock)</p></li><li><p>意向排它锁(<code>IX</code>, Intent Exclusive Lock)</p></li><li><p>意向共享排它锁(<code>SIX</code>, Share Intent Exclusive Lock)：对该对象加<code>S</code>锁后，再加<code>IX</code>锁。</p><blockquote><p><strong>不是</strong>下级对象的<code>IS</code>和<code>IX</code>的叠加</p></blockquote></li></ul></li><li><p>相容矩阵</p><p><img src="https://i.loli.net/2020/11/20/8KL7aMQVrhPAmRF.png" alt="image-20201120115143845" style="zoom:50%;" /></p><ul><li><p>上了<code>IS</code>后，可以上<code>IX</code>，反之亦然。</p><blockquote><p>意向锁来自不同的结点，所以<code>S</code>和<code>X</code>能够“同时出现”。</p></blockquote></li><li><p>可以多次上<code>IS</code>和<code>IX</code>锁</p></li><li><p>上了<code>IS</code>后，还可以上<code>S</code>和<code>IX</code>变成<code>SIX</code>；但是上了<code>IX</code>之后，<strong>不能</strong>再上<code>S</code>和<code>IX</code>变成<code>SIX</code>了。</p><blockquote><p>上了<code>IX</code>后<strong>不能</strong>再为下级结点隐式上<code>S</code>锁了</p></blockquote></li><li><p>上了<code>SIX</code>之后，还可以上<code>IS</code>，但是不能再上<code>IX</code>了。</p><blockquote><p>因为下级结点已经隐式上了<code>S</code>，不能再上<code>X</code>了。</p></blockquote></li></ul></li></ul></li></ul><h3 id="活锁和死锁"><a href="#活锁和死锁" class="headerlink" title="活锁和死锁"></a>活锁和死锁</h3><ul><li><p>活锁：系统正常运行，但是有些事务可能永远不能得到上锁机会。</p><ul><li>采用<code>FCFS</code>解决</li></ul></li><li><p>死锁</p><ul><li><p>预防</p><ul><li><p>一次封锁法：事务执行前为<strong>所有</strong>需要的资源上锁</p><ul><li>降低系统并发度</li></ul></li><li><p>顺序封锁法：为资源编号，事务执行时必须按照顺序对所需的资源上锁。</p><ul><li>实现难度大</li></ul><blockquote><p>不是按照顺序获取<strong>所有</strong>资源，而是在获取所需对象时按照顺序进行。</p></blockquote></li></ul></li><li><p>检测</p><ul><li>超时法：事务等待时间过长时认为发生死锁</li><li>等待图法：结点表示事务，边指向等待的事务，出现回路则发生死锁。</li></ul></li><li><p>恢复（解除）</p><ul><li><p>选择代价小的事务撤销</p><blockquote><p>撤销后，需要回滚该事务的所有操作</p></blockquote></li></ul></li></ul></li></ul><h3 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h3><ul><li><p>调度的单位是事务的<strong>操作</strong>，而<strong>不是</strong>事务本身。</p></li><li><p>事务执行正确性：保证数据库<strong>一致性</strong>的都是正确的执行结果</p><blockquote><p>不同执行顺序可能有不一样的执行结果（随机性），但可能都是正确的。</p></blockquote></li><li><p>可串行化：事务的并发执行正确$\Leftrightarrow$按照某一次序<strong>串行执行</strong>的结果和<strong>并发执行</strong>结果相同</p><ul><li>可串行化的并发调度是正确调度</li></ul></li><li><p>判定</p><ul><li><p><strong>冲突可串行化</strong>调度：调度$Sc$交换<strong>事务间不冲突</strong>操作的次序后，得到<strong>串行调度</strong>$Sc’$.</p><ul><li>不能交换<strong>事务间</strong>的冲突操作</li><li>不能交换<strong>一个事务内</strong>的操作</li></ul></li><li><p>冲突操作：读-写、写-写</p></li><li><p>充分条件：冲突可串行化调度$\Rightarrow$可串行化调度</p><blockquote><p>冲突可串行化调度$\Rightarrow$可串行化调度$\Rightarrow$正确调度</p></blockquote></li></ul></li><li><p>两段锁协议：保证并发调度可串行</p><ul><li>扩展阶段：读写操作执行前需要上锁</li><li>收缩阶段：开始释放锁之后，事务不再获取其他任何锁。</li></ul><blockquote><p>依然可能发生死锁</p></blockquote></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li><a href="https://www.zhihu.com/question/31346392" target="_blank" rel="noopener">https://www.zhihu.com/question/31346392</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2870&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter6-关系查询处理与查询优化</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter6-%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter6-%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</id>
    <published>2021-01-12T10:09:10.946Z</published>
    <updated>2021-01-12T10:12:47.166Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>448</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>分析</li><li>检查<ul><li>将查询转换为<strong>查询树</strong>（语法分析树）</li></ul></li><li>优化<ul><li>代数：恒等变换</li><li>物理：根据数据规模、分布等确定对应的底层存储策略。</li></ul></li><li>执行</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>查询代价=I/O代价<strong>（主要）</strong>+CPU代价+内存代价</li></ul><h3 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h3><ul><li>变换规则：主要是优化<strong>连接</strong>（笛卡尔积为主）运算。<ul><li>交换律</li><li>结合律</li></ul></li><li>特殊优化：先缩小范围再运算一般效率更高<ul><li>投影、选择的串接：合并操作减小遍历次数</li><li>投影、选择的交换律：先投影再选择</li><li>选择、笛卡尔积的交换律：能先投影时，先投影再作笛卡尔积。</li></ul></li><li>查询树的启发式优化<ul><li>减少<strong>中间</strong>（临时）关系：选择、投影尽可能先做。</li><li>减少扫描次数：投影、选择并行等操作。</li><li>减少操作总数：连接=笛卡尔积+选择</li><li>中间结果复用：使用中间文件存储公共表达式的结果</li></ul></li></ul><h3 id="物理优化"><a href="#物理优化" class="headerlink" title="物理优化"></a>物理优化</h3><ul><li><p>存取路径选择</p><ul><li><p>选择操作</p><ul><li>小关系：全表扫描</li><li>大关系：索引扫描</li></ul></li><li><p>连接操作</p><ul><li><p>排序-合并</p></li><li><p>索引连接：为连接属性建立索引</p></li><li><p>Hash Join：为小表建Hash文件</p></li><li><p>嵌套循环：小表在外层</p><blockquote><p>原因：分配时通常给外表的内存更大</p><ul><li><p>设外表分配$(K-1)$块，内表$1$块。</p><p>$Cost=Cost_{out}+Cost_{in}*\frac{B_{out}}{K-1}$</p></li></ul></blockquote></li></ul></li></ul></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>将查询转换成语法树</li><li>代数优化</li><li>物理优化，确定底层的存储路径</li><li>生成查询计划</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;448&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter5-关系数据理论</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter5-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter5-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</id>
    <published>2021-01-12T10:09:10.944Z</published>
    <updated>2021-01-12T10:12:42.792Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>4341</code>字，推荐阅读时间<code>30~45</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>数据依赖：影响<strong>模式质量</strong>的因素<ul><li>关系内部属性之间的约束关系</li><li>分类<ul><li>函数依赖</li><li>多值依赖</li></ul></li></ul></li><li>范式理论：衡量模式质量的标准</li><li>规范化方法与算法：提升模式质量的办法</li></ul><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>给定属性集$U$，及其子集$X$，$Y$，$R(U)$是其上的<strong>关系模式</strong>（域名元组），$r$是$R$的<strong>任意一个</strong>具体关系（填入了任意的具体内容），$t$，$s$是$r$中<strong>任意</strong>两个元组。</p><ul><li>如果$t[X]=s[X]$，则$t[Y]=s[Y]$.此时称“$X$函数确定$Y$”或“$Y$函数依赖于$X$”，记作$X\rightarrow Y$.</li></ul><blockquote><p>等价定义：对于$X$的每个具体值，$Y$有唯一的值与之对应。</p></blockquote></li><li><p>函数依赖属于<strong>语义</strong>范畴</p></li><li><p>函数依赖具有时间稳定性，<strong>不随</strong>时间改变。</p><blockquote><p><code>r</code>（具体关系）可能会发生变化，但是函数依赖<strong>不会</strong>发生改变。</p></blockquote></li></ul><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>平凡依赖：若$Y\subseteq X$，则$X\rightarrow Y$是平凡依赖。</li><li>非平凡</li><li>决定因素：$X$被称为决定因素</li></ul><h4 id="属性联系"><a href="#属性联系" class="headerlink" title="属性联系"></a>属性联系</h4><ul><li><code>1:1</code>：$X\rightarrow Y,Y \rightarrow X$，即两者<strong>相互决定</strong>。</li><li><code>1:n</code>：<code>n</code>端项($X$)决定<code>1</code>端项($Y$)，即$X\rightarrow Y$.</li><li><code>m:n</code>：两者之间<strong>不存在</strong>函数依赖</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>完全：$X$的<strong>任意</strong>真子集（除空集）都<strong>不能够</strong>确定$Y$，记为$X \rightarrow Y$（箭头上有一个<code>f</code>）。</p></li><li><p>部分：$X\rightarrow Y$（箭头上有一个<code>p</code>）</p></li><li><p>传递：若$X\rightarrow Y(Y\nsubseteq X),Y\rightarrow Z(Z\nsubseteq Y)$，且$Y$<strong>不确定</strong>$X$，则称为$Z$对$X$<strong>传递</strong>函数依赖（箭头上有一个<code>t</code>）。</p><blockquote><ul><li>如果$Y$可以确定$X$，则$Z$对$X$是<strong>直接</strong>依赖（因为可以归为以上三种类型之一，因此<strong>不是</strong>独立的类型）。</li><li>注意传递依赖要求两个函数依赖都是<strong>非平凡</strong>的</li></ul></blockquote></li></ul><h3 id="关系键"><a href="#关系键" class="headerlink" title="关系键"></a>关系键</h3><ul><li>候选码：设$K$是$R<U,F>$（$F$是属性集$U$上的函数依赖<strong>集</strong>）的属性或属性组合，若$U$<strong>完全依赖</strong>于$K$，则称$K$是$R$的候选码。当候选码多于一个时，选定其中一个作为主码。</li><li>性质<ul><li>唯一性</li><li>最小性</li></ul></li><li>属性分类<ul><li>主属性：包含在<strong>任一候选码</strong>中的属性</li><li>非主属性：不包含在任何候选码中的属性</li></ul></li><li>外码：关系模式$R$中的属性或属性组$X$并非$R$的码，但$X$是另一个关系模式的码，则称$X$是$R$的外码。</li></ul><h3 id="逻辑蕴涵"><a href="#逻辑蕴涵" class="headerlink" title="逻辑蕴涵"></a>逻辑蕴涵</h3><ul><li>通过函数依赖集$F$能够推出$X\rightarrow Y$，则称$F$逻辑蕴涵$X\rightarrow Y$.</li><li>$F$的闭包：$F$蕴涵的<strong>全体函数依赖</strong>称为$F$的闭包，记为$F^+$.</li></ul><h3 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h3><ul><li><p>定律（可从蕴涵定义出发证明）</p><p>对$R<U,F>$</p><ul><li><p>自反律：属性集蕴涵其<strong>子集</strong></p></li><li><p>增广率：对属性$Z\subseteq U$，若$X\rightarrow Y$，则$XZ\rightarrow YZ$.</p><blockquote><p>$XZ$：将两个属性组<strong>直接拼接</strong></p></blockquote></li><li><p>传递率</p></li></ul></li><li><p>推论</p><ul><li>合并：若$X\rightarrow Y, X\rightarrow Z$，则$X\rightarrow YZ$.</li><li>伪传递：若$X \rightarrow Y, WY\rightarrow Z$，则$WX\rightarrow Z$.</li><li>分解：若$X\rightarrow Y$且$Z\subseteq Y$，则$X \rightarrow Z$.</li></ul></li><li><p>定理</p><p>$X\rightarrow A_1A_2…A_k \Longleftrightarrow X\rightarrow A_i(i=1,2,…,k)$</p></li><li><p>属性集闭包：$X\subseteq U$，将所有从$X$出发，通过$F$能够导出的<strong>属性的集合</strong>，记为$X_F^+$.</p><ul><li>$K_F^+=U$，即通过主码能够推出全体属性。</li><li>定理：$X\rightarrow Y \Longleftrightarrow Y\subseteq X_F^+$</li></ul></li><li><p>有效性（正确性）：从$F$出发，根据Armstrong公理导出的所有函数依赖一定在$F$蕴涵的<strong>全体函数依赖</strong>中</p></li><li><p>完备性（实用性）：$F^+$一定可以由Armstrong公理系统导出</p><blockquote><p>证明逆否命题：如果$X\rightarrow Y$不能用Armstrong公理从$F$中导出，则它一定不被$F$逻辑蕴涵。（即不属于该函数依赖集合下的关系模式）</p></blockquote></li></ul><blockquote><p>Armstrong公理系统是一种操作$F$的方式，还可以有其他公理系统，<strong>不</strong>影响$F$本身的存在。</p></blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>算法：求$X_F^+$</p><ul><li>以$X$为起始属性集，对其所有<strong>子集</strong>（不只是元素）进行迭代推导。</li><li>属性集在某一次迭代中没有更新或者等于全集$U$时终止算法</li></ul><blockquote><p>闭包表示</p><ul><li>函数依赖闭包$F^+$：<code>{}</code></li><li>属性集闭包$X_F^+$：<strong>直接列举元素</strong>，外层不需要<code>{}</code>或<code>()</code>修饰。</li></ul></blockquote><h3 id="函数依赖集"><a href="#函数依赖集" class="headerlink" title="函数依赖集"></a>函数依赖集</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>对于$F,G$，若$F^+=G^+$，即两者能推出的全体函数依赖相同，则称两者等价。<ul><li>此时称$F$和$G$相互覆盖</li><li>$F^+=G^+\Longleftrightarrow F \subseteq G^+ \Longleftrightarrow G \subseteq F^+$</li></ul></li><li>最小依赖集<ul><li>右部单属性化：$F$中任一函数依赖$X\rightarrow A$，$A$必是单属性。</li><li>函数依赖<strong>左部</strong>没有多余属性：<strong>不存在</strong>部分函数依赖</li><li>没有多余的函数依赖：$F$中<strong>不存在</strong>可以被其他函数依赖导出的函数依赖</li></ul></li></ul><h4 id="极小化"><a href="#极小化" class="headerlink" title="极小化"></a>极小化</h4><ul><li><p>定理：每个函数依赖集$F$<strong>均等价于</strong>一个极小函数依赖集$Fm$</p></li><li><p>算法</p><ul><li><p>对于<strong>右部</strong>是属性集合的函数依赖进行分解，转换为<strong>多个</strong>单属性依赖。</p></li><li><p>对于<strong>左部</strong>是属性集合的函数依赖，对左侧进行消融检查。对于消融后函数依赖不受影响属性，均从左侧属性集中删除<strong>并更新迭代集</strong>。</p><blockquote><p>也可能消融实验后，左部依然是属性组。</p></blockquote></li><li><p>对于<strong>每个函数依赖</strong>做消融检查，如果消融某个依赖后依然可以推导出该函数依赖，则可以将该函数依赖删除<strong>并更新迭代集</strong>。</p><ul><li>算法一：转化为图的连通性判定</li><li>算法二：求该函数依赖左侧属性<strong>新的属性集闭包</strong>，判断是否包含该消融函数依赖的右侧元素。</li></ul></li></ul><blockquote><p>对于算法的2，3步而言，如果消融的顺序不一样，可能会得到不一样的$Fm$，即$Fm$不唯一。</p></blockquote></li></ul><h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><ul><li>目的：消除冗余和异常</li><li>思想：“一事一地”，一个关系只描述一个实体或者实体间的一种联系。</li><li>消除部分函数依赖和传递函数依赖</li></ul><h3 id="范式-Normal-Form"><a href="#范式-Normal-Form" class="headerlink" title="范式(Normal Form)"></a>范式(Normal Form)</h3><ul><li>一个关系满足的某个<strong>指定的约束集</strong></li><li>各级范式联系：$5NF \sub 4NF\sub BCNF \sub 3CNF \sub 2NF \sub 1NF$（反证法）</li><li>规范化：通过<strong>模式分解</strong>将低级范式的关系模式提升到更高的范式等级</li></ul><h4 id="分级"><a href="#分级" class="headerlink" title="分级"></a>分级</h4><ul><li><p>第一范式(1NF)：最低要求，满足的关系被称为<strong>规范化关系</strong>。</p><ul><li>一个关系只包含原子值（属性<strong>不可</strong>再分）</li></ul></li><li><p>第二范式(2NF)</p><ul><li><p>$R\in 1NF$，并且每个<strong>非主属性完全依赖</strong>于码，则称$R\in2NF$.</p></li><li><p><strong>允许主属性部分依赖于码</strong></p><blockquote><ul><li>任一主属性<strong>均部分依赖</strong>于码</li><li>某些所有属性都是主属性，但是码<strong>不是</strong>全体主属性的情况，例如<code>STC(S, T, C)</code>.</li></ul></blockquote></li><li><p>如果$R$的全体属性都是主属性，则$R\in 2NF$.</p></li><li><p>从$1NF$中消除非主属性对码的部分函数依赖即可升级为2NF</p><ul><li>画函数依赖图</li><li>投影分解法（选择部分列）</li></ul></li></ul></li><li><p>第三范式(3NF)</p><ul><li><p>若$R\in2NF$，并且每个<strong>非主属性</strong>都<strong>不传递依赖</strong>于$R$的任何码，则$R\in3NF$.</p><ul><li><p>推论：若非主属性$Z$<strong>部分依赖</strong>于码$X$，则$R\notin 3NF$.</p><blockquote><p>此时$R\notin 2NF$</p></blockquote></li></ul></li><li><p>投影分解法</p></li></ul></li><li><p>BCNF</p><ul><li><p>3NF<strong>没有限制主属性</strong>对码的<strong>部分及传递函数依赖</strong>，依然会在某些情况下带来异常。</p></li><li><p>若$R\in 1NF$，对任意函数依赖$X\to Y$，且$Y\nsubseteq X$时，$X$必含有码，则$R\in BCNF$.</p><blockquote><p>等价定义：BCNF中任意<strong>非平凡</strong>函数依赖的<strong>左部</strong>含有码</p></blockquote></li><li><p>性质（反证法）</p><ul><li><p><strong>所有</strong>非主属性<strong>完全函数依赖</strong>于任一候选码(2NF)</p></li><li><p><strong>所有</strong>主属性<strong>完全函数依赖</strong>于每个<strong>不包含它</strong>的候选码(BCNF)</p></li><li><p><strong>没有</strong>属性<strong>完全函数依赖</strong>于非码的任意属性组(3NF, BCNF)</p><blockquote><p>如果没有完全函数依赖，则不可能有部分函数依赖。</p></blockquote></li><li><p>全码（所有属性一起作为码的关系模式）关系就是BCNF</p></li></ul></li><li><p>BCNF是只考虑函数依赖的<strong>最高标准</strong></p><blockquote><p>和多值依赖对应，不是指保持函数依赖。</p></blockquote></li></ul></li></ul><h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li><p>给定属性组$X$，$Y$，$Z$，满足$Z=U-X-Y$.当给定一组$(x,z)$可以得到一个$Y$的取值集合，若该集合与$X$有关而与$Z$无关，则称$Y$多值依赖于$X$，记为$X\to \to Y$.</p><blockquote><ul><li>即$(x,z)$中$z$任意变化对$Y$的取值集合<strong>没有</strong>影响，由$X$确定了$Y$的一组取值。</li><li>因为一个自变量对应了多个因变量，因此叫做多值依赖而不是函数依赖。</li><li>函数依赖是多值依赖的特殊情况。</li></ul></blockquote></li><li><p>有效性范围</p></li><li><p>现实场景：各个域之间均为多对多关系，即<strong>不能够</strong>提取出函数依赖关系的模式。</p></li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>给定$Z=U-X-Y$</p><ul><li><p>对称性：若$X\to \to Y$，则$X\to\to Z$.</p></li><li><p>若$X\to Y$，则$X\to\to Y$，即函数依赖可以看作多值依赖的特例。</p></li><li><p>平凡：若$X\to\to Y$，且$Z= \phi$.</p><blockquote><p>即$U$只被划分为了$X$和$Y$</p></blockquote></li><li><p>非平凡：若$X\to\to Y$，且$Z\neq \phi$.</p></li></ul><h3 id="第四范式-4NF"><a href="#第四范式-4NF" class="headerlink" title="第四范式(4NF)"></a>第四范式(4NF)</h3><ul><li><p>对任意<strong>非平凡</strong>多值依赖$X\to\to Y(Y\nsubseteq X)$，$X$都含有码，则称$R\in 4NF$.</p><blockquote><p>若关系已经满足BCNF，且所有的多值依赖都是平凡的，则关系也满足4NF.</p></blockquote></li><li><p>意义：降低数据冗余程度，减少修改异常。</p></li></ul><h2 id="模式分解理论"><a href="#模式分解理论" class="headerlink" title="模式分解理论"></a>模式分解理论</h2><ul><li><p>目的：通过模式分解，将关系模式的范式等级提高，同时保有原关系模式的一定信息。</p><blockquote><p>如果不保有信息，分解是没有意义的。因此，所有的分解算法都和性质的保持有关。</p></blockquote></li></ul><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>分解$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>,…,R_n<U_n,F_n>\}$，满足：</p><ul><li><p>$U=\bigcup_{i=1}^n U_i$，且$\forall 1\leq i,j \leq n,U_i\nsubseteq U_j$.</p><blockquote><p>可以相交但<strong>不能</strong>包含</p></blockquote></li><li><p>$F_i$是$F$在$U_i$上的一个投影，即选择了$F^+$中相关属性<strong>都在</strong>$U_i$中($XY\subseteq U_i)$的函数依赖作为$F_i$.（可以只选择一部分，不一定全选）</p></li><li><p>表示</p><p>$\rho=\{R_1&lt;\{Sno,Sdept\},\{Sno \to Sdept\}&gt;,R_2&lt;\{Sno,Mname\},\{Sno \to Mname\}&gt; \}$</p></li></ul><h3 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性"></a>无损连接性</h3><ul><li><p>将分解后的关系模式做<strong>自然连接</strong>得到合成的新关系模式，如果新关系模式中的关系和分解前的原关系模式中的关系逐一相等，则称该分解$\rho$具有无损连接性，记为<strong>无损分解</strong>。</p></li><li><p>判定</p><ul><li><p>算法</p></li><li><p>定理（无损连接性的充要条件）：以分解为两个子模式为例，若$R_1$和$R_2$的共同属性<strong>至少构成二者之一</strong>的候选码，则为无损分解。</p><blockquote><p>扩展为<code>n</code>个子关系模式：将子模式间<strong>两两进行比较</strong>，若<strong>所有</strong>的比较都满足以上条件，则该分解无损连接性。（每一次都是无损连接，则合成后的连接也是无损连接）</p></blockquote></li></ul></li></ul><h3 id="保持函数依赖性"><a href="#保持函数依赖性" class="headerlink" title="保持函数依赖性"></a>保持函数依赖性</h3><ul><li>若$F^+=(\bigcup_{i=1}^nF_i)^+$，即两个函数依赖集等价，则称$\rho$是保持函数依赖性的分解。</li><li>判定：设$G=(\bigcup_{i=1}^nF_i)$，$G\subseteq F^+$一定成立，则只需要判断$F^+\subseteq G$是否成立。<ul><li>$\forall (X\to Y) \in F$，判断$Y$是否属于$X_G^+$.</li><li>对于$F$中的每个函数依赖，判断是否可以从$G$中的函数依赖导出。</li></ul></li></ul><blockquote><p>分解$\rho$可以无损连接性和保持函数依赖性，也可以只满足其中一个，也可以同时都不满足。</p></blockquote><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>规范化过程中采用的投影分解可能不唯一，但是好的无损分解应该无损连接并且保持函数依赖。</li><li>若要保持函数依赖，则最高可能只能到3NF.（BCNF的粒度过小，可能<strong>不保持</strong>函数依赖）</li><li>若要进行无损分解，则可以到达4NF或更高。</li></ul><blockquote><ul><li>模式分解是在求当前模式的“数据等价子集”，在保证<strong>数据完整性（无损连接）</strong>的条件下尽可能地减小单个模式的复杂度，因此某些不影响数据完整性的函数依赖可能被舍弃。</li><li>大多数情况下，3NF是最为合适的规范化等级，因为它是能够无损连接并且保持函数依赖的最高等级。</li></ul></blockquote><h3 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h3><ul><li><p>3NF+函数依赖</p><ul><li><p>对$F$进行<strong>极小化</strong>处理，记为$F$.</p></li><li><p>将<strong>不在</strong>$F$中出现的属性从$U$中删除，记为$U$.</p><blockquote><p>删除了部分元素，所以<strong>不具有</strong>无损连接性。</p></blockquote></li><li><p>若$F$只有一个函数依赖，则$\rho=\{R\}$.</p></li><li><p>对$F$按照<strong>“具有相同左部”</strong>的原则进行分组，由$F_i$求出$U_i$，则$\rho=\{R_1<U_1,F_1>,…R_k<U_k,F_k>\}$为所求。</p></li></ul></li><li><p>3NF+无损连接性+函数依赖</p><p>从<strong>满足保持函数依赖</strong>的分解$\rho$出发，设$X$是$R<U,F>$的码。</p><ul><li><p>若$\exist U_i, X\subseteq U_i$，则$\rho$为所求。</p></li><li><p>否则，令$\tau=\rho \cup\{R^*<X,F_X>\}$，则$\tau$为所求。</p><blockquote><ul><li>$F_X$是以$X$为属性集的函数依赖的投影</li><li>$X_F$是属性$X$蕴涵的属性集</li><li>在满足函数依赖的算法中，删去了<strong>不出现</strong>在$F$中的属性，但是它们是<strong>主属性</strong>，因此通过$X$对无损连接性进行了恢复。</li><li>注意，$\tau$求解时是直接把$R^<em>$并入，而<em>*不是</em></em>把$X$添加进$U_i$.</li></ul></blockquote></li></ul></li><li><p>BCNF+无损连接性</p><p>设$\rho$中$R_i<U_i,F_i>\notin BCNF$</p><ul><li>则$R_i$中存在$X\to A\in F_i^+(A\notin X)$，且$X$不是$R_i$的码（也不含有），则$XA$是$U_i$的真子集，将$R_i$分解为$\sigma=\{S_1,S_2\}$，其中$U_{S_1}=XA$，$U_{S_2}=U_i-\{A\}$.</li></ul><blockquote><p>$A$是<strong>单属性</strong>，而<strong>不是</strong>属性组。</p></blockquote><ul><li><p>使用$\sigma$进行迭代，直到$\sigma \in BCNF$.</p><blockquote><p>相当于逐步分离不符合BCNF的函数依赖</p></blockquote></li></ul></li></ul><h2 id="候选码求解"><a href="#候选码求解" class="headerlink" title="候选码求解"></a>候选码求解</h2><h3 id="单属性"><a href="#单属性" class="headerlink" title="单属性"></a>单属性</h3><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>$L$：<strong>仅</strong>出现在左部</li><li>$R$：<strong>仅</strong>出现在右部</li><li>$N$：两边均未出现</li><li>$LR$：两边均出现</li></ul><blockquote><p>以上是<strong>属性</strong>分类，而不是<strong>属性组</strong>分类。</p><p>例如，$BC\to A$和$C\to B$均成立时，$BC\notin L$.</p></blockquote><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><ul><li>L类属性一定是<strong>所有候选码</strong>中的成员（<strong>强于</strong>主属性）<ul><li>若L类属性能够推出全体属性，则该属性单独作为候选码，且由码的极小性，该候选码唯一，即<strong>主码</strong>为该属性。</li></ul></li><li>R类属性一定<strong>不是</strong>任意候选码成员</li><li>N类属性一定是<strong>所有候选码</strong>中的成员<ul><li>若L和N类属性组成的集合能够推出全体属性，则该属性集是<strong>主码</strong>。</li></ul></li></ul><h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><p>将<strong>单属性依赖</strong>关系模式转换为图$G(U,F)$，其中$F$为有向边集合，表示<strong>单属性</strong>函数依赖。</p><ul><li>关键点（原始点+孤立点）对应的属性必在$R$的任何候选码中</li><li>属性集$X$是$R$的唯一候选码$\Leftrightarrow$X能到达$G$中的任一结点<ul><li>在单属性条件下，即不存在独立回路。</li></ul></li><li>对途中点而言，成为候选码成员$\Leftrightarrow$途中点是独立回路中的结点。</li><li>对于存在独立回路的关系模式而言，候选码=关键属性集+独立回路笛卡尔积中的任意元素。</li></ul><h3 id="多属性"><a href="#多属性" class="headerlink" title="多属性"></a>多属性</h3><ul><li><p>$X=L\cup N，Y=LR$.</p></li><li><p>判断$X$是否可以推出全体属性集，如果不可以的话就从$Y$中取一个并进$X$，然后再次判断。</p></li><li><p>依次迭代取的个数，直到能够推出全体属性。</p><blockquote><ul><li>这是一个穷举算法，取两个不只是在取的第一个的基础上再取，而是遍历所有取两个的情况。</li><li>证明了独立回路存在时，主码$K\neq L\cup N$.</li></ul></blockquote></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>通过最小函数依赖集消除<strong>冗余</strong>联系</li><li>$D=F-F_m$中的函数依赖<strong>不一定</strong>是冗余的，因此除了$F_m$中的函数依赖外，可能$D$中也有需要保留的函数依赖。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;4341&lt;/code&gt;字，推荐阅读时间&lt;code&gt;30~45&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter4-数据库设计</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter4-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter4-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-01-12T10:09:10.942Z</published>
    <updated>2021-01-12T10:12:39.441Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2640</code>字，推荐阅读时间<code>20~25</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><ul><li>直接设计法（手工试凑）<ul><li>高度依赖开发人员经验</li><li>后期维护困难</li><li>移植困难</li><li>难以合作设计</li></ul></li><li>规范设计法<ul><li>将设计过程分为若干个阶段，每个阶段只解决整个设计中的部分问题。<ul><li>需求分析：调查应用环境</li><li>概念结构设计（在三级模式两级映象中<strong>没有</strong>对应的部分）：形成可以<strong>用E-R图</strong>表示的模型</li><li>逻辑结构设计（<strong>概念模型</strong>，即模式、信息世界）：将E-R图转换成DBMS的模式和子模式</li><li>物理结构设计（<strong>数据模型</strong>，即内模式、机器世界）：存储结构（内模式）和存取方法（例如索引）</li><li>数据库实施：建立数据库</li><li>数据库运行和维护</li></ul></li></ul></li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>处理要求</li><li>信息要求</li><li>安全性和完整性要求</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>和用户交流</p></li><li><p>分析、表达用户需求</p><ul><li><p>用<strong>数据流图</strong>表达数据和处理之间的关系</p><ul><li>数据流图(Data Flow Diagram, DFD)：表达系统逻辑功能和数据逻辑流向和逻辑变换<ul><li><strong>自顶向下</strong></li></ul></li></ul></li><li><p>用<strong>数据字典</strong>描述系统中各类数据</p><ul><li><p>数据字典：对数据进行集中的说明，包含数据元素的名字、含义等。</p><ul><li>从数据流图中提取原子数据项</li><li>把有联系的数据项组合为数据组</li></ul><blockquote><p>上述数据字典和在数据库实施阶段的数据字典<strong>不同</strong>，前者可以看作是现实世界的<strong>数据元素表</strong>，后者是数据库系统的组成部分。</p></blockquote></li></ul></li></ul></li></ul><h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><ul><li>概念结构是信息世界的结构，即概念模型。</li></ul><h3 id="E-R法"><a href="#E-R法" class="headerlink" title="E-R法"></a>E-R法</h3><ul><li>描述概念模型</li><li>组成部分<ul><li>E-R图</li><li>转换E-R图为对应的数据模型</li></ul></li></ul><h4 id="E-R图概述"><a href="#E-R图概述" class="headerlink" title="E-R图概述"></a>E-R图概述</h4><ul><li>组成<ul><li>实体（方框）</li><li>属性（椭圆框）</li><li>联系（菱形框）<ul><li>联系也可以有属性，例如学生和课程的选修联系可以拥有成绩属性。</li><li>两个实体型之间可以具有多种联系，例如机器和工人可以有使用、维修两种联系。</li><li>语义扩充<ul><li>存在依赖(<code>E</code>)</li><li>标识依赖(<code>E&amp;I</code>)</li><li>实体的子类（连线上有一个圈）</li></ul></li></ul></li></ul></li></ul><h3 id="E-R图设计"><a href="#E-R图设计" class="headerlink" title="E-R图设计"></a>E-R图设计</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li><p>自顶向下</p></li><li><p>自底向上<strong>（最常用）</strong></p><blockquote><p>自顶向下需求分析，自底向上概念设计。</p></blockquote></li><li><p>逐步扩张：先定义核心概念结构</p></li><li><p>混合策略</p></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>以自底向上为例</p><h5 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h5><ul><li>分类</li><li>聚集：定义某个实体型的组成成分</li><li>概括：定义类型之间的子集联系</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li><p>设计<strong>局部</strong>E-R图</p><ul><li><p>选择局部应用</p></li><li><p>利用数据抽象建立实体模型</p></li><li><p>确定实体之间的联系</p></li><li><p>必要调整（属性上升为实体）</p><ul><li><p>属性规范化（不可分割）：E-R图中属性不能和其他属性有<strong>关系</strong>（包括联系）</p></li><li><p>一个属性不能和多个实体之间有联系</p></li><li><p>属性和实体之间应该是“一对一”或者“多对一”的关系，不能“多对多”或者“一对多”。（即实体的某个属性取值是否确定）</p><blockquote><p>例如学生和课程号可能是“多对多”的关系，因此需要将课程号上升为实体。</p><ul><li>这里的多对多和<strong>实体</strong>之间的多对多不同，后者是靠<strong>联系</strong>体现的。但前者指<strong>取值的个数</strong>，例如存在一个学生有多门课，那么课程号的取值有多个，即一对多。</li></ul></blockquote></li></ul></li></ul></li><li><p>综合<strong>局部</strong>E-R图</p><ul><li><p>集成</p><ul><li>一次集成</li><li>逐步集成：累加</li></ul></li><li><p>消除冲突</p><ul><li><p>属性：类型、取值范围、取值单位</p><blockquote><p>协商讨论</p></blockquote></li><li><p>命名</p><blockquote><p>建立命名表</p></blockquote></li><li><p>结构</p><ul><li><p>同一个对象在不同应用中抽象层次不同，例如一个为实体，在另一个中为属性。</p><blockquote><p>实体上升或属性下降，通常为前者。</p></blockquote></li><li><p>同一个实体在不同应用中描述不同，例如属性个数、次序不同。</p><blockquote><p>取并集</p></blockquote></li><li><p>联系类型不同</p><blockquote><p>根据语义综合</p></blockquote></li></ul></li></ul></li><li><p>消除冗余：集成得到的初步E-R图可能存在<strong>数据冗余</strong>和<strong>联系冗余</strong>，调整过后得到<strong>基本E-R图</strong>。</p><ul><li>分析法<ul><li>重点考察<strong>联系的属性</strong>（可能由其他的属性表示，<strong>不一定成环</strong>）</li></ul></li><li>规范化方法</li></ul><blockquote><p>冗余危害：数据不一致。当某个属性变化时，需要更改所有相关的冗余属性，少改任何一个就会出问题。</p></blockquote></li></ul></li></ul><h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><ul><li><p>把概念模型（E-R图）转换为DBMS支持的数据模型（模式）的过程</p></li><li><p>任务</p><ul><li><p>形成初始关系数据库模式：关系</p><blockquote><p>其他的数据库可能是网状、层次等结构。</p></blockquote></li><li><p>关系模式规范化：特定DBMS支持下的数据模型</p></li><li><p>关系模式优化</p></li><li><p>子模式定义（定义外模式）</p><blockquote><p>模式是很多张表的<strong>规范</strong>（设计表），关系是具体的<strong>数据内容</strong>。</p></blockquote></li></ul></li></ul><h3 id="E-R图与关系模型"><a href="#E-R图与关系模型" class="headerlink" title="E-R图与关系模型"></a>E-R图与关系模型</h3><h4 id="普适转换规则"><a href="#普适转换规则" class="headerlink" title="普适转换规则"></a>普适转换规则</h4><blockquote><p>一个关系模式就是一种<strong>数据模型</strong></p></blockquote><ul><li><p>前提：确定每个关系模式的<strong>码</strong></p></li><li><p>一个实体型转换为一个关系模式</p></li><li><p>一个联系转换为一个关系模式</p><ul><li><p><code>1:1</code>：每个实体的码均是该联系的候选码，任意选择一个作为联系模型的主码即可。</p><blockquote><p><strong>不可以</strong>同时选，因为不满足码的<strong>最小性</strong>。</p></blockquote></li><li><p><code>1:n</code>：关系的码是<strong><code>n</code>端实体</strong>的码</p><blockquote><ul><li><code>n</code>端实体码才有唯一标识作用</li><li><strong>不是<code>n</code>端所有实体码的组合</strong></li></ul></blockquote></li><li><p><code>m:n</code>：关系的码是<strong>两端所有</strong>实体码的组合</p></li></ul><blockquote><ul><li>一般只有<code>n:m</code>关系才有属性，其他的联系都可以整合进属性，例如<code>1:n</code>可以在<code>n</code>端实体增加存放<code>1</code>端的码。</li><li>只选择一端实体的码<strong>不代表</strong>只存储一端实体的属性</li></ul></blockquote></li><li><p>多元联系转换为一个关系模式</p></li><li><p>具有相同的码的关系可以<strong>合并</strong>。例如消耗关系和零件的码都是零件号，就可以合并为一个关系。</p><blockquote><p>合并后可能和概念模型E-R图规范不符，但是在逻辑结构设计环节是合法的。</p></blockquote></li></ul><h4 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h4><p>存在依赖中依赖别的实体的实体</p><ul><li>为每个弱实体创建新的关系</li><li>将<strong>被依赖关系的码</strong>作为新关系的<strong>外码</strong></li><li>新关系的主码是<strong>被依赖实体的码</strong>和<strong>自身部分标识属性</strong>的组合</li></ul><h4 id="超类-子类联系"><a href="#超类-子类联系" class="headerlink" title="超类/子类联系"></a>超类/子类联系</h4><ul><li><p>为超类和每个子类创建单独的关系</p></li><li><p>超类关系中，<strong>包含所有子类共有的属性</strong>，包括<strong>主码</strong>。</p></li><li><p>在超类中选定属性组作为子类的判定符</p></li><li><p>子类关系中，包含超类主码以及子类特有的属性。（<strong>没有</strong>共有属性）</p><blockquote><p>子类使用超类的主码作为自己的主码</p></blockquote></li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul><li>确定范式等级（通常需要达到3NF）</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>模式的合并和分解</li><li>关系模式的分解可以提高存取效率和存储空间的利用率</li></ul><h4 id="水平分解"><a href="#水平分解" class="headerlink" title="水平分解"></a>水平分解</h4><ul><li><p>选取操作</p></li><li><p><code>2-8</code>原则：常使用的部分提取出来作为一个关系</p></li><li><p>数据分片：根据不相交的事务将关系分解为多个子关系</p><blockquote><p>事务：一组相对独立的操作</p></blockquote></li><li><p>恢复：并运算</p></li></ul><h4 id="垂直分解"><a href="#垂直分解" class="headerlink" title="垂直分解"></a>垂直分解</h4><ul><li><p>投影操作</p></li><li><p>将经常使用的属性提取出来作为一个子关系模式</p></li><li><p>垂直分解需要保证<strong>无损连接性</strong>和<strong>保持函数依赖</strong>（能够完全复原关系）</p><blockquote><p>完全复原的必要条件：垂直分解得到的子关系模式保留了主码</p></blockquote></li><li><p>恢复：连表运算</p></li></ul><h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><ul><li>用户需求</li><li>具体DBMS的特点，例如MySQL是<code>CREATE VIEW</code>.<ul><li>根据不同的用户设置不同的列名</li><li>权限管理保证系统的安全性</li><li>降低复杂查询的难度</li></ul></li></ul><h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><ul><li>确定数据库的存储结构（内模式）</li><li>存取方法</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>存放位置<ul><li>冷热数据分开存放</li><li>数据和日志备份放在<strong>不同的磁盘</strong>上</li></ul></li><li>系统配置<ul><li>存储分配参数</li><li>物理优化</li></ul></li></ul><h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul><li><p>索引记录/索引项：索引文件的记录</p><ul><li>索引域：数据文件中属性组的<strong>一个取值</strong></li><li>指针：指向索引域对应的磁盘块地址</li></ul><blockquote><p>在MySQL的底层，在发起查询时会先查找记录索引域的数据区，然后确定是否对索引进行查找。</p></blockquote></li><li><p>分类</p><ul><li>稀疏索引：把所有数据记录按索引值分组，每组设立一个索引项。</li><li>稠密索引：为每个记录设置一个索引项，记录的存放是任意的，但是<strong>索引是有序</strong>的。</li></ul></li><li><p>多级索引</p><ul><li>（排序）二叉树索引</li><li>多叉树索引：每个结点有<code>D</code>个值作为分界点，共<code>(D+1)</code>个指针。</li><li>平衡树索引：限制每个结点放置的关键字和指针最小/最大个数，从而使所有的叶子结点都在一层。</li><li><code>B+</code>树索引（常用）：把树中所有关键字按<strong>递增次序</strong>从左到右安排在叶结点上，并<strong>链接</strong>起来。</li></ul></li><li><p>索引域选择</p><ul><li>经常被查询的属性</li><li>经常作为库函数的参数</li><li>经常作为连接属性</li></ul><blockquote><p>索引并非越多越好</p></blockquote></li></ul><h4 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h4><ul><li><p>将关系中<strong>某个属性组值相同</strong>的记录集中存放在<strong>连续的物理块</strong>中，可以提高查询速度。</p><blockquote><p>就像同学院的同学安排在一栋宿舍楼中</p></blockquote></li><li><p><strong>一个</strong>关系<strong>只能</strong>参与<strong>一个</strong>聚集（一个关系只能被存储一次）</p></li><li><p>选择原则</p><ul><li>经常进行连接操作的关系</li><li>单个关系中经常比较的属性组</li><li>关系<strong>属性组值</strong>重复率高的属性组</li><li>更新操作较多时<strong>不应该</strong>使用聚集方法</li></ul></li></ul><h4 id="HASH文件"><a href="#HASH文件" class="headerlink" title="HASH文件"></a>HASH文件</h4><ul><li><p>通过HASH函数将记录关键字转换成地址，并将这个地址作为<strong>记录</strong>的存储地址。</p></li><li><p>选择原则</p><ul><li><p>关系大小可预知，并且不变。</p><blockquote><p>如果大小会变化，DBMS需要提供对应的动态HASH存取方法。</p></blockquote></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2640&lt;/code&gt;字，推荐阅读时间&lt;code&gt;20~25&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter3-SQL</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter3-SQL/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter3-SQL/</id>
    <published>2021-01-12T10:09:10.939Z</published>
    <updated>2021-01-12T10:15:25.583Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>3006</code>字，推荐阅读时间<code>25~30</code>分钟</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>综合统一</li><li>高度<strong>非过程化</strong>（只注重交互结果，而不是具体的实现）</li><li>面向集合操作</li><li>同一个语法结构可以实现关系代数和关系演算两种使用方式</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>基本表：独立、实际存在的，有对应的实体文件。</p><blockquote><p>在SQL中，一个关系对应一个表。</p></blockquote></li><li><p>导出表：从<strong>一个或多个</strong>基本表导出的表，分为视图(View)和快照(Snapshot).</p><ul><li><p>视图</p><ul><li>虚表，只在数据字典中存储视图的定义。</li><li>视图可以进行CRUD基本操作，也可以用来定义新的视图。</li></ul><blockquote><p>SQL可以直接操作基本表（模式）和导出表（外模式）</p></blockquote></li></ul></li></ul><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q;</span><br></pre></td></tr></table></figure><ul><li><p>从目标表<code>T</code>中选择符合条件<code>Q</code>的目标列<code>C</code></p><blockquote><p><code>WHERE</code>相当于是<code>filter()</code></p></blockquote></li><li><p>表的水平方向：根据检索条件选择<strong>元组</strong>（记录）</p></li><li><p>表的垂直方向：对<strong>目标列</strong>进行投影</p></li></ul><h3 id="投影检索"><a href="#投影检索" class="headerlink" title="投影检索"></a>投影检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT C</span><br><span class="line">FROM T;</span><br></pre></td></tr></table></figure><ul><li><code>DISTINCT</code>删去结果中的重复行</li></ul><h3 id="选取检索"><a href="#选取检索" class="headerlink" title="选取检索"></a>选取检索</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><code>=</code>/<code>&lt;</code>等</li><li><code>AND</code>/<code>OR</code>/<code>NOT</code></li><li><code>()</code></li><li><code>BETWEEN ... AND ...</code></li></ul><blockquote><p><code>WHERE</code>子句<code>Q</code>中出现的列通常会在<code>SELECT C</code>中出现</p></blockquote><h3 id="排序检索"><a href="#排序检索" class="headerlink" title="排序检索"></a>排序检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q</span><br><span class="line">ORDER BY A ASC&#x2F;DESC;</span><br></pre></td></tr></table></figure><ul><li><p><code>ASC</code>：根据<code>A</code>升序（<strong>缺省</strong>）</p></li><li><p><code>DESC</code>：根据<code>A</code>降序</p></li><li><p>多列排序，按照<strong>语句顺序</strong>进行多要素排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S</span><br><span class="line">ORDER BY SD ASC, SA DESC;</span><br></pre></td></tr></table></figure></li><li><p>排序语句通常放在<code>SELECT</code>语句的<strong>最后</strong></p></li></ul><h3 id="连接（连表）检索"><a href="#连接（连表）检索" class="headerlink" title="连接（连表）检索"></a>连接（连表）检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T1, T2</span><br><span class="line">WHERE T1.c1 &#x3D; T2.c2;</span><br></pre></td></tr></table></figure><ul><li><code>c1</code>/<code>c2</code>被称为<strong>连接字段</strong></li><li>本质就是将<code>T1</code>，<code>T2</code>进行<strong>笛卡尔积</strong>操作，然后对新的表的符合条件的元组进行筛选。</li></ul><h4 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT X.SN, X.SA</span><br><span class="line">FROM S X, S Y</span><br><span class="line">WHERE X.SA&gt;Y.SA AND Y.SN&#x3D;&#39;xxx&#39;;</span><br></pre></td></tr></table></figure><ul><li>连接后选取的属性（<code>SELECT</code>选择的属性）中如果有重名属性，<strong>也要加上表名</strong>用以区分。同时，在查询的时候不会被起别名，即返回结果中依然是<code>SN</code>/<code>SA</code>.</li><li>起别名后，原有的<code>S</code><strong>不能够</strong>再使用。</li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S, SC</span><br><span class="line">WHERE S.S &#x3D; SC.S(*);</span><br></pre></td></tr></table></figure><ul><li>单纯使用连接语句可能造成信息丢失，例如没有选课的学生在连接学生表和选课表时会被忽略。</li><li>增加<code>*/+</code>的表中会<strong>增加</strong>万能空行与<strong>另一个表</strong>进行连接</li></ul><h3 id="嵌套检索"><a href="#嵌套检索" class="headerlink" title="嵌套检索"></a>嵌套检索</h3><ul><li>子查询（嵌套查询）：<code>WHERE</code>中包含的另一个查询块<ul><li>普通：与外部查询无关，<strong>可以单独执行</strong>获得一组值。</li><li>相关：把<strong>外查询的值</strong>作为检索的条件值，<strong>不可以</strong>单独执行。</li></ul></li><li>外部查询：包含子查询的语句</li></ul><h4 id="自身嵌套"><a href="#自身嵌套" class="headerlink" title="自身嵌套"></a>自身嵌套</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM s</span><br><span class="line">WHERE S.SA &#x3D; (SELECT SA FROM S WHERE S.SN &#x3D; &#39;xxx&#39;);</span><br></pre></td></tr></table></figure><blockquote><p>嵌套运算的效率<strong>高于</strong>连表运算，空间开销也更低。</p></blockquote><ul><li><p>子查询返回<strong>单值</strong>时可以直接使用<strong>运算符</strong>进行连接</p></li><li><p>子查询返回<strong>一组值</strong>，则需要在子查询结果前加上<code>ANY</code>/<code>ALL</code>.</p><ul><li><p><code>IN</code>可以替代<code>=ANY</code></p></li><li><p><code>NOT IN</code>可以替代<code>!=ALL</code>，<strong>不是</strong><code>!=ANY</code>.</p><blockquote><p><code>!=ALL</code>和<code>!=ANY</code>的区别</p><ul><li><code>!=ALL</code>：当左值和<strong>任意</strong>右值<strong>都不相等</strong>的时候为真</li><li><code>!=ANY</code>：当左值和<strong>某个</strong>右值<strong>不相等</strong>的时候为真</li></ul></blockquote></li><li><p><code>EXISTS</code>：当仅当<strong>子查询</strong>结果为<strong>非空</strong>时为真，即<code>filter()</code>的拓展，可以在<code>filter()</code>中放更加复杂的筛选条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE EXISTS</span><br><span class="line">(SELECT * FROM SC WHERE SC.S&#x3D;S.S AND C&#x3D;&#39;xxx&#39;);</span><br></pre></td></tr></table></figure><blockquote><ul><li>相当于遍历S表中的每一个学生，然后利用学号在SC中进行检索。</li><li><strong>相关</strong>子查询，因为子查询的<code>S</code>不独立。</li><li><code>EXISTS</code>判定的方式决定了<code>SELECT</code><strong>不需要</strong>明确某一列</li></ul></blockquote></li><li><p><code>NOT EXISTS</code>：在子查询结果为<strong>空</strong>时返回真，可以使用<code>NOT EXISTS</code>表示谓词逻辑。</p><ul><li><p>单层<code>NOT EXISTS</code>：即<code>exclude()</code>，排除掉所有满足嵌套条件的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM C</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM SC WHERE SC.C &#x3D; C.S);</span><br></pre></td></tr></table></figure></li><li><p>全称量词$\forall$：$(\forall x)P=\neg(\exist x(\neg P))$</p><ul><li><p>对命题和子命题都取反，把任意变成存在，然后根据等价命题进行SQL语句构造。</p></li><li><p><strong>检索选修所有课程的学生的姓名</strong></p><ul><li><p>$Given\ s,\forall cP(s,c).$</p><p>其中$P(s,c)$表示学生选上了这门课，为了能够返回布尔值，我们使用$EXISTS$语句进行包装。</p><p>将其转换为$Given\ s, \neg\exist c(\neg P(s,c))$（其中$\neg$就是<code>NOT</code>）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM C</span><br><span class="line">     WHERE NOT EXISTS</span><br><span class="line">      (SELECT * FROM SC WHERE SC.S&#x3D;S.S AND SC.C&#x3D;C.C))</span><br></pre></td></tr></table></figure><blockquote><p>命题等价于：不存在没有选修的课程的学生的姓名，即排除没有全部选修的学生。</p></blockquote></li></ul></li><li><p>蕴涵：$p \rightarrow q = \neg p \or q$</p><ul><li><p><strong>检索至少选修了学生S2选修的全部课程的学生学号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT S</span><br><span class="line">FROM SC SCX</span><br><span class="line">WHERE NOT EXISTS # 不存在S2选了但是该学生没选的课程，所以下面是S2选了但是他没选的。</span><br><span class="line">(SELECT * FROM SC SCY</span><br><span class="line">     WHERE SCY.S&#x3D;S2 AND NOT EXISTS ( # 他没有选择这门课</span><br><span class="line">     SELECT * FROM SC SCZ WHERE SCZ.S&#x3D;SCX.S AND SCZ.C&#x3D;SCY.C))</span><br></pre></td></tr></table></figure><ul><li><code>p</code>：S2选修了某门课</li><li><code>q</code>：该学生也要选修这门课</li></ul><blockquote><p>命题等价于：不存在S2选修但是他没有选修的课程</p></blockquote></li></ul></li></ul><blockquote><p>用<code>NOT EXISTS</code>表示谓词逻辑：</p><ul><li>使用纯数理逻辑进行推导，但是对于谓词过多的情况可能出现问题。</li><li><strong>把命题改写成“不存在…”的形式，然后逐层使用<code>NOT EXISTS</code>.</strong></li></ul></blockquote></li></ul></li></ul><h3 id="并、差、交检索"><a href="#并、差、交检索" class="headerlink" title="并、差、交检索"></a>并、差、交检索</h3><p>操作对象必须是<strong>相容</strong>的：有相同的属性列。</p><ul><li><p>UNION</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c1&#39;</span><br><span class="line">UNION</span><br><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c2&#39;;</span><br></pre></td></tr></table></figure></li><li><p>MINUS</p></li><li><p>INTERSECT</p></li></ul><h3 id="库函数检索"><a href="#库函数检索" class="headerlink" title="库函数检索"></a>库函数检索</h3><ul><li><p><code>COUNT()</code>：按<strong>列值</strong>计数，统计<strong>属性数</strong>。</p><blockquote><p><code>COUNT(*)</code>：对<strong>行</strong>计数，统计<strong>记录数</strong>。</p></blockquote></li><li><p><code>SUM()</code>：对数值列求总和</p></li><li><p><code>AVG()</code>：对数值列求平均</p></li><li><p><code>MAX()</code>：在列中找出最大值</p></li><li><p><code>MIN()</code>：在列中找出最小值</p></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>只能在<code>SELECT</code>和<code>HAVING</code>子句中出现</p></li><li><p>检索学生总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM S;</span><br></pre></td></tr></table></figure></li><li><p>检索选择了课程的学生总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT S)</span><br><span class="line">FROM SC;</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>DISTINCT</code>的位置</p></blockquote></li><li><p>求S4的总分和平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(G), AVG(G)</span><br><span class="line">FROM SC</span><br><span class="line">WHERE SC.S&#x3D;&#39;S4&#39;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组检索"><a href="#分组检索" class="headerlink" title="分组检索"></a>分组检索</h3><p>按<strong>属性列</strong>将记录分组，每组具有某个共同特征，然后对每一组进行<code>SELECT</code>操作。（相当于对记录进行了<strong>打包</strong>）</p><ul><li><p>分组子句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GROUP BY C</span><br><span class="line">[HAVING conditionExpression]</span><br></pre></td></tr></table></figure><ul><li><p><code>WHERE</code>是对<strong>行</strong>进行过滤，去掉不符合条件的行。</p></li><li><p><code>HAVING</code>只能对<strong>分组</strong>进行过滤，必须建立在<code>GROUP BY</code>之上.</p><blockquote><p><code>WHERE-&gt;GROUP BY-&gt;HAVING</code></p></blockquote></li></ul></li><li><p>检索至少选修了三门课的学生学号和选课门数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, COUNT(*)</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY S</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 3;</span><br></pre></td></tr></table></figure><blockquote><p><code>GROUP BY</code>同时影响了<code>SELECT</code>的范围，相当于是<code>FROM SC GROUP BY S</code>.</p></blockquote></li></ul><h3 id="算术表达式值检索"><a href="#算术表达式值检索" class="headerlink" title="算术表达式值检索"></a>算术表达式值检索</h3><ul><li><p>为算术表达式起别名提高可读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT EMPN, BONUS&#x2F;SALARY BS</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><ul><li><p><code>LIKE/NOT LIKE</code>：对字符型列适用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  # &lt;列名&gt; LIKE&#x2F;NOT LIKE &lt;字符串常量&gt;</span><br><span class="line">  SELECT S, SN</span><br><span class="line">FROM S</span><br><span class="line">  WHERE SN LIKE &#39;刘%&#39;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;字符串常量&gt;</code>可包含特殊符号<ul><li><code>%</code>：通配<strong>0或多个</strong>字符</li><li><code>_</code>：通配<strong>单个</strong>字符</li></ul></li></ul></li></ul><h3 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h3><ul><li><p>MySQL目前不支持</p></li><li><p>出现在<code>FROM</code>中的子查询生成的表叫做派生表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, C</span><br><span class="line">FROM SC, (SELECT S, AVG(G) FROM SC GROUP BY S) AS AVG_SC(AVG_S,AVG_G)</span><br><span class="line"># WHERE ...</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><ul><li>基本表：定义、删除、<strong>修改</strong></li><li>视图：定义、删除</li><li>索引：定义、删除</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><code>char(n)</code>：固定长度的字符串</li><li><code>varchar(n)</code>：可变长字符串</li><li><code>numeric(p, q)</code>：定点数共<code>p</code>位，小数点右边<code>q</code>位。</li><li><code>interval</code>：两个<code>date</code>或<code>time</code>类型数据之间的差</li></ul><h3 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;tablename&gt; (&lt;columnname&gt;&lt;datatype&gt;[&lt;columnintegrity&gt;],...);</span><br><span class="line">ALTER TABLE &lt;tablename&gt; (ADD&#x2F;DROP&#x2F;MODIFY);</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li><p>创建学生表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(S CHAR(5) NOT NULL UNIQUE,</span><br><span class="line"> SN CHAR(50) NOT NULL,</span><br><span class="line"> SA INT NOT NULL,</span><br><span class="line"> PRIMARY KEY(S),</span><br><span class="line"> CHECK (SA&gt;&#x3D;18 AND SA&lt;&#x3D;45));</span><br></pre></td></tr></table></figure></li><li><p>修改属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE S ADD SCOME DATE;</span><br><span class="line">ALTER TABLE S MODIFY SA SMALLINT; # modify the data type</span><br></pre></td></tr></table></figure></li><li><p>删除基本表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE S;</span><br></pre></td></tr></table></figure></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>为了对<strong>经常查询的属性</strong>的存取进行<strong>加速</strong>而提出的策略</p><ul><li>索引项：属性组取值</li><li>位置指针：索引对应的记录存储的位置</li><li>索引文件是<strong>排序文件</strong>，进而加快了查找速度。</li></ul><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE][CLUSTER] INDEX &lt;indexname&gt; ON &lt;tablename&gt; (&lt;columnname&gt;[sequence]);</span><br><span class="line">DROP UNIQUE INDEX &lt;indexname&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>CLUSTER</code>：索引项的指针所指的<strong>内存顺序</strong>和<strong>实际数据库</strong>中的顺序是相同的（不常使用）</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX Scno ON SC (S ASC, C DESC);</span><br><span class="line">DROP INDEX Scno ON S;</span><br></pre></td></tr></table></figure><ul><li><p><code>DROP INDEX</code>可以作为<code>ALTER TABLE</code>的子句使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON tablename;</span><br><span class="line">ALTER TABLE tablename DROP INDEX index_name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>视图是一个虚表，属于外模式。</li><li>视图消解(View Resolution)：对视图的操作会被等价的转化为对<strong>基本表</strong>的操作，然后再执行。</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>简化用户操作</li><li>为同样的原始数据提供不同的角度（为一间房子在不同的方向开了窗）</li><li>逻辑独立性（数据的逻辑结构改变时，应用程序对数据的操作不需要改变）</li><li>安全保护（权限管理）</li></ul><h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW &lt;viewname&gt; [&lt;columnname&gt;] AS &lt;subquery&gt; [WITH CHECK OPTION];</span><br><span class="line">DROP VIEW &lt;viewname&gt; [IF EXISTS &lt;viewname&gt;];</span><br></pre></td></tr></table></figure><ul><li><code>WITH CHECK OPTION</code>：让用户只能对视图中的数据进行CRUD，从而保护了数据库中的其他数据。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW CS_Student</span><br><span class="line">AS</span><br><span class="line">SELECT S, SN, SA FROM S</span><br><span class="line">WHERE SD&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure><ul><li><p>在视图上查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S,SA</span><br><span class="line">FROM CS_Student</span><br><span class="line">WHERE SA&lt;20;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><p>单个元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;tablename&gt; (&lt;columnname1&gt;,...) VALUES (&lt;value1&gt;,...);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO S VALUES (&#39;xxx&#39;, &#39;yyy&#39;, &#39;zzz&#39;);</span><br><span class="line">INSERT INTO SC (S, C) VALUES (&#39;xxx&#39;, &#39;yyy&#39;);</span><br></pre></td></tr></table></figure></li><li><p>子查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO DA(SD, Aveage)</span><br><span class="line">SELECT SD, AVG(SA) FROM S GROUP BY SD;</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;tablename&gt; SET &lt;columnname&gt;&#x3D;&lt;expression&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE SC</span><br><span class="line">SET G&#x3D;666</span><br><span class="line">WHERE &#39;CS&#39;&#x3D;(SELECT SD FROM S</span><br><span class="line">           WHERE S.S&#x3D;SC.S);</span><br></pre></td></tr></table></figure><blockquote><p><code>WHERE</code>中可以把常量放在等号<strong>左边</strong></p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;tablename&gt; [WHERE &lt;conditions&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>注意<strong>不是</strong><code>DROP</code></p></blockquote><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><ul><li><p>空值用<code>NULL</code>表示</p><ul><li>不能确定的值</li><li>属性不应该被赋值</li><li>属性值不方便填写</li></ul></li><li><p>属性有<code>NOT NULL</code>或者<code>UNIQUE</code>约束的，以及主属性不能够为<code>NULL</code>.</p><blockquote><p>部分系统允许<code>UNIQUE</code>为空</p></blockquote></li></ul><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li>算数运算：<code>NULL</code></li><li>比较运算：<code>UNKNOWN</code></li><li>逻辑运算：除了<code>False AND NULL</code>和<code>True OR NULL</code>可以确定之外，其余都为<code>UNKNOWN</code>.</li></ul><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><ul><li>使用<code>IS NULL</code>或<code>IS NOT NULL</code>判断</li></ul><h2 id="数据控制"><a href="#数据控制" class="headerlink" title="数据控制"></a>数据控制</h2><ul><li><p>完整性约束</p></li><li><p>事务操作</p></li><li><p>安全控制</p><ul><li><p>授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; TO &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure></li><li><p>收回权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; FROM &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h2><ul><li><p>将SQL的特性和程序设计语言的<strong>过程处理能力</strong>结合起来</p></li><li><p>预编译</p><ul><li>把嵌入在程序中的SQL语句翻译为高级语言源码，然后再编译、链接、执行。</li></ul></li><li><p>实现</p><ul><li><p>区分SQL和高级语言：在SQL语句前加<code>EXEC SQL</code></p></li><li><p>数据库工作单元和程序工作单元之间的通信：通过主变量（主程序语言变量）的值来传递</p></li><li><p>SQL和主语言之间操作方式的协调：通过游标(<code>Cursor</code>)解决，由游标进行记录的操作，然后将结果传递给主变量。</p><blockquote><p>游标时系统开辟的存放SQL执行结果的缓冲区</p></blockquote></li></ul></li><li><p>动态SQL：允许嵌入式语句的某些参数不确定，在运行时动态生成<code>SQL</code>语句。</p></li><li><p>ODBC/JDBC</p><ul><li><p>执行效率相比嵌入式SQL低，但是开发效率高。</p></li><li><p>组件</p><ul><li>应用程序</li><li>驱动程序管理器</li><li>驱动程序</li><li>数据源</li></ul><blockquote><p>不同的数据库提供相同的API接口，通过驱动管理程序即可以实现程序的移植性。</p></blockquote></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;3006&lt;/code&gt;字，推荐阅读时间&lt;code&gt;25~30&lt;/code&gt;分钟&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter2-关系数据库</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-01-12T10:09:10.937Z</published>
    <updated>2021-01-12T10:12:31.040Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1694</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>关系理论建立在集合代数（离散数学）理论之上</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>关系模型的数据结构：关系</p></li><li><p>域(Domain)：一组具有<strong>相同数据类型</strong>的值的集合</p></li><li><p>元组和分量</p><blockquote><p>多个<strong>域</strong>进行笛卡尔积运算可以表示为<strong>二维表</strong></p></blockquote></li><li><p>关系：笛卡尔积$D_1 \times D_2 \times …\times D_n$的<strong>子集</strong>叫做这些域上的关系，用$R(D_1,D_2,…,D_n)$表示。</p><ul><li><p>$R$：关系名</p></li><li><p>$n$：度/目</p></li><li><p><strong>关系二维表</strong></p><ul><li><p>每个列附加一个名称，被称为<strong>属性</strong>(Attribute)。</p><blockquote><p>属性的名字需要<strong>唯一</strong></p></blockquote></li><li><p>关系是元组构成的集合</p></li></ul></li><li><p>关系的列是<strong>同质</strong>的</p></li><li><p>不同的列可以出自同一域（自相关）</p></li><li><p>列的顺序可以互换</p></li><li><p>任何两个元组（行）<strong>不能</strong>完全相同</p></li><li><p>规范性：分量不可再分，即1NF（First Normal Form，第一范式）</p></li></ul></li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>数据结构：关系</p></li><li><p>码</p><ul><li><p>候选码(Candidate Key)：具有<strong>最小性</strong>和唯一标识功能的<strong>属性组</strong></p><ul><li>最小性：指候选码的子集不能够唯一标识当前记录，和候选码的<strong>属性个数</strong>无关。例如候选码A中可能只有一个属性，但是在候选码B中可能有两个其他的属性。</li></ul><blockquote><p>属性组中<strong>可以</strong>只有一个属性</p></blockquote></li><li><p>主码(Primary Key)：简称为码，在多个候选码中选定一个为主码。</p></li></ul></li><li><p>属性</p><ul><li>主属性：<strong>所有候选码</strong>中的属性</li><li>非主属性：<strong>不包含</strong>在任何候选码中的属性</li></ul><blockquote><p>属性<strong>要么为</strong>主属性，<strong>要么为</strong>非主属性。</p></blockquote></li><li><p>关系模式：$R(U,D,dom,F,I)$</p><ul><li><p>$U$：属性名集合</p></li><li><p>$D$：域集合</p></li><li><p>$dom$：属性$\rightarrow$域的映象集合</p></li><li><p>$F$：数据依赖关系集合</p></li><li><p>$I$：完整性约束集合</p></li><li><p>关系是关系模式在<strong>某一时刻</strong>的<strong>状态或内容</strong></p><blockquote><p>关系模式相对稳定，可以理解成<strong>设计表</strong>；关系是动态的，是一张表的<strong>具体内容</strong>。</p></blockquote></li></ul></li></ul><h3 id="语义约束"><a href="#语义约束" class="headerlink" title="语义约束"></a>语义约束</h3><p>前两个是<strong>模型</strong>必须支持的约束条件</p><ul><li><p>实体完整性</p><ul><li><p>主码必须存在，<strong>其中任何一个域</strong>都不能为空。</p><blockquote><p>空：不知道/不存在的值</p></blockquote></li></ul></li><li><p>参照完整性</p><ul><li><p>外部码(Foreign Key)如果有效，则对应的外表必须存在对应记录。</p><blockquote><ul><li>外部码可以是<strong>同一个关系</strong>之间的联系（即同<strong>一张表</strong>中<strong>不同</strong>元组之间的联系）</li><li>外部码可以为空</li><li>外部码可以是<strong>属性组</strong></li></ul></blockquote></li></ul></li><li><p>用户定义完整性</p><ul><li>用户根据特定的应用环境定义的完整性约束条件</li></ul></li></ul><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li><p>集合操作：操作的对象和结果<strong>都是</strong>集合</p></li><li><p>关系运算</p><ul><li>关系代数（代数方式）</li><li>关系演算（逻辑方式）<ul><li>元组关系</li><li>域关系</li></ul></li></ul><blockquote><p>各种运算之间等价，可以相互转换。</p></blockquote></li></ul><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><ul><li><p>常规集合运算：并、差、交、广义笛卡尔积</p><ul><li><p>广义笛卡尔积</p><p>对度为<code>n</code>、<code>m</code>的两个集合，元组数分别为<code>k1</code>、<code>k2</code>，它们笛卡尔积的结果</p><ul><li><p>度为$(n+m)$</p></li><li><p>元组共$k1*k2$个</p></li><li><p>当出现重名属性时，需要进行重命名。</p><blockquote><p>通常使用<code>Tablename.Fieldname</code>的组合进行重命名</p></blockquote></li></ul></li></ul></li><li><p>特殊关系运算：选择、投影、连接、自然连接、除法</p><ul><li><p>选择：在关系R中选择<strong>满足给定条件</strong>的元组，记为$\sigma_F(R)=\{t|t\in R,F(t)=True\}$.</p></li><li><p>投影：从关系中取若干属性列，并删去重复行，组成新的关系，记为$\Pi_A(R)=\{t[A]|t \in R, A \subseteq U\}$.</p></li><li><p>连接：在两个关系的<strong>广义笛卡尔积</strong>中，指定属性<strong>组</strong>$X,Y$，并且选择其中满足条件$\theta$的<strong>元组</strong>并返回<strong>整条组合记录</strong>构成的集合。</p><ul><li><p>$\theta$</p><ul><li><code>=</code>：等值连接</li><li><code>&lt;</code>：小于连接</li><li><code>&gt;</code>：大于连接</li></ul></li><li><strong>一个元组</strong>可能和<strong>多个元组</strong>进行连接</li></ul></li></ul></li><li><p>自然连接（更常用）：在笛卡尔积中选取在<strong>相同属性组列</strong>上<strong>取值相等</strong>的记录，并<strong>去掉重复</strong>的列。</p><ul><li>不能自定义$X,Y$</li><li>不能更换连接条件$\theta$</li></ul></li><li><p>除法：对关系$R(X,Y),S(Z)$，它们的除法记为：</p><p>$R \div S=\{t|t \in \Pi_X(R) \and \forall s\in S \and <t,s> \in R\}$.</p><ul><li>要求$Y,Z$域等价<ul><li>属性数相同</li><li>对应属性出自同样的域</li></ul></li><li>除法$A \div B$的意义就是<strong>A包含了多少个B</strong></li><li>通俗地说，把B认为是组别，除法的意义就是得到A中指定属性满足<strong>同时在B中所有组</strong>的<strong>投影</strong>。</li></ul></li><li><p>运算组合</p><ul><li>从内套外嵌套</li><li>（自然）连接的语义：指定域后跨表查找，同时<strong>保留其他域</strong>。</li><li>除法：解决<strong>“任意”</strong>问题</li><li>先投影再运算效率更高</li></ul></li><li><p>基本运算（可以推出其他运算）</p><ul><li>并</li><li>差</li><li>笛卡尔积</li><li>选择</li><li>投影</li></ul></li></ul><h2 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h2><ul><li>将<strong>谓词演算</strong>应用到关系运算中就是关系演算</li></ul><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul><li>以元组为变量</li><li>基本结构：元组演算表达式$\{t|\Phi(t)\}$表示所有使$\Phi$为真的<strong>元组</strong>集合</li><li>优先级<ul><li>算术比较</li><li>量词($\exists &gt; \forall$)</li><li>逻辑运算符</li></ul></li><li>例子<ul><li>$R1=\{t|R(t) \and t[3] \geq 4\}$：关系R中第三个域大于等于4的元组集合<ul><li>$R(t)$：$t$是关系$R$中的元组</li></ul></li><li>$R2=\{(\exists u)(R(t) \and W(u) \and t[3] &lt; u[3])\}$</li></ul></li></ul><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><ul><li>变量对应元组各个分量的域变量<ul><li>$R(t) \Rightarrow R(x_1,x_2,…x_n)$</li></ul></li><li>例子<ul><li>$R1=\{xyz|R(xyz) \and Z&lt;8 \and x=d\}$</li></ul></li></ul><h2 id="安全约束"><a href="#安全约束" class="headerlink" title="安全约束"></a>安全约束</h2><ul><li>关系代数是安全的，但是关系演算<strong>不一定</strong>安全。</li><li>无限关系：$\{t|\neg R(t)\}$集合有无穷多个元素</li><li>无穷运算：$\forall t(R(t))$，当$t$域无穷时，即为无穷验证运算。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对$\Phi$定义一个有限符号集$DOM(\Phi)$，使$\Phi$中的运算结果和中间过程中产生的元组及其分量均属于$DOM(\Phi)$</li><li>在实现安全约束后，三种运算方式<strong>才是</strong>等价并且可以相互转换的。</li></ul><h2 id="关系数据语言"><a href="#关系数据语言" class="headerlink" title="关系数据语言"></a>关系数据语言</h2><ul><li>核心是查询，所以也称为查询语言。</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>数据定义（描述）语言(DDL)：包括模式DDL、外模式DDL、内模式DDL.</li><li>数据模拟语言(DML)：CRUD<ul><li>联机交互：独立于系统存在</li><li>宿主语言：嵌入在高级语言中</li></ul></li><li>数据控制语言(DCL)：安全性和完整性控制</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>一体化：例如SQL将DDL、DML、DCL的功能集成在一起</li><li>非过程化：用户不需要关注底层的实现细节</li><li>面向集合的存取方式<ul><li>操作对象是一个或多个关系</li><li>操作结果是新的关系</li></ul></li><li>可独立也可嵌套</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1694&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter1-概述</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter1-%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter1-%E6%A6%82%E8%BF%B0/</id>
    <published>2021-01-12T10:09:10.935Z</published>
    <updated>2021-01-12T10:12:26.896Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2102</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="数据管理技术发展"><a href="#数据管理技术发展" class="headerlink" title="数据管理技术发展"></a>数据管理技术发展</h2><ul><li><p>人工管理</p><ul><li><p>数据<strong>不在</strong>计算机上保存</p></li><li><p>程序决定数据的逻辑结构和物理结构，数据与程序之间<strong>不具有独立性</strong>。</p><blockquote><p>要改变数据的结构就要改变程序</p></blockquote></li><li><p>数据面向应用，程序之间<strong>不能共享</strong>数据。</p></li></ul></li><li><p>文件系统</p><ul><li><p>存取方法作为中介出现</p></li><li><p>数据以<strong>文件形式</strong>保存在<strong>外存</strong>上</p></li><li><p>数据的存取以<strong>记录</strong>为单位</p></li><li><p>程序和数据具有<strong>一定的独立性</strong></p></li><li><p>缺点：</p><ul><li>数据冗余度大（因为数据<strong>不能</strong>被程序共享，即不能够同时进行操作，必须创建多个副本），可能带来数据的不一致性。</li><li>数据和程序之间的独立性依然<strong>不</strong>明显，缺乏<strong>逻辑独立性</strong>。（改文件逻辑结构时还要修改程序）</li></ul><blockquote><p>文件系统是<strong>不具弹性</strong>的<strong>无结构</strong>的数据集合，<strong>数据之间</strong>（<strong>不是</strong>程序和数据）是孤立的，不能反映现实世界事物之间的内在联系。</p><ul><li>不具弹性：改变数据的结构就得改程序</li><li>无结构：数据之间孤立</li></ul></blockquote></li></ul></li><li><p>数据库系统</p><ul><li><p>数据结构化：描述数据时，不仅描述数据本身，还要描述数据之间的联系。</p><blockquote><p><strong>数据结构化</strong>是数据库与文件系统的<strong>根本区别</strong></p></blockquote></li><li><p>数据冗余度小，易扩充。</p></li><li><p>数据和程序的独立性<strong>较高</strong></p><ul><li><p>数据独立性</p><ul><li>物理：数据的物理结构改变时，数据的逻辑结构可以不变，从而程序也不用改变。</li><li>逻辑：数据的逻辑结构改变时，程序不用改变。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;局部逻辑结构</span><br><span class="line">局部逻辑结构--&gt;全局逻辑结构</span><br><span class="line">全局逻辑结构--&gt;物理结构</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据库映象：不同结构之间数据的<strong>转换关系</strong></p><p>物理结构发生变化时，可以通过调整数据库映象来确保逻辑结构不变。</p></li><li><p>统一的数据控制功能</p><ul><li><p>安全性控制</p></li><li><p>完整性控制：数据的正确性和相容性</p><blockquote><p>相容性：同一条数据在不同的程序应该是相同的</p></blockquote></li><li><p>并发控制</p></li><li><p>恢复</p></li><li><p>存取单位是数据项</p><p>可以存取一组记录，也可以取一组数据项。</p><blockquote><p>数据项的粒度小于文件</p><p>Q：数据项和记录的区别</p><p>A：数据项是列，记录是行。</p></blockquote></li></ul></li></ul></li></ul><h2 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>集成：本质是数据结构化</li><li>共享</li></ul><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul><li>DBMS</li><li>应用系统</li></ul><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>存储数据</li><li>运行系统</li></ul><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><ul><li>终端用户</li><li>应用程序员</li><li>数据库管理员</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul><li>用于抽象和表示现实世界中的<strong>数据和信息</strong></li><li>层次<ul><li>概念模型（信息模型）</li><li>数据模型（层次、网状、关系模型）</li></ul></li></ul><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">现实世界--&gt;信息世界</span><br><span class="line">信息世界--&gt;机器世界</span><br></pre></td></tr></table></figure><ul><li>信息世界就是<strong>概念</strong>模型：E-R图</li><li>机器世界就是<strong>数据</strong>模型：数据表</li></ul><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><ul><li>基于信息世界的主要概念，表达语义。</li><li>语义表达能力强</li><li>清晰</li><li>最常用的表示方法：E-R法(Entity-Relation)</li></ul><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>实体(Entity)：客观存在并可以<strong>相互区分</strong>的食物，在E-R图中为<strong>矩形</strong>。</p></li><li><p>属性(Attribute)：实体具有的某一<strong>特性</strong>，在E-R图中为<strong>椭圆形</strong>。</p></li><li><p>码(Key)：<strong>唯一</strong>的标识实体的<strong>属性集</strong>（至少一个，最多由属性集大小确定）</p></li><li><p>域(Domain)：某些属性的<strong>取值范围</strong></p></li><li><p>实体型(Entity Type)：表示一类实体(Class)</p><ul><li>用名称和属性集表示</li></ul></li><li><p>联系(Relation)：实体型之间的联系，在E-R图中为<strong>菱形</strong>。</p><ul><li>名称：产品<strong>由</strong>若干零件<strong>构成</strong></li><li>类型<ul><li>一对一(1:1)</li><li>一对多(1:n)</li><li>多对多(m:n)</li></ul></li></ul><blockquote><ul><li>联系可以具有<strong>属性</strong>，例如产品-组装-零件中，组装可以有<strong>零件数</strong>属性。</li><li>联系是有方向的，一对多<strong>不等价于反向</strong>的多对一。</li></ul></blockquote></li></ul><h4 id="E-R"><a href="#E-R" class="headerlink" title="E-R"></a>E-R</h4><ul><li>用E-R图描述现实世界</li><li>将E-R图转换为数据模型</li></ul><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul><li>实体</li><li>属性<ul><li>作为Key的属性<ul><li>在属性下画线，多个属性就都画。</li><li>在无向边上画两条杠</li><li>组合属性作为Key：在两条无向边之间画一条弧之后，在弧上画两条杠。</li></ul></li></ul></li><li>联系：无向边旁需要标注联系的类型（三选一）<ul><li>可能存在<strong>自相联</strong>关系</li><li>三个或多个实体可能通过<strong>一个联系</strong>建立关系</li><li>两个实体之间可能存在多种联系<ul><li>工人使用/维修仪器</li></ul></li></ul></li></ul><h5 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h5><ul><li>存在依赖：<strong>有向边</strong>指向<strong>弱实体</strong>（依赖于其他实体的实体）<ul><li>弱实体是双层框</li></ul></li><li>标识依赖：<strong>有向边</strong>指向<strong>被标识实体</strong>（不能由自己的属性来唯一标识，需要和其他实体的属性组合起来作为Key）</li><li>实体的子类：<strong>无向边</strong>上画一个圆<ul><li>子类是外侧框加两条竖线</li><li>子类的交<strong>不一定</strong>为空</li></ul></li></ul><h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><ul><li>数据结构</li><li>数据操作</li><li>完整性约束</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>描述对象的相关性质</li><li>描述对象之间的联系，如关系模型中的关系。</li><li>数据<strong>静态特征</strong>的描述</li><li>三要素中<strong>最重要</strong>的方面</li></ul><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><ul><li><p>操作及操作规则</p></li><li><p>操作符号、操作规则、操作语言</p><blockquote><p>SQL就是一种操作语言</p></blockquote></li><li><p>数据<strong>动态特征</strong>的描述</p></li><li><p>数据库中主要有<strong>检索和更新</strong>两大类操作</p></li></ul><h4 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h4><ul><li>完整性规则的集合</li><li>模型通用的完整性约束条件</li><li>针对具体数据的特定语义的约束条件</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>层次模型：树<ul><li>最早出现</li><li>有向树，连线表示一对多的联系（包含一对一）。</li><li>结构简单，效率高，但是支持的联系的种类太少（只能直接表示<strong>二元一对多</strong>联系）</li></ul></li><li>网状模型：图<ul><li>有向图，连线表示一对多的联系（包含一对一）。</li><li>结构复杂，效率高。</li></ul></li><li>关系模型：二维表<ul><li>用二维表格表示实体及实体之间的联系</li><li><strong>规范化关系</strong>：每个分量（域）是<strong>不可分割</strong>的数据项，并且不能出现表中套表的情况。</li><li>有数学基础</li></ul></li></ul><h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><ul><li>三级模式<ul><li>外模式</li><li>模式</li><li>内模式</li></ul></li><li>两级映象<ul><li>外模式/模式映象</li><li>模式/内模式映象</li></ul></li><li>优点<ul><li>数据独立性</li><li>简化用户接口</li><li>有利于数据共享（外模式可以相互覆盖）</li><li>利于数据的安全保密</li></ul></li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li><strong>逻辑模式/概念模式</strong></li><li><strong>全体数据</strong>的逻辑结构和特性的描述，例如所有关系模式构成的集合。</li><li><strong>三级模式的核心</strong></li><li>模式描述语言(DDL, Data Description Language)</li></ul><h3 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h3><ul><li><p>个别用户的数据<strong>视图</strong>（与某一应用有关的数据逻辑表示）</p></li><li><p>通常是<strong>模式的子集</strong>（子模式）</p></li><li><p>不同的外模式可以相互覆盖，<strong>一个</strong>应用只能启用<strong>一个</strong>外模式。</p><blockquote><p>外模式和应用是<strong>一对多</strong>的关系</p></blockquote></li><li><p>外模式DDL，通常和应用具有相同的语法。</p></li></ul><h3 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h3><ul><li>存储模式，数据的物理结构和存储方式的描述。</li><li>内模式DDL</li></ul><h3 id="两级映象"><a href="#两级映象" class="headerlink" title="两级映象"></a>两级映象</h3><ul><li>数据<strong>逻辑</strong>独立性：外模式/模式映象</li><li>数据<strong>物理</strong>独立性：模式/内模式映象</li></ul><h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul><li>数据库的定义功能<ul><li>使用DDL语言描述外模式、模式、内模式（源模式）</li></ul></li><li>数据存取功能<ul><li>提供DML(Data Manipulation Language)语言进行CRUD</li></ul></li><li>数据库运行管理<ul><li>并发控制</li><li>存取控制</li><li>完整性</li><li>日志组织和管理</li><li>事务管理</li><li>自动恢复</li></ul></li></ul><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>语言编译处理程序</li><li>系统运行控制程序</li><li>系统建立和维护</li><li>数据字典（数据目录）：由若干个表组成</li></ul><h3 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h3><p>数据库管理员</p><ul><li>建库</li><li>用库</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2102&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Database-Chapter0-概论</title>
    <link href="http://yoursite.com/2021/01/12/Database-Chapter0-%E6%A6%82%E8%AE%BA/"/>
    <id>http://yoursite.com/2021/01/12/Database-Chapter0-%E6%A6%82%E8%AE%BA/</id>
    <published>2021-01-12T10:09:10.932Z</published>
    <updated>2021-01-12T10:11:42.217Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>687</code>字，推荐阅读时间<code>5~7</code>分钟。</p><a id="more"></a><h2 id="数据和信息"><a href="#数据和信息" class="headerlink" title="数据和信息"></a>数据和信息</h2><ul><li>信息是<strong>一种</strong>已经被加工为<strong>特定形式</strong>的数据</li><li>数据是信息的载体，是信息的具体表现形式。</li></ul><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ul><li>对数据进行加工得到信息的过程</li></ul><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><ul><li>数据处理的<strong>基本操作</strong></li><li>数据库技术就是一种数据管理技术<ul><li>提供数据共享</li></ul></li></ul><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><ul><li>建立在DBMS之上，以<strong>数据管理</strong>为<strong>主要功能</strong>的计算机软件系统。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;DBMS</span><br><span class="line">DBMS--&gt;数据库</span><br></pre></td></tr></table></figure><blockquote><p>DBS &gt; DBMS &gt; DB</p><ul><li>DBS包括了<strong>用户/应用程序</strong>构成的交互层</li></ul></blockquote><h3 id="架构-B-S"><a href="#架构-B-S" class="headerlink" title="架构(B/S)"></a>架构(B/S)</h3><ul><li>Browser</li><li>Server<ul><li>Web Server</li><li>DB Server(DBMS location)</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>数据模型</li><li>底层实现技术、事务处理、数据库安全、完整性控制</li><li>关系数据理论、数据库设计方法</li></ul><blockquote><p>事务处理（原子性）是DBMS的工作，不是DBS.</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>图书馆</li><li>电商</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;687&lt;/code&gt;字，推荐阅读时间&lt;code&gt;5~7&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter2-Divide and Conquer</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter2-Divide%20and%20Conquer/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter2-Divide%20and%20Conquer/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>559</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><a id="more"></a><h2 id="MCS"><a href="#MCS" class="headerlink" title="MCS"></a>MCS</h2><ul><li>Maximum Contiguous Subarray<ul><li>Find the span of years in which the company earned most</li></ul></li></ul><h3 id="Exhaustive-Search"><a href="#Exhaustive-Search" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_Val</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^3)$</li></ul><h3 id="Data-Reuse"><a href="#Data-Reuse" class="headerlink" title="Data-Reuse"></a>Data-Reuse</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_val</span></span><br></pre></td></tr></table></figure><ul><li>$V(i,j)=V(i,j-1)+A[j]$</li><li>$O(n^2)$</li></ul><h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input A[s...t]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s == t:</span><br><span class="line">    retun A[s] <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    MCS(A, s, mid) <span class="comment"># T(n/2)</span></span><br><span class="line">    MCS(A, mid, t) <span class="comment"># T(n/2)</span></span><br><span class="line">    <span class="comment"># find the max_val of cut position containing A[mid] and A[mid+1]</span></span><br></pre></td></tr></table></figure><ul><li>Be cautious the array may be at the cut position.</li><li>When finding the <code>max_val</code> containing <code>A[mid]</code> and <code>A[mid+1]</code>, we can do it from <code>mid</code> to <code>0</code>.</li><li>$T(n)=2T([n/2])+n$</li><li>$O(nlogn)$</li></ul><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, temp, ans, temp_sum;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">    temp_sum = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// When temp_sum &lt; 0, it means last temp &lt; 0, and last temp has already been compared with ans to decide whether to update the start point of the sub-array.</span></span><br><span class="line">        temp_sum = max(<span class="number">0</span>, temp_sum); </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        temp_sum += temp;</span><br><span class="line">        ans = max(temp_sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Counting-inversions"><a href="#Counting-inversions" class="headerlink" title="Counting inversions"></a>Counting inversions</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># count inversion</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^2)$</li></ul><h3 id="Merge-Sort-Idea"><a href="#Merge-Sort-Idea" class="headerlink" title="Merge Sort Idea"></a>Merge Sort Idea</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(L) == <span class="number">0</span>:</span><br><span class="line">    reutrn <span class="number">0</span>, L</span><br><span class="line">cnt_a, A = sort_and_count(L[l, mid])</span><br><span class="line">cnt_b, B = sort_and_count(L[mid+<span class="number">1</span>, r])</span><br><span class="line">cnt_c, L = merge_and_count(L[l, mid], L[mid+<span class="number">1</span>, r])</span><br><span class="line"><span class="keyword">return</span> cnt_a + cnt_b + cnt_c, L</span><br></pre></td></tr></table></figure><ul><li>Increase inversion count when merging sorted two list.</li><li>$O(nlogn)$</li></ul><h2 id="Polynomial-Multiplication"><a href="#Polynomial-Multiplication" class="headerlink" title="Polynomial Multiplication"></a>Polynomial Multiplication</h2><h3 id="Brute-Force-1"><a href="#Brute-Force-1" class="headerlink" title="Brute Force"></a>Brute Force</h3><ul><li>compute all coefficients and merge them at last<ul><li>multiplications:$O(n^2)$</li><li>addition:$O(n^2)$</li><li>complexity:$O(n^2)$</li></ul></li></ul><h3 id="Divide-and-Conquer-1"><a href="#Divide-and-Conquer-1" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><ul><li>extract $x^{\frac{n}{2}}$ to make size <code>n</code> problem into $2*2$ problem</li><li>$O(n^2)$</li></ul><h4 id="Improve"><a href="#Improve" class="headerlink" title="Improve"></a>Improve</h4><ul><li>We need $A_0B_1+A_1B_0$ instead of $A_0B_1$and$A_1B_0$.<ul><li>$\begin{cases} U=A_0B_0 \\ V=A_0B_1 \\ W=A_1B_0 \\ Z=A_1B_1\end{cases}$</li><li>Take $Y=(A_0+A_1)(B_0+B_1)$, then we can get $A_0B_1+A_1B_0=Y-U-Z$.</li><li>$T(n)=\begin{cases} 3T(n/2) + n&amp;(n&gt;1) \\ 1&amp;(n=1) \end{cases}$</li></ul></li></ul><h2 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h2><ul><li>partition with pivot as a benchmark</li><li>place pivot into right place</li><li>above can be a recursive process</li><li>$O(nlogn)$: the average complexity</li></ul><h3 id="Improve-1"><a href="#Improve-1" class="headerlink" title="Improve"></a>Improve</h3><ul><li><p>The normal complexity of quicksort is $O(n^2)$ because the array may be partially sorted.</p><p>$T(n)=T(0)+T(n-1)+O(n)$</p><blockquote><ul><li>The complexity of quick sort is $O(n^2)$ instead of $O(nlogn)$.</li><li>$O(n)$ comes from the count of key comparisons.</li></ul></blockquote></li><li><p>Adopt random pivot to get randomized partition</p><ul><li>Swap random position with the last position for reuse the partition function</li><li>This action can validly lower the probability to encounter unlucky array partition</li></ul></li></ul><h4 id="Expected-Case"><a href="#Expected-Case" class="headerlink" title="Expected Case"></a>Expected Case</h4><ul><li>Analysis for randomization algorithm</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;559&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;10~15&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter3-Dynamic Programming</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter3-Dynamic%20Programming/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter3-Dynamic%20Programming/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>906</code> words</p><p>Preferred Reading Time: <code>20~25</code> minutes</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><p>Similar to Divide and Conquer, but when subproblems overlap, DP is preferred.</p><blockquote><ul><li>Recurrence is from top to bottom, while DP is from bottom to top.</li><li>Recurrence is efficient when subproblems are independent, while DP requires overlapped subproblems.</li><li>DP trades space for time.</li></ul></blockquote></li><li><p>DP is used for <strong>optimization</strong> problems</p></li><li><p><strong>Core: As long as all subproblems are optimized, the merged problem can be optimized.</strong></p><blockquote><p>Prerequisite: All subproblems cannot be completely individual, and in other words,  they have to affect each other’s solution.</p></blockquote></li></ul><h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ul><li>model subproblems</li><li>establish value connections between subproblems</li><li>bottom-up computation to get result</li><li>trace to get format answer</li></ul><h2 id="0-1-knapsack"><a href="#0-1-knapsack" class="headerlink" title="0-1 knapsack"></a>0-1 knapsack</h2><h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h3><ul><li>try all $2^n$ methods and compare them.</li></ul><h4 id="Simple-Recursion"><a href="#Simple-Recursion" class="headerlink" title="Simple Recursion"></a>Simple Recursion</h4><ul><li><p>$V[i,w]=max(V[i-1,w], v_i+V[i-1,w-w_i])$</p><ul><li><p>$V[i,w]$ denote any subset of items $\{1, 2, 3, …i\}$ value sum with <strong>at most</strong> weight $w$.</p><blockquote><p>Real weight may be smaller than $w$.</p></blockquote></li></ul></li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li>State of subproblems<ul><li>establish formal description for problem requirements</li></ul></li><li><p>Relate a problem to its subproblems</p><ul><li>establish recurrence equation</li><li>set boundary cases</li></ul></li><li><strong>Bottom-up</strong> computation of $V[i,w]$</li><li>initialize boundary cases<ul><li>Save trace when calculating $V[i,j]$, and till the end we can use recorded result to get $V[i,w]$.</li></ul></li><li>Add <code>keep[i,w]</code> to record for a specific w, whether an item is taken.</li></ul><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>DP save duplicate computation.</li><li>DP trades space for time.</li><li>Strategy<ul><li>Structure</li><li>Recursion</li><li>Bottom-up computation</li><li>Construct optimal solution: trace the table</li></ul></li></ul><h2 id="Rod-Cutting"><a href="#Rod-Cutting" class="headerlink" title="Rod Cutting"></a>Rod Cutting</h2><h3 id="brute-force-1"><a href="#brute-force-1" class="headerlink" title="brute force"></a>brute force</h3><ul><li>$r_n=max(p_n,r_1+r_{n-1},…,r_{n-1}+r_1)$<ul><li>$r_n$ is the optimal revenue of length <code>n</code> rod.</li><li>$p_n$ is the price of length <code>n</code> rod.</li><li>simpler definition:  $r_n=max_{1\leq i \leq n}(p_i+r_{n-i})$</li></ul></li><li>Even recurrence equation is established, the recursive method still contains duplicate computation.</li></ul><h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><ul><li>one-dimension array <code>r[]</code> to store max revenue of length from 0 to n.</li><li><code>r[i] = max(r[i], p[j] + r[i - j])</code></li></ul><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>$O(n^2)$</li></ul><h2 id="Chain-Matrix-Multiplication"><a href="#Chain-Matrix-Multiplication" class="headerlink" title="Chain Matrix Multiplication"></a>Chain Matrix Multiplication</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>C(<code>p*q</code> and <code>q*r</code> matrix to multiply, each entry takes $O(q)$ to calculate): $O(pqr)$</p></li><li><p>$A_1A_2A_3=(A_1A_2)A_3=A_1(A_2A_3)$</p><blockquote><p>cause of different complexity</p></blockquote></li></ul><h3 id="Exhaustive-Search"><a href="#Exhaustive-Search" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><ul><li>$\Omega(\frac{4^n}{n^{\frac{3}{2}}})$</li></ul><h3 id="DP-2"><a href="#DP-2" class="headerlink" title="DP"></a>DP</h3><p>for matrix $A_i$, it has dimension of $p_{i-1}*p_i$.</p><ul><li><p>model subproblems</p></li><li><p>establish <strong>value</strong> connection between subproblems</p><p>$m[i,j]=\begin{cases}0, &amp; i=j\\min_{i\leq k&lt;j}(m[i,k]+m[k+1,j])+p_{i-1}p_kp_j, &amp; i&lt;j\end{cases}$</p></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$<ul><li>Outlying loop layer is for traverse multiply-array’s length from 2 to n.</li></ul></li><li>space: $O(n^2)$</li></ul><h2 id="Longest-Common-Subsequence-Problem"><a href="#Longest-Common-Subsequence-Problem" class="headerlink" title="Longest Common Subsequence Problem"></a>Longest Common Subsequence Problem</h2><h3 id="Basic-Concepts-1"><a href="#Basic-Concepts-1" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>subsequence: not necessarily continuous</li><li>substring: <strong>must</strong> be continuous</li></ul><h3 id="DP-3"><a href="#DP-3" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ the length of LCS in $A[1..i]$ of $A[1..m]$ and $B[1..j]$ of $B[1..n]$</p><ul><li>$d_{i,j}=\begin{cases} 0, &amp; i,j=0 \\ d_{i-1,j-1}+1, &amp; x_i=y_j \\ max(d_{i-1.j},d_{i,j-1}), &amp; x_i\neq y_j\end{cases}$</li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(mn)$</p></li><li><p>space: $O(n^2)$</p><ul><li><p>optimization for solution matrix: only save two rows</p><blockquote><p>The trace matrix needs totally preserving.</p></blockquote></li></ul></li><li><p>Different trace may lead to different subsequence.</p></li></ul><h2 id="Longest-Common-Substring-Problem"><a href="#Longest-Common-Substring-Problem" class="headerlink" title="Longest Common Substring Problem"></a>Longest Common Substring Problem</h2><h3 id="Basic-Concepts-2"><a href="#Basic-Concepts-2" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>Different from subsequence, substring must be contiguous.</li></ul><h3 id="DP-4"><a href="#DP-4" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ to be the length of the longest common substring of $X[1..i]$ and $Y[1..j]$</p><ul><li>$d_{i,j}=\begin{cases} d_{i-1,j-1}+1, &amp;x_i=y_j\\ 0, &amp;x_i\neq y_j\end{cases}$</li><li>$maxSubstring(X,Y)=max(d_{i,j})$</li></ul><h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Without saving DP direction, we can still trace the whole substring by knowing the <strong>end index</strong> of substring $(X_i|Y_j)$ and its length $d_{i,j}$.</li><li>time: $O(mn)$</li><li>Subsequence algorithm can be used to solve this problem by only outputting diagonal $LU$ elements.</li></ul><h2 id="Minimum-Edit-Distance"><a href="#Minimum-Edit-Distance" class="headerlink" title="Minimum Edit Distance"></a>Minimum Edit Distance</h2><h3 id="Basic-Concepts-3"><a href="#Basic-Concepts-3" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><ul><li>“Spell Correction” in search engine</li><li>Computational Biology such as comparing DNA</li><li>Machine Translation, Information Extraction, Speech Recognition etc.</li></ul><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>calculate the smallest number of edit operations</p><ul><li><p>edit operations</p><ul><li>insertion: add a letter</li><li>deletion: delete a letter</li><li>substitution: replace a character</li></ul><blockquote><p>All operations’ cost is usually (throughout the course) counted as <code>1</code>, but the cost can be adjusted.</p></blockquote></li></ul><h3 id="DP-5"><a href="#DP-5" class="headerlink" title="DP"></a>DP</h3><p>define $D[i,j]$ the edit distance of $X[1..i]$ and $Y[1..j]$</p><ul><li>$D[i,j]=min\begin{cases} D[i-1,j]+1, &amp;delete\ X[i] \\ D[i,j-1]+1, &amp;insert\ Y[j] \\ D[i-1,j-1] +0, &amp;X[i]=Y[j] \\ D[i-1,j-1]+1, &amp;X[i] \neq Y[j] \end{cases}$</li></ul><blockquote><ul><li>All edit operations take place on $X[1..i]$.</li><li>When operation cost changes, the constant in equation will be changed as well.</li><li>When the problem can be depicted as a state graph, <strong>shortest path algorithm</strong> can be used to solve the problem. In other words, the problems degrades to shortest path problem.</li></ul></blockquote><h3 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>When tracing the edit process, <code>L</code>/<code>U</code>/<code>LR</code> stand for four different operations(<strong>including doing nothing</strong>).</li><li>time: $O(mn)$</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>multi-stage strategy problem</li><li>DP is not a specific method but a way of thinking.</li><li>Key to DP: basic equations and boundary conditions</li><li>DP’s effect is also called Markova effect for there’s no effect on future events. </li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;906&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;20~25&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter4-mid-term review</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter4-mid-term%20review/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter4-mid-term%20review/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>413</code> words</p><p>Preferred Reading Time: <code>15~20</code> minutes</p><a id="more"></a><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2><h3 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h3><ul><li><p>Any comparison-based sorting algorithm requires $\Omega(nlogn)$ comparisons.</p><blockquote><p>proved by binary decision tree</p></blockquote></li><li><p>Thus, in order to break the lower bound, we should take other methods except comparison.</p></li><li><p>counting sort isn’t based on comparison.</p></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>When inputting numbers, count occurrences of all numbers.</p><blockquote><p>counting array’s length is based on boundary value of inputting array.</p></blockquote></li><li><p>Fill sorted array with the counting array.</p></li></ul><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n)$</li><li>counting sort is a <strong>stable</strong> sort as long as the final filling loop is from raw array’s <strong>end</strong> to its <strong>head</strong>.</li></ul><h2 id="Randomized-Selection-Problem"><a href="#Randomized-Selection-Problem" class="headerlink" title="Randomized Selection Problem"></a>Randomized Selection Problem</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>find the <code>i-th</code> smallest element in a given array</li></ul><h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h3><ul><li>sort the array and index specific element</li></ul><h3 id="Partition-and-Selection"><a href="#Partition-and-Selection" class="headerlink" title="Partition and Selection"></a>Partition and Selection</h3><ul><li>The same as quick sort, part the array into two subarrays, and then make sure the index of selected separator number.</li><li>When the index is greater than <code>i</code>, handle another branch and abandon this one, vice versa.</li></ul><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(n)$</p><blockquote><p>Different from quick sort’s $O(nlogn)$, this algorithm only deals with one branch of subproblems, while quick sort handles both branches.</p></blockquote></li></ul><h2 id="Optimal-Binary-Search-Tree"><a href="#Optimal-Binary-Search-Tree" class="headerlink" title="Optimal Binary Search Tree"></a>Optimal Binary Search Tree</h2><h3 id="Basic-Concepts-1"><a href="#Basic-Concepts-1" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>construct a BST with smallest search cost</p></li><li><p>height</p><ul><li>$node_height=max(children_height + 1)$</li><li>$leave_ height=0$</li><li>$tree_height=root_height$</li><li>$empty_tree_height = -1$</li></ul><blockquote><p><code>root_height</code> is the <strong>biggest</strong> one.</p></blockquote></li><li><p>$depth=H(root)-H(n)+1$</p><ul><li>$root_depth=1$</li></ul></li><li><p>balanced binary tree: the height difference of two subtrees cannot go beyond 1.</p><ul><li>$balance_factor = H(right)-H(left)$</li></ul></li><li><p>AVL tree: besides balanced binary tree, every node will store the height of two subtrees.</p></li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li><p>subproblem: find an optimal BST containing $keys<a href="1 \leq i \leq j \leq n">i..j</a>$</p></li><li><p>$e[i,j]$: the expected search cost of a subtree with $k[i..j]$.</p><ul><li>$e[i, j] =\begin{cases} q_{i-1}, &amp;j=i-1 \\ min_{i\leq r\leq j}(e[i, r-1]+e[r+1, j]+w[i, j]), &amp;i\leq j\end{cases}$</li><li>$w[i,j]=E_r=w[i,r-1]+p_r+w[r+1,j]=w[i,j-1]+p_j+q_j$</li></ul></li><li><p>diagonal traverse template</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>): <span class="comment"># length of fixed diagnals</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n-l+<span class="number">1</span>):</span><br><span class="line">        j = i + l - <span class="number">1</span> <span class="comment"># (n-l+1, n) is always on f(i, j)</span></span><br></pre></td></tr></table></figure><blockquote><p>Due to $i\leq j$, then the traverse should be diagonal.</p></blockquote></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$</li><li>space: $O(n^2)$</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;413&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;15~20&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter5-Greedy Algorithms</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter5-Greedy%20Algorithms/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter5-Greedy%20Algorithms/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>522</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><a id="more"></a><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li><p>Greedy algorithms don’t always produce the optimal solution.</p></li><li><p>As a result, if the result is optimal, we need to prove its correctness.</p><blockquote><p>The usual way is to prove that any other optimal solution can be converted into the greedy one.</p></blockquote></li></ul><h2 id="Fraction-Knapsack-Problem"><a href="#Fraction-Knapsack-Problem" class="headerlink" title="Fraction Knapsack Problem"></a>Fraction Knapsack Problem</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Different from 0-1 problem, knapsack can take only a fraction of an item.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li>calculate value-per-pound of every item</li><li>sort items by <strong>decreasing</strong> value-per-pound</li><li>put as much as possible weight of an item into knapsack from the starting point to the end of the sorted array</li></ul><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$, the time complexity of sort process.</li><li>Different from DP, all subproblems of greedy algorithms are optimal no matter whether they are connected with each other.</li></ul><h2 id="Huffman-Coding-Problem"><a href="#Huffman-Coding-Problem" class="headerlink" title="Huffman Coding Problem"></a>Huffman Coding Problem</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>Encode characters according to its frequency so that the variable length can save the memory space compared with fixed length.</p><blockquote><p>especially useful when storing images</p></blockquote></li><li><p>Uniquely Decodable: In order to decode correctly, the encoding method should avoid one character’s code being the prefix of another character, and then the code can be named after <strong>prefix (free) code</strong>.</p></li><li><p>Huffman coding targets at the <strong>minimized binary prefix code</strong>.</p></li></ul><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><ul><li>pick two least-occur characters from alphabet and build a subtree</li><li>the subtree’s frequency is the sum of its sub-subtrees</li><li><strong>note that the Huffman tree can be a complete binary tree as well</strong></li></ul><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$<ul><li>Every update of the priority queue is $O(logn)$ and the total operation count is $n$.</li></ul></li></ul><h2 id="Activity-Selection-Problem"><a href="#Activity-Selection-Problem" class="headerlink" title="Activity Selection Problem"></a>Activity Selection Problem</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Given activities that may overlap with each other, take part in as many activities as possible.</li><li>core: find a maximized compatible activity set</li></ul><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>sort activities list in ascending order of finishing time</p></li><li><p>select the first activity: the one <strong>finishes at the earliest time</strong></p><blockquote><p>not the one starting earliest or the shortest one</p></blockquote></li><li><p>advance the time and update sort activities until the head activity’s starting time is still valid</p></li><li><p>select next activity</p></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>Time: $O(nlogn)$ to sort activity list.</p></li><li><p>The correctness can be proved that greedy algorithms produce the optimal solution of this problem.</p><blockquote><p>Proof: we can convert any other optimal solution($P’$) to the greedy algorithm solution($P$) by replacing different elements in $P’$ with corresponding elements in $P$.</p></blockquote></li></ul><h2 id="Weighted-Activity-Selection-Problem"><a href="#Weighted-Activity-Selection-Problem" class="headerlink" title="Weighted Activity Selection Problem"></a>Weighted Activity Selection Problem</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Every activity is given a weight, and the goal is to construct the set with maximized weight sum.</li></ul><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>Greedy algorithm is correct when weight are all equal.</p></li><li><p>DP can still work in this weight-varied scenario.</p><ul><li><p><strong>First of all, sort activity with its finishing time.</strong></p></li><li><p>$p(j)$ : the largest index $i&lt;j$ guaranteeing $a_i$ compatible with $a_j$.</p><blockquote><p><strong>index</strong> is the one of <strong>sorted</strong> activity array.</p></blockquote></li><li><p>$OPT(j)$: the max weight sum of any subset in $a[1..j]$</p><script type="math/tex; mode=display">OPT(j)=\begin{cases} 0,& j=0 \\ max(OPT(i-1), w_j+OPT(p(j)), & j>0\end{cases}</script></li></ul></li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$ to sort the activity list</li><li>Greedy algorithms never reconsider its previous choices, while DP construct its solution by comparing all possible previous choices.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;522&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;10~15&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter6-Graph Algorithms</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter6-Graph%20Algorithms/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter6-Graph%20Algorithms/</id>
    <published>2021-01-03T10:58:25.100Z</published>
    <updated>2021-01-03T11:00:09.200Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>1887</code> words</p><p>Preferred Reading Time: <code>30~45</code> minutes</p><a id="more"></a><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><ul><li><p>complete graph</p><ul><li>undirected: $|E|=n(n-1)/2$</li><li>directed: $|E|=n(n-1)$</li></ul></li><li><p>dense &amp; sparse graph: not quantitative defined</p></li><li><p>degree: number of edges incident on a vertex</p><ul><li>degree of a graph is the sum of degrees of all vertices</li></ul></li><li><p>leave node</p><ul><li>directed graph: no out degree</li><li>undirected graph: degree is <code>1</code></li></ul></li><li><p>path length: <strong>edges’</strong> count(not vertex)</p></li><li><p>simple path: all <strong>vertices</strong> are distinct on the path(no cycle, acyclic)</p></li><li><p>cycle: requires all <strong>edges</strong> are distinct with multi-exist vertices</p><blockquote><ul><li><p>an edge cannot be used twice in a cycle</p></li><li><p>Q: self-to-self edge can produce cycle?</p><p>A: Yes, that’s why a legal tree <strong>cannot</strong> have self-to-self edge.</p></li></ul></blockquote></li><li><p>connected component</p><ul><li><p><strong>disconnected</strong> graph’s biggest connected subgraph</p><blockquote><p>a disconnected graph can have <strong>more than one</strong> connected components</p></blockquote></li><li><p>connected graph itself</p></li></ul></li><li><p>included subgraph: As long as <strong>both</strong> endpoints are preserved, the edges should be preserved.</p></li><li><p>leaf</p><ul><li>directed graph: out-degree is zero</li><li>undirected graph: degree is one</li></ul></li></ul><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><ul><li>Adjacency List<ul><li>space complexity: $O(V+E)$</li><li>$adj[u]$: hold all vertices adjacent to $u$, usually a linked list.</li><li>mostly for sparse graph</li></ul></li><li>Adjacency Matrix<ul><li>space complexity: $O(V^2)$</li><li>undirected graphs always have <strong>symmetric</strong> adjacency matrix</li><li>mostly for dense graph</li></ul></li></ul><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul><li><p>data structure</p><ul><li><code>color[u]</code>: state of vertex <code>u</code><ul><li><code>undiscovered</code></li><li><code>discovered but not finishing processing</code></li><li><code>finished processing</code></li></ul></li><li><code>pred[u]</code>: the predecessor of vertex <code>u</code></li><li><code>d[u]</code>: distance from starting point to <code>u</code></li></ul></li><li><p>end-loop condition: the vertex queue is empty</p></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><blockquote><p>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</p></blockquote></li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li><p>tree-like traverse process</p></li><li><p>data structure</p><ul><li><code>color[u]</code></li><li><code>pred[u]</code></li><li><code>d[u]</code>: discovery time of vertex <code>u</code></li><li><code>f[u]</code>: finishing time of vertex <code>u</code></li></ul></li><li><p><code>u</code> is a descendant of <code>v</code> if and only if $[d[u],f[u]]\subset[d[v],f[v]]$</p><ul><li><p>tree edge$(u,v)$: $u$ is the predecessor in a DFS path</p></li><li><p>back edge$(u,v)$: $v$ is the predecessor in a DFS path</p><blockquote><p>As long as the graph is acyclic, there is no back edge.</p></blockquote></li><li><p>cross edge$(u,v)$: both vertices are endpoints of a DFS path</p></li></ul></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><ul><li>Different from normal complexity calculation, we can think it in this way: as for each vertex, $O(1)$ is needed to update the timestamp, and $O(degree(u))$ is required to run the for loop. Therefore, the total time complexity is the sum of every single time complexity.</li></ul><blockquote><ul><li>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</li><li>The time complexity is the same as the one of BFS under adjacency list.</li></ul></blockquote></li><li><p>White-path theorem: As long as $v$ is a descendant(direct or indirect) of $u$, then there is a white path between them in DFS algorithm.</p></li></ul><h2 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Topological sort is adopted for <strong>directed acyclic graph(DAG)</strong>.<ul><li>$G$ doesn’t need to be connected, for the order of disconnected parts won’t break the rule.</li></ul></li><li>find a sequence based on edge $(u,v)$ that $u$ must be ahead of $v$</li><li>If no “zero in-degree” vertex is found, the graph must contain cycle.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li>BFS<ul><li>find all vertices with in-degree as 0</li><li>delete them and their outgoing edges(decrease in-degree of its direct descendants)</li><li>repeat above steps</li></ul></li><li>DFS<ul><li>traverse all vertices and build a DFS tree</li><li>Once a vertex cannot span the tree anymore, add it into $L$.<ul><li>all direct descendants are added into $L$</li><li>no direct descendant exists</li></ul></li><li>next DFS tree traverse won’t reach vertices in $L$</li><li>Tasks with <strong>later</strong> finishing time should be down <strong>earlier</strong>, so $L$ needs reversing to be correct order.</li></ul></li></ul><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>BFS<ul><li>time: $O(|V|+|E|)$</li></ul></li><li>DFS<ul><li>time: $O(|V|+|E|)$</li></ul></li></ul><h2 id="Strongly-Connected-Components"><a href="#Strongly-Connected-Components" class="headerlink" title="Strongly Connected Components"></a>Strongly Connected Components</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>SCC is a subset of a <strong>directed</strong> graph, in which all vertices can reach each other, <strong>and</strong> the subset should be <strong>maximal</strong>(no more vertex can be added).</p><ul><li>SCC can contain <strong>only one</strong> vertex.</li></ul></li><li><p>Theorem: Suppose $S_1$ and $S_2$ are both SCCs of $G$, then the intersection must be $\Phi$.</p><blockquote><p>Proof: Any vertex in intersection can make $S_1\cup S_2$ a bigger SCC.</p><ul><li>After finding a SCC, all vertices within can be taken as a single vertex.</li></ul></blockquote></li><li><p>Finding all SCC of $G$ is to find a partition with all subset are SCC.</p></li><li><p>Sink SCC: SCC with no outgoing edge</p><ul><li><p>$G^{SCC}$ is a graph taking all SCC as a single vertex.</p></li><li><p>$G^{SCC}$ is a DAG</p><blockquote><p>Proof: As long as there is a cycle, the element of $SCC$ can be merged.</p></blockquote></li><li><p>$G^{SCC}$ must contain at least one <strong>SSCC</strong>.</p><blockquote><p>Proof: The DAG graph can be topological sorted, so the last vertex in the topological order has no outgoing edge, which means the vertex is a SSCC.</p></blockquote></li></ul></li></ul><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><ul><li>generate reverse graph $G^R$</li><li>Operate topological sort on $G^R$, and the result is $L^R$.</li><li>reverse $L^R$ to get $L$</li><li>execute DFS on $G$ with starting point as white ones in $L$</li><li>Every DFS on $G$ can produce a SCC, and corresponding vertices should be marked black.<ul><li>Starting from a SSCC, then the component won’t contain vertices of other SCC.</li></ul></li></ul><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(V+E)$</li></ul><h2 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a>Spanning Tree</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>An <strong>undirected</strong> graph’s subgraph containing all vertices.</p><blockquote><p>Q: Can spanning tree has cycle?</p><p>A: No,  tree is an <strong>acyclic</strong> graph.</p></blockquote></li><li><p>Every connected graph has at least one spanning tree.</p></li><li><p>Minimum Spanning Tree: the subgraph with smallest weight sum in a weighted undirected graph</p><ul><li><p>minimum spanning tree may <strong>not</strong> be unique</p><blockquote><p>Only when weight varies from one to another, the minimum spanning tree is unique.</p></blockquote></li></ul></li><li><p>safe edge: After adding safe edge to a subset of MST, the new set is still a subset of MST.</p><ul><li><p>Find the light edge of a cut respecting subset A, and then the light edge is the sage edge.</p><blockquote><p>Subset contains only edges, which means <strong>not all</strong> edges needs selecting even though their endpoints are with in the subset.</p></blockquote></li></ul></li><li><p>min heap</p><ul><li>root has min value</li><li>any vertex’s sons have <strong>greater</strong> value than its own value.</li></ul></li></ul><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><ul><li><p><strong>focus on vertex</strong></p></li><li><p>start with a randomly picked up <strong>vertex</strong></p></li><li><p>iterate to find the <strong>lightest</strong> edge outside the tree and add it (and its <strong>endpoint</strong>) into tree</p><ul><li><p>priority queue</p><ul><li><p>insert: insert at tail and <strong>reverse up</strong></p></li><li><p>extract min</p><ul><li><p>After extracting the first element, the last element needs swapping to the first.</p><blockquote><p>Only the last element won’t influence the tree structure.</p></blockquote></li><li><p><strong>roll down</strong> new first element to construct a new heap</p></li><li><p>time complexity is $O(logn)$</p></li></ul></li><li><p>update value: <strong>reverse up</strong> to respect the heap</p></li></ul></li></ul></li><li><p>When adding an new edge and its vertex into SMT, loop over its adjacent vertices to update key values.</p></li></ul><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><ul><li><strong>focus on edges</strong></li><li>Construct many forests, and finally they will be merged.<ul><li>When selecting edges, be cautious there cannot be cycles.<ul><li>disjoint set</li></ul></li></ul></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time</p><ul><li><p>Prim: $O(VlogV+ElogV)=O(ElogV)$</p><ul><li>Usually, $E$ is greater than $V$ and sometimes may be $V^2$, which means $E=O(V^2)$.</li></ul><blockquote><p>As for loops like <code>while Q.size() &gt; 0</code>, and <code>Q</code> is changed within, we can consider it based on every single operation instead of every loop.</p></blockquote></li><li><p>Kruskal: $O(ElogE)=O(ElogV)$</p><blockquote><p>$logE\leq logV^2 \leq 2logV \leq O(logV)$</p><ul><li>Usually place $E$ outside $log$, and $V$ is placed inside.</li></ul></blockquote></li></ul></li></ul><h2 id="Shortest-Path"><a href="#Shortest-Path" class="headerlink" title="Shortest Path"></a>Shortest Path</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><ul><li>distance is the <strong>minimal</strong> length between two vertices</li><li>lemma: Any sub-path of a shortest path must also be a shortest path.</li></ul><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><ul><li><p>single source problem</p></li><li><p>can only handle <strong>no-negative-edge</strong> graph</p></li><li><p>greedy algorithm</p></li><li><p>maintain <code>d[v]</code> and <code>S</code></p><ul><li><p><code>d[v]</code>: upper bound of length <code>l(source, v)</code></p><ul><li><p>can be optimized by priority queue</p></li><li><p>relax</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[v] &lt;- min(d[v], d[u] + w(u, v));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>S</code>: set of distance-settled vertices</p></li></ul></li></ul><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><ul><li><p>single source problem</p></li><li><p>relax according to <strong>edges</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to <span class="params">|V|</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> E <span class="keyword">do</span></span><br><span class="line">        relax(e.p1, e.p2, e.w);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>Every iteration will settle an edge in the shortest paths.</p></li><li><p>The shortest path can at <strong>most</strong> contain <code>(|V|-1)</code> edges.</p></li><li><p>Iteration at most runs for <code>(|V|-1)</code> times.</p><blockquote><p><code>ith</code> iteration settle the paths containing <code>i</code> edges</p></blockquote></li></ul></li><li><p>If relaxation still happens after <code>(|V|-1)</code> iterations, there must be negative cycles in graph.</p></li></ul><h4 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h4><ul><li><p>all-pairs problem</p></li><li><p>dynamic programming algorithm</p><ul><li><p>$f[k][i][j]=min\{f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j]\}$</p><ul><li><p>using rolling array to optimize</p><p>$f[i][j]=min\{f[i][j],f[i][k]+f[k][j]\}$</p></li></ul></li></ul></li><li><p>The sequence to traverse <code>k</code>(intermediate vertex) isn’t important.</p><blockquote><p>Proof: Mathematics Induction(<a href="https://blog.csdn.net/dypdypdyp123/article/details/50492894" target="_blank" rel="noopener">https://blog.csdn.net/dypdypdyp123/article/details/50492894</a>)</p></blockquote></li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><p>time</p><ul><li><p>Dijkstra: $O(VlogV+ElogV)=O(ElogV)$</p></li><li><p>Bellman-Ford: $O(EV)$</p></li><li><p>Floyd-Warshall: $O(V^3)$</p><blockquote><p>Apart from data structure, Floyd’s traversal decides the $n^3$ complexity.</p></blockquote></li></ul><h2 id="Maximum-Flow-amp-Minimum-Cut"><a href="#Maximum-Flow-amp-Minimum-Cut" class="headerlink" title="Maximum Flow &amp; Minimum Cut"></a>Maximum Flow &amp; Minimum Cut</h2><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>a flow network <code>G</code> with source <code>s</code>, sink <code>t</code> and no parallel edges.</p></li><li><p>capacity is nonnegative: $c(e) \geq 0$</p></li><li><p>cut’s capacity: $cap(A, B)=\sum_{e\ out\ of\ A}c(e)$</p><ul><li>a cut requires $s \in A$ and $t \in B$</li></ul></li><li><p>minimum cut: output a cut of minimum capacity</p></li><li><p>maximum flow: output a flow of maximum value</p></li><li><p>Except <code>s</code> and <code>t</code>, every vertex’s <code>out</code> equals <code>in</code>, which means it cannot store any water.</p></li><li><p>flow value: $val(f)=\sum_{e\ out\ of\ s}f(e)$, and <code>s</code> is the source.</p><blockquote><p><code>value</code> may not be the sum of capacity</p></blockquote></li></ul><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Heuristic-Algorithm"><a href="#Heuristic-Algorithm" class="headerlink" title="Heuristic Algorithm"></a>Heuristic Algorithm</h4><ul><li>initialize all <code>f(e)</code> to zero</li><li>find a <code>s-t</code> path where each edge meets $f(e)&lt;c(e)$</li><li>augment flow along <code>s-t</code> path</li><li>iterate above steps until no <code>s-t</code> path can be found</li></ul><blockquote><p><code>Heuristic Algorithm</code> <strong>cannot</strong> guarantee the optimal answer</p></blockquote><h4 id="Ford-Fulkerson-Method"><a href="#Ford-Fulkerson-Method" class="headerlink" title="Ford-Fulkerson Method"></a>Ford-Fulkerson Method</h4><ul><li><p>residual network: add reverse edges to dynamically adjust the flow of an edge</p><ul><li>residual capacity: $c_f(e)=\begin{cases} c(e)-f(e), &amp; c(e)&gt;f(e) \\ f(e), &amp;f(e)&gt;0 \end{cases}$</li></ul><blockquote><p>Once and residual capacity is zero, there is <strong>only one</strong> edge between two vertices.(even no edge at all)</p></blockquote></li><li><p>augment(ing) path: a simple <code>s-t</code> path in $G_f$</p><ul><li><p>bottleneck capacity: minimum residual capacity of any edge in augment path</p></li><li><p>key property: $val(f’)=val(f)+bottoleneck(G_f, P)$</p><ul><li>As for specific edge, the flow may decrease. However, the overall flow will increase.</li></ul></li><li><p>$val(f’)&gt;val(f)$</p><blockquote><p>the out edges of <code>s</code> must have the <strong>same</strong> direction as that in augment path</p></blockquote></li></ul></li><li><p>Process</p><ul><li>start with all <code>f(u, v) = 0</code></li><li>randomly choose an augment path to update <code>f</code> and $G_f$.</li><li>iterate until there is <strong>no</strong> augment path $\Leftrightarrow$ no <code>s-t</code> path in $G_f$</li></ul></li></ul><h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(|E||f^<em>|)$, $f^</em>$ is the max flow of graph $G$.</p><ul><li><p>BFS/DFS: $O(|V| + 2|E|)=O(|E|)$</p><blockquote><p>the worst case: one edge in $G$ has two corresponding edges in $G_f$</p></blockquote></li><li><p>The time complexity is determined by $|f^*|$, so the method to pick up an augment path is important.</p><ul><li>EK Algorithm: ignore all edges’ weight and find a shortest path</li><li>In a flow network, EK’s time complexity is $O(|V||E|)$.<ul><li>an edge <strong>at most</strong> can be critical for $|V|/2$ times</li></ul></li><li>new time complexity of Ford-Fulkerson Algorithm: $O(|V||E|^2)$</li></ul></li></ul></li><li><p>Augmenting Path Theorem: A flow of $f$ is a max-flow $\Leftrightarrow$ <strong>no</strong> augment path in $G_f$</p></li><li><p>Max Flow &amp; Min Cut Theorem</p><ul><li>$val(f)=cap(min_cut)$</li><li>$f$ is the max flow</li><li>$f$ has no augmenting path</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li><li>BUAA Algorithm MOOC, Autumn of 2020.</li><li>OI Wiki</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;1887&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;30~45&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter0-Introduction</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter0-Introduction/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter0-Introduction/</id>
    <published>2021-01-03T10:58:25.092Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>161</code> words</p><p>Preferred Reading Time: <code>3~5</code> minutes</p><a id="more"></a><h2 id="Syllabus"><a href="#Syllabus" class="headerlink" title="Syllabus"></a>Syllabus</h2><ul><li>Basics</li><li>Divide and Conquer</li><li>DP</li><li>Greedy</li><li>Graph</li><li>Hard Problems</li></ul><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ul><li>Design</li><li>Analyze</li></ul><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><ul><li>Computational Problem</li><li>Instance</li><li>Algorithm</li></ul><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><ul><li>Memory</li><li>Running time(focus of course)<ul><li>computer</li><li>implementation details</li><li>input(size etc.)</li></ul></li></ul><h3 id="Machine-independent-running-time"><a href="#Machine-independent-running-time" class="headerlink" title="Machine-independent running time"></a>Machine-independent running time</h3><ul><li>depend on quantity of <strong>primitive operations</strong><ul><li>addition</li><li>multiplication</li><li>comparison</li></ul></li><li>$T(n)$:denote the running time of n-size input<ul><li>n<ul><li>sorting: items to be sorted</li><li>graph: vertices and edges</li></ul></li></ul></li><li>Best Case: an instance for given size <code>n</code> results in the most efficient situation<ul><li>eg. A sorted list for insertion sort</li></ul></li><li>Worst Case<strong>(Mostly Used)</strong>: opposite to Best Case<ul><li>eg. A rev-sorted list for insertion sort</li></ul></li><li>Average Case: based on probability of all situations </li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li><p>$Θ(n)$ notation</p><ul><li><p>a supplement of <code>T(n)</code> notation</p><blockquote><p>$T(n)$ is exact while $Θ(n)$ is approximate</p></blockquote></li><li><p>eg. Mergesort</p><p>$T(n) = 2T(n/2) + Θ(n)\ (n&gt;1)$</p><p>$T(n)=Θ(1)\ (n=1)$</p><blockquote><p>Recursive notation</p></blockquote></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;161&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;3~5&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Chapter1-Asymptotic Notations And Recurrence</title>
    <link href="http://yoursite.com/2021/01/03/Algorithm-Chapter1-Asymptotic%20Notations%20And%20Recurrence/"/>
    <id>http://yoursite.com/2021/01/03/Algorithm-Chapter1-Asymptotic%20Notations%20And%20Recurrence/</id>
    <published>2021-01-03T10:58:25.092Z</published>
    <updated>2021-01-03T11:00:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Total Count: <code>291</code> words</p><p>Preferred Reading Time: <code>5~10</code> minutes</p><a id="more"></a><h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><h3 id="Big-Oh"><a href="#Big-Oh" class="headerlink" title="Big-Oh"></a>Big-Oh</h3><ul><li><p><strong>Upper</strong> bounds</p></li><li><p>$f(n)=O(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\leq{c*g(n)}\ (c&gt;0, n&gt;n0)$</p></li><li><p>Example</p><ul><li>$sin(n)=O(1)$</li><li>$log(n!)=O(nlog(n))$</li><li>$\sum{1/n}=O(log(n))$</li></ul></li><li><p>$log_{b_1}(n)=O(log_{b_2}(n))$</p><blockquote><p>Bases in <code>O</code> notation are usually omitted.</p></blockquote></li></ul><h3 id="Big-Omega"><a href="#Big-Omega" class="headerlink" title="Big-Omega"></a>Big-Omega</h3><ul><li><p><strong>Lower</strong> bounds</p></li><li><p>$f(n)=Ω(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\geq{c*g(n)}\ (c&gt;0,n&gt;n0)$</p></li><li><p>Example</p><ul><li><p>$\sum{1/n}=Ω(log(n))$</p><blockquote><p><code>log(n)</code> is both bounds above and below, the difference is coefficient.</p></blockquote></li></ul></li></ul><h3 id="Big-Theta"><a href="#Big-Theta" class="headerlink" title="Big-Theta"></a>Big-Theta</h3><ul><li><strong>Tight</strong> bounds</li><li>$f(n)=Θ(g(n))$ when $f(n)=O(g(n))$ and $f(n)=Ω(g(n))$</li></ul><h2 id="Recurrence"><a href="#Recurrence" class="headerlink" title="Recurrence"></a>Recurrence</h2><script type="math/tex; mode=display">\begin{cases} T(n)=3T(n/4)+n^2&(n>1) \\ 1&(n=1) \tag{1} \end{cases}</script><ul><li>$n^2$ is workload of first level</li></ul><h3 id="Recursion-tree-Method"><a href="#Recursion-tree-Method" class="headerlink" title="Recursion-tree Method"></a>Recursion-tree Method</h3><p>$T(n) \leq n^2+3/16n^2+(3/16)^2n^2 + … =O(n^2)$</p><h3 id="Substitution-Method"><a href="#Substitution-Method" class="headerlink" title="Substitution Method"></a>Substitution Method</h3><p>Prove $T(n) \leq cn^2$.</p><p>$T(n)=3T(n/4)+n^2 \le3c(n/4)^2 =cn^2-(13c/16-1)n^2 \leq cn^2 (c\geq16/13)$</p><p>So when $c\geq16/13$, we can prove $T(n)\leq cn^2$.</p><blockquote><p>Since $T(n) \geq n^2$, then $Θ(n)=Ω(n)=O(n)$.</p></blockquote><h3 id="Master-Method-and-Master-Theorem"><a href="#Master-Method-and-Master-Theorem" class="headerlink" title="Master Method and Master Theorem"></a>Master Method and Master Theorem</h3><p>If $T(n)=aT(upper(\frac{n}{b}))+O(n^d)(a&gt;0,b&gt;1,d\geq0)$, then</p><script type="math/tex; mode=display">T(n)=\begin{cases} O(n^d)&d>lob_ba,b^d>a \\ O(n^dlogn)&d=lob_ba,b^d=a \\ O(n^{log_b{a}})&d<lob_ba,b^d<a \end{cases}</script><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Total Count: &lt;code&gt;291&lt;/code&gt; words&lt;/p&gt;
&lt;p&gt;Preferred Reading Time: &lt;code&gt;5~10&lt;/code&gt; minutes&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter6-整数规划</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter6-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter6-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/</id>
    <published>2021-01-03T10:46:53.760Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>311</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>和普通规划模型不同，整数规划中的<strong>某些</strong>变量只能是整数。</li><li>纯整数规划：所有变量都是整数</li><li>混合整数规划：部分变量是整数</li><li>0-1规划：所有变量的取值只能为0或1<ul><li>常见模型：选择问题（投资项目）</li></ul></li><li>整数规划的最优解<strong>不一定</strong>出现在连续规划最优解的附近</li></ul><h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2><ul><li>求出连续情况下的最优解，例如$x_1=3.75$.</li><li>对$x_1$进行分支限界，在原问题增加约束$x1\leq 3$或$x_1\geq 4$，分别再求一次可行解。</li><li>例如在$x_1\geq 4$的分支上$x_2$不能求出整数解，则对$x_2$进行分支限界。</li><li>在限界过程中<ul><li>出现无解则抛弃该分支</li><li>出现之前被限界的变量$x_1$可行解为小数的情况，则需要对$x_1$再次进行分支限界。</li></ul></li><li>迭代上述过程，直到求出所有的可行解。</li><li>比较所有可行解，确定最优解。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;311&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization-Chapter7-动态规划</title>
    <link href="http://yoursite.com/2021/01/03/Optimization-Chapter7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/01/03/Optimization-Chapter7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-01-03T10:46:53.760Z</published>
    <updated>2021-01-03T10:51:40.632Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>428</code>字，推荐阅读时间<code>3~5</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>动态规划的递归性质：将一个问题的最优解作为下一个问题的输入</p><ul><li><p>前向递归：把起点设在<strong>左边</strong>，然后进行递推。</p></li><li><p>后向递归：把起点设在<strong>右边</strong>，然后进行递推。</p></li><li><p>阶段划分：<code>n</code>层节点对应<code>(n-1)</code>个阶段</p></li><li><p>格式：设有<code>1-3</code>共<code>3</code>个阶段</p><ul><li><p>前向：<script type="math/tex">\begin{cases} f_i(x_i)=min\{f_{i-1}(x_{i-1})+d(x_{i-1},x_i)\} \\ f_0(x_0)=0\end{cases}</script></p></li><li><p>后向：<script type="math/tex">\begin{cases} f_i(x_i)=min\{f_{i+1}(x_{i+1})+d(x_{i},x_{i+1})\} \\ f_4(x_4)=0\end{cases}</script></p></li><li><p>每个阶段求解时，列出分类讨论的情况，并在最优值后用括号括出路径。</p><p>$f_3(1)=formula=min\{…\}=10$（节点<code>(i+1)</code>出发）</p></li></ul></li></ul></li><li><p>基本要素</p><ul><li>阶段：<code>i</code></li><li>各个阶段的可选方案（从阶段<strong>起点</strong>到阶段<strong>终点</strong>可以采用的方案）：<code>min/max</code>中对应的算法</li><li>各个阶段的状态（从整个模型的起点到该状态的累计）：<code>xi</code></li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><p>背包模型</p><p><img src="https://i.loli.net/2020/11/30/LbmSFM7Vc1J6GhX.png" alt="image-20201130114716371" style="zoom: 33%;" /></p><ul><li>当前阶段<strong>部分</strong>的解由<strong>当前状态</strong>决定</li></ul></li><li><p>劳动力规模模型</p><p><img src="https://i.loli.net/2020/11/30/JIA7ZEHw9QUKhra.png" alt="image-20201130114918767" style="zoom: 67%;" /></p><ul><li>当前阶段<strong>部分</strong>的解由<strong>前一阶段</strong>的状态决定</li></ul></li><li><p>设备更新模型</p><p><img src="https://i.loli.net/2020/11/30/EBsF5vDXRi1SoZj.png" alt="image-20201130115204212" style="zoom: 67%;" /></p><ul><li><p>当前阶段的解由不同的算法决定</p><blockquote><p>前两个模型不同的情况对应<strong>同样的</strong>算法</p></blockquote></li><li><p>通过画图确定不同阶段状态的可能取值</p><p><img src="https://i.loli.net/2020/11/30/43lSb1przDjTkRw.png" alt="image-20201130115505833" style="zoom:50%;" /></p></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Optimization Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;428&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Optimization" scheme="http://yoursite.com/categories/Optimization/"/>
    
    
  </entry>
  
</feed>

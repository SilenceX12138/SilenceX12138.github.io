<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-08T07:51:59.816Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Silence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL-Chapter1-关系模型</title>
    <link href="http://yoursite.com/2020/07/08/MySQL-Chapter1-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/07/08/MySQL-Chapter1-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-07-08T07:53:34.385Z</published>
    <updated>2020-07-08T07:51:59.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>全文共<code>1315</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>关系数据库是建立在关系模型上的</li><li>关系模型本质上就是<strong>若干个</strong>存储数据的<strong>二维表</strong>（看作很多Excel表）</li><li>表的<strong>每一行</strong>称为<strong>记录</strong>(Record)，记录是一个<strong>逻辑意义</strong>上的数据。</li><li>表的<strong>每一列</strong>称为<strong>字段</strong>(Column)，同一个表的<strong>每一行</strong>记录都拥有<strong>相同类型</strong>的若干<strong>字段（列）</strong>。<ul><li>字段定义数据类型</li><li>字段定义数据是否可以为<code>NULL</code>，<code>NULL</code>表示数据<strong>不存在</strong>，<strong>不是</strong>0/空串。</li></ul></li></ul><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>记录需要一个<strong>唯一</strong>的标识来进行区分</li><li>所有的记录的<strong>主键</strong>一定是不同的</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>主键是一个<strong>字段</strong></li><li>主键是用来区分记录的，各个记录的主键字段值<strong>不能相同</strong>。</li></ul><blockquote><p>主键在建立起字段后最后<strong>不要</strong>再进行修改</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>不能用业务相关的字段作为主键</p><blockquote><p>业务相关：变更不可控，例如身份证号的位数可能会发生<strong>变更</strong>。</p></blockquote></li><li><p>不应该允许NULL</p></li><li><p>主键常命名为id</p><ul><li><p>自增整数类型(<code>BIGINT NOT_NULL AUTO_INCREMENT</code>)</p><p>数据库会在插入数据时<strong>自动</strong>为每一条记录分配一个自增整数</p></li><li><p>全局唯一GUID类型</p><p>使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。</p></li></ul></li></ul><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><ul><li>关系数据库实际上还允许通过<strong>多个字段唯一标识记录</strong>，即<strong>两个或更多的字段</strong>都设置为主键，这种主键被称为联合主键。</li></ul><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li><p>在表1中增加表2的主键id，命名为<code>table2_id</code>，即可在<strong>表一</strong>中查找到记录在<strong>表二</strong>中相关字段的索引。</p><blockquote><p>通常用来实现实现<strong>一对多</strong>关系：例如一个班级（<strong>表2</strong>）对应多个学生（<strong>表1</strong>）。</p></blockquote></li></ul><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><ul><li><p><strong>正规外键</strong>不是通过新增字段实现的，而是通过定义外键约束实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><ul><li><code>fk_class_id</code>：外键约束的名称，可以任意。</li><li><code>FOREIGN KEY (class_id)</code>：指定<code>class_id</code>是<strong>外键</strong></li><li><code>REFERENCES classes (id)</code>：指定将<code>class_id</code>这个外键关联到<code>classes</code>的<code>id</code><strong>主键</strong>上</li></ul></li><li><p>通过定义外键约束，关系数据库可以保证<strong>无法插入</strong>无效的数据。即如果<code>classes</code>表<strong>不存在</strong><code>id=99</code>的记录，<code>students</code>表就<strong>无法</strong>插入<code>class_id=99</code>的记录。</p></li><li><p>由于外键约束会<strong>降低</strong>数据库的性能，可以采用变种外键，即<code>class_id</code>仅仅是一个<strong>普通的列</strong>，只是它<strong>起到了</strong>外键的作用而已。</p></li><li><p>删除外键约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><blockquote><p>删除外键约束<strong>并没有</strong>删除外键这一列。<strong>删除列</strong>是通过<code>DROP COLUMN ...</code>实现的。</p></blockquote></li></ul><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><ul><li><p>通过两个一对多关系实现</p><ul><li><p>通过一张中间表，关联两个一对多关系。</p><p>| id   | teacher_id | class_id |<br>| —— | ————— | ———— |<br>| 1    | 1          | 1        |<br>| 2    | 1          | 2        |<br>| 3    | 2          | 1        |<br>| 4    | 3          | 1        |</p></li></ul></li></ul><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><ul><li>一个表的记录对应到另一个表的<strong>唯一一个</strong>记录</li></ul><blockquote><p>一对一表理论上可以合并为一个表，但是一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得<strong>更高的性能</strong>。</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>为了在大数据库中取得较高的查找速度提出的方法</li><li>索引是关系数据库中对<strong>某一列</strong>或<strong>多个列</strong>的<strong>值</strong>进行<strong>预排序</strong>的数据结构（本质是为了缩小查找的范围）</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>情景：经常根据列表的<code>score</code>字段进行查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>索引名称是任意的，索引如果有多列，可以在括号里依次写上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果记录的列存在大量<strong>相同</strong>的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，此时对该列创建索引就<strong>没有意义</strong>。</li><li>索引越<strong>多</strong>，插入、更新和删除记录的速度就越<strong>慢</strong>。</li><li>对于<strong>主键</strong>，关系数据库会<strong>自动</strong>对其创建主键索引。使用主键索引的效率是<strong>最高</strong>的，因为主键会保证绝对唯一。</li></ul></blockquote><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul><li><p>当记录的该字段不会发生重复时，就可以为该列增加唯一索引。</p><p>例如不重名时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD UNIQUE INDEX uni_name (name);</span><br></pre></td></tr></table></figure></li><li><p>唯一索引<strong>不是</strong>主键，例如身份证号，就算位数变化，也不影响唯一性，但是会影响主键的查找。</p></li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会<strong>自动使用索引</strong>来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中<strong>逐步优化</strong>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关系模型&quot;&gt;&lt;a href=&quot;#关系模型&quot; class=&quot;headerlink&quot; title=&quot;关系模型&quot;&gt;&lt;/a&gt;关系模型&lt;/h1&gt;&lt;p&gt;全文共&lt;code&gt;1315&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
&lt;h2 id=&quot;概
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL-Chapter2-数据查询</title>
    <link href="http://yoursite.com/2020/07/08/MySQL-Chapter2-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2020/07/08/MySQL-Chapter2-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-07-08T07:53:34.385Z</published>
    <updated>2020-07-08T07:52:17.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><p>全文共<code>1349</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;table_name&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>SELECT</code>：表示要执行一个查询</li><li><code>*</code>：表示所有<strong>列</strong></li><li><code>FROM</code>：表示将要从哪个表查询、</li></ul><blockquote><ul><li><code>SELECT 1;</code>常用来测试数据库连接</li><li>查询结果是一个<strong>二维表</strong></li></ul></blockquote><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><ul><li><p><code>WHERE</code>引出条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE score &gt;&#x3D; 80;</span><br></pre></td></tr></table></figure></li><li><p><code>AND</code>/<code>OR</code>/<code>NOT</code>进行逻辑运算</p></li><li><p><code>=</code>（<strong>一个</strong>等号）表示相等判断</p></li><li><p><code>&lt;&gt;</code>表示<strong>不等</strong>判断（等价于<code>NOT xxx = xxx;</code>）</p></li><li><p><code>()</code>进行条件分组</p></li></ul><h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><ul><li><p><code>BETWEEN...AND...</code>（<strong>闭</strong>区间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WHERE score &gt;&#x3D; 60 AND score &lt;&#x3D;90;</span><br><span class="line">WHERE score BETWEEN 60 AND 90;</span><br></pre></td></tr></table></figure></li><li><p><code>LIKE</code>判断相似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name LIKE &#39;ab%&#39;</span><br></pre></td></tr></table></figure><ul><li><code>%</code>表示<strong>任意字符</strong>，可以为<strong>空</strong>字符。</li></ul></li></ul><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>只查询<strong>某些列</strong>的操作被称为<strong>投影查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score, name FROM students;</span><br></pre></td></tr></table></figure><ul><li><p>为列增加别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score points, name FROM students;</span><br></pre></td></tr></table></figure><blockquote><p><code>SELECT row1, row2 name2, row3 FROM ...</code></p></blockquote></li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li><p>数据库的查询结果默认按照<code>id</code>（主键）排序</p></li><li><p>使用<code>ORDER BY</code>子句将记录根据字段值<strong>从低到高</strong>进行排序（默认升序<code>ASC</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score;</span><br></pre></td></tr></table></figure><blockquote><p>增加<code>DESC</code>表示<strong>倒序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>多要素排序：将要素依次列出，逗号分隔即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</span><br></pre></td></tr></table></figure></li><li><p>多行查询语句（关键词换行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id &#x3D; 1</span><br><span class="line">ORDER BY score DESC;</span><br></pre></td></tr></table></figure></li><li><p><code>ORDER BY</code>放在查询语句的<strong>最后</strong></p></li></ul><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>当查询结果量很大时，进行分页显示。</p><ul><li><p>实质上就是从结果中<strong>截取</strong>一部分进行显示，进行多次查询即可得知所有结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure><ul><li><code>LIMIT M OFFSET N</code>：从<code>N</code>开始的<strong>最多</strong><code>M</code>条记录（少于<code>M</code>条也不会报错）</li><li>可以简写为<code>LIMIT M, N</code></li><li><code>LIMIT M</code>默认<code>N</code>为0</li></ul></li></ul><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>对于总数、平均数的计算，SQL内置了聚合函数，使用聚合函数进行查询就叫聚合查询。</p><ul><li><p>查询表中<strong>记录</strong>总数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM students;</span><br></pre></td></tr></table></figure><blockquote><p>为返回的表设置别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students;</span><br><span class="line"></span><br><span class="line">&#x2F;* output</span><br><span class="line">    +-----+</span><br><span class="line">    | num |</span><br><span class="line">    +-----+</span><br><span class="line">    |  10 |</span><br><span class="line">    +-----+</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>查询特定记录总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(id) boys FROM students WHERE gender &#x3D; &#39;M&#39;;</span><br></pre></td></tr></table></figure><ul><li><code>COUNT(*)</code>和<code>COUNT(id)</code>等价</li><li>没有匹配到行返回<code>0</code></li></ul></li></ul><h3 id="其他聚合函数"><a href="#其他聚合函数" class="headerlink" title="其他聚合函数"></a>其他聚合函数</h3><ul><li><p><code>SUM</code>：计算某一列的和</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul></li><li><p><code>AVG</code>：计算某一列的平均值</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(score) average FROM students WHERE gender &#x3D; &#39;M&#39;;</span><br></pre></td></tr></table></figure></li><li><p><code>MAX</code>：计算某一列的最大值</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul></li><li><p><code>MIN</code>：计算某一列的最小值</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul></li></ul><blockquote><p>后两个<strong>不限于</strong>数值类型</p></blockquote><ul><li><p><code>FLOOR</code>：向下取整函数</p></li><li><p><code>CEILING</code>：向上取整函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CEILING(COUNT(*) &#x2F; 3) FROM students;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li><p>根据字段值自动分组计数（不用多次查询）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><ul><li><p>为了区分输出的结果是哪个班的，可以多<code>SELECT</code>一个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><ul><li>注意只能<code>SELECT</code>用于分组的字段，加入其他字段可能会出现<strong>一个框内多个值</strong>的情况，MySQL会报错。</li></ul></li></ul></li><li><p>多字段分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, gender, COUNT(*) num </span><br><span class="line">FROM students </span><br><span class="line">GROUP BY class_id, gender;</span><br></pre></td></tr></table></figure></li><li><p>查询各个班级的平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, AVG(score) avg</span><br><span class="line">FROM students</span><br><span class="line">GROUP BY class_id;</span><br></pre></td></tr></table></figure></li><li><p>查出各个班级男生和女生的平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, gender, AVG(score) avg</span><br><span class="line">FROM students</span><br><span class="line">GROUP BY class_id, gender;</span><br><span class="line">-- ORDER BY gender;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>查询两个表的乘积，又称笛卡尔查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students, classes;</span><br></pre></td></tr></table></figure><ul><li><p>将两张表的行逐一进行枚举组合后拼在一起返回</p></li><li><p>结果集<strong>列数</strong>是两张表<strong>列数之和</strong></p></li><li><p>结果集<strong>行数</strong>是两张表<strong>行数之积</strong></p></li><li><p>查询时为了区分列，可以设置别名。（注意字段名的访问方式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">students.id sid,</span><br><span class="line">students.name,</span><br><span class="line">students.gender,</span><br><span class="line">students.score,</span><br><span class="line">classes.id cid,</span><br><span class="line">classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure><p>当表名过长时，可以选择给<strong>表</strong>再起一个别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">s.id sid,</span><br><span class="line">s.name,</span><br><span class="line">s.gender,</span><br><span class="line">s.score,</span><br><span class="line">c.id cid,</span><br><span class="line">c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure></li></ul><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>对多个表进行<code>JOIN</code>运算：先确定一个主表，然后从其他表中选择性地提取一些行加入到结果集中。</p><ul><li><p>查询学生信息的同时需要知道班级id对应的班级名</p><ul><li><p>内连接</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">ON s.class_id &#x3D; c.id;</span><br></pre></td></tr></table></figure><ul><li>确认主表(students)</li><li>确认连接表(classes)</li><li>确认连接条件(<code>ON</code>)：当条件满足时把主表和连接表的<strong>对应行</strong>连接起来</li><li>可以加上查询语句等辅助功能</li></ul></li><li><p>外连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id &#x3D; c.id;</span><br></pre></td></tr></table></figure><blockquote><p>相比于内连接会多出一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idnameclass_idclass_namegenderscore</span><br><span class="line">NULLNULLNULL四班   NULL    NULL</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>RIGHT OUTER JOIN</code>：返回<strong>右表</strong>（连接表）中存在的行（左表不存在无所谓）</li><li><code>LEFT OUTER JOIN</code>：返回<strong>左表</strong>（主表）中存在的行（右表不存在无所谓）</li><li><code>FULL OUTER JOIN</code>：两边表只要有一个存在就返回（<code>RIGHT</code>和<code>LEFT</code>的并集）</li><li><code>INNER JOIN</code>：返回两张表<strong>都存在</strong>的记录</li></ul></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据查询&quot;&gt;&lt;a href=&quot;#数据查询&quot; class=&quot;headerlink&quot; title=&quot;数据查询&quot;&gt;&lt;/a&gt;数据查询&lt;/h1&gt;&lt;p&gt;全文共&lt;code&gt;1349&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
&lt;h2 id=&quot;基
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL-Chpater0-数据库概述</title>
    <link href="http://yoursite.com/2020/07/08/MySQL-Chpater0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/07/08/MySQL-Chpater0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</id>
    <published>2020-07-08T07:53:34.385Z</published>
    <updated>2020-07-08T07:51:25.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><p>全文共<code>348</code>字，推荐阅读时间<code>3~5</code>分钟。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>应用程序<strong>不需要</strong>自己管理数据，而是通过数据库软件提供的<strong>接口</strong>来读写数据。</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><ul><li>树形结构</li></ul><p><img src="https://i.loli.net/2020/07/01/wScTtsDdWhjIzL4.png" alt="XR@5HT3{ZYUZH}~HSF~HTWE" style="zoom:50%;" /></p><h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><ul><li>图结构</li></ul><p><img src="https://i.loli.net/2020/07/01/lK8DtykOrIJS5eA.png" alt="two" style="zoom:50%;" /></p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><ul><li>二维表格</li><li>通过行号和列号定位</li><li><strong>占数据库的主导地位</strong></li></ul><p><img src="https://i.loli.net/2020/07/01/ricl1Rg87oAECqd.png" alt="three" style="zoom:50%;" /></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>关系表中，除了每一列的名称，还需要定义每一列的<strong>数据类型</strong>。</li></ul><div class="table-container"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>INT</td><td>整型</td><td>4字节</td></tr><tr><td>BIGINT</td><td>长整型</td><td>8字节</td></tr><tr><td>REAL</td><td>浮点型</td><td>4字节</td></tr><tr><td>DOUBLE</td><td>浮点型</td><td>8字节</td></tr><tr><td>DECIMAL(M,N)</td><td>高精度小数</td><td>M表示数字总共多少位，N表示小数有多少位，常用于财务计算。</td></tr><tr><td>CHAR(N)</td><td>定长字符串</td><td>N表示字符串长度</td></tr><tr><td>VARCHAR(N)</td><td>变长字符串</td><td>N表示长度上限</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td><td>True/False</td></tr><tr><td>DATE</td><td>日期类型</td><td>2020-07-01</td></tr><tr><td>TIME</td><td>时间类型</td><td>12:20:25</td></tr><tr><td>DATETIME</td><td>日期和时间类型</td><td>2020-07-01 12:20:25</td></tr></tbody></table></div><blockquote><p><code>BIGINT</code>和<code>VARCHAR</code>是使用<strong>最广泛</strong>的两种类型</p></blockquote><h4 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h4><p>SQL关键字<strong>不区分</strong>大小写，但是规范如下：</p><ul><li>关键字统一使用<strong>大写</strong></li><li>表名和列名统一使用<strong>小写</strong></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库概述&quot;&gt;&lt;a href=&quot;#数据库概述&quot; class=&quot;headerlink&quot; title=&quot;数据库概述&quot;&gt;&lt;/a&gt;数据库概述&lt;/h1&gt;&lt;p&gt;全文共&lt;code&gt;348&lt;/code&gt;字，推荐阅读时间&lt;code&gt;3~5&lt;/code&gt;分钟。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript-Chapter3-面向对象编程</title>
    <link href="http://yoursite.com/2020/07/08/JavaScript-Chapter3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/08/JavaScript-Chapter3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2020-07-08T03:58:19.068Z</published>
    <updated>2020-07-08T03:59:13.050Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1107</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不同于Java，JavaScript的OO中没有Class和实例的概念。</p><ul><li><p>在JavaScript中，通过<strong>原型</strong>实现OO编程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'Robot'</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Student;</span><br></pre></td></tr></table></figure><ul><li><p>定义一个模型变量<code>Student</code></p></li><li><p>通过修改对象的<code>__proto__</code>域可以实现对象的<strong>动态</strong>改变，但是在编程时<strong>不推荐</strong>使用这种方式创建对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Bird = &#123;</span><br><span class="line">    fly: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is flying...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Bird;</span><br></pre></td></tr></table></figure><blockquote><p>此时<code>xiaoming</code>就<strong>没有</strong><code>run</code>方法了</p></blockquote></li></ul></li><li><p>JavaScript中所有对象<strong>都是实例</strong></p></li><li><p>使用封装好的<code>Object.create()</code>方法改变对象继承的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'Robot'</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'is running...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</span><br><span class="line">    s.name = name;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">'xiaoming'</span>);</span><br><span class="line">xiaoming.run();</span><br><span class="line">xiaoming.__proto___ === Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>所有原型最后都会回到<code>null</code></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>如果不写<code>new</code>，则<code>Student</code>函数就是一个普通函数；如果写了<code>new</code>，则<code>Student</code>就是一个构造函数，它<strong>根据原型对象</strong>创建一个<strong>新对象</strong>并把<code>this</code>指向它，同时<strong>不需要</strong>显式<code>return</code>.</p></li><li><p><code>xiaoming</code><strong>从新对象</strong>得到了一个<code>constructor</code>属性，指向函数<code>Student</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.constructor === Student.prototype.constructor; <span class="comment">// true</span></span><br><span class="line">Student === Student.prototype.constructor; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(xiaoming) === Student.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>关系示意图<br><img src="https://static.liaoxuefeng.com/files/attachments/1024698721053600/l"  /></p><ul><li>某个对象即构造函数对应的<strong>唯一的原型对象</strong></li></ul></li><li><p>不同对象尽管由同一个原型对象创建得到，但是其中的属性除了<code>constructor</code>之外都是<strong>独立的</strong>。（但是访问<code>constructor</code>直接<code>xxx.constructor</code>，<strong>而不是</strong>使用<code>xxx.prototype.constructor</code>.）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.name; <span class="comment">// '小明'</span></span><br><span class="line">xiaohong.name; <span class="comment">// '小红'</span></span><br><span class="line">xiaoming.hello; <span class="comment">// function: Student.hello()</span></span><br><span class="line">xiaohong.hello; <span class="comment">// function: Student.hello()</span></span><br><span class="line">xiaoming.hello === xiaohong.hello; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p>对于可共享函数，可以采用直接对<strong>原型对象域</strong>操作的办法进行设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>此时所有的<code>Student</code>对象共享同一个<code>hello</code></p><blockquote><p>构造函数中的属性都是独立的，直接在<code>prototype</code>中修改的就是共享的。</p></blockquote></li><li><p>此时<code>this</code>指向调用<strong>该方法</strong>的对象</p></li><li><p><code>prototype</code>这个属性只有构造函数有，对象只有<code>__proto__</code>.</p></li></ul></li></ul></li><li><p>普通函数的首字母小写，构造函数的<strong>首字母大写</strong>。</p></li><li><p>为了省略显示<code>new</code>操作，可以进行封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = props.name || <span class="string">'匿名'</span>; <span class="comment">// 默认值为'匿名'</span></span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>; <span class="comment">// 默认值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Student(props || &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(&#123;</span><br><span class="line">    name: <span class="string">'xiaoming'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>使用<code>||</code>实现默认值操作</li><li>注意传入的参数是<strong>对象</strong></li></ul></li></ul><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><ul><li><p>定义新的构造函数，并在内部调用被继承的函数，并绑定<code>this</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Student构造函数，绑定this变量:</span></span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>借助中间函数<code>F</code>实现原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrimaryStudent构造函数:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空函数F:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把F的原型指向Student.prototype:</span></span><br><span class="line">F.prototype = Student.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span></span><br><span class="line">PrimaryStudent.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span></span><br><span class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建xiaoming:</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> PrimaryStudent(&#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    grade: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">xiaoming.name; <span class="comment">// '小明'</span></span><br><span class="line">xiaoming.grade; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型:</span></span><br><span class="line">xiaoming.__proto__ === PrimaryStudent.prototype; <span class="comment">// true</span></span><br><span class="line">xiaoming.__proto__.__proto__ === Student.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承关系:</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> PrimaryStudent; <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>一个函数本身就算不是构造函数，加了<code>new</code>也能正常执行。</p></blockquote><ul><li><p>关系图</p><p><img src="https://static.liaoxuefeng.com/files/attachments/1034288859918112/l" alt=""></p></li><li><p>为了简化，可以把继承封装为一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line">    Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在新的构造函数的原型上定义新方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = props.name || <span class="string">'Unnamed'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现原型继承链:</span></span><br><span class="line">inherits(PrimaryStudent, Student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h2><p>为了简化原型继承提出了新关键字<code>class</code></p><ul><li><p>使用<code>class</code>直接编写类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hello() &#123;</span><br><span class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义方法<strong>不需要</strong><code>function</code>关键字</li></ul></li><li><p>继承实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, grade) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myGrade() &#123;</span><br><span class="line">        alert(<span class="string">'I am at grade '</span> + <span class="keyword">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>class继承就是为了简化原型继承，但是可能会碰到不兼容的情况，可以使用<code>Babel</code>工具进行<code>class</code>继承到传统原型继承的转换。</p></blockquote></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1107&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript-Chapter2-标准对象</title>
    <link href="http://yoursite.com/2020/07/07/JavaScript-Chapter2-%E6%A0%87%E5%87%86%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/07/07/JavaScript-Chapter2-%E6%A0%87%E5%87%86%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-07-07T02:37:40.719Z</published>
    <updated>2020-07-07T02:38:27.546Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1397</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>使用<code>typeof</code>操作符获取对象的类型（返回一个<strong>小写字符串</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'str'</span>; <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// 'function'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure><ul><li><code>null</code>的类型属于<code>object</code></li></ul></li><li><p>包装对象：类似Java中<code>int</code>和<code>Integer</code>的关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>) === <span class="string">'str'</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p>通常<strong>不使用</strong>包装对象</p></li><li><p>当不写<code>new</code>时，<code>Number()</code>/<code>Boolean()</code>/<code>String()</code>会被当作<strong>普通函数</strong>，把其他数据转换成自己的<strong>基本数据类型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">Number</span>(<span class="string">'123'</span>); <span class="comment">// 123，相当于parseInt()或parseFloat()</span></span><br><span class="line"><span class="keyword">typeof</span> n; <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Boolean</span>(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// 'boolean'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Boolean</span>(<span class="string">'false'</span>); <span class="comment">// true! 'false'字符串转换结果为true！因为它是非空字符串！</span></span><br><span class="line"><span class="keyword">var</span> b3 = <span class="built_in">Boolean</span>(<span class="string">''</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">String</span>(<span class="number">123.45</span>); <span class="comment">// '123.45'</span></span><br><span class="line"><span class="keyword">typeof</span> s; <span class="comment">// 'string'</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>类型判断</p><ul><li><code>Array</code>：<code>Array.isArray(arr)</code></li><li><code>null</code>：<code>myVar === null</code></li><li>全局变量是否存在：<code>typeof window.myVar === &#39;undefined&#39;</code></li><li>局部变量是否存在：<code>typeof myVar === &#39;undefined&#39;</code></li></ul></li><li><p>注意事项</p><ul><li><p><code>null</code>和<code>undefined</code>没有<code>toString()</code>方法</p><blockquote><p>尽管<code>null</code>是<code>object</code>类型</p></blockquote></li><li><p>数字转换为字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span>.toString(); <span class="comment">// two dots</span></span><br><span class="line">(<span class="number">123</span>).toString(); <span class="comment">// add brackets</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>不能</strong>使用<code>123.toStirng()</code></p></blockquote></li></ul></li></ul><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p><code>Date</code>对象表示日期和时间</p><ul><li><p>获取当前时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br><span class="line"><span class="built_in">Date</span>.now(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个指定日期和时间的<code>Date</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mannully set arguments</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</span><br><span class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// format string of ISO 8601</span></span><br><span class="line"><span class="keyword">var</span> timeStamp = <span class="built_in">Date</span>.parse(<span class="string">'2015-06-24T19:49:22.875+08:00'</span>);</span><br><span class="line">timeStamp; <span class="comment">// 1435146562875</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp);</span><br><span class="line">d; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">d.getMonth(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><ul><li><p>JavaScript中月份范围用整数表示是<code>0~11</code>，所以5表示6月。</p><blockquote><p>使用<code>Date.parse()</code>时传入的字符串使用实际月份<code>01~12</code>，转换为Date对象后<code>getMonth()</code>获取的月份值为<code>0~11</code>.</p></blockquote></li></ul></li><li><p>时区转换</p><p>Date显示的时间总是按<strong>浏览器所在时区</strong>显示的，也可以转换为UTC时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>);</span><br><span class="line">d.toLocaleString(); <span class="comment">// '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关</span></span><br><span class="line">d.toUTCString(); <span class="comment">// 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>通过<code>//</code>引出</p></li><li><p>通过<code>RegExp</code>声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ABC\\-001'</span>);</span><br><span class="line"></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure><blockquote><p>第二种写法要同时考虑<strong>字符串中<code>\</code>的转义问题</strong></p></blockquote></li></ul><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;</span><br><span class="line">re.test(<span class="string">'010-12345'</span>); <span class="comment">// true</span></span><br><span class="line">re.test(<span class="string">'010-1234x'</span>); <span class="comment">// false</span></span><br><span class="line">re.test(<span class="string">'010 12345'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a b   c'</span>.split(<span class="string">' '</span>); <span class="comment">// ['a', 'b', '', '', 'c']</span></span><br><span class="line"><span class="string">'a b   c'</span>.split(<span class="regexp">/\s+/</span>); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"><span class="string">'a,b, c  d'</span>.split(<span class="regexp">/[\s\,]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br><span class="line"><span class="string">'a,b;; c  d'</span>.split(<span class="regexp">/[\s\,\;]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>在正则中进行分组可以直接在字符串中提取出想要的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</span><br><span class="line">re.exec(<span class="string">'010-12345'</span>); <span class="comment">// ['010-12345', '010', '12345']</span></span><br><span class="line">re.exec(<span class="string">'010 12345'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><ul><li>匹配成功时，返回的数组的第一个元素的整个字符串。</li><li>匹配失败时，返回<code>null</code>.</li></ul><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>JavaScript默认采用贪婪匹配，也就是匹配尽可能多的字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '102300', '']</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p></blockquote><ul><li><p>开启非贪婪匹配：加一个<code>?</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '1023', '00']</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h3><p>全局匹配可以对同一个字符串进行多次匹配，并且下一次匹配的起点是这一次匹配终点的下一个字符索引。</p><h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'test'</span>, <span class="string">'g'</span>);</span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'JavaScript, VBScript, JScript and ECMAScript'</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s); <span class="comment">// ['JavaScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['VBScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['JScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['ECMAScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure><h3 id="其他标志"><a href="#其他标志" class="headerlink" title="其他标志"></a>其他标志</h3><ul><li><code>i</code>表示忽略大小写</li><li><code>m</code>表示执行多行匹配</li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是JavaScript Object Notation的缩写，是一种数据交换格式。</p><ul><li>JSON的序列集必须是UTF-8</li><li>JSON的<strong>字符串和Object的key</strong>必须使用<code>&quot;&quot;</code></li><li>JSON反序列化后即可成为JavaScript对象</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</span><br><span class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>普通序列化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);</span><br></pre></td></tr></table></figure></li><li><p>格式序列化：二、三参数只是为了<strong>占位</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">' '</span>);</span><br></pre></td></tr></table></figure><blockquote><p>输出一个键值对就换一次行</p></blockquote></li><li><p>筛选格式化：第二个参数传入数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, [<span class="string">'name'</span>, <span class="string">'skills'</span>], <span class="string">' '</span>);</span><br></pre></td></tr></table></figure><blockquote><p>只输出指定的属性</p></blockquote></li><li><p>预处理格式化：第二个参数传入函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, convert, <span class="string">'  '</span>);</span><br></pre></td></tr></table></figure></li><li><p>精确序列化：为对象增加<code>toJSON</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</span><br><span class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>],</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 只输出name和age，并且改变了key：</span></span><br><span class="line">            <span class="string">'Name'</span>: <span class="keyword">this</span>.name,</span><br><span class="line">            <span class="string">'Age'</span>: <span class="keyword">this</span>.age</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p><code>JSON.parse</code>可以把输入元素解析为JavaScript对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1,2,3,true]'</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>); <span class="comment">// Object &#123;name: '小明', age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'123.45'</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><ul><li><p>指定处理函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'name'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">'同学'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;name: '小明同学', age: 14&#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1397&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript-Chapter1-函数</title>
    <link href="http://yoursite.com/2020/07/06/JavaScript-Chapter1-%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/07/06/JavaScript-Chapter1-%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-06T07:25:02.176Z</published>
    <updated>2020-07-06T07:33:37.342Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>3321</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="定义与调用"><a href="#定义与调用" class="headerlink" title="定义与调用"></a>定义与调用</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>返回值、函数参数<strong>不用</strong>标注类型</p></li><li><p>如果<strong>没有</strong><code>return</code>语句或<code>return</code>后没有值，函数执行完毕后返回<code>undefined</code>.</p><blockquote><p>相当于函数体最后默认添加<code>return undefined;</code></p></blockquote></li><li><p>函数实际上是一个函数对象，函数名可以视为指向该函数的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>此时<code>abs</code>是一个函数变量，指向的函数被称作<strong>匿名函数</strong>。</li><li>注意函数体后有一个<code>;</code></li><li>调用方式依然为<code>abs(x)</code></li></ul></li></ul><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><ul><li><p><code>JavaScript</code>允许传入任意多个参数，即使比规定的参数要多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abs(<span class="number">10</span>, <span class="string">'balabala'</span>); <span class="comment">// return 10</span></span><br><span class="line">abs();<span class="comment">// return NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>参数无效时返回<code>NaN</code>而不是<code>undefined</code></p></blockquote></li><li><p>无效参数的过滤方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x !== <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Not a number'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>arguments</code>：在函数内部存储所有参数的一个<strong>类数组</strong>（不是数组）</p><ul><li><p>过滤空参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rest</code>：用于存储变长参数的<strong>数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行<code>return</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号 因为&#123;表示语句尚未结束</span></span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>return</code>所在行一定要有<code>{</code>，否则引擎会自动添加分号导致<code>return</code>一个<code>undefined</code>.</p></blockquote></li></ul><h2 id="作用域和解构赋值"><a href="#作用域和解构赋值" class="headerlink" title="作用域和解构赋值"></a>作用域和解构赋值</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li><p>变量的作用域就在函数体内部，如果出现嵌套函数中<strong>变量重名</strong>的情况，则以<strong>内部函数自己</strong>的变量为准。(变量栈)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x in bar() = '</span> + x); <span class="comment">// 'A'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x in foo() = '</span> + x); <span class="comment">// 1</span></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><blockquote><p>内部函数的<code>x</code>值也<strong>不会</strong>影响外部函数</p></blockquote></li><li><p>变量提升：<strong>函数</strong>（普通代码段<strong>也是</strong>）在执行前会先扫描整个函数体的语句，并且把所有声明都移动到<strong>函数顶部</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>函数可以正常执行，但是输出是<code>Hello, undefined</code>.</p></li><li><p>提升的<strong>仅仅是</strong>变量的<strong>声明</strong>，而<strong>不是</strong>变量的<strong>赋值</strong>。</p></li><li><p>良好的编码习惯是<strong>手动</strong>在函数顶部就声明所有的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">    x = <span class="number">1</span>,</span><br><span class="line">    y = x + <span class="number">1</span>,</span><br><span class="line">        z, i; <span class="comment">// init as undefined</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>全局作用域：不在任何一个函数内定义的变量</p><ul><li><p>JavaScript默认有一个<strong>全局对象<code>window</code></strong>，全局作用域的变量实际上会被绑定为<code>window</code>的一个<strong>属性</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> course = <span class="string">'Learn JavaScript'</span>;</span><br><span class="line">alert(course); <span class="comment">// Learn JavaScript</span></span><br><span class="line">alert(<span class="built_in">window</span>.course); <span class="comment">// Learn JavaScript</span></span><br><span class="line">course === <span class="built_in">window</span>.course; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>顶层函数</strong>也会被视为一个全局变量绑定到<code>window</code>上</p></li></ul><blockquote><p><code>window.xxx</code>的效果和<code>xxx</code>的全局变量其实是一样的（与对象的<code>this</code><strong>无关</strong>）</p></blockquote></li><li><p>名字空间</p><ul><li><p>当不同文件使用了<strong>相同的</strong>全局变量（包括顶层函数）就会造成命名冲突</p></li><li><p>把自己的所有变量和函数全部绑定到<strong>一个自定义的全局变量</strong>中就可以解决命名冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MYAPP.name = <span class="string">'myapp'</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>MYAPP</code>被称作<strong>名字空间</strong></p></blockquote></li></ul></li><li><p>局部作用域</p><ul><li><p>for语句<code>var</code>定义的循环变量<strong>不是</strong>局部作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将<code>var</code>改为<code>let</code>就可以声明一个<strong>块级作用域</strong>的变量</p></blockquote></li></ul></li><li><p>常量：<code>const</code>定义，<strong>初始化后不能被修改</strong>，具有<strong>块级</strong>作用域。</p></li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul><li><p>同时对一组变量进行赋值的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">'hello'</span>, [<span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]];</span><br><span class="line">x; <span class="comment">// 'hello'</span></span><br><span class="line">y; <span class="comment">// 'JavaScript'</span></span><br><span class="line">z; <span class="comment">// 'ES6'</span></span><br></pre></td></tr></table></figure><ul><li>保证左右两边的<strong>结构相同</strong></li></ul></li><li><p>忽略元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]; <span class="comment">// 忽略前两个元素，只对z赋值第三个元素</span></span><br><span class="line">z; <span class="comment">// 'ES6'</span></span><br></pre></td></tr></table></figure></li><li><p>拆解对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>拆解对象时<strong>不是</strong>按照顺序，而是按照<strong>指定的属性名字</strong>。</p></li><li><p>变换赋值变量的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person; <span class="comment">// id's value is 'G-12345678'</span></span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>嵌套对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        city: <span class="string">'Beijing'</span>,</span><br><span class="line">        street: <span class="string">'No.1 Road'</span>,</span><br><span class="line">        zipcode: <span class="string">'100001'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>当属性不存在时，会得到<code>undefined</code>.</p></li><li><p>使用默认值可以避免<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>以上情况都是把变量声明和赋值放在一起执行的，当分开并且是<strong>对象间赋值时（大括号）</strong>，需要进行特殊处理，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量:</span></span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correction : add brackets</span></span><br><span class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>交换变量值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>JavaScript的对象方法设计存在缺陷，因此需要单独设立新的<strong>对象方法调用方式</strong>。</p><ul><li><p><code>apply</code>/<code>call</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 30</span></span><br><span class="line">getAge.apply(xiaoming,[]);</span><br><span class="line">getAge.call(xiaoming,); <span class="comment">// comma can be neglected</span></span><br></pre></td></tr></table></figure><ul><li><code>apply</code>的第一个参数是使用对象，第二个参数是所有函数参数组成的数组。</li><li><code>call</code>的方法参数<strong>不按数组</strong>传入，而是<strong>按照顺序</strong>传入。</li><li><code>obj.xxx()</code>的方式<strong>不推荐</strong>使用，因为对于嵌套函数，<code>this</code>在<strong>内层</strong>的指向是<code>undefined</code>/<code>window</code>（取决于是否打开strict模式）</li></ul></li><li><p>装饰器</p><p>使用apply动态改变函数的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>新的自定义函数<code>parseInt</code>可以统计函数调用次数</p></blockquote></li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>接受<strong>函数作为参数</strong>的函数叫做高阶函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">-3</span>, <span class="built_in">Math</span>.abs);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><p><code>map()</code>定义在<code>Array</code>上，调用<code>Array</code>的<code>map()</code>方法并传入我们自己的函数，作用于数组的每一个元素，就能得到一个新的<code>Array</code>并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow);</span><br><span class="line"><span class="built_in">console</span>.log(results); <span class="comment">// 1,4,9</span></span><br></pre></td></tr></table></figure><ul><li><p>整数数组转换为字符串数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.map(<span class="built_in">String</span>); <span class="comment">// ['1', '2', '3']</span></span><br></pre></td></tr></table></figure></li><li><p>字符串数组变为整数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">arr.map(<span class="built_in">parseInt</span>); <span class="comment">// 1,NaN,NaN</span></span><br><span class="line">arr,map(<span class="built_in">Number</span>); <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>map()</code>接收的回调函数可以有3个参数：<code>callback(currentValue, index, array)</code>，通常我们仅需要第一个参数，而忽略了传入的后面两个参数。不幸的是，<code>parseInt(string, radix)</code><strong>没有</strong>忽略第二个参数，导致实际执行的函数分别是：</p><ul><li>parseInt(‘1’, 0); // 1, 按十进制转换</li><li>parseInt(‘2’, 1); // NaN, 没有一进制</li><li>parseInt(‘3’, 2); // NaN, 按二进制转换不允许出现3</li></ul><p>可以改为<code>r = arr.map(Number);</code>，因为<code>Number(value)</code>函数仅接收<strong>一个</strong>参数。</p></blockquote></li></ul></li></ul><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul><li><p>二元参数函数的迭代运算</p><p>$[x1,\ x2,\ x3,\ x4].reduce(f)\ =\ f(f(f(x1,\ x2),\ x3),\ x4)$</p></li><li><p>数组求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>把某些元素过滤掉，返回剩下的元素组成的数组。</p><h4 id="过滤函数"><a href="#过滤函数" class="headerlink" title="过滤函数"></a>过滤函数</h4><p>返回值为<strong><code>true</code>则保留</strong>，返回值为<strong><code>false</code>则删除</strong>。（不能省略<code>return</code>）</p><ul><li><p>删除偶数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>删除空字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">'C'</span>, <span class="string">'  '</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s &amp;&amp; s.trim(); <span class="comment">// 注意：IE9以下的版本没有trim()方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>删除重复元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数通常有三个参数</p><ul><li><code>element</code>：数组元素</li><li><code>index</code>：数组索引</li><li><code>self</code>：数组本身</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul><li><p>JavaScript的<code>sort</code>方法默认把<strong>所有元素</strong>先转换为<code>String</code>再排序（整数数组也按<strong>字典序</strong>排序）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure></li><li><p><code>sort</code>方法接受自定义排序函数</p></li></ul><h3 id="其他高阶函数"><a href="#其他高阶函数" class="headerlink" title="其他高阶函数"></a>其他高阶函数</h3><ul><li><p><code>every</code>：判断所有元素是否满足测试条件，有一个不满足就返回<code>false</code>.</p></li><li><p><code>find</code>：查找符合条件的第一个元素，找到了返回该元素，否则返回<code>undefined</code>.</p></li><li><p><code>findIndex</code>：类似<code>find</code>，但是查找失败时返回<code>-1</code>.</p></li><li><p><code>forEach</code>：类似<code>map</code>但是<strong>不会</strong>返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>];</span><br><span class="line">arr.forEach(<span class="built_in">console</span>.log); <span class="comment">// 依次打印每个元素</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为<strong>返回值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当调用<code>lazy_sum()</code>时，返回的<strong>不是求和结果</strong>，而是<strong>求和函数</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure></li><li><p>调用函数<code>f</code>时才返回求和结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li>在<code>lazy_sum</code>中定义函数<code>sum</code>时虽然<code>arr</code>有效，但是此时<strong>是定义而不是调用</strong>，因此不会计算。</li><li>每次调用<code>lazy_sum</code>都会返回一个<strong>新函数</strong></li></ul></blockquote><h3 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h3><p>在<code>lazy_sum</code>返回<code>sum</code>后，<code>lazy_sum</code>中的<strong>参数和变量</strong>都保存在返回的函数中，这种程序结构被称作闭包。</p><ul><li><p>闭包中函数的调用时机</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 16</span></span><br><span class="line">f2(); <span class="comment">// 16</span></span><br><span class="line">f3(); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><ul><li>首先<code>var results = count();</code>，函数<code>count</code>已经被调用了，所以依次执行函数内的各段代码。</li><li>此时循环体执行了push方法，将一个个函数<code>function () { return i * i;}</code>添加到数组内，但是这个函数并没有被调用，还只是一个变量，所以for循环依次执行，直到<code>i = 4</code>.</li><li>因为闭包，内部函数<code>function () { return i * i;}</code>引用的<code>i</code>就是for循环中的<code>i = 4</code>。所以，之后数组<code>arr</code>内的函数的<code>i</code>都是4。</li><li>调用函数<code>count</code>后，变量<code>results</code>已经是数组<code>arr</code>了。数组里面元素依次是<ul><li><code>function f1() { return i * i;}</code></li><li><code>function f2() { return i * i;}</code> </li><li><code>function f3() { return i * i;}</code></li></ul></li><li>但是三个函数都没有被调用，<strong>直到</strong><code>f1()</code>.（闭包内函数的调用）</li><li>此时<code>function f1() { return i * i;}</code>开始执行，如上段所写，此时的<code>i = 4</code>，所以，返回值就<strong>都是</strong>16了。</li></ul></li><li><p>闭包函数调用注意事项</p><ul><li><p>返回函数不要引用任何<strong>循环变量</strong>，或者<strong>后续会发生变化的变量</strong>。</p></li><li><p>一定要引用循环变量时，用<strong>函数参数</strong>绑定<strong>循环变量</strong>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push((<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> n * n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 1</span></span><br><span class="line">f2(); <span class="comment">// 4</span></span><br><span class="line">f3(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><ul><li><p>创建匿名函数并<strong>绑定参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)(<span class="number">3</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><blockquote><p>注意函数部分（不包括参数）需要单独再多加<strong>一对括号</strong>。</p></blockquote></li></ul></li></ul></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>创建<strong>延迟执行</strong>的函数</p></li><li><p>在没有<code>class</code>机制的<code>JavaScript</code>中封装一个私有变量</p><p>利用闭包返回一个对象，在该对象中的变量无法通过外界访问到，相当于实现了私有变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = initial || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = create_counter();</span><br><span class="line">c1.inc(); <span class="comment">// 1</span></span><br><span class="line">c1.inc(); <span class="comment">// 2</span></span><br><span class="line">c1.inc(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</span><br><span class="line">c2.inc(); <span class="comment">// 11</span></span><br><span class="line">c2.inc(); <span class="comment">// 12</span></span><br><span class="line">c2.inc(); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><blockquote><p>此时只有<code>c1</code>/<code>c2</code>可以修改各自的<code>x</code></p></blockquote></li><li><p>利用闭包将<strong>多参数</strong>函数变为<strong>单参数</strong>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_pow</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>和装饰器不同，闭包封装函数并没有立即执行。</li></ul></li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li><p>结构</p><p>$(参数列表)+\{…\}$</p><ul><li>参数只有<strong>一个</strong>时可以<strong>不需要</strong>用括号把参数包起来</li></ul></li><li><p>返回对象时，因为对象的外层是<code>{}</code>和块结构语法冲突，所以需要<strong>单独</strong>加一层<code>()</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure></li><li><p>和匿名函数的区别：箭头函数内的<code>this</code>由词法作用域决定，而不是<code>window</code>或<code>undefined</code>.</p><ul><li>匿名函数中的<code>this</code>在没有开启<code>strict</code>模式时指向<code>window</code>对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anonymous function</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window或undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>箭头函数中的<code>this</code>指向词法作用域，也就是<code>obj</code>对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrow function</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul><li>类似于函数，但是除了<code>return</code>外，还可以<code>yield</code>返回多次。</li><li>一个可以记住执行状态的函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>生成器实现fib数列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        arr = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (arr.length &lt; max) &#123;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        arr.push(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试:</span></span><br><span class="line">fib(<span class="number">5</span>); <span class="comment">// [0, 1, 1, 2, 3]</span></span><br><span class="line">fib(<span class="number">10</span>); <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = fib(<span class="number">5</span>);</span><br><span class="line">f.next(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> fib(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 依次输出0, 1, 1, 2, 3, ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次<code>next</code>调用就会返回一次<code>yield</code>对象</li><li>碰到<code>return</code>后返回的对象中<code>done</code>为<code>true</code></li><li>直接使用<code>for-of</code>循环遍历也可以得到结果</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;3321&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript-Chapter0-基础</title>
    <link href="http://yoursite.com/2020/07/05/JavaScript-Chapter0-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/07/05/JavaScript-Chapter0-%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-05T03:54:22.805Z</published>
    <updated>2020-07-05T04:10:56.373Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>2099</code>字，推荐阅读时间<code>10~15</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">'Hello, world'</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>也可以把JavaScript代码放到一个单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src = &quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/js/abc.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li><p>语句以<code>;</code>结束，语句块用<code>{...}</code>.</p><blockquote><p>和Java相同</p></blockquote></li><li><p>注释</p><ul><li>行：<code>//</code></li><li>块：<code>/*...*/</code></li></ul></li></ul><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ul><li><p>Number</p><p>不区分整数和浮点数，统一用Number表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>;</span><br><span class="line"><span class="number">0.456</span>;</span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// Not a Number 表示无法计算的结果</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// 无限大</span></span><br></pre></td></tr></table></figure></li><li><p>字符串</p><p>单引号或双引号括起来的文本</p></li><li><p>布尔值</p><ul><li><p><code>true</code>/<code>false</code></p></li><li><p>逻辑运算：<code>&amp;&amp;</code>/<code>||</code>/<code>!</code></p></li><li><p>比较运算符</p><ul><li><p><code>==</code>：<strong>会自动转换</strong>数据类型，可能得到奇怪的结果。</p></li><li><p><code>===</code>：<strong>不会自动转换</strong>数据类型，类型不一致会返回<code>false</code>.</p><blockquote><p>使用<code>===</code>进行比较</p></blockquote></li><li><p><code>NaN</code>和其他所有值都不相等，<strong>包括自己</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>通过<code>isNaN</code>对NaN进行判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);</span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ul></li><li><p><code>null</code>/<code>undefined</code></p><p>  两者意义相近，通常使用<code>null</code>，<code>undefined</code>仅在<strong>判断函数参数是否传递</strong>的情况下有用。</p></li><li><p>数组</p><ul><li><p>可以包括任意数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li><li><p>创建数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象</p><p>  一组由键值对组成的<strong>无序</strong>集合</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">'js'</span>, <span class="string">'web'</span>],</span><br><span class="line">    zipcode: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>key都是<strong>字符串</strong>类型</li><li>value可以是<strong>任意</strong>数据类型</li><li>使用<code>person.name</code>访问值</li></ul></li><li><p>变量</p><p>  JavaScript是<strong>动态语言</strong></p><ul><li><p>声明变量</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// $ can be used as a part of var name</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>显示变量内容：<code>console.log(x)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>alert</code>会弹出对话框，但是<code>console.log</code>不会。</li><li><code>log</code>会自动增加<strong>换行</strong></li></ul></blockquote></li><li><p>strict模式</p><ul><li><p>如果声明变量时<strong>不</strong>使用<code>var</code>，则变量就会被声明为<strong>全局变量</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>strict模式在遇到<strong>未使用</strong><code>var</code>声明的变量时会报错</p></li><li><p>开启strict模式：在第一行写上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>尽量在所有的<code>.js</code>文件中都启用strict模式</p></blockquote></li></ul></li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>多行字符串</p><p>用反引号<strong>`</strong>表示</p></li><li><p>模板字符串</p><ul><li><p>字符串可以使用<code>+</code>号链接</p></li><li><p>使用<code>${}</code>进行字符串替换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>, I'm <span class="subst">$&#123;age&#125;</span> years old!`</span></span><br></pre></td></tr></table></figure><blockquote><p>反引号也可以引出<strong>单行</strong>字符串</p></blockquote></li></ul></li><li><p>操作字符串</p><ul><li><p>获取长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</span><br><span class="line">s.length; <span class="comment">// length是一个属性</span></span><br></pre></td></tr></table></figure></li><li><p>指定索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong>超过</strong>s长度（<strong>包括</strong>访问空字符<code>\0</code>位置）时返回<code>undefined</code></p></blockquote></li><li><p>字符串<strong>不可变</strong>，对<strong>索引</strong>赋值不会引起错误，但是也<strong>不会改变</strong>字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Test'</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'X'</span>;</span><br><span class="line">alert(s); <span class="comment">// 'Test'</span></span><br></pre></td></tr></table></figure><blockquote><p>但是如果对将字符串变量<strong>整个</strong>重新赋值，就会指向一个<strong>新的字符串</strong>。</p></blockquote></li><li><p>以下函数不会改变原有字符串，而是<strong>返回</strong>新字符串。</p><ul><li><p><code>toUpperCase</code>/<code>toLowerCase</code>：改变<strong>所有字符</strong>的大小写</p></li><li><p><code>indexOf</code>：搜索指定<strong>字符串</strong>出现的<strong>首字母</strong>位置</p><blockquote><p>没有找到时返回<code>-1</code></p></blockquote></li><li><p><code>substring</code>：字符串切片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'0123456789'</span>;</span><br><span class="line">s.substring(<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// 012</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 789</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>不包括<strong>右</strong>端点</li><li>超过字符串长度<strong>不会</strong>报错，而是返回一个<strong>空字符串</strong>。</li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>数组长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr.length;</span><br></pre></td></tr></table></figure><ul><li><p><code>arr.length</code><strong>可以</strong>直接被改变，多余的位置填充<code>undefined</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// [1, 2, 3, null, true, undefined]</span></span><br><span class="line">arr.length = <span class="number">1</span>;</span><br><span class="line">arr; <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组是<strong>可变</strong>的，因此可以直接对索引赋值改变数组。</p><ul><li><p>如果赋值时索引超过了长度返回，<strong>不会报错</strong>，数组长度同样会发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// [1, 2, 3, undefined, undefined, 99]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>indexOf</code>：搜索一个指定元素的位置</p></li><li><p><code>slice</code>：行为和substring类似</p><ul><li><p><strong>不指定</strong>索引参数时，可以进行数组<strong>深复制</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy === a; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>push</code>：向数组<strong>末尾</strong>添加元素（直接改变数组）</p><ul><li><p>可以一次性添加多个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>pop</code>：把<strong>最后</strong>一个元素删除掉（直接改变数组）</p><ul><li>空数组<code>pop</code><strong>不会</strong>报错，而是返回<code>undefined</code>.</li></ul></li><li><p><code>unshift</code>/<code>shift</code>：对数组<strong>首</strong>元素进行操作，和<code>push</code>/<code>pop</code>对应。</p></li><li><p><code>sort</code>：对数组排序并返回新数组（<strong>同时</strong>直接修改数组）</p></li><li><p><code>reverse</code>：反转数组（直接修改数组）</p></li><li><p><code>splice</code>：从指定索引开始<strong>删除</strong>若干元素<strong>并返回</strong>，然后再从该位置<strong>添加</strong>若干元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br></pre></td></tr></table></figure></li><li><p><code>concat</code>：连接两个数组，并返回新的数组。（<strong>不改变</strong>原数组）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">added; <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ul><li><p><code>concat</code>还可以接收多个数组并执行<strong>拆解后合并</strong>（不论多少层<strong>都会被</strong>拆开）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">added1 = arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line">added2 = arr.concat(<span class="number">1</span>, <span class="number">2</span>, [[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]); <span class="comment">// [1, 2, 3, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>join</code>：把数组元素都当作字符串，用<strong>指定字符</strong>连接起来，然后返回一个长字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure></li><li><p>多维数组：数组嵌套</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="string">'-'</span>];</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p>当属性名包含<strong>特殊字符</strong>时</p><ul><li>必须用<code>&#39;&#39;</code>括起来</li><li>访问时需要使用<code>[&#39;xxx&#39;]</code>表示</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">'小红'</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'No.1 Middle School'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaohong[<span class="string">'middle-school'</span>];</span><br></pre></td></tr></table></figure></li><li><p>访问不存在的值不会报错，而是返回<code>undefined</code>.</p></li><li><p>对象是动态类型，可以随时添加和删除属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">'name'</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure></li><li><p>检测对象是否拥有某一属性：使用<code>in</code>操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">'No.1 Middle School'</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">'grade'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>使用<code>in</code>时会同时<strong>包括继承</strong>得到的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不考虑继承</strong>属性时使用<code>hasOwnProperty</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li>JavaScript把<strong><code>null</code>/<code>undefined</code>/<code>0</code>/<code>NaN</code>和空字符串</strong>视为<code>false</code>，其他都是<code>true</code>.</li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li><p><code>for</code>循环</p></li><li><p><code>for-in</code>循环</p><ul><li><p>用于遍历一个对象的所有<strong>属性</strong></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 'name', 'age', 'city'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历数组</p><p>数组也是一个对象，<strong>key是索引</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// '0', '1', '2'</span></span><br><span class="line">    <span class="built_in">console</span>.log(a[i]); <span class="comment">// 'A', 'B', 'C'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map是一种键值对结构，查找速度快。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">18</span>); <span class="comment">// add element</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">20</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 18</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>);</span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>如果重复<code>set</code>，后面的值会把前面的值冲掉。</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是key的集合，并且key<strong>不能</strong>重复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a set</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// number and string are different</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add element</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete element</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h2><p>包括<code>Array</code>/<code>Map</code>/<code>Set</code>类型</p><ul><li><p><code>for-of</code>遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]); <span class="comment">// 0 stands for key and 1 stands for value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组遍历通常使用<code>for-of</code>而<strong>不是</strong><code>for-in</code></p></blockquote></li><li><p><strong><code>forEach</code>（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素</span></span><br><span class="line"><span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">    <span class="built_in">console</span>.log(element + <span class="string">', index = '</span> + index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(element); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// neglect some args</span></span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;2099&lt;/code&gt;字，推荐阅读时间&lt;code&gt;10~15&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Chpater6-移动操作系统</title>
    <link href="http://yoursite.com/2020/07/04/Chpater6-%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/07/04/Chpater6-%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-07-04T08:05:30.932Z</published>
    <updated>2020-07-04T08:11:56.974Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>505</code>字，推荐阅读时间<code>5~7</code>分钟。</p><a id="more"></a><h2 id="智能手机系统"><a href="#智能手机系统" class="headerlink" title="智能手机系统"></a>智能手机系统</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>传统功能机</li><li>智能移动终端<ul><li>智能指配备了OS,并不是人工智能。（扩展性）</li></ul></li></ul><h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><h4 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul><li>硬件到服务的闭环</li><li><p><strong>不</strong>授权在非Apple硬件安装</p></li><li><p>Mac OS &amp; IOS</p></li></ul><h5 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h5><ul><li>Core OS(C)：基于微内核</li><li>Core Services(C)</li><li>Media(C&amp;Object-C)</li><li>Cocoa Touch(Objective-C)：提供应用程序框架和API</li></ul><h5 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h5><ul><li>Xcode</li><li>Objective-C&amp;Swift</li></ul><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><ul><li>基于Linux</li><li>接口基于Java</li></ul><h5 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h5><ul><li><p>Linux Kernel：底层硬件的管理</p></li><li><p>Libraries</p><ul><li><p>大部分由C/C++编写，实现了通用功能。</p></li><li><p>Android Runtime：装入了一个虚拟机，每个应用有自己<strong>独立</strong>的虚拟机。</p><blockquote><p><code>.dex</code>：将<code>.class</code>进行字节码再次翻译达到压缩目的</p></blockquote></li></ul></li><li><p>Application Framework</p><ul><li>基本由Java编写</li><li>提供开发使用的API</li><li>应用程序可以使用<code>JNI</code>调用下层函数库（高效性）</li></ul></li><li><p>Application</p><ul><li>平台无关</li><li>Java开发</li></ul></li></ul><h5 id="Android-Market-Google-Play"><a href="#Android-Market-Google-Play" class="headerlink" title="Android Market(Google Play)"></a>Android Market(Google Play)</h5><ul><li>Market本身自己也是应用</li></ul><h5 id="开发环境-1"><a href="#开发环境-1" class="headerlink" title="开发环境"></a>开发环境</h5><ul><li>Android SDK</li><li>Java SDK</li><li>集成开发环境</li></ul><h4 id="Windows-CE-Mobile"><a href="#Windows-CE-Mobile" class="headerlink" title="Windows CE/Mobile"></a>Windows CE/Mobile</h4><ul><li>Windows CE<ul><li>嵌入式系统</li><li>支持ARM/MIPS/x86/SH4</li></ul></li><li>Windows Mobile<ul><li>基于Windows CE</li></ul></li></ul><h4 id="Symbian"><a href="#Symbian" class="headerlink" title="Symbian"></a>Symbian</h4><p>开发生态并不友好，赶走了开发者，导致了灭绝。</p><h2 id="区块链平台操作系统"><a href="#区块链平台操作系统" class="headerlink" title="区块链平台操作系统"></a>区块链平台操作系统</h2><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><ul><li>链式数据结构<ul><li>记录前一个结点的地址和哈希值</li></ul></li><li>分布式节点共识算法</li><li>智能合约</li></ul><blockquote><p>不可篡改、可追溯、构建信任、<strong>去中心</strong>、支持智能合约。</p></blockquote><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h4><h4 id="2-0（以太坊）"><a href="#2-0（以太坊）" class="headerlink" title="2.0（以太坊）"></a>2.0（以太坊）</h4><ul><li>支持图灵完备的虚拟机</li><li>使用智能合约程序管理资产</li></ul><h4 id="3-0"><a href="#3-0" class="headerlink" title="3.0"></a>3.0</h4><ul><li>在货币和金融外，在其他产业领域上提供可扩展的区块链应用。</li><li>联盟链(ToB)</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>不可篡改<ul><li>物流、法证、电子政务、发票、学位证书</li></ul></li><li>共识信任<ul><li>供应链金融</li></ul></li><li>去中心<ul><li>新型交易</li></ul></li><li>确权和可信<ul><li>医疗、物联网、大数据协调</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;505&lt;/code&gt;字，推荐阅读时间&lt;code&gt;5~7&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter4-文件系统</title>
    <link href="http://yoursite.com/2020/07/04/Chapter4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/07/04/Chapter4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-07-04T08:05:30.932Z</published>
    <updated>2020-07-04T08:11:46.444Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>3454</code>字，推荐阅读时间<code>15~20</code>分钟</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>数据可以长期保存</li><li>方便不同进程共享</li><li>容量大</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>抽象为一个<strong>单独的、连续的逻辑地址空间</strong>，其大小为文件大小，和<strong>进程</strong>的地址空间<strong>无关</strong>。</li><li>一组带标识的、在逻辑上有<strong>完整意义</strong>的<strong>信息项的序列</strong>。</li><li>本质是一组字节序列：<strong>一切皆是文件</strong><ul><li>设备文件</li></ul></li><li>文件组成<ul><li>文件体：文件本身的<strong>内容</strong></li><li>文件<strong>说明</strong>：文件名、存储地址、访问权限等。</li></ul></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>OS中统一管理信息资源的一种<strong>软件</strong></p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ul><li><p><strong>磁盘空间</strong>的分配与回收</p></li><li><p>文件按<strong>名</strong>存取</p></li><li><p>文件信息共享</p></li><li><p>向用户提供友好的接口</p></li><li><p>提高文件系统的性能</p></li><li><p>提供和I/O系统统一的接口</p><blockquote><p>文件系统在I/O系统等级之下</p></blockquote></li></ul><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><ul><li>接口（接近用户）<ul><li>命令行接口</li><li>程序接口：用户程序进行<strong>系统调用</strong></li></ul></li><li>管理软件集合（核心）</li><li><strong>被管理</strong>对象及其属性（文件的性质）<ul><li>文件，文件系统管理的<strong>直接对象</strong>。</li><li>目录</li><li>磁盘存储空间</li></ul></li></ul><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><ul><li><p>创建时指定（必须），<strong>用户</strong>通过<strong>文件名</strong>来<strong>访问文件</strong>。（<strong>不是地址</strong>）</p></li><li><p>格式：<code>文件名.扩展名</code></p><blockquote><ul><li><p>文件名一般不超过<code>8</code>个字符</p></li><li><p>Linux<strong>区分</strong>大小写</p></li><li>Windows<strong>不区分</strong>大小写</li></ul></blockquote></li></ul><h4 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h4><ul><li>性质&amp;用途：系统文件、库文件、用户文件</li><li>数据形式：源文件、目标文件、可执行文件</li><li>保护级别：只读、读写、执行、不保护</li><li><strong>逻辑结构</strong>：有结构（记录文件）、无结构（流式文件）</li><li><strong>物理结构</strong>：顺序文件、链接文件、索引文件</li></ul><h4 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h4><ul><li><p>流式结构：把文件看成字节序列，提供了最大的灵活性，用户程序可以任意更改文件。</p><p>所有的UNIX版本（含Linux和OS X）以及Windows都采用这种方式</p></li><li><p>记录式文件：文件是具有<strong>固定长度的记录</strong>的序列，每个记录内部都有结构。</p><blockquote><ul><li>之所以叫记录，就是因为读操作返回数据时是返回某次写的东西，这叫做返回记录；在写操作时，会改写一个原有的记录<strong>或者</strong>追加一个记录。</li><li>底层依然是字节序列</li></ul></blockquote></li><li><p>树形结构（也属于记录式）：文件各个记录的长度不一定相同，但是在每个记录的固定位置上，有一个<strong>Key</strong>字段用来进行迭代。</p><p>在处理商业数据的大型计算机中被广泛使用</p></li></ul><h4 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h4><ul><li>顺序</li><li>随机：直接给定<strong>读写</strong>位置</li></ul><h4 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h4><ul><li>磁盘、磁带、光盘等</li></ul><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>打开文件时，每个进程为维护<strong>文件索引表</strong>，系统有一个整合的文件开关表。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>由<strong>文件索引</strong>组成的，用于检索文件的<strong>特殊文件</strong>。</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>提高效率</li><li>命名<ul><li><strong>不同</strong>文件可以有<strong>相同</strong>名字</li><li><strong>一个</strong>文件可以有<strong>多个</strong>名字</li></ul></li><li>分组<ul><li>将文件按照属性进行分组</li></ul></li></ul><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ul><li>基本信息：文件名、别名（名字及数目）等</li><li>文件类型</li><li>地址信息：存放位置、文件长度</li><li><strong>访问控制信息</strong>：文件的<strong>所有者</strong>和<strong>访问权限</strong></li><li>使用信息：创建信息、上次访问时间、上次修改时间。</li></ul><h4 id="单级目录"><a href="#单级目录" class="headerlink" title="单级目录"></a>单级目录</h4><p>根目录-&gt;文件</p><ul><li>常用于嵌入式系统</li><li>不方便共享</li></ul><h4 id="两级目录"><a href="#两级目录" class="headerlink" title="两级目录"></a>两级目录</h4><p>根目录-&gt;用户目录-&gt;文件</p><blockquote><p>用户目录<strong>不是指不同的用户</strong>，就是指<strong>不同的目录</strong>。</p></blockquote><h4 id="多级（层次）目录"><a href="#多级（层次）目录" class="headerlink" title="多级（层次）目录"></a>多级（层次）目录</h4><p>根目录-&gt;…-&gt;文件</p><ul><li>文件访问<ul><li>绝对路径：从<strong>根目录</strong>开始</li><li>相对路径：从当前目录开始（路径中<strong>不含</strong>当前目录名）</li></ul></li><li>解决文件重名的问题</li><li>查找速度快</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="系统布局"><a href="#系统布局" class="headerlink" title="系统布局"></a>系统布局</h3><ul><li>一个磁盘通常被划分为多个<strong>分区</strong>，每个<strong>分区</strong>有一个<strong>独立的文件系统</strong>。</li><li>磁盘的0号<strong>扇区（不是分区）</strong>称为主引导记录(MBR)，在MBR的结尾是分区表，该表给出了每个分区的起始地址和结束地址。</li><li>MBR的第一个块叫做引导块，为了统一起见，每个<strong>分区</strong>的第一个块都是引导块。</li><li>引导块之后的第二个块是超级块，包含文件系统所有关键参数，在计算机<strong>启动</strong>时，超级块会被<strong>读入</strong>内存。</li></ul><h3 id="文件控制块-inode-FCB-目录项"><a href="#文件控制块-inode-FCB-目录项" class="headerlink" title="文件控制块(inode,FCB,目录项)"></a>文件控制块(inode,FCB,目录项)</h3><ul><li>基本信息<ul><li>文件名</li><li>物理位置</li><li>文件<strong>逻辑</strong>结构</li><li>文件<strong>物理</strong>结构</li></ul></li><li>访问控制信息<ul><li>所有者</li><li>访问权限</li></ul></li><li>使用信息<ul><li>创建时间</li><li>上一次修改时间</li></ul></li></ul><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>一般是一个<strong>非负整数</strong>，标识唯一一个<strong>打开</strong>的文件。</p><ul><li>不同进程可以拥有相同的文件描述符指向一个<strong>文件表项</strong></li><li><strong>文件表项</strong>又能导向文件对应的具体的inode/FCB</li></ul><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><h4 id="连续-顺序文件"><a href="#连续-顺序文件" class="headerlink" title="连续/顺序文件"></a>连续/顺序文件</h4><p>讨论<strong>文件内部、文件和文件之间</strong>如何组织</p><p>连续的分配磁盘容量</p><blockquote><p>容易出现磁盘碎片</p></blockquote><p><strong>优点</strong></p><ul><li>容易实现</li><li><strong>顺序、随机</strong>存取效率高</li></ul><p><strong>缺点</strong></p><ul><li>不利于动态修改文件</li></ul><h4 id="串联-链接文件"><a href="#串联-链接文件" class="headerlink" title="串联/链接文件"></a>串联/链接文件</h4><ul><li>讨论<strong>文件内部</strong>如何组织</li><li>链表指针结构，将<strong>文件分块</strong>。</li><li>文件所在的磁盘块号<strong>不一定连续</strong></li></ul><blockquote><p>对于记录式文件，一个块中可以包含<strong>若干个</strong>逻辑记录，也可以<strong>若干个</strong>物理块包含<strong>一个</strong>逻辑记录。</p></blockquote><p><strong>优点</strong></p><ul><li>空间利用率高</li><li><strong>顺序</strong>存取效率高</li></ul><p><strong>缺点</strong></p><ul><li>随机存取效率低</li><li>可靠性较低</li><li>当要访问文件的最后一块时，需要访问整个文件。</li></ul><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>讨论的是<strong>文件内部</strong>的组织方式</p><p>索引文件：<strong>逻辑块号</strong>和<strong>物理块号</strong>（地址）的<strong>哈希表</strong>，称为文件的索引表。</p><ul><li><p>访问过程：</p><p>文件目录-&gt;索引表-&gt;某一个物理块</p></li><li><p>存放位置</p><p>由于每个文件的索引文件的长度不一，因此<strong>PCB</strong>中只保存<strong>索引文件</strong>的<strong>存放地址</strong>，而不保存其内容。</p><blockquote><p>有时存放位置固定在<strong>文件目录</strong>中、<strong>文件的开头</strong>等。</p></blockquote></li></ul><p><strong>优点</strong></p><ul><li>顺序、随机存取效率高</li></ul><p><strong>缺点</strong></p><ul><li>空间开销大</li></ul><p><strong>索引表的组织</strong></p><ul><li><p>链接模式</p><p>为每个盘块分配一张表，然后将这些表链接起来。</p></li><li><p>多级索引</p></li><li><p>综合</p></li></ul><p><strong>inode&amp;索引表辨析</strong></p><ul><li>当使用inode管理文件时，提供inode的索引功能的表并一定是hash索引表，因为文件块号是顺序存放在inode中的。</li></ul><blockquote><p>UNIX下通常采用<strong>三级</strong>索引表</p><p>eg.当每个磁盘块可以容纳256个索引指针时，总共可以容纳$12+256+256^{2}+256^{3}$个块。（12是由直接索引的块数决定的）</p></blockquote><h3 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h3><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul><li><p>直接法：目录项 = 文件名 + 文件控制块</p><blockquote><p>DOS/Windows</p></blockquote></li><li><p>间接法：目录项 = 文件名 + 文件控制块<strong>地址</strong></p><blockquote><p>Unix(inode)</p></blockquote></li></ul><blockquote><p>一个目录有多个目录项，一个目录项对应一个inode.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">目录--&gt;目录项1</span><br><span class="line">目录--&gt;目录项2</span><br><span class="line">目录--&gt;...</span><br><span class="line"></span><br><span class="line">目录项1--&gt;目录inode1</span><br><span class="line">目录项2--&gt;目录inode2</span><br><span class="line"></span><br><span class="line">目录inode1--&gt;文件inode1</span><br><span class="line">文件inode1--&gt;具体内容</span><br></pre></td></tr></table></figure><blockquote><p>目录中的inode用来存放文件inode位置，而文件的inode用来存放文件具体内容</p></blockquote><h4 id="长文件名"><a href="#长文件名" class="headerlink" title="长文件名"></a>长文件名</h4><ul><li><p>在目录项中将文件名长度固定为255个字符</p><blockquote><p>浪费空间，很少有文件使用长名字。</p></blockquote></li><li><p>目录项<strong>(entry for one file)</strong>长度可变</p><ul><li><p><strong>存放目录项长度的区域大小</strong>不变</p></li><li><p>属性信息长度不变</p></li><li><p>文件名长度可变</p><blockquote><p>通常在文件名的特殊结束字符如<code>\0</code>之后，还会填充使文件名空间<strong>字对齐</strong>。</p></blockquote></li></ul><blockquote><p>文件占用空间不好回收</p></blockquote></li><li><p>目录项长度固定，但是文件名变长并<strong>统一</strong>放在目录文件的末尾。（堆：<strong>向下扩展</strong>）</p><blockquote><p>此时<strong>不会</strong>对文件名进行<strong>字对齐</strong>处理</p></blockquote></li></ul><h4 id="查询技术"><a href="#查询技术" class="headerlink" title="查询技术"></a>查询技术</h4><ul><li>顺序查找</li><li>Hash方法</li></ul><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>使不同目录可以用<strong>相同</strong>或者<strong>不同</strong>的文件名来访问它（<strong>有向无环图</strong>）</p><blockquote><p>环指<strong>有向环</strong></p></blockquote><p><strong>链接技术</strong></p><ul><li><p>硬链接：不同的文件索引使用同一个inode结点，并且这个结点就是文件的inode结点。</p><ul><li><p>当使用硬链接时，虽然inode1被共享，但从inode没有办法推出有哪些目录在引用这个文件，因此如果在一个目录的控制下决定删除这个文件和inode，那么只有这个目录的inode会被更新，其他的目录会指向一个无效的inode.</p></li><li><p>不能针对<strong>目录</strong>创建</p><blockquote><p>当针对目录创建时，会出现环路。</p></blockquote></li><li><p>不能针对<strong>不存在的文件</strong>创建</p></li></ul></li><li><p>软链接（符号链接）：创建一个类型为<code>LINK</code>的新文件，并把该文件放在目录A下，这个文件使得A和目录B下的某个文件存在链接，因为这个文件的内容就是所链接的文件的名字和路径。</p><ul><li>在访问文件时，会重定向到文件本身的inode进行。</li><li>因为从A和C都能够找到同一个文件，因此在A和C的再顶层目录中统计文件时，这个文件会被多次定位，造成统计冗余或者拷贝冗余。</li></ul></li></ul><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><h4 id="建立副本"><a href="#建立副本" class="headerlink" title="建立副本"></a>建立副本</h4><p>适用于<strong>短小且极为重要</strong>的文件</p><h4 id="定时转储"><a href="#定时转储" class="headerlink" title="定时转储"></a>定时转储</h4><p>Unix采用</p><h4 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h4><ul><li><p><strong>磁盘块</strong>的一致性</p><p>磁盘块有两个计数器</p><ul><li>记录磁盘块是否被使用</li><li>记录磁盘块是否在空闲块中</li></ul><p>当磁盘块在两个计数器中同时出现则不一致</p><blockquote><ul><li>当出现<strong>丢失块</strong>（两个计数器都未记录），则将块加入空闲块表。</li><li>当<strong>使用块计数</strong>中出现重复块（第一个计数器中出现<code>n</code>次），在空闲表中取<code>n-1</code>个块进行拷贝，然后标记为已使用。</li><li>当<strong>空闲块计数</strong>中出现重复块：重新建立空闲链表。</li></ul></blockquote></li><li><p><strong>文件</strong>的一致性</p><p>文件有两个计数器</p><ul><li>inode结点被引用的次数</li><li>文件目录引用的次数</li></ul><p>两个计数器不相等时出现不一致</p></li></ul><h4 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h4><ul><li>文件保护机制</li><li>存取权限验证</li></ul><h4 id="并发访问"><a href="#并发访问" class="headerlink" title="并发访问"></a>并发访问</h4><ul><li><p>访问文件之前<strong>必须</strong>打开文件</p><blockquote><p>文件目录会被读入内存中，因此多个进程共享同一个文件目录，确保了文件<strong>一致性</strong>。</p></blockquote></li></ul><h4 id="块高速缓存"><a href="#块高速缓存" class="headerlink" title="块高速缓存"></a>块高速缓存</h4><p>在<strong>内存</strong>中为<strong>磁盘</strong>设置一个缓冲区</p><ul><li>组织：双向链表<ul><li>尾部使用MRU（最常使用算法），将最近访问的块放在尾部。</li><li>头部自然就是LRU，进行淘汰。</li></ul></li><li>块大：磁盘利用率<strong>低</strong>，效率<strong>高</strong>。（块小<strong>反之</strong>）</li></ul><h2 id="基于日志结构的文件系统-LFS"><a href="#基于日志结构的文件系统-LFS" class="headerlink" title="基于日志结构的文件系统(LFS)"></a>基于日志结构的文件系统(LFS)</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>磁盘以<strong>写</strong>操作为主，其中<strong>磁头寻道</strong>是影响写性能的主要因素之一。</li><li>写一个数据块要修改数据和<strong>元数据</strong>(inode 目录 etc.)</li></ul><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li><p>将<strong>磁盘</strong>看作是一个<strong>日志系统</strong></p><blockquote><p>文件总是<strong>顺序</strong>地追加到磁盘上</p></blockquote></li><li><p>新的数据块和元数据先以<code>segment</code>为单位放在缓存中，当<code>segment</code>填满之后写入到硬盘。</p><ul><li><code>segment &gt; block</code></li><li>若修改了数据，不对<code>segment</code>已有数据进行修改，而是继续追加。</li></ul></li><li><p>inode根据不同的追加写操作分散在整个日志中（位置<strong>不固定</strong>）</p></li><li><p>inode查找：<code>inode map</code>是从inode号到磁盘块的映射，用于查找inode.</p><ul><li>缓存在<strong>内存</strong></li><li>在磁盘上设置<code>checkpoint</code>，周期性地更新<code>inode map</code>.（追加的inode直接把之前的覆盖了）</li></ul></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>以<code>segment</code>为单位进行回收</li><li><code>segment summary</code>：记录每个数据块对应的inode号</li></ul><blockquote><ul><li>LFS的<strong>写</strong>效率比传统的UNIX更高</li><li>LFS的<strong>读</strong>和普通的文件系统性能相当</li></ul></blockquote><h2 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统(VFS)"></a>虚拟文件系统(VFS)</h2><p>初衷是为了让文件系统不需要关心数据到底存在什么样的硬件上，或者存在哪个特定的地方。只要有文件系统提供的函数，就能够满足VFS的读写要求。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>系统启动时，<strong>根文件</strong>系统在VFS中<strong>注册</strong>。</li><li>当装载其他文件系统时，它们需要向VFS提供一个<strong>包含VFS所需要的控制函数的地址列表</strong>（之后VFS就可以对该文件系统进行读写操作了）。</li><li>VFS创建v结点是为了方便<strong>上层</strong>对文件系统进行操作</li></ul><blockquote><p>VFS对用户进程提供的<strong>上层接口</strong>，就是著名的POSIX接口。</p></blockquote><h3 id="超块"><a href="#超块" class="headerlink" title="超块"></a>超块</h3><ul><li>设备：块设备标识符</li><li>索引节点指针</li><li>数据块大小</li><li>超块操作集</li><li>文件系统类型</li><li>特殊信息</li></ul><h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><ul><li>设备</li><li>编号</li><li>模式：对象类型、访问权限</li><li>用户标识符</li><li>时间</li><li>块大小</li><li>操作集</li><li>计数</li><li>锁定</li><li>脏位</li><li>特殊信息</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;3454&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter5-安全</title>
    <link href="http://yoursite.com/2020/07/04/Chapter5-%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2020/07/04/Chapter5-%E5%AE%89%E5%85%A8/</id>
    <published>2020-07-04T08:05:30.932Z</published>
    <updated>2020-07-04T08:10:50.948Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1172</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><h3 id="信息系统安全性"><a href="#信息系统安全性" class="headerlink" title="信息系统安全性"></a>信息系统安全性</h3><ul><li>机密性（暴露）：防止<strong>非授权</strong>访问，是信息安全<strong>最重要</strong>的要求。</li><li>完整性（篡改）：信息在<strong>存储</strong>和<strong>传输</strong>过程中保持不被修改、破坏或者丢失。</li><li>可用性（不能服务）</li><li>可靠性</li></ul><h3 id="OS安全目标"><a href="#OS安全目标" class="headerlink" title="OS安全目标"></a>OS安全目标</h3><ul><li>为应用程序提供安全可靠的运行环境</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>OS是信息系统安全<strong>基础</strong>之一</li><li>OS规模庞大，安全难以保证。（理论上，OS的安全是<strong>不可判定问题</strong>）</li></ul><h3 id="OS安全需求"><a href="#OS安全需求" class="headerlink" title="OS安全需求"></a>OS安全需求</h3><ul><li>系统边界安全：禁止非法用户进入</li><li>权限管理机制：不同用户有<strong>不同</strong>的权限</li><li>应用和数据访问控制：指定安全的访问<strong>策略</strong></li><li>可信通路：保证登录和应用安全<strong>机制</strong>不被旁路</li><li>安全审计和管理：<strong>检测</strong>错误原因，或者记录攻击<strong>痕迹</strong>。</li></ul><h2 id="安全标准"><a href="#安全标准" class="headerlink" title="安全标准"></a>安全标准</h2><ul><li><p>A：<strong>验证型</strong>保护</p><p>A1：功能<strong>等同于</strong>B3,但是顶层规格设计、验证、模型都需要是<strong>形式化</strong>的。</p><p>A1以上级：比A1更加安全</p></li><li><p>B：<strong>强制型</strong>保护(B1&lt;B2&lt;B3)</p><ul><li><p>B1：满足C2，<strong>标记安全保护</strong>，并且实施强制访问控制(MAC)</p><blockquote><p>用户不能为其他用户赋予权限</p></blockquote></li><li><p>B2：可信计算基(TCB)是明确定义的<strong>形式化</strong>模型</p></li><li><p>B3：TCB可以控制所有主体对客体的访问</p></li></ul></li><li><p>C：<strong>自主型</strong>保护(C1&lt;C2)</p><ul><li>C1(Linux/Unix)：有一定<strong>自主访问控制</strong></li><li>C2(Linux/Windows NT)：相比于C1粒度更<strong>细</strong>（对<strong>每个用户</strong>分别管理），并且引入<strong>审计</strong>机制。</li></ul></li><li><p>D(MS DOS)</p></li></ul><h2 id="常见问题、方法与机制"><a href="#常见问题、方法与机制" class="headerlink" title="常见问题、方法与机制"></a>常见问题、方法与机制</h2><h3 id="加密基础"><a href="#加密基础" class="headerlink" title="加密基础"></a>加密基础</h3><ul><li><p>对称密钥（<strong>私钥</strong>算法）</p><p>加密密钥和解密密钥之间关系很明显，知道一个就能够较为容易的推出另外一个。（两者<strong>不一定相同</strong>）</p><blockquote><p>例如在单字母替换型密钥中，如果加密密钥<strong>前三位</strong>是XYZ，即<code>A-X B-Y C-Z</code>，所以明文中的A被转换为X.这也说明了密文中的Q和A对应。（替换是一个双射，因此可以推出解密密钥为ABC）</p><p>注意区分的是，<strong>密文</strong>中的A就<strong>不和明文</strong>中的X对应了，而应该和加密密钥中和A对应的明文字符（比如是Q）对应。</p><p>可以理解为：明文中的A和密文中的A没有任何关系，它们的双射之间互不干扰。</p></blockquote></li><li><p>非对称密钥（<strong>公钥</strong>算法）</p><p>原理：使用<strong>公钥</strong>进行<strong>加密</strong>，使用<strong>私钥</strong>进行<strong>解密</strong>。</p><p>​    $y=f(x)$生成一对密钥，<code>y</code>作为公钥，<code>x</code>作为私钥。</p><ul><li>解密时已经知道<code>y</code>,需要反解<code>x</code>才能够进行破解。</li></ul><blockquote><p>RSA：基于大数分解</p></blockquote></li><li><p>数字签名</p><ul><li>发送者将文档hash为小文档之后，再使用私钥对小文档进行散列值运算得到<strong>签名块</strong><code>D(hash)</code>作为签名。</li><li>接收者利用公钥对签名块进行运算，得到<code>E(D(hash))</code>.同时对文档再次进行hash变为小文档并记录hash.</li><li>加密算法要求<code>E(D(hash)) = hash</code>，如果计算得到的<code>E(D(hash))</code>和文档<code>hash</code>值不同，则说明文档被<strong>修改</strong>过。</li></ul></li></ul><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><ul><li><p>密码认证</p><ul><li>密码存储<ul><li>明文</li><li>存储hash后的值</li><li>hash+随机数(etc/shadow)</li></ul></li></ul></li><li><p>一次性口令</p><p>每一次成功登录后密钥需要被更新</p><ul><li><p>单向函数</p><p>密钥生成和<strong>上一次</strong>的密钥<strong>无关</strong>，但是和<strong>最后一次</strong>能够使用的<strong>函数</strong>有关。</p><p>$p1=f(f(f(s)))$</p><p>$p2=f(f(s))$</p><p>$p3=f(s)$</p><blockquote><ul><li>服务器存储<code>p3</code>，用户第<code>i</code>次登录需要输入正确的<code>pi</code>.</li><li>该单向函数只能使用三次</li></ul></blockquote></li></ul></li><li><p>生物特征</p></li></ul><h3 id="内部攻击"><a href="#内部攻击" class="headerlink" title="内部攻击"></a>内部攻击</h3><ul><li>逻辑炸弹：软件中的恶意陷阱、后门（旁路）</li><li>后门陷阱</li><li>登录欺骗：伪造登录页面</li></ul><h3 id="外部攻击"><a href="#外部攻击" class="headerlink" title="外部攻击"></a>外部攻击</h3><p>利用代码漏洞</p><ul><li><p>缓冲区溢出攻击(Buffer Overflow Attacks)</p><p>输入时将缓冲区填满溢出，然后改变<strong>函数</strong>返回地址。</p><ul><li>返回libc的攻击(Return to libc Attacks)<ul><li>使用<code>strcpy</code>将恶意代码拷贝到栈中继续执行</li></ul></li></ul></li><li><p>代码注入攻击(Code Injection Attacks)</p><ul><li>利用程序的命令分析漏洞</li></ul></li><li><p>恶意软件(Malware)</p></li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li><p>沙箱机制：严格限制程序的运行空间</p><blockquote><p>虚拟化，沙箱中的改动不影响OS</p></blockquote></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li><li>Wikipedia</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1172&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter0-1-系统引导</title>
    <link href="http://yoursite.com/2020/07/04/Chapter0-1-%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/"/>
    <id>http://yoursite.com/2020/07/04/Chapter0-1-%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:09:37.970Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>752</code>字，推荐阅读时间<code>5~10</code>分钟。</p><a id="more"></a><h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>系统加电后运行的第一个程序，在内核之<strong>前</strong></p></li><li><p><code>Bootloader = Booter + Loader</code></p><ul><li>Booter负责初始化系统硬件，使其<strong>部分</strong>运行。</li><li>Loader将OS镜像加载到内存中，并跳转到OS的代码开始运行。</li></ul></li><li>可以帮助OS和硬件分离</li></ul><blockquote><p>MIPS:U-Boot</p><p>X86:LILO/GRUB</p></blockquote><h2 id="启动及引导"><a href="#启动及引导" class="headerlink" title="启动及引导"></a>启动及引导</h2><h3 id="MIPS-U-Boot"><a href="#MIPS-U-Boot" class="headerlink" title="MIPS(U-Boot)"></a>MIPS(U-Boot)</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ul><li><p>Stage1:和体系结构相关，常为<strong>汇编</strong>语言。</p></li><li><p>Stage2:为了可移植性，常为<strong>C</strong>语言。</p></li></ul><h4 id="MIPS基本地址空间"><a href="#MIPS基本地址空间" class="headerlink" title="MIPS基本地址空间"></a>MIPS基本地址空间</h4><ul><li><p><code>0x0000_0000-0x7FFF_FFFF(2GB)</code>:kuseg，需要<strong>MMU</strong>才可使用。</p></li><li><p><code>0x8000_0000-0x9FFF_FFFF(512MB)</code>:Unmapped cached(kseg0)，最高位清零则是物理地址，没有MMU也可以使用。</p><ul><li>无MMU:放置程序和数据</li><li>有MMU:操作系统<code>kernel</code>(0x80010000)</li></ul><blockquote><p>这段地址的存取几乎一定会经过cache,所以在cache设置好之前，不能随意访问。</p></blockquote></li><li><p><code>0xA000_0000-0xBFFF_FFFF(512MB)</code>:Unmapped uncached(kseg1)，<strong>高三位</strong>清零是物理地址。</p><ul><li>不用通过cache存取，通常用于访问外部设备。</li></ul></li><li><p><code>0xC000_0000-0xFFFF_FFFF(1GB)</code>:Mapped(kseg2),MMU支持。</p></li></ul><h4 id="MIPS-ROM-Flash启动地址"><a href="#MIPS-ROM-Flash启动地址" class="headerlink" title="MIPS ROM/Flash启动地址"></a>MIPS ROM/Flash启动地址</h4><ul><li>在kseg0中选择</li><li>0xBFC0_0000</li></ul><h4 id="OS引导过程"><a href="#OS引导过程" class="headerlink" title="OS引导过程"></a>OS引导过程</h4><ul><li>Head.s<ul><li>完成内核堆栈初始化</li><li>将未初始化段清零(bss)</li><li><code>start_kernel()</code></li></ul></li></ul><h3 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h3><h4 id="启动过程（与OS无关）"><a href="#启动过程（与OS无关）" class="headerlink" title="启动过程（与OS无关）"></a>启动过程（与OS无关）</h4><h5 id="第一步-启动BIOS"><a href="#第一步-启动BIOS" class="headerlink" title="第一步 启动BIOS"></a>第一步 启动BIOS</h5><ul><li>turn on</li><li>BIOS（固化在ROM中的程序）<ul><li>放在<code>0xF_FFF0</code></li></ul></li><li>加电自检(POST)</li></ul><blockquote><p> UEFI</p><ul><li>支持大硬盘引导</li><li>可移植性好</li></ul></blockquote><h5 id="第二步-读取MBR"><a href="#第二步-读取MBR" class="headerlink" title="第二步 读取MBR"></a>第二步 读取MBR</h5><p>MBR(Master Boot Record)：主引导记录，位于<strong>第0磁头的第0磁道的第1个扇区</strong>，大小是512字节。存放了启动信息、分区表信息。</p><blockquote><p>扇区(sector)</p><ul><li>磁道上的弧段</li></ul><p>磁道(track)</p><ul><li>盘片上的同心圆</li></ul><p>柱面(cylinder)</p><ul><li>不同盘片同半径的磁道构成的柱面</li></ul><p>磁头(head)</p><ul><li>每个磁盘有两个面，每个面都有一个磁头。</li></ul></blockquote><ul><li>寻找可启动的设备（硬盘扇区）</li><li>把MBR加载进内存</li></ul><blockquote><p>MBR = 启动代码 + 数据 + 分区表(DPT,Disk Partition Table) + 幻数(Magic Number)</p><p>启动代码 + 数据：0-446字节，存放<em>bootloader</em>.</p><p>分区表：447-510字节，四个分区项，各分区有16字节。</p><ul><li>第1字节：引导标志，80H表示活动分区，00H表示非活动。（装系统时用于激活）</li></ul><p>幻数：511-512字节，固定装入<code>AA</code>和<code>55</code>,如果MBR没有这两个幻数，则是没有被分区（安装了OS）的硬盘。</p></blockquote><h5 id="第三步-BIOS将控制权交给OS-BootLoader"><a href="#第三步-BIOS将控制权交给OS-BootLoader" class="headerlink" title="第三步 BIOS将控制权交给OS BootLoader"></a>第三步 BIOS将控制权交给<code>OS BootLoader</code></h5><ul><li>初始化硬件，所以Bootloder十分依赖硬件。</li><li>建立内存映射</li><li>准备调用系统内核<ul><li>GRUB和LILO是<code>Linux</code>加载器，也可以加载<code>Windows</code>.</li><li>GRUB和LILO可以放在MBR中，也可以放在活动分区的第一个扇区内（推荐）。</li></ul></li></ul><blockquote><p>内核镜像(Kernel Image) = 引导代码 + 启动代码 + 压缩的OS代码</p></blockquote><h4 id="OS引导过程-1"><a href="#OS引导过程-1" class="headerlink" title="OS引导过程"></a>OS引导过程</h4><p>bootloader-&gt;kernel-&gt;init</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;752&lt;/code&gt;字，推荐阅读时间&lt;code&gt;5~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter0-操作系统引论</title>
    <link href="http://yoursite.com/2020/07/04/Chapter0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/07/04/Chapter0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:10:00.484Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全文共<code>2443</code>字，推荐阅读时间<code>10~15</code>分钟。</strong></p><a id="more"></a><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>操作系统是一组管理计算机硬件资源的<strong>软件集合</strong></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>用户和计算机硬件间的接口</li><li>系统资源的管理者</li><li>实现计算机资源的抽象</li></ul><h3 id="矛盾解决"><a href="#矛盾解决" class="headerlink" title="矛盾解决"></a>矛盾解决</h3><h4 id="人机"><a href="#人机" class="headerlink" title="人机"></a>人机</h4><p>批处理</p><ul><li>联机批处理<ul><li>在输入机和主机之间增加<strong>磁带</strong></li><li>输入输出时CPU仍处于空闲状态</li></ul></li><li>脱机批处理<ul><li>增加不和主机直接连接的<strong>卫星机</strong>（让主机和IO设备隔离）</li><li>卫星机处理输入机和输出机的结果</li><li>当发出I/O请求（磁盘访问等）仍会出现CPU空闲</li></ul></li></ul><h4 id="CPU和外设"><a href="#CPU和外设" class="headerlink" title="CPU和外设"></a>CPU和外设</h4><p>多道程序设计：允许<strong>多个程序</strong>同时在内存中运行</p><ul><li>当程序因为I/O请求暂停运行时，CPU立即执行另外一个程序。</li></ul><h2 id="多道程序系统"><a href="#多道程序系统" class="headerlink" title="多道程序系统"></a>多道程序系统</h2><h3 id="单处理机"><a href="#单处理机" class="headerlink" title="单处理机"></a>单处理机</h3><ul><li>多道：内存中可存放不止一道相互独立的程序</li><li><strong>宏观</strong>并行</li><li><strong>微观</strong>串行</li></ul><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ul><li>成批：运行过程中不允许用户与其作业发生交互作用</li></ul><blockquote><p>优点：</p><ul><li>系统吞吐量大</li><li>资源利用率高</li></ul><p>缺点：</p><ul><li>平均周转时间长</li><li>不能交互</li></ul></blockquote><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>将CPU处理时间分割成多个<strong>时间片</strong>，将时间片分配给不同程序达到<strong>宏观</strong>并行的效果。</p><ul><li>支持多用户、多进程</li><li>分时：多个用户分享同一台计算机</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>多路性</li><li>交互性</li><li>独立性：系统保证用户程序的完整性</li><li>及时性：系统及时响应用户的输入</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>使用可重入代码</li><li>引入虚存减少对换</li></ul><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>有网络作为底层支撑</li><li>模块性：各个分支机器具有自己的功能</li><li>并行性：相对独立，重在合作。<ul><li>物理上：松散耦合</li><li>逻辑上：紧密耦合</li></ul></li><li>自治性</li><li>通信性</li></ul><blockquote><p>和计算机网络的区别：分布式系统具有多机合作和健壮性</p></blockquote><h2 id="实时系统（嵌入式系统）"><a href="#实时系统（嵌入式系统）" class="headerlink" title="实时系统（嵌入式系统）"></a>实时系统（嵌入式系统）</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>及时响应</li><li>安全和可靠性</li><li>整体性</li><li>交互性较弱，通常是周期性任务。</li><li>专用系统：有特别需求</li></ul><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>异常(exception) = 陷阱(trap) + 中断(interrupt)<ul><li>中断是<strong>异步</strong>异常</li><li>陷阱是<strong>同步</strong>异常</li><li><strong>系统调用</strong>看作<strong>同步</strong>异常</li></ul></li><li>软件和硬件都可产生中断</li><li>陷阱帧：线程描述表的子集，用于现场保护。</li><li>陷阱处理程序：处理少量事件后移交给其他<strong>内核</strong>或<strong>执行体</strong>模块 </li></ul><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li><p>批处理系统</p></li><li><p>分时系统（现代OS的源头）</p></li><li><p>实时系统</p></li><li><p>混合系统（现代OS）</p><blockquote><p>现代OS是软实时，不是强实时。</p></blockquote></li></ul><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>两个进程在一个<strong>时间段</strong>内同时完成，微观上依然是有顺序的。</p><blockquote><p>并行：两个进程同时运行，多核，微观上也是并列的。</p></blockquote><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ul><li>互斥共享（打印机、变量）</li><li>同时访问（宏观）</li></ul><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><ul><li>多道程序中的CPU</li><li>SPOOLING（虚拟外围设备同时联机操作）</li><li>虚拟存储</li></ul><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><ul><li>程序以“走走停停”的方式执行</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h3><ul><li>进程/线程控制：创建和撤销</li><li>进程/线程同步：保证进程的次序正确</li><li>进程通信：进程间的数据交换</li><li>进程/线程调度：控制次序</li></ul><h3 id="存储机管理"><a href="#存储机管理" class="headerlink" title="存储机管理"></a>存储机管理</h3><ul><li>内存分配：静态和动态分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充：虚拟存储连接内外存</li></ul><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><ul><li>缓冲管理：匹配CPU和IO的速度</li><li>设备分配</li><li>设备处理：中断处理等</li><li>虚拟设备功能：防止设备产生死锁</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li>存储空间</li><li>目录管理</li><li>文件读、写管理</li><li>文件保护</li><li>为用户提供接口</li></ul><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><ul><li><p>作业调度：从磁盘到内存，再从内存写回磁盘的整个过程。</p><blockquote><p>进程调度：只指从内存进行调度的过程</p></blockquote></li><li><p>作业控制</p><ul><li>批处理</li><li>终端型</li></ul></li></ul><h2 id="OS需要解决的问题"><a href="#OS需要解决的问题" class="headerlink" title="OS需要解决的问题"></a>OS需要解决的问题</h2><ul><li>解决各种冲突<ul><li>资源的竞争引起</li></ul></li><li>协调并发的关系</li><li>保证数据的一致性<ul><li>一台机器</li><li>分布式系统</li></ul></li><li>数据存取控制</li></ul><h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><h3 id="模块接口（单体系统）"><a href="#模块接口（单体系统）" class="headerlink" title="模块接口（单体系统）"></a>模块接口（单体系统）</h3><ul><li>内聚性</li><li>耦合性</li></ul><blockquote><p>优点：开发效率高</p><p>缺点：接口定义困难</p></blockquote><h3 id="有序分层法"><a href="#有序分层法" class="headerlink" title="有序分层法"></a>有序分层法</h3><ul><li>自底向上、自顶向下</li><li>设置原则</li><li>调用方式</li></ul><blockquote><p>在<code>MULTICS</code>系统中，有许多的同心环，内环比外环有更高的级别，当<strong>外环</strong>想要调用<strong>内环</strong>的过程时，需要使用<code>TRAP</code>/<code>syscall</code>等指令。</p></blockquote><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h3 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h3><ul><li>内核中只有中断处理、进程通信(IPC)、基本调度等</li><li>其他的文件系统、网络、内存管理、设备管理都在<strong>微内核</strong>上运行</li></ul><blockquote><p>优点：内核易于实现、可移植性好、适应分布式环境</p><p>缺点：速度慢</p></blockquote><h3 id="机制与策略分离"><a href="#机制与策略分离" class="headerlink" title="机制与策略分离"></a>机制与策略分离</h3><ul><li>策略：用户自定义调度算法</li><li>机制：内核对资源的分配办法</li></ul><blockquote><ul><li>机制就是寻找最高优先级的进程并运行它，策略就是为每个进程赋予不同的优先级。</li><li>机制是框架，策略是调用组合。</li></ul></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Q：多道程序设计和分时系统的区别</p><p>A：多道设计是指，将内存分配给多个<strong>进程</strong>，<strong>轮流</strong>占用CPU。（没有进行整个内存的刷新）</p><p>​      而分时系统根据时间片刷新内存，为不同<strong>用户</strong>提供服务，依然是轮流占用CPU。</p><p>​      多道系统强调效率，一个进程分配的时间会比分时系统的时间片长，但是两者并不矛盾。</p><blockquote><p>发展过程：批处理-&gt;多道程序-&gt;分时系统</p></blockquote><h2 id="Modern-OS-Extract"><a href="#Modern-OS-Extract" class="headerlink" title="Modern OS Extract"></a>Modern OS Extract</h2><ul><li><p>用户接口程序(shell&amp;GUI)<strong>并不是</strong>操作系统的一部分</p></li><li><p>嵌入式系统<strong>没有</strong>内核态</p></li><li><p>资源时间复用就是不同的程序或用户轮流使用它</p></li><li><p>SPOOLing(Simultaneous Peripheral Operation On Line),同时的外部设备联机操作——运算完成后能立即读入下一个程序进行运算，不用等待当前程序输出完成。（多道程序设计）</p><blockquote><p>多道程序设计的本质依旧是批处理系统</p></blockquote></li><li><p>POSIX是IEEE提出的一个UNIX标准</p></li><li><p><strong>单核</strong>多线程并不提供真正的<strong>并行</strong>处理，在一个时刻只有<strong>一个进程</strong>在运行，但是线程的切换时间则减少到<strong>纳秒</strong>数量级。</p></li><li><p>GPU指的是由成千上万个<strong>微核</strong>组成的处理器</p></li><li><p>主存被分割成<strong>高速缓存行(cache line)</strong>,其典型大小为64字节。</p></li><li><p>EEPROM和闪存可以进行擦除和重写，但是ROM不可以。</p><blockquote><p>CMOS是<strong>易失性</strong>的，常被用来保持当前的时间和日期。</p></blockquote></li><li><p>为了能够使用设备驱动程序，必须把设备驱动程序装入OS中。（可能在内核态也可能在用户态运行）</p></li><li><p>即插即用：系统自动地收集有关I/O设备的信息，集中赋予终端级别和I/O地址，然后通知每块I/O卡具体的数值。</p></li><li><p><strong>批处理系统</strong>处理不需要交互式用户干预的<strong>周期性作业</strong>，例如保险公司的索赔处理和商店的销售报告；<strong>事务处理系统</strong>负责大量小的请求，例如银行的支票处理和航班预定；<strong>分时系统</strong>允许多个远程用户同时在一台计算机上运行作业。</p></li><li><p>数字音频、多媒体系统和智能手机是<strong>软实时</strong>系统。</p></li><li><p>每个<strong>进程</strong>都有一个<strong>工作目录</strong>，对于没有以斜线开头给出绝对地址的路径将在这个<strong>工作目录</strong>下进行寻找。</p><blockquote><p><code>/mnt/hgfs</code>和<code>mnt/hgfs</code>可能指不同的文件</p></blockquote></li><li><p>在读写文件之前，需要<strong>打开文件</strong>，检查访问权限。若权限许可，系统将返回一个小整数，称作文件描述符；若禁止访问，系统则返回一个错误码。</p></li><li><p><strong>块特殊文件</strong>指那些由可随机存取的块组成的设备，如磁盘等；<strong>字节特殊文件</strong>用于打印机、调制解调器和其他接受或输入字符流的设备。</p><blockquote><p>特殊文件保存在<code>\dev</code>目录中，例如<code>\dev\lp</code>是打印机。</p></blockquote></li><li><p>管道是一种虚文件，它可以连接两个进程。</p></li><li><p>对目录来说，文件保护码<code>rwx</code>中的<code>x</code>指<strong>是否可查询</strong>。</p></li><li><p>虚拟内存使得程序可以在运行时动态地链接库，而不是必须在编译时链接。</p></li><li><p>第一类虚拟机管理程序没有底层支持，所以必须自行实现所有功能（在自己的分区上进行存储管理）。</p></li><li><p>第二类虚拟机将操作系统安装在一个<strong>虚拟盘</strong>上，这个盘实际上是宿主操作系统的一个大文件，因此可以利用宿主操作系统的相关接口。</p></li><li><p>在所有情形下，操作系统的代码都是<strong>直接</strong>在硬件上执行的，不用解释器，也不是即时编译。</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;全文共&lt;code&gt;2443&lt;/code&gt;字，推荐阅读时间&lt;code&gt;10~15&lt;/code&gt;分钟。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter1-2-进程同步</title>
    <link href="http://yoursite.com/2020/07/04/Chapter1-2-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2020/07/04/Chapter1-2-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:10:16.049Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>6329</code>字，推荐阅读时间<code>30~45</code>分钟。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><p>制约</p><ul><li>直接：进程合作</li><li>间接：资源共享</li></ul></li><li><p>进程同步：多个相关进程在<strong>次序</strong>上的协调</p></li><li><p>原语：由若干条指令组成的序列，并实现某个特定的操作功能。</p><ul><li><p>指令序列的执行是连续的，不可<strong>分割</strong>。</p><blockquote><p>即指原语的执行是原子的，不能够被打断。</p></blockquote></li><li><p>OS的核心组成部分</p></li><li><p>必须在管态（内核态）下执行，且常驻内存。</p></li><li><p>根据用途进行命名，例如用于进程同步则叫做“同步原语”。</p></li></ul></li></ul><h2 id="并发错误"><a href="#并发错误" class="headerlink" title="并发错误"></a>并发错误</h2><h3 id="数据竞争-data-race"><a href="#数据竞争-data-race" class="headerlink" title="数据竞争(data race)"></a>数据竞争(data race)</h3><ul><li><p>多个进程/线程对共享变量<strong>无保护同时</strong>访问，且<strong>至少有一个</strong>是<strong>写</strong>。</p></li><li><p>互斥：一个时刻只能由一个进程访问共享数据。</p><blockquote><p>避免数据竞争</p></blockquote></li><li><p>临界区：对临界资源进行访问的<strong>程序片段</strong></p><ul><li>一个时间，临界区内只能有<strong>一个</strong>进程。</li><li>临界区外的进程不能妨碍其他的进程进入临界区</li><li>一个进程不能在临界区外<strong>无限等待</strong></li></ul></li><li><p>临界资源：一次只允许<strong>一个</strong>进程使用的资源，如打印机、共享变量。</p><blockquote><p>假脱机打印(spooling)：进程打印文件是把文件放在缓冲区，使临界资源（打印机）可以被共享访问。</p></blockquote></li></ul><h3 id="原子性违反-Atomicity-Violation"><a href="#原子性违反-Atomicity-Violation" class="headerlink" title="原子性违反(Atomicity Violation)"></a>原子性违反(Atomicity Violation)</h3><ul><li><code>HeisenBug</code></li><li>多线程结果不可再现的原因<ul><li>不同的环境输入</li><li>不同的API返回</li><li>不同的调度时间</li><li>中断时间</li><li>共享内存访问的顺序（取决于各个核执行的快慢）</li></ul></li><li>执行<strong>重放技术</strong>：在执行时记录所有的相关信息，重放时再写回。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>进程集合中都在<strong>互相等待</strong></li></ul><h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待：当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</li></ul><h2 id="互斥方法"><a href="#互斥方法" class="headerlink" title="互斥方法"></a>互斥方法</h2><h3 id="基于忙等待的互斥方法"><a href="#基于忙等待的互斥方法" class="headerlink" title="基于忙等待的互斥方法"></a>基于忙等待的互斥方法</h3><ul><li><p>忙等：不能满足进入临界区条件就一直等</p><blockquote><p>可能导致优先级反转：进入临界区后的进程被调度后依然在临界区中</p><p>Q：用户级线程实现会不会发生优先级反转</p><p>A： 不会。</p><p>在<strong>用户级</strong>线程之间，因为抢占发生在<strong>进程</strong>级别，所以低优先级不会被高优先级抢占。但是<strong>内核级</strong>线程可能会发生优先级反转。</p></blockquote></li><li><p>屏蔽中断</p><ul><li>用户程序不可取（安全问题）</li><li>关闭中断<strong>只能关闭</strong>一个CPU</li><li>内核常使用</li></ul></li><li><p>共享锁变量</p><ul><li>初值设置为0</li><li>发现未上锁，并且在上锁（置1）<strong>前</strong>被调度的话会导致多个进程进入临界区</li></ul><blockquote><p>读取和设置锁<strong>必须</strong>是一个原子操作</p></blockquote></li><li><p>严格轮换法</p><ul><li><p>要求<strong>两个</strong>进程交替执行（使用<code>turn</code>实现）</p></li><li><p>由于IO可能会导致进程被<strong>未处在</strong>临界区的进程阻塞，违反了同步机制和临界区的规则。</p></li></ul></li><li><p>Peterson算法</p><ul><li><p>在严格轮换法基础上增加<code>interested[]</code>表示进程是否会马上使用CPU</p><blockquote><ul><li>当两个进程同时调度<code>enter_region</code>时，先被写入的<code>turn</code>会被覆盖，因此调度执行的可能会是后写<code>turn</code>的进程。</li><li>并发执行也能正常执行，但是<strong>非抢占式</strong>调度可能导致不公平。</li></ul></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line"><span class="keyword">int</span> interested[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> procnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> othernum;</span><br><span class="line">    </span><br><span class="line">    othernum = <span class="number">1</span> - procnum;</span><br><span class="line">    interested[procnum] = TRUE;</span><br><span class="line"><span class="built_in">turn</span> = procnum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">turn</span> == procnum &amp;&amp; interested[other] == TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> procnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    interested[procnum] = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>硬件指令机制</p><ul><li><p><code>TSL</code>：CPU会锁住<strong>内存总线</strong></p></li><li><p><code>XCHG</code>：<strong>原子性</strong>的值交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVE REG,#1</span><br><span class="line">XCHG REG,LOCK</span><br></pre></td></tr></table></figure></li></ul></li><li><p>信号量机制(Semaphore)</p><ul><li><p>原子操作：一组相关联的操作要么<strong>不间断</strong>地执行，要么<strong>都不</strong>执行。</p></li><li><p>S有且只有一次置初值的机会</p><ul><li><p>$S&gt;0$：表示可以同时获取的资源数目</p><blockquote><p>不同的OS中可能出现$S&lt;0$的情况</p></blockquote></li><li><p>只能由P/V操作改变</p></li></ul></li><li><p>$P(S)$：<code>down</code>操作分配资源</p></li><li><p>$S&gt;0$：信号量减1后继续执行</p><ul><li>$S=0$：进程被直接阻塞，减1操作等到阻塞完成后再执行。 </li></ul><blockquote><p>原子操作，只有一个进程能完成$P(S)$.</p></blockquote></li><li><p>$V(S)$：<code>up</code>操作释放资源</p><ul><li><p>首先将S加1</p></li><li><p>如果加1后发现有进程在信号量队列中<code>sleep</code>,则随机唤醒一个进程然后进行<code>P(S)</code></p><blockquote><p>S：0-&gt;1-&gt;0</p></blockquote></li></ul></li><li><p>实现</p><ul><li>DS：一个整数+一个队列（类似哈希链表）</li><li>操作前关闭中断，操作后打开中断。</li><li>单CPU：关闭中断后测试并更新信号量</li><li>多CPU：使用<strong>锁变量</strong>保护信号量，使用<code>TSL</code>/<code>XCHG</code>保证每次只能由一个CPU检查<strong>信号量</strong>。</li></ul></li></ul><blockquote><p>类似于分配一个数组中的元素，s是数组的元素个数，当s设置为1时，就是<code>mutex</code>（互斥）的。</p></blockquote></li></ul><h3 id="基于信号量的方法"><a href="#基于信号量的方法" class="headerlink" title="基于信号量的方法"></a>基于信号量的方法</h3><p>信号量将<code>sleep</code>和<code>wakup</code>信息存储了起来，避免了相关信息丢失造成的死锁。</p><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><ul><li>信号量初值设置为1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line">P(mutex)</span><br><span class="line">a();</span><br><span class="line">V(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line">P(mutex);</span><br><span class="line">b();</span><br><span class="line">V(mutex);</span><br></pre></td></tr></table></figure><h4 id="汇合-Rendezvous"><a href="#汇合-Rendezvous" class="headerlink" title="汇合(Rendezvous)"></a>汇合(Rendezvous)</h4><ul><li><p>两个进程的同步，使得a1永远在b2之前，b1永远在a2之前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore aArrived = <span class="number">0</span>; <span class="comment">// not 1</span></span><br><span class="line">semaphore bArrived = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1</span></span><br><span class="line">a1();</span><br><span class="line">V(aArrived);</span><br><span class="line">P(bArrived);</span><br><span class="line">a2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// P2</span></span><br><span class="line">b1();</span><br><span class="line">V(bArrived);</span><br><span class="line">P(aArrived);</span><br><span class="line">b2();</span><br></pre></td></tr></table></figure></li></ul><h4 id="多路复用-Multiplex"><a href="#多路复用-Multiplex" class="headerlink" title="多路复用(Multiplex)"></a>多路复用(Multiplex)</h4><ul><li><code>mutex</code>泛化，使n个线程能够<strong>同时在临界区</strong>运行，也称为限流阀。</li></ul><h4 id="屏障-Barriers"><a href="#屏障-Barriers" class="headerlink" title="屏障(Barriers)"></a>屏障(Barriers)</h4><ul><li><p>低级通信原语</p></li><li><p>对Rendezvous进行<strong>泛化</strong>，能够同步<strong>多个</strong>线程。 </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = the number of threads</span><br><span class="line">count = <span class="number">0</span> <span class="comment"># threads arrive at barrier</span></span><br><span class="line">semaphore mutex = <span class="number">1</span> <span class="comment"># protect count</span></span><br><span class="line">semaphore barrier = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">count = count + <span class="number">1</span></span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count == n:</span><br><span class="line">    V(barrier)</span><br><span class="line">P(barrier)</span><br><span class="line">V(barrier)</span><br></pre></td></tr></table></figure><blockquote><p>注意在<code>count==n</code>时地进程也需要执行尾部的一对PV操作</p></blockquote><h4 id="“信号量集”机制"><a href="#“信号量集”机制" class="headerlink" title="“信号量集”机制"></a>“信号量集”机制</h4><ul><li>当出现多个临界资源时（多个对不同信号量的P操作），不正确的PV顺序可能会导致死锁。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1</span></span><br><span class="line">P(mutex1); <span class="comment">// step 1</span></span><br><span class="line">P(mutex2); <span class="comment">// wait</span></span><br><span class="line">V(mutex2); <span class="comment">// cannot execute</span></span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line">P(mutex2); <span class="comment">// step 2</span></span><br><span class="line">P(mutex1); <span class="comment">// wait</span></span><br><span class="line">V(mutex1); <span class="comment">// cannot execute</span></span><br><span class="line">V(mutex2);</span><br></pre></td></tr></table></figure><h4 id="AND型信号量集"><a href="#AND型信号量集" class="headerlink" title="AND型信号量集"></a>AND型信号量集</h4><ul><li>同时需要<strong>多个</strong>资源且每种占用<strong>一个</strong>资源</li><li>基本思想：将几个进程需要的所有资源一次性分配给其中一个进程，等它使用完它需要的资源后再释放。</li><li>$SP(S_1,S_2,…,S_n)$</li><li>$SV(S_1,S_2,…,S_n)$</li><li>可能影响SP操作进程化归到不同的阻塞队列，但是资源的<strong>原子性</strong>获取不受影响，所以不会死锁。</li></ul><blockquote><p>当某个资源数量不够时，其他资源也<strong>不会被</strong>分配，因此<strong>原子性</strong>分配保证了安全性。</p></blockquote><h4 id="一般“信号量集”机制"><a href="#一般“信号量集”机制" class="headerlink" title="一般“信号量集”机制"></a>一般“信号量集”机制</h4><ul><li><p>同时需要多种资源，每种占用数目<strong>不同</strong>，并且被分配的资源还存在一个<strong>临界值</strong>（大于该临界值才能够分配资源）。</p></li><li><p>$SP(S_1,t_1,d_1;…;S_n,t_n,d_n)$</p><p><code>ti</code>是检测值，当所有<code>Si&gt;=ti</code>时才分配<code>di</code>个<code>i</code>类资源，其余情况则阻塞。</p></li><li><p>$SV(S_1,d_1;…;S_n,d_n)$</p></li></ul><blockquote><p>特殊情况：</p><ul><li>$SP(S,d,d)$：每次分配d个资源，少于d时不分配。</li><li>$SP(S,1,1)$：当S初值为1时，等价于<code>mutex</code>.</li><li>$SP(S,1,0)$：开关机制，S为0时可以禁止所有的进程进入临界区。</li></ul></blockquote><h4 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量(Mutex)"></a>互斥量(Mutex)</h4><ul><li>信号量设置为1就是互斥量</li><li><strong>0表示解锁，1表示加锁。</strong>（和PV操作中0阻塞不同）</li><li>如果<code>mutex</code>已经加锁，调用<code>mutex_lock</code>会阻塞。</li><li>主要在<strong>用户线程库</strong>实现</li><li><code>mutex_trylock</code>使得进程不会因为无法获得锁而阻塞，而是返回错误码。</li></ul><h3 id="基于管程的同步和互斥"><a href="#基于管程的同步和互斥" class="headerlink" title="基于管程的同步和互斥"></a>基于管程的同步和互斥</h3><h4 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h4><ul><li>一种<strong>高级</strong>的同步原语，基于条件变量实现。</li><li>定义了一个数据结构和并发进程能执行的一组操作</li><li>为每个临界资源设立一个管程</li><li>任意时刻，管程中只能有一个活跃进程。</li></ul><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul><li>增加<code>wait/signal</code>操作</li><li>条件变量不像信号量可以存储信号，因此<code>wait</code>必须在<code>signal</code>之前执行。</li></ul><blockquote><ul><li>依赖于编译器支持</li><li>不适用于分布式系统</li></ul></blockquote><h3 id="进程通信-IPC-方法"><a href="#进程通信-IPC-方法" class="headerlink" title="进程通信(IPC)方法"></a>进程通信(IPC)方法</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>低级通信：只能传递<strong>状态和整数值</strong>（控制信息）<ul><li>进程互斥/同步采用的信号量和管程机制</li></ul></li><li><p>高级通信：可以传递任意数量的数据</p><ul><li>管道(Pipe)</li><li>共享内存(Shared Memory)：最快的IPC形式</li><li>消息系统</li></ul><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4></li><li><p>无名管道：使用<code>|</code>连接</p><ul><li>半双工：<strong>单方向</strong>流动</li><li>只能用于<strong>父子</strong>进程/<strong>兄弟</strong>进程</li></ul></li><li>有名管道：使用<code>mkfifo()</code>创建</li></ul><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><ul><li><p>通信原语</p><ul><li><code>send(dest, &amp;message)</code></li><li><code>receive(src, &amp;message)</code></li></ul></li><li><p>过程：</p><ul><li>发起<code>send</code>请求并<strong>陷入内核</strong></li><li>将消息复制进入OS空间的消息缓冲区</li><li>将消息加入<strong>接收进程</strong>PCB的消息队列</li><li>将消息复制到<strong>接收进程</strong>中</li></ul></li><li><p>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore buf_empty = N;</span><br><span class="line">semaphore buf_full = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1 = <span class="number">1</span>; <span class="comment">// mem</span></span><br><span class="line">semaphore mutex2 = <span class="number">1</span>; <span class="comment">// PCB queue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// send</span></span><br><span class="line">P(buf_empty);</span><br><span class="line">P(mutex1);</span><br><span class="line">dup_to_mem();</span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line">P(mutex2);</span><br><span class="line">add_to_queue();</span><br><span class="line">V(mutex2);</span><br><span class="line">V(buf_full);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reveive</span></span><br><span class="line">P(buf_full);</span><br><span class="line">P(mutex1);</span><br><span class="line">dup_to_proc();</span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line">P(mutex2);</span><br><span class="line">del_from_queue();</span><br><span class="line">V(mutex2);</span><br><span class="line">V(buf_empty);</span><br></pre></td></tr></table></figure><blockquote><p>本质上也是一个生产者-消费者模型</p><ul><li>消费者<strong>一开始</strong>就申请满缓冲区，<strong>最后</strong>释放空缓冲区。</li><li>生产者<strong>一开始</strong>就申请空缓冲区，<strong>最后</strong>释放满缓冲区。</li></ul></blockquote></li></ul><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul><li>需要同步机制的约束</li></ul><h2 id="经典的进程同步问题"><a href="#经典的进程同步问题" class="headerlink" title="经典的进程同步问题"></a>经典的进程同步问题</h2><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><ul><li>网络应用响应</li></ul><h3 id="读写者问题"><a href="#读写者问题" class="headerlink" title="读写者问题"></a>读写者问题</h3><ul><li><p>共享资源<strong>并发</strong>访问</p></li><li><p>分类互斥问题</p><ul><li><p>写进程在临界区：其他进程不可以进入临界区</p></li><li><p>读进程在临界区：写进程不可以进入临界区</p><blockquote><p>第一个读线程加锁，最后一个读线程解锁。（灯开关模式）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readers = <span class="number">0</span>;</span><br><span class="line">  semaphore mutex = <span class="number">1</span>;</span><br><span class="line">  semaphore roomEmpty = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  cobegin&#123;</span><br><span class="line">    <span class="built_in">Process</span> Writer</span><br><span class="line">      P(roomEmpty);</span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">      V(roomEmpty);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Process</span> Reader</span><br><span class="line">      P(mutex);</span><br><span class="line">      <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">          P(roomEmpty);</span><br><span class="line">      readers += <span class="number">1</span>;</span><br><span class="line">      V(mutex);</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">read</span>();</span><br><span class="line">  </span><br><span class="line">      P(mutex);</span><br><span class="line">      readers -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">          V(roomEmpty);</span><br><span class="line">      V(mutex);</span><br><span class="line">  &#125;coend</span><br></pre></td></tr></table></figure></li><li><p>实现方式</p><ul><li><p>一般信号量集机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore readers = N;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin&#123;</span><br><span class="line">    <span class="built_in">Process</span> Writer</span><br><span class="line">    SP(mutex,<span class="number">1</span>,<span class="number">1</span>;readers,N,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    SV(mutex,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Process</span> Reader</span><br><span class="line">    SP(mutex,<span class="number">1</span>,<span class="number">0</span>;readers,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    SV(readers,<span class="number">1</span>);</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure><blockquote><p>在写者中维护<code>mutex</code>，在读者中维护<code>readers</code>.</p></blockquote></li><li><p><code>wait-signal</code></p></li><li><p>PV</p></li></ul><blockquote><p>灯开关模式对<strong>读</strong>有利，对<strong>写</strong>不利。</p></blockquote></li><li><p>公平读写（非饥饿版本）</p><ul><li>使用<code>barrier</code>实现<code>Turnstile</code></li><li>闸机可以阻塞所有的进程，也可以让进程轮流通过。<ul><li>当信号量为0，闸机关闭，任何进程都<strong>不能够</strong>进入。（在写者<strong>进入</strong>后设置）</li><li>当信号量为1，闸机打开，允许多个进程<strong>排队</strong>进入。（在写者<strong>完成</strong>后设置）</li></ul></li></ul><blockquote><p>是否完全公平还取决于<strong>调度器</strong>选择哪一个在<code>turnstile</code>中排队的进程</p></blockquote></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int readers = <span class="number">0</span></span><br><span class="line">Semaphore mutex = <span class="number">1</span><span class="comment"># mutually exclusively access readers</span></span><br><span class="line">Semaphore roomEmpty = <span class="number">1</span></span><br><span class="line">Semaphore turnstile = <span class="number">1</span> <span class="comment"># use turnstile as a barrier to make it fair</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader</span></span><br><span class="line">P(turnstile)</span><br><span class="line">V(turnstile)</span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">readers += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (readers == <span class="number">1</span>):</span><br><span class="line">    P(roomEmpty) <span class="comment"># the first reader will lock the room</span></span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line">read_in_critical_region()</span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">reader -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(readers == <span class="number">0</span>):</span><br><span class="line">    V(roomEmpty) <span class="comment"># the last reader will unlock the room</span></span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Writer</span></span><br><span class="line">P(turnstile) <span class="comment"># wait in line of turnstile</span></span><br><span class="line">P(roomEmpty) <span class="comment"># wait in line of roomEmpty</span></span><br><span class="line"></span><br><span class="line">write_in_critical_region()</span><br><span class="line"></span><br><span class="line">V(roomEmpty) <span class="comment"># after writing, unlock the room.</span></span><br><span class="line">V(turnstile) <span class="comment"># after writing, reopen the turnstile.</span></span><br></pre></td></tr></table></figure><blockquote><p>在两个进程最开始都是获得<code>turnsile</code>，不会出现写者获得<code>turnsile</code>并且<code>roomEmpty</code>被锁定时的同时没有任何<strong>读进程</strong>在执行的死锁情况。（一定先有读进程获得了<code>turnsile</code>才会获得<code>roomEmpty</code>.</p></blockquote><h3 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h3><ul><li><p>理发店中有一位理发师、一把理发椅和<code>n</code>把等候椅。</p></li><li><p>没有顾客时，理发师在理发椅上休息，顾客到来时叫醒理发师。</p></li><li><p>顾客到来时，如果有空椅子则等待，否则离开。</p></li><li><p>分析：</p><ul><li><p><strong>互斥</strong>：两个进程对等待人数的改变</p><blockquote><p>本质是两个进程都会改变的<strong>非信号量</strong></p></blockquote></li><li><p><strong>同步</strong>：第一个顾客唤醒理发师，理发师唤醒下一个顾客。</p><blockquote><p>本质是使用<strong>信号量</strong>进行进程间同步</p></blockquote></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAIRS 10</span></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore clients = <span class="number">0</span>;</span><br><span class="line">semaphore barber = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin&#123;</span><br><span class="line">    Barber</span><br><span class="line">    P(clients);</span><br><span class="line">    </span><br><span class="line">    P(mutex);</span><br><span class="line">    waiting -= <span class="number">1</span>;</span><br><span class="line">    V(mutex);</span><br><span class="line">    </span><br><span class="line">    cut();</span><br><span class="line">    V(barber);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Client</span></span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting == CHAIRS)</span><br><span class="line">    &#123;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    waiting += <span class="number">1</span>;</span><br><span class="line">    V(mutex)</span><br><span class="line">    </span><br><span class="line">    V(clients);</span><br><span class="line">    P(barber);</span><br><span class="line">    get_cut();</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>P</code>操作就是在排队，相当于是一个<code>while(conditionNotSatisfied);</code>阻塞。</li><li><code>waiting</code>计数在限制等待容量时才有意义</li><li>在某某些条件不满足直接返回时（如没有椅子直接离开和没有顾客直接睡觉），要<strong>释放</strong>当前进程已经占有的资源，不能够直接<code>continue</code>或者<code>return</code>.</li><li><code>waiting</code>和<code>clients</code>虽然意义相似，但是信号量不能直接取值进行比较，所以需要增加<code>waiting</code>.</li><li>在<code>Barber</code>线程中，将<code>P(clients)</code>放在最前面可以简化将<code>waiting</code>放在前面时对0的判断。</li></ul></blockquote><h3 id="有序唤醒问题"><a href="#有序唤醒问题" class="headerlink" title="有序唤醒问题"></a>有序唤醒问题</h3><ul><li>顾客接受服务的顺序应该和进入顺序保持一致</li><li>分析：<ul><li>互斥：当前已经进入银行的人员总数</li><li>同步：注意<strong>同一个柜台连续两次</strong>服务的人员<code>id</code>可能是<strong>跳跃</strong>的</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> clients = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next_id = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore next_mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin&#123;</span><br><span class="line">    Stuff</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(next_mutex);</span><br><span class="line">        <span class="keyword">if</span>(next_id == clients)</span><br><span class="line">        &#123;</span><br><span class="line">            V(next_mutex);</span><br><span class="line">            V(mutex);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_id += <span class="number">1</span>;</span><br><span class="line">        V(next_mutex);</span><br><span class="line">        V(mutex);</span><br><span class="line"></span><br><span class="line">        serve(next_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Client</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    P(mutex);</span><br><span class="line">    clients += <span class="number">1</span>;</span><br><span class="line">    id = clients;</span><br><span class="line">V(mutex);</span><br><span class="line">    </span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure><blockquote><ul><li>此时人员不用<strong>唤醒柜台</strong>（柜台没有睡觉），柜台会自动进行服务，所以能够简化<code>stuff</code>信号量。</li></ul></blockquote><h3 id="固定差值问题"><a href="#固定差值问题" class="headerlink" title="固定差值问题"></a>固定差值问题</h3><ul><li>无限大的仓库装A和B，要求两者始终满足库存$-M&lt;=A-B&lt;=N$</li><li>分析：<ul><li>互斥：A和B的差值，只取正数的话需要分为两个。</li><li>同步：满足条件时才能够继续入库</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">semaphore sa = N; <span class="comment">// A - B</span></span><br><span class="line">semaphore sb = M; <span class="comment">// B - A</span></span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">&#123;</span><br><span class="line">A</span><br><span class="line">    P(sa);</span><br><span class="line">   a += <span class="number">1</span>;</span><br><span class="line">    V(sb);</span><br><span class="line">    </span><br><span class="line">    B</span><br><span class="line">    P(sb);</span><br><span class="line">    b += <span class="number">1</span>;</span><br><span class="line">    V(sa);</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果仓库容量有限，可以在两个进程的最前面加一个判断。</li><li>增加<strong>一个</strong>消费者：需要先对库存进行<strong>非零</strong>判断，同时，P操作其实隐含了一个条件判断，所以在消费是，需要把P操作放在V操作之前，如果P不能通过，那么V就不应该出现。<ul><li>消费A：<code>P(sb)&amp;V(sa)&amp;mutex</code></li><li>消费B：<code>P(sa)&amp;V(sb)&amp;mutex</code></li></ul></li></ul></blockquote><h3 id="构建水分子-H2O"><a href="#构建水分子-H2O" class="headerlink" title="构建水分子(H2O)"></a>构建水分子(H<sub>2</sub>O)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">oxygen = <span class="number">0</span></span><br><span class="line">hydrogen = <span class="number">0</span></span><br><span class="line">Semaphore mutex = <span class="number">1</span> <span class="comment"># only oxygen or hydrogen can be modified at a time</span></span><br><span class="line">Barrier barrier(<span class="number">3</span>)  <span class="comment"># after wait for three times, process can go on.</span></span><br><span class="line">Semaphore oxyQueue = <span class="number">0</span></span><br><span class="line">Semaphore hydroQueue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># oxygen atom</span></span><br><span class="line">P(mutex)</span><br><span class="line">oxygen += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (hydrogen &gt;= <span class="number">2</span>):</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    hydrogen -= <span class="number">2</span></span><br><span class="line">    V(oxygenQueue)</span><br><span class="line">    oxygen -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    V(mutex)</span><br><span class="line">P(oxygenQueue)</span><br><span class="line">bond()</span><br><span class="line">barrier.wait()</span><br><span class="line">V(mutex) <span class="comment"># only oxygen thread has this V operation</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hydrogen atom</span></span><br><span class="line">P(mutex)</span><br><span class="line">hydrogen += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (hydrogen &gt;= <span class="number">2</span> <span class="keyword">and</span> oxygen &gt;= <span class="number">1</span>):</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    hydrogen -= <span class="number">2</span></span><br><span class="line">    V(oxygenQueue)</span><br><span class="line">    oxygen -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    V(mutex)</span><br><span class="line">P(hydrogenQueue)</span><br><span class="line">bond()</span><br><span class="line">barrier.wait()</span><br></pre></td></tr></table></figure><blockquote><ul><li>分子中有<strong>几个原子</strong>就开<strong>几个线程</strong></li><li>同时开启三个线程/进程，由于氧原子<strong>进程</strong>只有一个，因此最后释放<code>mutex</code>的操作在氧原子操作中。</li><li><code>bond()</code>操作会在三个原子凑齐后在三个线程中<strong>各</strong>被调用一次。</li><li><code>mutex</code>同时对<code>hydrogen</code>和<code>oxygen</code>进行了上锁操作。</li></ul></blockquote><h2 id="死锁-deadlock"><a href="#死锁-deadlock" class="headerlink" title="死锁(deadlock)"></a>死锁(deadlock)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>并发死锁</p><p>并发程序执行的<strong>顺序不当</strong>造成的死锁</p></li><li><p>资源死锁</p><ul><li>$饥饿\neq死锁$</li></ul><blockquote><p>资源</p><ul><li>可剥夺资源：CPU、内存。</li><li>非可剥夺资源：CD刻录机、打印机、<strong>临时性资源（消息、中断）</strong></li></ul></blockquote></li></ul><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li>互斥：一段时间内某个资源只能够由<strong>一个</strong>进程占用</li><li>保持和请求：已经得到资源的线程<strong>可以</strong>请求新的资源（多个锁的请求顺序）</li><li>不剥夺：已经获得资源的进程不能被强制剥夺该资源，只能自行释放。</li><li>环路（循环）等待条件：发生死锁时必然存在多个进程组成的环形链。</li></ul><h3 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h3><ul><li><p>鸵鸟算法</p><p>死锁概率小、影响低时可以考虑。</p></li><li><p>死锁检测&amp;死锁恢复(detection and recovery)</p><ul><li>允许死锁发生，发生后采取措施恢复。</li><li>检测方法<ul><li>资源分配图<ul><li>使用场景：每类资源只有<strong>一个</strong></li></ul></li><li>资源向量计算<ul><li>使用场景：每类资源有<strong>多个</strong></li></ul></li></ul></li></ul></li><li><p>死锁预防(avoidance)</p><ul><li><p><strong>静态</strong>行为</p></li><li><p>破坏四个<strong>必要条件</strong>之一（或更多）</p></li></ul></li><li><p>死锁避免(prevention)</p><ul><li><strong>动态</strong>行为</li><li>分配资源前进行<strong>安全检查</strong><ul><li>银行家算法：运行前知道所有进程所需资源的最大值</li></ul></li></ul></li></ul><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>检测算法核心：是否存在进程之间的<strong>循环等待</strong></p><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>适合每类资源只有一个的死锁检测，主要是检查图中是否存在<strong>有向环</strong>。</p><ul><li>圆形：进程(<code>P</code>)</li><li>方形：资源(<code>R</code>)</li><li>资源-&gt;进程：资源被占用</li><li>进程-&gt;资源：进程正在请求资源</li></ul><blockquote><p>作图：<strong>先画资源然后画进程</strong></p></blockquote><h4 id="资源向量（矩阵）法"><a href="#资源向量（矩阵）法" class="headerlink" title="资源向量（矩阵）法"></a>资源向量（矩阵）法</h4><p><strong>概念</strong></p><p>适用于每类资源有多个的死锁检测</p><p>$\sum_{i=1}^{n}C_{ij}+A_j=E_j$</p><p>当前分配矩阵中选定一列和A中对应列一起求和的值等于资源总量中对应的列的值。</p><ul><li>E(existing resource vector)：存在资源<strong>行向量</strong>，表示各类资源存在的<strong>总量</strong>。</li><li>A(available resource vector)：可用资源<strong>行向量</strong>，当前未被分配的可用资源数.</li><li>C(current allocation matrix)：当前分配<strong>矩阵</strong>，第<code>i</code>个行向量对应第<code>i</code>个进程<strong>已经分配</strong>到的各类资源数量。</li><li>R(request matrix)：第<code>i</code>个行向量表示第<code>i</code>个进程<strong>还需要的</strong>资源数量</li></ul><p><strong>实现步骤</strong></p><ul><li>寻找进程$P_i$,要求其在R矩阵中对应的第<code>i</code>行<strong>小于等于</strong>A，如果找不到，则跳过下一步。</li><li>使$P_i$运行完成，将$P_i$的当前分配向量<code>flush</code>到A中，并<strong>标记该进程执行完毕</strong>，然后<strong>跳转回第一步</strong>。</li><li>算法结束，如果存在没有标记的进程，则发生死锁。</li></ul><blockquote><p>Q：选择$P_i$的顺序是否有影响</p><p>A：没有，这是一个饱和式算法，会有多次遍历。</p></blockquote><h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><ul><li><p>资源抢占法</p><p>挂起一些占有资源的进程，解除死锁，等待死锁结束后，<strong>再次激活</strong>这些被挂起的进程。</p></li><li><p>杀死进程法</p><p>杀死一个或若干进程，直到打破死循环。</p><blockquote><p><strong>编译进程</strong>可以，但是<strong>数据库进程、打印进程</strong>等不可以。</p></blockquote></li><li><p>回滚法</p><p>设置检查点（记录上下文），当出现死锁时选择一个拥有资源的进程回滚到<strong>未占用资源</strong>的检查点状态。</p><ul><li>定期创建检查点</li><li>回滚常用来<strong>容错</strong><ul><li>数据库事务</li><li>高可用服务系统：脱敏疗法（脱离过敏原）</li></ul></li></ul></li></ul><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul><li><p>打破互斥条件</p><p>使用假脱机技术让独占资源共享（缓冲区）</p></li><li><p>打破保持和请求条件</p><ol><li>当进程需要的<strong>所有</strong>资源都满足后一次性分配，进程结束后再<strong>统一释放</strong>。<strong>（SP&amp;SV操作）</strong></li><li>每次请求资源之前<strong>先释放</strong>已有资源，然后再尝试<strong>获取所有的资源</strong>。</li></ol><blockquote><p>局限：</p><ul><li>不可预测</li><li>资源利用率低</li><li>降低进程的并发性</li></ul></blockquote></li><li><p>打破不可抢占条件</p><p>允许进程强行抢占某些资源</p></li><li><p>打破循环等待条件</p><p>提前为资源编号，分配资源时必须按照顺序进行。</p><blockquote><p>局限：</p><ul><li>增加系统开销</li><li>因为必须按照顺序申请，则“挡”在<strong>现在</strong>需要的资源之前的进程也要被<strong>一并申请</strong>，因此会增加进程对资源的占用时间。(不产生竞争条件的资源<strong>不用</strong>进行编号)</li></ul></blockquote></li></ul><h3 id="哲学家进餐问题-the-dining-philosophers-problem"><a href="#哲学家进餐问题-the-dining-philosophers-problem" class="headerlink" title="哲学家进餐问题(the dining philosophers problem)"></a>哲学家进餐问题(the dining philosophers problem)</h3><p>解决思路</p><ul><li>每次只允许4个哲学家竞争餐具，则总有一个哲学家可以进餐完毕。（破除<strong>循环等待</strong>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Semaphore dinners = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_forks</span><span class="params">(i)</span>:</span></span><br><span class="line">    dinners.wait()</span><br><span class="line">    </span><br><span class="line">    forks[right[i]].wait()</span><br><span class="line">    forks[left[i]].wait()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_forks</span><span class="params">()</span>:</span></span><br><span class="line">    forks[right[i]].signal()</span><br><span class="line">    forks[left[i]].signal()</span><br><span class="line">    </span><br><span class="line">    dinners.signal()</span><br></pre></td></tr></table></figure><ul><li><p>假如至少一个左撇子和一个右撇子，则不会发生死锁。（反证法）（破除<strong>循环等待</strong>）</p></li><li><p>对餐具进行编号，哲学家按照<strong>升序</strong>拿餐具。（破除<strong>循环等待</strong>）</p><p>本质上，1号哲学家是<strong>右撇子</strong>，5号哲学家是<strong>左撇子</strong>。</p><blockquote><p>Q：当被1和5号筷子夹着的1号哲学家哲学家用餐时，是否会同时占用2、3、4？</p><p>A：不会。假设大家都拿起了筷子，那么1、5或者1、2之间的哲学家一定有一个没有拿起，不如假设是前者。那么4、5之间的哲学家可以正常用餐，放下筷子后又可以正常进行竞争，因此1、5之间的哲学家不需要去竞争2、3、4，所以便不会出现问题中描述的情况。</p></blockquote></li><li><p>对哲学家编号，奇数号先拿左再拿右，偶数号相反。（破除<strong>循环等待</strong>）</p><blockquote><p>相当于加入了左撇子和右撇子</p></blockquote></li><li><p><strong>同时拿起</strong>两边的餐具，要不都不拿。（破除<strong>保持等待</strong>）</p></li><li><p><code>Tanebum</code>算法：加入对哲学家状态<code>eating</code>/<code>bungry</code>的判断</p><blockquote><p>破除<strong>死锁</strong>，但是依然有<strong>饥饿</strong>现象。</p></blockquote></li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p><strong>动态策略</strong>，对每个资源请求进行检查，避免<strong>资源死锁</strong>。</p><blockquote><p>这里的动态和死锁恢复不一样，死锁恢复的动态体现在死锁<strong>发生后</strong>，而这里是死锁<strong>发生前</strong>。</p></blockquote><ul><li><p>安全序列：不产生死锁的资源分配顺序</p></li><li><p>安全状态：没有死锁时，所有进程突然请求<strong>最大</strong>需要的资源量<strong>（同时请求并不是同时分配）</strong>，也<strong>不发生</strong>死锁。</p></li><li><p>不安全状态：<strong>不存在</strong>安全序列使进程可以运行完毕</p><blockquote><p>系统进入不安全状态也<strong>不一定</strong>会产生死锁；但是产生死锁后，<strong>一定处于</strong>不安全状态。</p><p>Q：为什么不安全状态不一定产生死锁</p><p>A：不安全状态是由<strong>最大需求</strong>推导出的，但是实际上，可能在进程下一次真正申请资源时，资源条件已经得到满足，从而<strong>不产生</strong>死锁。</p></blockquote></li></ul><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul><li><p>可用资源向量(Available)</p></li><li><p>最大需求矩阵(Max)</p></li><li><p>分配矩阵(Allocation)</p></li><li><p>需求矩阵(Need)</p><p>$Need_{ij}=Max_{ij}-Allocation_{ij}$</p></li></ul><p><strong>实现步骤：</strong></p><p>设request是P的请求向量，且需要k个R类资源</p><ul><li>${request}\leq{need}$则进入下一步，否则认为出错。（请求资源超过了<strong>事先约定的</strong>限额）</li><li>${request}\leq{available}$则进入下一步，否则进入等待状态。</li><li>系统模拟把资源分配给P,并执行<strong>安全性算法检查</strong>。</li><li>如果检查通过，则正式分配资源，否则恢复到模拟前的状态，让P等待。</li></ul><p><strong>安全性算法：</strong></p><ul><li><p>设置两个向量</p><ul><li><p>工作向量(Work)：表示系统<strong>可提供的各类资源的数目</strong></p><p>初始时<code>Work:=Available</code></p></li><li><p>完成向量(Finish)：表示系统是否有足够的资源分配给进程</p><p>初始时<code>Finish[i]:=false</code>，如果资源足够（<strong>不是检查通过</strong>）则置为<code>true</code>.</p></li></ul></li><li><p>寻找满足以下条件的进程</p><ul><li>$Finish[i]=false$</li><li>${Need_i}\leq{Work}$</li></ul><p>如果找到则进入下一步，否则跳过。</p></li><li><p>将Allocation<code>flush</code>到Available并返回上一步</p></li><li><p>如果<code>Finish[i]=true</code><strong>都成立</strong>则检查通过</p></li></ul><blockquote><p>特点：</p><ul><li>算法考虑到了<strong>互斥、部分分配、不可抢占</strong>，因而可提高资源利用率</li><li>要求实现说明最大资源要求，在现实中无法使用。</li></ul></blockquote><h4 id="资源分配图-1"><a href="#资源分配图-1" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>原理和银行家算法相同</p><ul><li>封锁进程：对应银行家算法中Need无法被满足的线程</li><li>非封锁进程：没有被封锁的进程</li><li>化简：一个进程运行完成则使其成为孤立节点</li></ul><p>死锁定理：</p><ul><li>死锁等价于资源分配图<strong>不能</strong>完全化简（不能全部成为孤立节点）</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Q：一个进程的死锁是否存在？</p><p>A：否，死锁发生时必须存在环路（必要条件）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;6329&lt;/code&gt;字，推荐阅读时间&lt;code&gt;30~45&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter2-内存管理</title>
    <link href="http://yoursite.com/2020/07/04/Chapter2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/04/Chapter2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:10:32.244Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1684</code>字，推荐阅读时间<code>7~10</code>分钟。</p><a id="more"></a><h2 id="存储器硬件"><a href="#存储器硬件" class="headerlink" title="存储器硬件"></a>存储器硬件</h2><ul><li>RAM<ul><li>SRAM：常用于制作高速缓存</li><li>DRAM：常用于制作主存</li><li>SDRAM、DDR SDRAM：常用于制作主存</li></ul></li><li>ROM<ul><li>PROM、EPROM、EEPROM</li></ul></li><li>FLASH<ul><li>NOR</li><li>NAND</li></ul></li><li>DISK</li><li>Tape</li></ul><blockquote><ul><li>RAM是易失性存储，ROM是非易失性存储。</li><li>RAM和ROM是内存（reg+cache+主存）</li><li>ROM只读，FLASH可写容量小，RAM可读写容量大。</li></ul></blockquote><h2 id="基本需求"><a href="#基本需求" class="headerlink" title="基本需求"></a>基本需求</h2><ul><li>独立性：程序发出的地址和物理地址不相关</li><li>保护性：一个程序不能访问另一个程序的地址空间</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>主要内容：存储分配和回收</li><li>地址变换<ul><li>可执行文件<strong>生成</strong>时的<strong>链接</strong>技术</li><li>程序<strong>加载</strong>时的<strong>重定位</strong>技术</li><li>进程<strong>运行</strong>时硬件和软件地址<strong>变换</strong>技术</li></ul></li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><ul><li>分配原则：多退少补，但是退的太少时就不退了。</li><li><p>空闲分区合并：注意取哪个分区的首地址</p></li><li><p>分配算法</p><ul><li>下次适应算法：尽管一个分区没有分配完，但是再次寻找时还是会跳转到下一个分区。</li></ul></li></ul><h2 id="碎片处理"><a href="#碎片处理" class="headerlink" title="碎片处理"></a>碎片处理</h2><h3 id="内碎片"><a href="#内碎片" class="headerlink" title="内碎片"></a>内碎片</h3><ul><li><strong>只能</strong>等待释放</li></ul><h3 id="外碎片"><a href="#外碎片" class="headerlink" title="外碎片"></a>外碎片</h3><ul><li><p>紧凑技术(Compaction)：将多个空闲分区拼接</p><p>技术支撑：动态重定位（<strong>不同于</strong>装载）-&gt;移动作业时，内存位置会发生变化。</p></li></ul><h2 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h2><h3 id="覆盖-Overlay"><a href="#覆盖-Overlay" class="headerlink" title="覆盖(Overlay)"></a>覆盖(Overlay)</h3><ul><li>将程序分成多个<strong>独立</strong>的程序段，利用时间差共享同一块<strong>小内存</strong>区域。</li></ul><blockquote><p>分段需要程序员进行，增加了负担。</p></blockquote><h3 id="交换-Swapping"><a href="#交换-Swapping" class="headerlink" title="交换(Swapping)"></a>交换(Swapping)</h3><ul><li>以程序为单位进行主存与辅存间的交换</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li>x86保护模式下段式访存不能禁止，但是页式访存可以启用和禁止。</li><li>多级页表页目录所在地址的计算（按照抽象层级的方法计算）</li></ul><h2 id="Modern-OS-Extract"><a href="#Modern-OS-Extract" class="headerlink" title="Modern OS Extract"></a>Modern OS Extract</h2><ul><li><p>当一个进程运行时，程序的<strong>起始物理地址</strong>装载到<strong>基址寄存器</strong>中，<strong>程序的长度</strong>装载到<strong>界限寄存器</strong>中。</p></li><li><p>对每个进程都使用基址寄存器和界限寄存器的缺点就是每次访问内存都需要进行加法和比较运算</p></li><li><p>在决定把一个占<code>k</code>个分配单元的进程调入内存时，存储管理器必须搜索位图，在位图中找到有<code>k</code>个<strong>连续0</strong>的串。查找位图中指定长度的<code>0</code>串时耗时的操作，因为串可能跨越了<strong>最小分配单元</strong>。</p></li><li><p><strong>下次适配算法</strong>每次在<strong>上一次</strong>结束的地方开始搜索，而不是像首次适配算法、最佳适配算法那样<strong>从头开始</strong>搜索。</p><blockquote><p>下次适配的性能略<strong>低于</strong>首次适配算法</p></blockquote></li><li><p>为进程和空闲区设置独立的链表，即<strong>进程链表</strong>和<strong>空闲区链表</strong>分离，可以提高算法的速度。</p></li><li><p>空闲区链表可以合并进空闲区本身——例如空闲区第一个字是空闲区大小，第二个字指向下一个空闲区。</p></li><li><p>覆盖技术是指一个程序的若干程序段，或者<strong>几个程序</strong>的某些部分共享某一个存储空间。</p><blockquote><p>由程序员将程序分割成多个片段</p></blockquote></li><li><p>页表的目的式把虚拟页面映射为页框。从数学角度说，页表是一个函数，它的参数是<strong>虚拟页号</strong>，结果是<strong>物理页框号</strong>。</p></li><li><p>对于IO映射到内存中的设备而言，需要在页表中设置<strong>高速缓存禁止位</strong>，但是对于独立的IO空间和不使用内存映射IO的设备则不需要。</p></li><li><p>发生缺页中断时，操作系统需要调入的页面的磁盘地址等信息保存在操作系统内部的<strong>软件表格</strong>中，硬件(MMU)<strong>不需要它</strong>。</p></li><li><p>地址放入MMU进行转换时，硬件首先通过将虚拟页号和TLB中<strong>所有表项并行</strong>进行匹配，判断虚拟页面是否在其中。</p></li><li><p>当一个页面访问在内存中而不再TLB中时，产生<strong>软失效</strong>；当页面本身不在内存中时（当然也不在TLB中），将产生<strong>硬失效</strong>。</p></li><li><p>在反置页表中，实际内存中的每个<strong>物理页框</strong>对应一个表项。</p></li><li><p>在反置页表中，当进程访问虚拟页面时，必须搜索<strong>整个</strong>反置页表来查找某个页表项。</p><blockquote><p>可以使用Hash加速</p></blockquote></li><li><p>引入多级页表的原因是避免把全部页表一直保存在内存中，特别是某些从来都不会用到的页表。</p><blockquote><p>当只有单级页表时，因为需要直接使用虚拟地址访问到对应的页表项，所以需要用<strong>页表始址寄存器</strong>保存页表的起始物理地址。由于这个寄存器的个数限制（只有一个），所有的页表只能被放在固定的地址上，因此单级页表需要一块<strong>连续</strong>的<strong>物理</strong>内存空间用来存放页表。</p><p>但是对于多级页表，只需要用这个寄存器存储一级页表的物理始址，之后查找的高级页表就可以是不连续的了。</p></blockquote></li><li><p>当调度一个进程执行时，<strong>必须</strong>为新进程<strong>重置</strong>MMU，<strong>刷新</strong>TLB，以清楚以前的进程遗留的痕迹。</p></li><li><p>如果分页算法是全局算法，包含IO缓冲区的页面也<strong>有很小的可能</strong>会被换出内存。此时如果一个IO设备正处在对该页面的DMA传输过程中，则传输的数据一部分在换出前的缓冲区页面中，一部分在新装入的页面中。</p><blockquote><p>解决方法一般有两种：</p><ul><li>将此类页面设置为<strong>不可换出</strong>的</li><li>在<strong>内核缓冲区</strong>中完成IO操作后再将数据复制到<strong>用户页面</strong></li></ul></blockquote></li><li><p>由于程序正文通常是只读的，当内存资源紧张、程序页不得移出内存时，尽管丢弃它们，再需要的时候再从可执行文件读入即可。</p><blockquote><p><strong>共享库</strong>正是使用这个方式工作</p></blockquote></li><li><p><strong>每个</strong>段由一个从<strong>0到最大的线性地址序列</strong>构成，不同的段的长度可以不同，并且在运行期间可以动态改变。</p><blockquote><p>堆栈段的长度再数据被压入时会增长，在数据弹出时又会减小。</p></blockquote></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1684&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter1-1-进程、线程与并发</title>
    <link href="http://yoursite.com/2020/07/04/Chapter1-1-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/07/04/Chapter1-1-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:10:07.763Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>3661</code>字，推荐阅读时间<code>15~30</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>并发：两个活动可以在<strong>同一个</strong>处理机，也可以在<strong>不同</strong>的处理机上执行，只要满足都在正常执行即可。</p></li><li><p>并行：两个程序运行在<strong>不同</strong>的处理机上</p><blockquote><p>并发可能是<strong>伪并行</strong>，也可能是<strong>真并行</strong>。</p></blockquote></li><li><p>前趋图：<strong>有向无环</strong>图，指向下一个执行的语句、程序段或进程。</p><blockquote><p><strong>单个</strong>节点引出的多个结点是<strong>可并发</strong>的</p></blockquote></li><li><p>顺序执行</p><ul><li>顺序性</li><li>封闭性：一个时间只有一个进程<strong>独占</strong>全部资源</li><li>可再现性</li></ul></li><li><p>并发执行</p><ul><li>间断性</li><li><strong>非</strong>封闭性</li><li>不可再现性</li></ul></li><li><p>竞争：多个进程在读写共享数据时的<strong>结果</strong>依赖于它们执行的<strong>相对顺序</strong></p></li><li><p>并发进程的无关性：并发进程执行结果和顺序无关的<strong>充分条件</strong>（Bernstein条件）</p><p>若两个进程P1，P2满足</p><ul><li>P1的<strong>读区域</strong>和P2的<strong>写区域</strong>没有交集</li><li>P1的<strong>写区域</strong>和P2的<strong>读区域</strong>没有交集</li><li>P1的<strong>写区域</strong>和P2的<strong>写区域</strong>没有交集</li></ul><p>则两个进程的并发执行结果与<strong>顺序无关</strong></p></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>进程时系统进行<strong>资源分配和调度</strong>的一个<strong>独立单位</strong>（这里的调度指<strong>资源调度</strong>，不是线程中提到的<strong>运行调度</strong>。）</p></li><li><p>$进程 = 程序 + 数据 + 进程控制块$</p><blockquote><ul><li>多次执行：一个程序对应多个进程</li><li><strong>调用</strong>：<strong>一个进程</strong>含有<strong>多个程序</strong></li></ul></blockquote></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>程序段</li><li>数据段</li><li>进程控制块PCB</li></ul><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ul><li>代码</li><li>数据</li><li>PC值</li><li>通用寄存器的值、堆、栈</li><li>系统资源（如打开的文件）</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul><li>主要任务是<strong>创建和撤销</strong>进程和进程的<strong>状态转换</strong></li><li><strong>内核</strong>实现</li></ul><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul><li>就绪</li><li>执行</li><li>阻塞</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">执行--&gt;就绪</span><br><span class="line">就绪--&gt;执行</span><br><span class="line"></span><br><span class="line">执行--&gt;阻塞</span><br><span class="line"></span><br><span class="line">阻塞--&gt;就绪</span><br></pre></td></tr></table></figure><blockquote><p>注意<strong>就绪</strong>不能够变为<strong>阻塞</strong></p></blockquote><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>管理进程的创建和撤销</li><li>进程的<strong>唯一标志</strong></li><li>限制系统进程的<strong>总数</strong></li></ul><h5 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h5><ul><li>进程标识符</li><li>程序和数据地址</li><li>当前状态</li><li>现场保护区</li><li>互斥和同步机制：存储<strong>信号量</strong></li><li>进程通信机制</li><li>优先级</li><li>资源清单：IO设备，打开的文件等。</li><li>链接字：下一个进程的PCB</li><li>家族关系</li></ul><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><ul><li><strong>调度器</strong>执行</li><li>保存断点及相关寄存器</li><li>切换内存映射（页表基址、TLB重填）</li></ul><h4 id="陷入内核"><a href="#陷入内核" class="headerlink" title="陷入内核"></a>陷入内核</h4><ul><li>CPU状态改变</li><li>中断、异常、Trap指令（系统调用）</li><li>需要保存现场（寄存器、堆栈）</li></ul><blockquote><ul><li>进程上下文切换是指进程调度层面的<strong>大切换</strong>，因此开销很大。</li><li>进程上下文切换时<strong>一定会</strong>陷入内核</li><li>陷入内核<strong>不一定</strong>需要切换进程，有可能只是<strong>内核态和用户态</strong>的切换，因此开销较小。</li></ul></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>为了弥补进程不能够灵活切换导致的功能单一、效率低的问题。</li><li>一种可以并发、<strong>可以共享地址</strong>空间的实体（第二点发挥主要作用：将<strong>资源和计算分离</strong>）</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>MS DOS：<strong>单进程、单线程</strong></li><li>早期UNIX：<strong>多进程、单线程</strong></li><li>Java：<strong>单进程、多线程</strong></li><li>NT、OS/2、SALORIS、MACH：<strong>多进程、多线程</strong></li></ul><blockquote><p>Linux并不确切区分进程和线程，而将线程定义为“执行上下文”，所以切换线程就是切换“执行上下文”。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>用户级线程：POSIX、MACH、Java</p><p>内核中只有<strong>进程表</strong>，没有<strong>线程表</strong>。</p><ul><li>优点<ul><li>移植性好</li></ul></li><li>缺点<ul><li>系统调用可能会阻塞<strong>所有的线程</strong>（线程在一个处理机上）</li><li>内核分配处理器时是以<strong>进程</strong>为单位，因此<strong>线程</strong>无法<strong>真并行</strong>。</li></ul></li></ul></li><li><p>内核级线程：Windows 2000/XP、OS/2、Linux、Solaris、UNIX、Mac OS</p><p>内核中既有<strong>进程表</strong>，又有<strong>线程表</strong>。</p><ul><li>优点<ul><li>真并行</li><li>阻塞时一般只阻塞一个线程</li></ul></li><li>缺点<ul><li>线程切换需要陷入内核，效率降低。</li></ul></li></ul></li><li><p>混合线程</p><p>用户线程和内核线程实现多路复用（映射关系可以发生变化）</p><ul><li><p>Many-to-One</p><p>多个<strong>用户级线程</strong>对应一个<strong>内核线程</strong>，线程只需要在用户空间进行统一管理，效率较高。</p></li><li><p>One-to-one</p><p>阻塞只会影响一个线程</p></li><li><p>Many-to-Many（要求<strong>内核线程数量&lt;=用户线程数量</strong>）</p></li></ul></li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li>线程安全：多个线程之间</li><li><p>可重入：在<strong>一个线程</strong>中，函数在执行的任何阶段都有可能被<strong>中断</strong>，中断处理函数中可能<strong>在该线程中</strong>再次调用这个函数，如果多次执行的结果都是正确的，那么这个函数就是可重入的。</p></li><li><p>可重入&amp;线程安全</p><ul><li>可重入<strong>不一定</strong>线程安全</li><li>线程安全<strong>不一定</strong>可重入</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reentrant</span></span><br><span class="line"><span class="comment">// NOT Thread safe</span></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add10</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmp = a;<span class="comment">// tmp may be overwritten by other threads</span></span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">10</span>;  <span class="comment">// return value will always be correct</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// non-reentrant</span></span><br><span class="line"><span class="comment">// Thread safe</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add10</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmp = a;<span class="comment">// tmp is different in every thread</span></span><br><span class="line">    <span class="keyword">return</span> tmp + <span class="number">10</span>;<span class="comment">// return value may not equal a + 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>在第一个函数中，<code>tmp</code>是全局变量，因此不同的线程可能会互相覆盖<code>tmp</code>，但是返回值永远之和参数有关，也就是说，函数的功能永远是正确的，因此线程不安全，但是可重入。</li><li>在第二个函数中，<code>tmp</code>是线程全局变量，不同的线程<strong>不能够</strong>相互修改<code>tmp</code>，但是在一个线程中多次的反复调用是可以修改<code>tmp</code>的，因此返回值不一定是<code>a+10</code>，所以线程安全，但是不可重入。</li></ul></blockquote></li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>高级调度：从用户工作流程的角度，一次提交若干个作业，对<strong>每个作业进行调度</strong>，时间单位通常是分钟、小时或天。</li><li>中级调度：<strong>内外存</strong>交换</li><li>低级调度：<strong>进程（线程）调度</strong>，时间单位通常是毫秒。<ul><li>抢占式<ul><li>时间片</li><li>优先级</li><li>短作业优先</li></ul></li><li>非抢占式</li></ul></li></ul><h3 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h3><ul><li>周转时间：作业从提交到完成所经历的<strong>总时间</strong>，通常<strong>大于等于运行时间</strong>。<ul><li>平均周转时间</li><li>带权平均周转时间</li></ul></li><li>响应时间：用户输入一个请求到系统首次相应的时间</li><li>截止时间：开始截止时间和完成截止时间</li><li>优先级：关键性任务的区分度<ul><li>不同于<strong>优先数</strong>，优先级是一个<strong>相对</strong>概念，优先数是一个<strong>绝对</strong>概念。</li></ul></li><li>公平性</li><li>吞吐量：单位时间内完成的<strong>作业数</strong></li><li>处理机利用率</li><li>资源的均衡利用</li></ul><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><h4 id="公式集锦"><a href="#公式集锦" class="headerlink" title="公式集锦"></a>公式集锦</h4><ul><li><p><strong>运行时间 = 没有进程竞争时需要的完成时间 = 只有这一个作业时需要的周转时间</strong></p></li><li><p>吞吐量 = 作业数 / 总运行时间</p></li><li><p>周转时间 = 完成时刻 - 提交时刻</p></li><li><p>带权周转时间 = 周转时间 / 运行时间</p><blockquote><p>周转时间相同时，运行时间越短，说明该作业等待的时间较长，因此需要在求周转时间是进行一定的<strong>放大</strong>。</p></blockquote></li><li><p>平均周转时间 = 周转时间之和 / 作业数</p></li><li><p>平均带权周转时间 = 带权周转时间之和 / 作业数</p></li></ul><blockquote><p>吞吐量<strong>不是</strong>平均周转时间的倒数，因为总周转时间<strong>不一定</strong>等于总运行时间。</p><p>例如在并发系统中，两个作业的周转时间分别是1.5h和2h，则总周转时间为3.5h，但是总运行时间是2h.此时，</p><ul><li>平均周转时间 = 3.5 / 2 = 1.75h</li><li>吞吐量 = 2 / 2 = 1个/h</li></ul></blockquote><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><ul><li><strong>非抢占方式</strong></li><li>当前进程如果遇到IO阻塞一样<strong>会让出</strong>CPU，但是阻塞结束后，由于非抢占，并不会立即恢复执行，而是等到当前进程让出CPU.</li><li>利于CPU繁忙的作业，不利于IO繁忙的作业。</li><li>利于长作业，不利于短作业。</li></ul><h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><ul><li><strong>非抢占方式</strong></li><li>对就绪队列中的进程按照执行时间<strong>升序</strong>排列，依次执行。</li></ul><h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><ul><li><strong>抢占式调度</strong></li></ul><h4 id="最高响应比优先"><a href="#最高响应比优先" class="headerlink" title="最高响应比优先"></a>最高响应比优先</h4><ul><li><p>每次调度时先计算作业队列中各个作业的响应比，然后选择值<strong>最大</strong>的作业运行。</p><p>响应比 = 1 + 已经等待时间 / 要求运行时间</p></li><li><p>不会出现饥饿现象</p></li><li><p>计算响应比带来时间开销，性能比SJF略低。</p></li></ul><h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><ul><li>时间片轮转</li><li>多级队列</li><li>多级反馈队列</li></ul><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul><li>排队：FCFS</li><li>轮转</li><li>中断</li><li><strong>抢占</strong>：将队首进程调到队尾，然后执行队首进程。</li><li>出让：进程未执行完一个时间片时就让出CPU（例如阻塞）</li></ul><h5 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h5><ul><li><strong>系统</strong>响应时间 = 进程数目 * 时间片长度</li><li>时间片过短时，用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间<strong>也会增加</strong>。</li></ul><h4 id="优先级算法"><a href="#优先级算法" class="headerlink" title="优先级算法"></a>优先级算法</h4><ul><li>静态优先级</li><li>动态优先级<ul><li>等待时间长则优先级升高</li><li>用完时间片都没有执行完则优先级降低</li></ul></li></ul><h5 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h5><p>高优先级进程被低优先级进程延迟或阻塞</p><ul><li>通常发生在资源竞争中，低优先级进程抢先对共享资源上锁，但是被高优先级进程抢占了CPU，而高优先级进程却因为锁只能被阻塞。</li></ul><p><strong>解决办法</strong></p><ul><li><p>优先级置顶</p><p>当任意进程进入临界区后，将其优先级设置为最高。</p></li><li><p>优先级继承</p><p>当高优先级进程发现资源被低优先级进程上锁之后，将低优先级进程的优先级临时升高和高优先级进程相等。</p></li></ul><h4 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h4><ul><li>不同队列有不同的优先级、时间片长度、调度策略。</li></ul><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><ul><li>设置多个就绪队列，分别赋予不同的优先级，队列1的优先级最高。</li><li>优先级<strong>越低</strong>的队列时间片长度也<strong>越长</strong></li><li>新进程先加入优先级最高的队列，如果时间片用完都没有执行完，则调入低一级队列，以此类推。</li><li>最后一级队列按照<strong>FCFS</strong>的策略进行调度，其他都是“时间片轮转法”。</li><li><strong>高优先级</strong>队列<strong>空</strong>时才会执行<strong>低优先级</strong>队列</li><li><strong>抢占式</strong>调度，当低优先级进程被抢占后，加入原队列的末尾。<strong>（不用改变优先级）</strong></li></ul><blockquote><ul><li>IO型进程放在<strong>高优先级</strong>队列，因为阻塞会自动让出CPU，并且计算任务通常在<strong>较短时间</strong>内即可完成。</li><li>计算型进程放在<strong>低优先级</strong>队列，最终使用<strong>大时间片</strong>执行，减少调度次数。</li></ul></blockquote><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>时间主导</li><li>硬实时：作业<strong>绝对满足</strong>截止时间要求（汽车、飞机的控制系统）</li><li>软实时：偶尔不满足（视频播放软件）</li><li>要求每个进程的行为<strong>可预测</strong></li></ul><h4 id="调度要求"><a href="#调度要求" class="headerlink" title="调度要求"></a>调度要求</h4><ul><li><strong>抢占式</strong>调度</li><li>调度信息更多</li><li>中断快速响应</li><li>任务快速分派：采用线程调度</li></ul><h4 id="静态表调度"><a href="#静态表调度" class="headerlink" title="静态表调度"></a>静态表调度</h4><ul><li>固定的调度方案</li><li>无灵活性，任务完全固定。</li></ul><h4 id="单调速率调度-RMS"><a href="#单调速率调度-RMS" class="headerlink" title="单调速率调度(RMS)"></a>单调速率调度(RMS)</h4><ul><li><p>RMS时单处理器下<strong>最优静态调度</strong>算法</p></li><li><p>任务集可调度的<strong>充分条件</strong>是：$CPU利用率&lt;=ln2\approx0.693147$</p></li><li><p>任务周期<strong>越小</strong>优先级<strong>越高</strong>，优先级高的抢占式调度。</p><blockquote><p>优先级相等时会随机选择</p></blockquote></li></ul><h4 id="最早截止时间优先算法-EDF"><a href="#最早截止时间优先算法-EDF" class="headerlink" title="最早截止时间优先算法(EDF)"></a>最早截止时间优先算法(EDF)</h4><ul><li><p>截止时间<strong>越早</strong>，优先级<strong>越高</strong>。（<strong>动态</strong>优先级）</p><blockquote><p>优先级相等时会随机选择，有时候如果当前有没有执行完成的任务，则保持其运行可以减少一次切换。</p></blockquote></li><li><p>任务集可调度的<strong>充要条件</strong>是：$CPU利用率&lt;=1$</p></li></ul><h4 id="最低松弛度优先算法-LLF"><a href="#最低松弛度优先算法-LLF" class="headerlink" title="最低松弛度优先算法(LLF)"></a>最低松弛度优先算法(LLF)</h4><ul><li><p>任务紧急程度越高（<strong>松弛度越低</strong>），则其优先级<strong>越高</strong>。</p></li><li><p>$松弛度 = 进程截止时间 - 当前时间 - 剩余运行时间$</p></li><li><p>调度时机：进程完成/某个进程松弛度为0</p><blockquote><p>发生调度时计算被调出的进程的<strong>最晚重启时间</strong></p></blockquote></li><li><p>任务集可调度的<strong>充要条件</strong>是：$CPU利用率&lt;=1$</p></li></ul><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><ul><li>周转时间<ul><li><strong>长</strong>作业：先来先服务 <strong>优于</strong> 最高响应比优先 <strong>优于</strong> 时间片轮转</li><li><strong>短</strong>作业：时间片轮转 <strong>优于</strong> 最高响应比优先 <strong>优于</strong> 先来先服务</li></ul></li></ul><h3 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h3><ul><li>调度单位通常采用<strong>线程</strong></li></ul><h4 id="非对称式多处理系统"><a href="#非对称式多处理系统" class="headerlink" title="非对称式多处理系统"></a>非对称式多处理系统</h4><ul><li>每个处理机的分工、地位不同</li><li>一个主机负责分派任务给每个处理机</li><li>由潜在的不可靠性（主机）</li></ul><h4 id="对称式多处理系统"><a href="#对称式多处理系统" class="headerlink" title="对称式多处理系统"></a>对称式多处理系统</h4><ul><li>各个处理机的分工、地位相同</li><li>集中控制（专门的处理机负责分配）：静态/动态调度</li><li>分散控制：自调度</li></ul><h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><ul><li>每个CPU有自己的就绪队列，进程一直在同一个CPU上执行。</li><li>容易出现忙闲不均</li></ul><h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><ul><li>各个CPU共享一个就绪队列，进程可能<strong>跨CPU</strong>执行。</li><li>避免忙闲不均</li></ul><h5 id="自调度"><a href="#自调度" class="headerlink" title="自调度"></a>自调度</h5><ul><li>在动态分配的基础上，取消分配处理机，让各个CPU自由竞争。</li></ul><h5 id="成组调度"><a href="#成组调度" class="headerlink" title="成组调度"></a>成组调度</h5><ul><li>将<strong>一个进程</strong>的<strong>一组线程</strong>同时分派到<strong>不同</strong>的处理机上工作</li></ul><h5 id="专用处理机调度"><a href="#专用处理机调度" class="headerlink" title="专用处理机调度"></a>专用处理机调度</h5><ul><li>为进程每个线程都设置一个专用CPU，直到线程执行完成。</li></ul><h3 id="Linux处理机调度"><a href="#Linux处理机调度" class="headerlink" title="Linux处理机调度"></a>Linux处理机调度</h3><ul><li>2.4：O(n)</li><li>2.6.0：O(1)</li><li>2.6.23：CFS（<strong>完全公平调度器</strong>）<ul><li>使用红黑树维护就绪的进程（按照虚拟运行时间vt排序）</li><li>每次选择<strong>vt最小</strong>的进程执行（树最<strong>左侧</strong>）</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;3661&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~30&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter3-1-磁盘存储管理</title>
    <link href="http://yoursite.com/2020/07/04/Chapter3-1-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/04/Chapter3-1-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:10:40.161Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>1685</code>字，推荐阅读时间<code>10~15</code>分钟。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>扇区(sector)：磁道中的<strong>小扇形段</strong>（<strong>一个</strong>磁道上有<strong>多个</strong>扇区，<strong>不同</strong>磁道的扇区数可以<strong>不等</strong>）</p></li><li><p>磁道(tract)：同心<strong>环</strong></p></li><li><p>柱面(cylinder)：不同盘片<strong>相同半径</strong>的磁道组成的圆柱</p></li><li><p>磁盘分为软盘和硬盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">磁盘--&gt;硬盘</span><br><span class="line">磁盘--&gt;软盘</span><br><span class="line"></span><br><span class="line">硬盘--&gt;机械硬盘</span><br><span class="line">硬盘--&gt;闪存实现的固态硬盘</span><br><span class="line">硬盘--&gt;...</span><br></pre></td></tr></table></figure></li></ul><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p>读取一个扇区需要柱面，磁头，磁道三个参数，通常以<code>(x,y,z)</code>传入。</p><ul><li>x：定位柱面</li><li>y：定位磁道</li><li>z：定位扇区</li></ul><blockquote><p>对于IBM PC而言，最大参数一般是<code>(65536,16,63)</code>，因为一个扇区512字节，因此需要使用<code>16+4+6+9=35</code>位地址来进行访问，但是因为<code>z</code>是63，因此磁盘的最大容量是<code>31.5GB</code>.</p></blockquote><h4 id="扇区"><a href="#扇区" class="headerlink" title="扇区"></a>扇区</h4><ul><li><p>将磁盘所有扇区看作一个<strong>一维的</strong>逻辑块数组（突破IBM PC遗留的内存限制）</p></li><li><p><strong>数组排序</strong>：扇区-&gt;磁道-&gt;柱面<strong>（从外到内）</strong></p><p>先按照<strong>磁道内</strong>的<strong>扇区顺序</strong>排序，然后按照<strong>柱面内</strong>的<strong>磁道顺序</strong>排序，最后按<strong>从外到内</strong>的<strong>柱面顺序</strong>来排序。</p></li></ul><h2 id="I-O性能"><a href="#I-O性能" class="headerlink" title="I/O性能"></a>I/O性能</h2><h3 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h3><ul><li><p>寻道时间：<strong>启动</strong>时间<code>s</code>与磁头<strong>移动<code>n</code>条磁道</strong>花费的时间之和</p><p>$T_s = m*n+s\ (m = const)$</p><blockquote><p><code>m</code>是移动一条磁道花费的时间</p></blockquote></li><li><p>旋转延迟时间</p><p>$T_r=\frac{1}{2*r}(r=RPS\ r/s)$</p><blockquote><ul><li><code>r</code>是转速，并且单位是秒。</li><li>公式的意思：旋转<strong>一周</strong>需要的<strong>平均</strong>时间</li></ul></blockquote><ul><li>硬盘</li><li>软盘</li></ul></li><li><p>传输时间：和每次所读写的字节数<code>b</code>,旋转速度<code>r</code>以及磁道上<strong>单位长度</strong>的字节数<code>N</code>有关</p><p>$T_t=\frac{b}{r*N}$</p><blockquote><p><code>r*N</code>是单位时间内磁盘可以读写的字节数（<strong>传输速率</strong>），所以公式就是求如果需要读写<code>b</code>字节，那么需要多少个单位时间。</p></blockquote></li></ul><p>$ResponseTime=Queue+DiskServiceTime \tag{1}$</p><blockquote><p>磁盘延迟 = 设备驱动排队时间 + 磁盘服务时间</p></blockquote><p>$DiskServiceTime=SeekTime+RotateTime+TransferTime \tag{2}$</p><blockquote><p>磁盘服务时间 = 寻道时间 + 旋转延迟时间 + 传输时间</p></blockquote><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>注意，和电梯不同的是，磁头移动到目标位置即算作服务完成。</p><ul><li><p>FCFS</p></li><li><p>SSTF</p></li><li><p>SCAN：对两侧磁道不公平</p></li><li><p>CSCAN：走到一头后直接返回（返回过程中不处理请求）</p><blockquote><p>CSCAN消除了SCAN对两端磁道的不公平现象</p></blockquote></li><li><p>LOOK/CLOOK：分别是对SCAN/CSCAN<strong>调头条件</strong>的改进</p></li></ul><h3 id="主要途径"><a href="#主要途径" class="headerlink" title="主要途径"></a>主要途径</h3><ul><li>磁盘性能</li><li>并行化</li><li>调度算法</li><li>设置缓冲区<ul><li>独立缓存：大小<strong>固定</strong></li><li>使用内存作为磁盘的缓存：大小<strong>可变</strong></li><li>周期性写回</li></ul></li><li>优化物理块分布，例如将文件和其所需数据放在一起。</li><li>优化索引节点分布，将索引节点统一管理。</li></ul><blockquote><p>其他方法：</p><ul><li>提前读</li><li>延迟写</li><li>虚拟盘</li></ul></blockquote><h2 id="Flash-Disk-闪存盘"><a href="#Flash-Disk-闪存盘" class="headerlink" title="Flash Disk 闪存盘"></a>Flash Disk 闪存盘</h2><p>闪存是固态硬盘，属于硬盘的一种，因此也算是磁盘。</p><h3 id="NAND"><a href="#NAND" class="headerlink" title="NAND"></a>NAND</h3><ul><li>地址分为块号、块内页号、页内字节号，因此访存需要寻址三次，读写速度慢。</li></ul><h3 id="NOR"><a href="#NOR" class="headerlink" title="NOR"></a>NOR</h3><ul><li>使用大量地址线实现一次性直接<strong>字节</strong>寻址</li></ul><blockquote><p>速度高于NAND,成本也高于NAND.</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>擦除影响寿命</p><p>使用磨损均衡化技术解决(Wear Leveling)</p></li><li><p>功耗低</p></li><li><p>速度快</p></li></ul><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>RAID：廉价冗余磁盘阵列</p><ul><li>利用冗余信息恢复丢失数据</li></ul><h3 id="组织-1"><a href="#组织-1" class="headerlink" title="组织"></a>组织</h3><p>把多块独立的硬盘（<strong>物理</strong>硬盘）按照不同方式组合起来形成一个硬盘组（<strong>逻辑</strong>硬盘）</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>价格低</p></li><li><p>可以让多个硬盘<strong>并行传输</strong></p><p>将数据分段，例如将一个文件数据分为多个<strong>条带</strong>，然后放在<strong>多个硬盘</strong>上。</p></li><li><p>容错带来的更高的安全性</p></li></ul><h3 id="级别"><a href="#级别" class="headerlink" title="级别"></a>级别</h3><ul><li><p>RAID0：<strong>仅提供</strong>并行交叉存取，<strong>没有冗余</strong>校验功能。（<strong>不能提高</strong>可靠性）</p><ul><li>磁盘容量<strong>线形叠加</strong></li><li>对大量数据的请求<strong>效率最高</strong></li></ul></li><li><p>RAID1：镜像磁盘冗余阵列，在<strong>两个盘</strong>上存储一样的数据，有效容量下降一半。</p><ul><li>磁盘容量只有<strong>一半</strong>，成本高，但是可靠性好。</li><li>读性能好</li><li>写性能取决于两者中较低的那一块盘</li></ul></li><li><p>RAID0+1：先<strong>分块</strong>后<strong>镜像</strong></p><p><img src="https://i.loli.net/2020/05/29/vFmTgfOlLBrwxUp.png" style="zoom:67%;" /></p><ul><li>相当于是两组完全相同的RAID0</li><li>并行体现在组内</li></ul></li><li><p>RAID1+0：先<strong>镜像</strong>后<strong>分块</strong></p><p><img src="https://i.loli.net/2020/05/29/j31kOvPZKDVX9e8.png" style="zoom:67%;" /></p><ul><li>同组的两块盘是完全相同的</li><li>并行体现在组层次上</li></ul><blockquote><p>可靠性比0+1更高</p><ul><li>RAID0+1如果坏一块盘，不会引起数据丢失，但是该盘所在的<strong>条带</strong>会失效。</li><li>坏2块盘时引起磁盘故障的概率<ul><li>RAID0+1：n/(2n-2)</li><li>RAID1+0：1/(n-1)</li></ul></li></ul></blockquote></li><li><p>RAID2：<strong>按位条带化</strong>，将奇偶校验位插入数据中（海明码：多重<strong>奇偶校验</strong>）</p><p>利用$2^P&gt;=P+D+1$确定海明码的位数</p><ul><li>P是海明码位数</li><li>D是数据位数</li></ul><blockquote><p><strong>一个</strong>海明码只能够校验或者恢复<strong>一位</strong>的数据错误</p></blockquote></li><li><p>RAID3：RAID2的简化版本，一组数据只用一个校验盘，将校验码（奇偶校验）和数据分开存储。</p><blockquote><p>不能直接定位出错的盘，可以使用“出错离线”方式进行判断。</p></blockquote></li><li><p>RAID4：<strong>数据块交叉存储</strong>，和RAID0类似，将条带分开存储，同一行使用一块校验盘。</p></li><li><p>RAID5：在RAID4基础上，将校验块和和数据位进行<strong>混合</strong>存放，没有单独的奇偶校验驱动器。</p></li><li><p>RAID6：<code>单个数据:冗余 = 1:2</code>，例如<strong>A0对应0校验码和A校验码</strong>，可以容<strong>两块</strong>盘的错。</p><blockquote><p>整体比例<strong>不是</strong><code>1:2</code></p></blockquote></li></ul><h3 id="XOR恢复数据"><a href="#XOR恢复数据" class="headerlink" title="XOR恢复数据"></a>XOR恢复数据</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><p>结合律</p><p>$({a}\bigoplus{b})\bigoplus{c}={a}\bigoplus({b}\bigoplus{c})$</p></li><li><p>循环对称性</p><p>当${a}\bigoplus{b}\bigoplus{c}=d$时，</p><ul><li>$a={b}\bigoplus{c}\bigoplus{d}$</li><li>$b={a}\bigoplus{c}\bigoplus{d}$</li><li>$c={a}\bigoplus{b}\bigoplus{d}$ </li></ul></li></ul><blockquote><p>把a,b,c,d看作磁盘上的四个数据，其中三个是真正的数据，最后一个最为校验数据块，则可以进行数据恢复。</p></blockquote><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>条带化：一个字节块可能放在多个数据盘上</li><li>镜像：数据完全拷贝</li><li>校验：冗余代价介于前两者之间</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li><li>Wikipedia</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;1685&lt;/code&gt;字，推荐阅读时间&lt;code&gt;10~15&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter1-程序、进程和线程</title>
    <link href="http://yoursite.com/2020/07/04/Chapter1-%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/04/Chapter1-%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:10:22.106Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全文共<code>1327</code>字，推荐阅读时间<code>7~10</code>分钟。</strong></p><a id="more"></a><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><ul><li>编译：得到目标文件（二进制）</li><li>链接(linkage editor)：得到可执行（加载）文件</li><li>装入(loader)</li></ul><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><ul><li><p>本质是一个工具集\脚本集</p><ul><li><p>cc1:预处理器和编译器</p><blockquote><p>预处理将库、宏展开，编译器将<code>.c</code>变成<code>.s</code>,常存放在<code>\tmp</code>作为临时文件。</p></blockquote></li><li><p>as:汇编器</p><blockquote><p><code>.s</code>-&gt;<code>.o</code></p></blockquote></li><li><p>collect2:链接器</p></li></ul></li></ul><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>将<code>.o</code>文件符号化</p><h3 id="ELF-Executable-and-Linkable-Format"><a href="#ELF-Executable-and-Linkable-Format" class="headerlink" title="ELF(Executable and Linkable Format)"></a>ELF(Executable and Linkable Format)</h3><ul><li><code>.out</code>+<code>.o</code></li><li><code>.out</code>-&gt;程序头表</li><li><p><code>.o</code>-&gt;节头表</p></li><li><p><code>.bss</code>:<strong>不占</strong>文件空间的<strong>未</strong>初始化数据</p></li></ul><h4 id="文件头的定义"><a href="#文件头的定义" class="headerlink" title="文件头的定义"></a>文件头的定义</h4><ul><li>e_indent:头文件标志，前4字节是magic number.</li><li>e_type:标明文件类型，例如可执行文件、动态链接库、可重定位文件。</li><li>e_machine:体系结构，如x86、MIPS、PowerPC.</li><li>e_version:文件版本</li><li>e_entry:程序入口的<strong>虚拟</strong>地址</li><li>e_phoff:程序头表在ELF文件中的偏移</li><li>e_shoff:节头表在ELF文件中的偏移</li><li>e_eflags:处理器的标志</li></ul><h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>使用<code>readelf</code>/<code>objdump</code>反汇编实现</p><ul><li>在<code>.o</code>文件中是逻辑地址</li><li>在<code>.out</code>文件中是物理地址</li></ul><h3 id="Relocation-Entry"><a href="#Relocation-Entry" class="headerlink" title="Relocation Entry"></a>Relocation Entry</h3><ul><li><p>函数重定位地址的计算</p></li><li><p>全局变量重定位地址的计算</p></li></ul><h2 id="装载和运行"><a href="#装载和运行" class="headerlink" title="装载和运行"></a>装载和运行</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ul><li>shell调用<code>fork()</code></li><li>创建一个子进程</li><li>子进程调用<code>execve()</code>加载程序</li></ul><h3 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>一个segment在<strong>文件</strong>中的大小<strong>小于等于</strong>在<strong>内存</strong>中的大小</li><li>如果文件中大小<strong>小于</strong>在内存中的大小，则应该<strong>补零</strong>使其达到对应内存大小。</li></ul><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>读取ELF文件头的magic number: 0x7f/E/L/F</li><li>找到段表项</li><li>解析段表项需要加载到的虚地址</li></ul><h3 id="execve"><a href="#execve" class="headerlink" title="execve()"></a>execve()</h3><ul><li><code>sys_execve()</code>只是一个界面，实际在<code>do_execve()</code>中执行。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>根据文件名查找可执行文件结点</li><li>检查文件权限</li><li>设置程序参数结构</li><li>调用<code>prepare_binprm()</code>检查前128字节</li><li>调用<code>do_mmap()</code>把程序加载进内存</li><li><code>set_brk()</code>加载BSS段和初始化寄存器（包括指令寄存器）</li><li><code>start_thread()</code>进入就绪状态，等待OS调度后执行。</li></ul><blockquote><p>栈中原本存储着环境变量、命令行参数等，在下方才存访程序的函数帧。</p></blockquote><h2 id="Modern-OS-Extract"><a href="#Modern-OS-Extract" class="headerlink" title="Modern OS Extract"></a>Modern OS Extract</h2><ul><li><p>由于CPU在各个进程之间来回快速切换，因此每个进程执行的运算速度是不确定的。</p></li><li><p>通常大多数进程并不受CPU多道程序设计或者其他进程相对速度的影响</p></li><li><p>如果<strong>一个</strong>程序运行了两遍，则算作<strong>两个</strong>进程。</p></li><li><p>停留在后台处理诸如电子邮件、Web页面、新打印之类活动的进程称为<strong>守护进程(Daemon)</strong></p></li><li><p>在UNIX系统中，只有<code>fork</code>可以用来创建新进程。通常，子进程接着执行<code>execve</code>或者一个类似的系统调用，以修改其<strong>内存映像</strong>并运行一个新的程序。</p></li><li><p>在<strong>Windows</strong>中，从一开始父进程和子进程的地址空间就是<strong>不同</strong>的。</p></li><li><p>在有些系统中（<strong>不包括</strong>UNIX和Windows），当一个进程终止时，无论是自愿还是其他原因，由该进程创建的<strong>所有</strong>进程也一律被终止。</p></li><li><p>在Windows中，创建进程时父进程得到一个特别的令牌（<strong>句柄</strong>），该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他进程，因此<strong>不存在</strong>进程层次。</p></li><li><p>当正在运行的进程被调度时，不是加入<strong>阻塞</strong>队列，而是加入<strong>就绪</strong>队列。</p></li><li><p>所有的中断都从保存寄存器开始，通常是保存在进程表项中。随后，会从堆栈中删除由<strong>中断硬件机制</strong>存入堆栈的那部分信息，并将堆栈指针指向一个由<strong>进程处理程序</strong>所使用的<strong>临时堆栈</strong>。</p><blockquote><ul><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装入新的程序计数器</li><li><strong>汇编语言</strong>过程保存<strong>寄存器值</strong></li><li><strong>汇编语言</strong>过程设置<strong>新的堆栈</strong></li><li>C中断服务例程<strong>运行</strong></li><li>调度程序决定下一个运行的进程</li><li>C过程返回至汇编代码</li><li>汇编语言过程开始运行新的当前进程</li></ul></blockquote></li><li><p>每个线程有自己的程序计数器、寄存器、堆栈、状态。但是进程之间<strong>可以</strong>互相修改对方的堆栈。</p></li><li><p>如果在用户空间实现线程，则每个进程都要有其专用的<strong>线程表</strong>，用来跟踪该进程中的线程。</p></li><li><p>用户级线程的切换不需要陷入内核，也不需要上下文切换、对高速缓存进行刷新，相比于进程切换十分快捷。</p></li><li><p>用户级线程允许每个进程有<strong>自己定制</strong>的调度算法</p></li><li><p>在混合型实现方式中，每个内核线程有一个可以轮流使用的<strong>用户级线程集合</strong>。</p><blockquote><p><strong>多个</strong>用户级线程对应一个内核级线程</p></blockquote></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;全文共&lt;code&gt;1327&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter2-1-分页系统管理及设计</title>
    <link href="http://yoursite.com/2020/07/04/Chapter2-1-%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%8F%8A%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/07/04/Chapter2-1-%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%8F%8A%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:10:27.445Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>3463</code>字，推荐阅读时间<code>15~20</code>分钟。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>发生缺页中断时，OS必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。</li><li>置换算法存在于许多领域<ul><li>高速缓存的置换问题</li><li>Web服务器的网页置换问题</li></ul></li></ul><h2 id="最优置换算法-OPT"><a href="#最优置换算法-OPT" class="headerlink" title="最优置换算法(OPT)"></a>最优置换算法(OPT)</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>换出<strong>未来</strong>最长时间内<strong>不会</strong>被访问的页面</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对所有<strong>逻辑</strong>页面的<strong>下一次</strong>访问时间进行排序</li><li>换出最大时间对应的的<strong>物理</strong>页面</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>无法实现</li><li>意义是作为评价标准的<strong>上限</strong></li></ul><blockquote><p>可以首先在仿真程序上运行程序，跟踪所有页面的访问情况，然后正式执行时利用仿真信息其实可以实现最有置换算法。</p></blockquote><h2 id="最近未使用页面置换算法-NRU"><a href="#最近未使用页面置换算法-NRU" class="headerlink" title="最近未使用页面置换算法(NRU)"></a>最近未使用页面置换算法(NRU)</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在最近的一个时钟周期内，淘汰一个<strong>没有被访问</strong>的<strong>已修改</strong>页面要比淘汰一个被<strong>频繁使用</strong>的<strong>干净</strong>页面更好。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul><li>为每个页面设置R位和M位<ul><li>R表示页面是否被访问</li><li>M表示页面是否被修改</li></ul></li><li><strong>R位</strong>（不是M位）定期地被清零</li><li>所有页面可以被分为以下四类<ul><li>0：没有被访问，没有被修改。</li><li>1：没有被访问，已经被修改。</li><li>2：已经被访问，没有被修改。</li><li>3：已经被访问，已经被修改。</li></ul></li><li>淘汰时<strong>随机</strong>选择编号小的类进行修改</li></ul><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ul><li>易于理解并且可以被有效实现</li><li>性能并不是最好的</li></ul><h2 id="先进先出-First-In-First-Out-FIFO"><a href="#先进先出-First-In-First-Out-FIFO" class="headerlink" title="先进先出(First-In First-Out,FIFO)"></a>先进先出(First-In First-Out,FIFO)</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ul><li>选择进入内存时间<strong>最长</strong>的页面进行置换</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><ul><li>构造按时间<strong>降序</strong>排列的链表</li><li>调出<strong>头部</strong>页面，调入页面接在<strong>尾部</strong>。</li></ul><h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><ul><li>实现简单</li><li>性能低</li><li>Belady现象：因为头部页面也可能被访问，增加物理页框后缺页<strong>不一定</strong>减少。</li><li>很少<strong>单独</strong>使用</li></ul><h2 id="第二次机会页面置换算法"><a href="#第二次机会页面置换算法" class="headerlink" title="第二次机会页面置换算法"></a>第二次机会页面置换算法</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><ul><li>在FIFO基础上增加对链表头页面的访问位判断</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><ul><li>检查链表头页面的R位<ul><li>如果R位是0，则<strong>头部</strong>页面可以直接被淘汰。</li><li>如果R位是1，则将R位清零，然后把链表头页面插在<strong>尾部</strong>，从<strong>头</strong>开始继续搜索。</li></ul></li><li>淘汰页面后进行新页面的插入。</li></ul><h3 id="特征-3"><a href="#特征-3" class="headerlink" title="特征"></a>特征</h3><ul><li>发生缺页时，如果链表中所有页面的R位都是1，则二次机会算法退化为FIFO.</li></ul><h2 id="时钟置换算法-Clock"><a href="#时钟置换算法-Clock" class="headerlink" title="时钟置换算法(Clock)"></a>时钟置换算法(Clock)</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><ul><li>在二次机会算法的机会上使用<strong>环形</strong>链表简化<strong>线形</strong>链表的“<strong>掐头去尾</strong>”操作</li></ul><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><ul><li><p>环形链表的指针指向<strong>最老的页面</strong></p><blockquote><p>在页面链表中，最先被调入的页面就是最老的页面。</p></blockquote></li><li><p>发生缺页中断时，检查页面的R位</p><ul><li><p>如果R位为0，则被指向的页面可以直接被淘汰。</p></li><li><p>如果R位为1，则将R位清零，然后将表指针顺时针/逆时针转动。</p><blockquote><p>旋转方向和插入页面的方向<strong>相同</strong></p></blockquote></li></ul></li><li><p>当装入页面后，指针需要移动到新页面的<strong>下一个</strong>相邻的<strong>旧页面</strong>处。</p><blockquote><p>此时被指向的<strong>旧页面</strong>就是当前环形链表中<strong>最老</strong>的页面</p></blockquote></li></ul><h3 id="特征-4"><a href="#特征-4" class="headerlink" title="特征"></a>特征</h3><ul><li>相比于二次机会算法，减少了链表操作。</li></ul><h2 id="最近最少使用页面置换算法-LRU"><a href="#最近最少使用页面置换算法-LRU" class="headerlink" title="最近最少使用页面置换算法(LRU)"></a>最近最少使用页面置换算法(LRU)</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><ul><li>局部性原理</li><li>选择<strong>最长</strong>时间没有被访问的页面置换</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><ul><li>维护一个所有页面的链表，按照上次使用到现在的时间<strong>升序</strong>排序，则最近最多使用的页面在链表头，最近最少使用的页面在链表尾。</li></ul><blockquote><ul><li>这种方法在每次<strong>正常</strong>访存（没有缺页）时都要更新链表——访问一个页面就在链表中找到它，删除后移动到链表头。</li></ul></blockquote><ul><li>发生缺页中断则删除<strong>尾部</strong>页面，将新页面插在链表头。</li></ul><h4 id="计数器实现"><a href="#计数器实现" class="headerlink" title="计数器实现"></a>计数器实现</h4><ul><li>在每个页表项处维护一个”上次使用时间“寄存器</li><li>发生缺页中断时，选择寄存器值<strong>最小</strong>的页面进行置换。</li></ul><h3 id="特征-5"><a href="#特征-5" class="headerlink" title="特征"></a>特征</h3><ul><li>代价高</li><li>可能需要特殊硬件实现</li><li><strong>没有</strong>Belady现象</li></ul><h2 id="最不常用算法-LFU"><a href="#最不常用算法-LFU" class="headerlink" title="最不常用算法(LFU)"></a>最不常用算法(LFU)</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><ul><li>置换从<strong>上电</strong>开始访问次数最少的页面</li></ul><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><ul><li>发生<strong>时钟中断</strong>时，OS扫描所有的页面，将R位为1的页面的计数器加1.<strong>（同时把R位清零）</strong></li><li>发生<strong>缺页中断</strong>时，置换计数器值最小的页面。<strong>（但是不对其他页面计数器进行清零操作）</strong></li></ul><h3 id="特征-6"><a href="#特征-6" class="headerlink" title="特征"></a>特征</h3><ul><li>LRU的简化版本，开销依然较大。</li><li>”不忘记任何事情“，在整个系统的运行过程中<strong>所有的</strong>访问都会被记录在案，在中途不会被清除。</li></ul><h2 id="老化算法-Aging"><a href="#老化算法-Aging" class="headerlink" title="老化算法(Aging)"></a>老化算法(Aging)</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><ul><li>在LFU的基础上，增加移位操作，规避”钉子户“现象。</li></ul><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><ul><li>每次<strong>时钟中断</strong>时，OS扫描所有的页面，将R位为1的页面的计数器<strong>右移一位</strong>，然后将<strong>最高位</strong>置为1.</li><li><strong>缺页中断</strong>时，置换计数器值最小的页面。<strong>（但是不对其他页面计数器进行清零操作）</strong></li></ul><h3 id="特征-7"><a href="#特征-7" class="headerlink" title="特征"></a>特征</h3><ul><li>相比于LRU，老化算法记录了更长时间段内页面的访问情况，而不只是<strong>上一次</strong>。</li><li>计数器的位数是有限的，因此相比于LFU，老化算法能够记录的绝对访问次数是<strong>有限的</strong>。</li></ul><h2 id="工作集页面置换算法"><a href="#工作集页面置换算法" class="headerlink" title="工作集页面置换算法"></a>工作集页面置换算法</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><ul><li><p>当发生缺页中断时，淘汰一个不在工作集中的页面。</p></li><li><p>一个进程当前正在使用的页面的集合称为它的<strong>工作集</strong>。</p><ul><li>工作集是随着<strong>时间</strong>变化的</li><li>工作集就是<code>W(t,Δ)</code><ul><li>t：时刻</li><li>Δ：工作集窗口(working-set window)，一个<strong>定长</strong>的页面访问时间段（窗口）。</li><li><code>W(t,Δ)</code>是当前时刻t<strong>前</strong>Δ时间窗口内<strong>所有</strong>访问页面组成的集合</li><li><code>|W(t,Δ)|</code>是工作集中页面数目</li><li><code>W</code>是一个<strong>单调不减函数</strong></li></ul></li><li>当工作集基本稳定之后，当程序<strong>重新开始</strong>时，就有可能根据上次<strong>结束</strong>时的工作集进行一个推测，从而在本次程序开始运行前进行<strong>预调页</strong>操作。</li></ul></li><li>若每执行几条指令就发生一次缺页中断，则称这个程序发生了<strong>颠簸</strong>。</li></ul><h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><ul><li>设置一个时间窗口<code>t</code>，每个<strong>页框</strong>在原有基础上增加对<strong>上次使用时间</strong>的记录。</li><li>发生<strong>时钟中断</strong>时，需要清空页面的R位。</li><li>发生<strong>缺页中断</strong>时，扫面检查所有页面的R位。<ul><li>如果R位为1，则设置页面的<strong>上次使用时间</strong>为<strong>当前时间</strong>。</li><li>如果R位为0<ul><li>若页面生存时间<strong>大于</strong>时间窗口<code>t</code>，则淘汰该页面。</li><li>若页面生存时间<strong>小于等于</strong>时间窗口<code>t</code>，则将其加入淘汰页面候选列表。</li></ul></li></ul></li><li>在淘汰页面候选列表中选择<strong>上次使用时间最小</strong>的页面进行淘汰</li><li>无法选出时，则随机选择一个页面进行淘汰，不过最好是<strong>干净的</strong>（未被修改）页面。</li></ul><h3 id="特征-8"><a href="#特征-8" class="headerlink" title="特征"></a>特征</h3><ul><li>开销大</li><li>对局部性明显的程序效果好</li></ul><h2 id="工作集时钟页面置换算法-WSClock"><a href="#工作集时钟页面置换算法-WSClock" class="headerlink" title="工作集时钟页面置换算法(WSClock)"></a>工作集时钟页面置换算法(WSClock)</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><ul><li>在工作集算法的基础上，简化每个时钟周期遍历所有页面的操作。</li></ul><h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><ul><li><p>构建以<strong>页框</strong>为元素的循环链表</p></li><li><p>发生<strong>时钟中断</strong>时，需要清空页面的R位。</p></li><li><p>发生<strong>缺页中断</strong>时</p><ul><li><p>对R位的处理和时钟置换算法相同</p></li><li><p>当碰到R=0的页面时</p><ul><li><p>如果生存时间大于时间窗口</p><ul><li><p>如果页面是干净的，则淘汰该页面。</p></li><li><p>如果该页面被修改过，则发起磁盘回写（异步），指针继续旋转处理下一个页面。</p><blockquote><p>为了降低磁盘阻塞，需要设置一个限制，在一个循环中，<strong>最大</strong>只允许写回<code>n</code>个页面。</p></blockquote></li></ul></li><li><p>如果生存时间小于等于时间窗口，则更新上次使用时间。</p></li></ul></li></ul></li><li><p>在指针循环一整周后，可能是以下两种情况。</p><ul><li><p>至少发起过一次回写操作</p><p>说明发现了工作集<strong>外</strong>的脏页面，但是<strong>没有</strong>工作集外的干净页面。此时指针<strong>继续旋转</strong>，淘汰遇到的第一个干净页面（回写操作已经完成的工作集外页面）</p><blockquote><p>此时遇到的第一个干净页面<strong>不一定</strong>是第一个发起回写的页面，因为磁盘驱动程序可能将回写任务进行了<strong>重排序</strong>。</p></blockquote></li><li><p><strong>没有</strong>发起过回写操作</p><p>此时指针一圈都没有发现工作集外的页面，则随便置换一个干净的页面来使用。</p><blockquote><p>旋转时可以记录下干净页面的位置</p></blockquote><p>如果此时循环表中没有干净的页面，则<strong>相当于</strong>再进行一次<strong>所有页面都在工作集外的依次回写</strong>循环，再下一圈一定能够化归到<strong>至少发起过一次回写操作</strong>的情况中。</p></li></ul></li></ul><h3 id="特征-9"><a href="#特征-9" class="headerlink" title="特征"></a>特征</h3><ul><li>开销较大</li><li>实现简单</li><li>性能较好</li><li>应用广泛</li></ul><blockquote><p>最好的算法通常是老化算法和工作集时钟算法，在实际应用中通常是最重要的。</p></blockquote><h2 id="分页系统设计"><a href="#分页系统设计" class="headerlink" title="分页系统设计"></a>分页系统设计</h2><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><ul><li><p>局部：在进程内部进行页面置换</p></li><li><p>全局</p></li></ul><div class="table-container"><table><thead><tr><th>局部</th><th>全局</th></tr></thead><tbody><tr><td>每个进程有固定的内存片段</td><td>各个进程的页框数随时间变化</td></tr><tr><td>/</td><td>通常效果<strong>优于</strong>局部算法</td></tr><tr><td>基于工作集的算法<strong>只有</strong>在局部策略下才有意义</td><td>/</td></tr></tbody></table></div><h3 id="缺页中断率算法-PFF"><a href="#缺页中断率算法-PFF" class="headerlink" title="缺页中断率算法(PFF)"></a>缺页中断率算法(PFF)</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><ul><li>缺页中断率 = <strong>每秒</strong>的缺页中断数</li></ul><h4 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h4><ul><li>PFF将每个进程的缺页中断率控制在一个可以接受的范围内</li></ul><h3 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h3><p>调节<strong>并发</strong>进程数(MPL,multiprogramming level)，增大某个进程拥有的内存，从而降低该进程的缺页率。</p><ul><li>进程页面大小和 = 内存大小</li><li>平均缺页时间间隔(MTBF) = 缺页异常处理时间(PFST)</li></ul><h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><p>通常小页面更优</p><ul><li><p>小尺寸页面可以减小内碎片</p></li><li><p>传输一个大页面和一个小页面所花费的时间通常差别不大</p><blockquote><ul><li>装入64个512字节的页面可能需要64*10ms</li><li>装入4个8KB页面可能需要4*12ms</li></ul></blockquote></li><li><p><strong>但是</strong>，<strong>大</strong>页面能更充分地利用TLB空间。（占用的页表项更少）</p></li><li><p><strong>内核</strong>使用大页面，<strong>用户进程</strong>使用小页面。</p></li></ul><h3 id="指令和数据空间分离"><a href="#指令和数据空间分离" class="headerlink" title="指令和数据空间分离"></a>指令和数据空间分离</h3><p>将指令和数据地地址空间分离，每个地址空间<strong>都从0开始</strong>到某个最大值。</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ul><li>共享页面<ul><li>写时保护机制</li></ul></li><li>共享库</li></ul><h4 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h4><ul><li><p>任何在目标文件中被调用了但是没有被定义的函数，都被称作<strong>未定义外部函数</strong>(undefined externals)</p></li><li><p>当一个共享库被装载和使用时，整个库<strong>并不是一次性</strong>地读入内存。而是根据需要，以<strong>页面</strong>为单位进行装载的，因此没有被调用到的函数<strong>不会</strong>被装载进内存中。</p></li><li><p>当多个程序引用同一个库时，装载时的重定位就会<strong>失效</strong>。</p><blockquote><p>重定位是指在链接时根据函数的<strong>最终</strong>位置对指令进行修正的过程，这个<strong>最终</strong>位置通常是指<strong>程序绝对起始位置+函数相对位置</strong>。</p><p>由于不同的程序链接后产生的可执行文件不同，因此程序绝对起始地址会有不同，此时在指令中同一个函数的最终位置就会不同，因此调用就会发生错误。</p></blockquote></li><li><p>在编译时使用特殊选项告知编译器，仅仅使用与<strong>相对地址</strong>有关的指令，避免<strong>绝对地址</strong>的出现，就可以实现正确的库共享。（这种只使用<strong>相对偏移量</strong>的代码叫做<strong>位置无关代码</strong>）</p></li></ul><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><ul><li>比共享库更为<strong>通用</strong>的一种机制</li><li>进程可以发起一个系统调用，将一个文件映射为虚拟地址空间的<strong>一部分</strong>。</li><li>可以实现<strong>高速</strong>进程间通信</li></ul><h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><ul><li><p>发生缺页中断时，如果内存中有大量空闲页框，说明分页系统工作状态好。</p></li><li><p>增加<strong>分页守护进程</strong>，该进程大多数时候睡眠，但是定期唤醒检查内存状态。如果内存中空闲页框过少（<strong>不一定没有空闲页框</strong>），则该进程同过一定的分页置换算法将一部分页面换出，同时<strong>可能会</strong>发起磁盘写回请求。</p><blockquote><p>分页守护进程就可以保证真正发生缺页中断时，被替换的页框大都是干净的。</p></blockquote></li></ul><h3 id="虚拟内存接口"><a href="#虚拟内存接口" class="headerlink" title="虚拟内存接口"></a>虚拟内存接口</h3><ul><li>允许程序员控制虚拟内存的映射关系，增强某些进程的行为。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li><li>TSU OS Lecture, Spring Of 2019.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;3463&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter3-设备管理</title>
    <link href="http://yoursite.com/2020/07/04/Chapter3-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/04/Chapter3-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:11:24.952Z</updated>
    
    <content type="html"><![CDATA[<ul><li>全文共<code>4275</code>字，推荐阅读时间<code>15~20</code>分钟</li></ul><a id="more"></a><ul><li>若没有特殊说明，本文中I/O与IO等价。</li><li>有输入输出功能的设备都叫做I/O设备，没有特殊说明时，设备等价于I/O设备。</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>提高效率</li><li>方便使用：对不同类型的设备统一使用方法</li><li>方便控制：OS<strong>增加和删除</strong>设备</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>提供用户接口：<strong>命令</strong>接口和<strong>编程</strong>接口</li><li>设备分配和释放</li><li>设备的访问和控制：<strong>并发</strong>访问和<strong>差错处理</strong></li><li>I/O缓冲和调度：提高效率</li></ul><h3 id="总线-Bus"><a href="#总线-Bus" class="headerlink" title="总线(Bus)"></a>总线(Bus)</h3><p>接入I/O设备的<strong>主要</strong>方式</p><ul><li>PCI：卡类接口为主</li><li>PCIe</li><li>SCSI：快于PCI，接硬盘、打印机等智能设备。</li><li>expansion：扩展总线，不与上面三种标准并列。</li></ul><p>$总线带宽=频率*宽度(Bytes/sec)$</p><h2 id="管理概述"><a href="#管理概述" class="headerlink" title="管理概述"></a>管理概述</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>把<strong>硬件设备</strong>抽象为<strong>控制器</strong>，用<strong>应用程序和文件系统</strong>统一管理所有I/O.（IO设备可以直接从<strong>应用程序或者文件系统</strong>得到请求，并负责完成这个请求。）</p><ul><li>逻辑I/O：与设备<strong>无关</strong>的操作，例如设备分配和释放。</li><li>设备驱动程序：通过读写设备寄存器来<strong>真正控制</strong>设备</li><li>中断服务程序：<strong>设备</strong>工作结束<strong>后</strong>向<strong>CPU</strong>发<strong>中断</strong>信号</li></ul><h3 id="I-O分类"><a href="#I-O分类" class="headerlink" title="I/O分类"></a>I/O分类</h3><h4 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h4><ul><li><p>块设备：以数据<strong>块</strong>为单位进行读写，速率高，<strong>可寻址</strong>（随机读写）。（磁盘、光盘、USB）</p><p>块大小通常在512B到65536B<strong>(64KB)</strong>之间(2<sup>9</sup>~2<sup>16</sup>)</p></li><li><p>字符设备：字符为单位进行读写，速率低，<strong>不可寻址</strong>。（打印机网络接口、鼠标）</p></li></ul><blockquote><ul><li>这种分类方式并<strong>没有</strong>囊括所有的设备，例如时钟和内存映射的显示器。</li><li>文件系统只处理<strong>抽象</strong>的块设备，把与设备相关的部分留给更底层的软件实现。</li></ul></blockquote><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>存储设备</li><li>传输设备</li><li>人机交互设备</li></ul><h4 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h4><ul><li><p>独占分配：<strong>一段时间</strong>只能由<strong>一个进程</strong>使用，如打印机、磁带机等。</p></li><li><p>共享设备：硬盘</p></li><li><p>虚设备：用<strong>共享</strong>设备模拟<strong>独占</strong>设备，用<strong>高速</strong>设备模拟<strong>低速</strong>设备。（例如Spooling技术下的打印机是共享设备）</p><blockquote><p>因为可以<strong>共享</strong>，所以才能够利用假脱机技术来<strong>模拟</strong>独占。</p></blockquote></li></ul><h3 id="目标和任务"><a href="#目标和任务" class="headerlink" title="目标和任务"></a>目标和任务</h3><ul><li>完成I/O请求<ul><li>设备分配和回收</li><li>设备驱动程序：真正的操作</li><li>设备中断管理</li><li>缓冲区</li></ul></li><li>建立<strong>统一</strong>接口<ul><li>屏蔽物理硬件的细节</li></ul></li><li>提高CPU与设备、设备与设备之间的<strong>并行</strong>工作能力，提高资源利用率。</li><li>保护数据安全</li></ul><h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><ul><li><p>功能</p><ul><li>接收、识别CPU命令</li><li>数据交换</li><li>报告设备状态</li><li><strong>地址处理</strong></li><li><strong>作为缓冲区</strong></li><li>差错检查</li></ul></li><li><p>组成</p><ul><li><p>控制器和<strong>CPU</strong>接口（向<strong>上</strong>）：寄存器</p><ul><li><p>控制寄存器</p></li><li><p>状态寄存器</p></li><li><p>数据寄存器</p></li></ul></li><li><p>控制器与<strong>设备</strong>接口（向<strong>下</strong>）：信号</p><ul><li>控制信号</li><li>状态信号</li><li>数据信号</li></ul></li><li><p>I/O逻辑：解释I/O控制指令（处理来自上下接口的信息，然后<strong>继续传递</strong>）</p></li></ul></li></ul><h3 id="I-O端口地址"><a href="#I-O端口地址" class="headerlink" title="I/O端口地址"></a>I/O端口地址</h3><h4 id="内存映像编址"><a href="#内存映像编址" class="headerlink" title="内存映像编址"></a>内存映像编址</h4><p>将<strong>设备控制器</strong>的<strong>内存/寄存器地址空间</strong>映射为内存地址的一部分</p><ul><li>通常映射到地址空间的顶端</li></ul><blockquote><p><strong>不能够</strong>对控制寄存器的信息进行缓存（一旦缓存则<strong>不会</strong>再去检测外设来确定信号）</p></blockquote><h4 id="独立编址"><a href="#独立编址" class="headerlink" title="独立编址"></a>独立编址</h4><p>I/O设备和内存地址空间分离，有IO专用的指令。</p><ul><li>接口电路中每个<strong>寄存器</strong>具有的<strong>唯一</strong>地址</li><li>所有的I/O<strong>端口地址</strong>形成IO端口空间（OS才能操作）</li><li>外设不占用内存的地址空间</li><li>实现I/O保护</li><li>控制指令少，不够灵活。</li></ul><blockquote><p>intel体系架构in/out指令</p></blockquote><h2 id="I-O控制技术"><a href="#I-O控制技术" class="headerlink" title="I/O控制技术"></a>I/O控制技术</h2><ul><li><p>程序控制(PIO)</p><ul><li>轮询</li></ul></li><li><p>中断驱动(Interrupt-drive I/O)</p><ul><li>设备向驱动发出请求</li></ul></li><li><p>直接存储访问(DMA, Direct Memory Access)</p><ul><li>由专门的控制器完成<strong>数据从设备到内存</strong>、<strong>内存到设备</strong>的传输工作。</li></ul></li><li><p>通道技术(<strong>Channel</strong>)</p><ul><li>通道是一个<strong>特殊</strong>处理器，替代了CPU的<strong>传输控制</strong>功能，CPU只有<strong>数据处理</strong>功能。</li></ul><blockquote><p>注意不是<strong>管道</strong></p></blockquote></li></ul><h3 id="程序控制"><a href="#程序控制" class="headerlink" title="程序控制"></a>程序控制</h3><p>设备<strong>驱动程序反复</strong>查看<strong>设备控制器</strong>的<strong>状态寄存器</strong>，当把数据都拷贝进入内存后再由<strong>设备驱动程序</strong>通知应用程序。</p><blockquote><ul><li>查询时，CPU没有工作。<strong>（驱动程序也是运行在CPU上的）</strong></li><li>多核、高速网络设备使用轮询可以提高效率（避免中断阻塞）</li></ul></blockquote><h3 id="中断驱动"><a href="#中断驱动" class="headerlink" title="中断驱动"></a>中断驱动</h3><p>驱动程序负责将设备状态记录在表中，然后CPU可以去做其他事情，直到<strong>CPU</strong>收到来自外设<strong>状态寄存器</strong>中断信号，并切换进入<strong>中断处理程序</strong>。</p><ul><li>收到中断信号<strong>不代表</strong>数据已经读入内存，而是说明数据已经<strong>就绪可读</strong>（数据会被放在<strong>缓冲寄存器</strong>）。</li><li><strong>中断处理程序</strong>通知<strong>设备管理程序</strong>（不是设备<strong>驱动</strong>程序），在<strong>查表后</strong>再把<strong>数据读入内存</strong>，再然后由CPU读取。</li></ul><h3 id="直接存储访问"><a href="#直接存储访问" class="headerlink" title="直接存储访问"></a>直接存储访问</h3><ul><li>由<strong>程序</strong>设置DMA控制器中的寄存器（实际上是设置读写参数，如内存始址，传送字节数），然后进行统一的I/O操作。</li><li>DMA将<strong>外设数据</strong>拷进<strong>内存</strong>（循环操作，不是一次完成。</li><li>操作完成后由<strong>DMA控制器</strong>向<strong>CPU</strong>发出中断</li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li>命令/状态寄存器(CR)：接受CPU发送的I/O指令、设备传来的状态等。</li><li>内存地址寄存器(MAR)：数据读写的<strong>内存地址</strong></li><li>数据寄存器(DR)：暂存发生交换的数据</li><li>数据计数器(DC)：存放需要传送的字节数，每拷贝一次减拷贝的字节数，到<code>0</code>后触发中断。</li></ul><blockquote><p>DMA&amp;中断驱动辨析</p><ul><li>DMA在传输<strong>一批数据</strong>后触发中断，中断控制则在<strong>每个数据</strong>传输后触发中断。</li><li>DMA的数据传送控制（传什么、传多少）是由DMA控制器完成的，CPU只负责在最开始向这个控制器发送一些指令即可。但是中断的数据传送过程（<strong>设备管理程序</strong>）则<strong>全都由</strong>CPU指导完成。</li></ul></blockquote><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><ul><li>增加<strong>独立控制器</strong>的功能，有自己的指令体系，进一步减少CPU的干预。</li><li>通道程序通常由操作系统构造，并放在内存中。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p><strong>字节多路</strong>通道：多个设备<strong>交替</strong>以字节为单位传输，适用于打印机、终端等低速、中速设备。</p></li><li><p><strong>选择</strong>通道：对外设分组，每次多组通过<strong>多个通道</strong>并行传输。</p><blockquote><p>但是<strong>一个通道</strong>在一段时间内只能为<strong>一个设备</strong>服务</p></blockquote></li><li><p><strong>数组多路</strong>通道：不同组别可以同时使用<strong>非本组</strong>的<strong>空闲</strong>通道</p></li></ul><blockquote><p>通道&amp;DMA辨析</p><ul><li>通道的处理能力更强</li><li>通道可以同时控制<strong>多种</strong>设备，DMA通常只能控制少量的<strong>同类</strong>设备。</li><li>通道的费用较高</li></ul></blockquote><h2 id="I-O软件组成"><a href="#I-O软件组成" class="headerlink" title="I/O软件组成"></a>I/O软件组成</h2><p>分层设计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">用户进程--&gt;与设备无关的软件</span><br><span class="line">与设备无关的软件--&gt;设备驱动程序</span><br><span class="line">设备驱动程序--&gt;硬件</span><br><span class="line"></span><br><span class="line">硬件--&gt;中断处理程序</span><br><span class="line">中断处理程序--&gt;设备驱动程序</span><br><span class="line">设备驱动程序--&gt;与设备无关的软件</span><br><span class="line">与设备无关的软件--&gt;用户进程</span><br></pre></td></tr></table></figure><blockquote><p>中断处理程序其实应该在硬件和设备驱动程序之间</p></blockquote><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><ul><li>逻辑设备</li><li>物理设备</li></ul><p>系统将逻辑设备名称转换为物理设备名称</p><blockquote><ul><li>设备分配灵活<ul><li><strong>同类设备</strong>可以相互替代</li></ul></li><li>实现I/O重定向</li><li>实现了应用程序和物理设备之间的独立</li></ul></blockquote><h4 id="LUT（逻辑设备表）"><a href="#LUT（逻辑设备表）" class="headerlink" title="LUT（逻辑设备表）"></a>LUT（逻辑设备表）</h4><p>将逻辑设备名映射为物理设备名和驱动程序入口地址</p><ul><li>整个系统一张表：所有设备只能有<strong>一个逻辑设备名</strong></li><li>一个用户一张表</li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>接受上层软件的抽象请求，并执行这个请求。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li><p>自动配置和初始化子程序</p></li><li><p>I/O操作子程序</p><blockquote><p>系统I/O请求调用该子程序，并从用户态切换到内核态。</p></blockquote></li><li><p>中断服务子程序</p></li></ul><h4 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h4><ul><li>设备驱动是<strong>内核</strong>的一部分</li><li>设备驱动为内核提供一个标准接口</li><li>动态可加载</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p>初始化函数</p><ul><li>向操作系统登记该驱动程序的接口函数，在系统启动时安装进入内核执行。</li></ul></li><li><p>卸载驱动、申请释放设备</p></li><li><p>I/O操作</p></li><li><p>中断处理</p><blockquote><ul><li>中断处理才会使用到设备驱动的<strong>下层</strong>部分来接受<strong>外设</strong>触发的<strong>中断</strong>（I/O请求传递给设备时<strong>不会</strong>）</li><li>上层是用来处理和管理I/O请求的程序</li><li>当把中断处理程序归为设备驱动程序时，中断处理在下层，上层主要是和OS的交互部分。</li></ul></blockquote></li></ul><h4 id="驱动程序-amp-应用程序"><a href="#驱动程序-amp-应用程序" class="headerlink" title="驱动程序&amp;应用程序"></a>驱动程序&amp;应用程序</h4><ul><li>应用程序以<code>main</code>开始</li><li>驱动程序没有<code>main</code>，但以一个<strong>模块初始化函数</strong>作为入口。</li><li>应用程序从头到尾执行<strong>一个</strong>任务</li><li>驱动程序不会自主运行，而是在初始化后等待系统调用。</li><li>应用程序可以使用标准C库，但是驱动程序不行。</li></ul><h2 id="I-O缓冲管理"><a href="#I-O缓冲管理" class="headerlink" title="I/O缓冲管理"></a>I/O缓冲管理</h2><h3 id="单缓冲-single-buffer"><a href="#单缓冲-single-buffer" class="headerlink" title="单缓冲(single buffer)"></a>单缓冲(single buffer)</h3><ul><li>输出时间(T)：I/O-&gt;缓冲区</li><li>传送时间(M)：缓冲区-&gt;工作区</li><li>处理时间(C)</li><li><strong>一块数据平均</strong>处理时间：$max(T,C)+M$</li><li>总运行时间 = 块数 <em> 平均处理时间 <em>*+ C</em></em>（最后一块数据的处理没有和任何的IO设备输出并行）</li></ul><blockquote><p><strong>输出</strong>和<strong>处理</strong>可以并行</p></blockquote><h3 id="双缓冲-double-buffer"><a href="#双缓冲-double-buffer" class="headerlink" title="双缓冲(double buffer)"></a>双缓冲(double buffer)</h3><ul><li>增加缓冲区使<strong>IO输出</strong>和<strong>缓冲区传送</strong>并行</li><li>适用于CPU和外设速度相近的情况(${M+C}\approx{T}$)</li><li><strong>一块数据平均</strong>处理时间：$max(T,C)$</li></ul><h3 id="环形缓冲-circular-buffer"><a href="#环形缓冲-circular-buffer" class="headerlink" title="环形缓冲(circular buffer)"></a>环形缓冲(circular buffer)</h3><p>适用于CPU和外设速度相差较大的情况（专用缓冲）</p><p>将多个缓冲区组织成循环（圆圈），输入进程不断输入<strong>空缓冲区</strong>，计算进程不断从<strong>就绪缓冲区</strong>中提取数据。</p><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>缓冲区<ul><li>空缓冲区(R)</li><li>装满数据的缓冲区(G)</li><li>正在使用的工作缓冲区(C)</li></ul></li><li>指针<ul><li>Nextg：下一个<strong>可计算</strong>缓冲区</li><li>Nexti：下一个<strong>可输入</strong>缓冲区</li><li>Current：当前计算缓冲区</li></ul></li></ul><blockquote><p>当输入过快时可能套圈然后冲掉<code>Current</code>的内容</p></blockquote><h3 id="缓冲池-buffer-pool"><a href="#缓冲池-buffer-pool" class="headerlink" title="缓冲池(buffer pool)"></a>缓冲池(buffer pool)</h3><p>将相同类型的缓冲区链成一个队列</p><ul><li>空缓冲队列(emq)</li><li>输入队列(inq)</li><li>输出队列(outq)</li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li><p>收容输入(hin)：<strong>输入</strong>进程需要输入数据<strong>（空-&gt;输入）</strong></p><p>从空缓冲区队列中取队首，使用完后加入<strong>输入队列</strong>。</p></li><li><p>提取输入(sin)：<strong>计算</strong>进程需要输入数据<strong>（输入-&gt;空）</strong></p><p>同上取空缓冲区，使用完后调用<code>Putbuf(emq,sin)</code>将缓冲区<strong>重新加回空缓冲</strong>队列。</p></li><li><p>收容输出(hout)：<strong>计算</strong>进程需要输出数据<strong>（空-&gt;输出）</strong></p><p>取空缓冲区，然后装入输出数据，装满后放在<strong>输出队列</strong>末尾。</p></li><li><p>提取输出(sout)：<strong>输出</strong>进程需要输出数据<strong>（输出-&gt;空）</strong></p><p>在输出对首取缓冲区，提取完数据后，将缓冲区加回<strong>空缓冲队列</strong>末尾。</p></li></ul><blockquote><p>收容就是<strong>取空缓冲区</strong>，然后放进相应的队列；提取则是用完后一定<strong>放回空缓冲区</strong>。</p></blockquote><h3 id="缓冲的问题"><a href="#缓冲的问题" class="headerlink" title="缓冲的问题"></a>缓冲的问题</h3><p>多次复制一个数据包：<strong>各级缓存（缓冲区）</strong>都有相同的数据</p><h2 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I/O设备管理"></a>I/O设备管理</h2><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><ul><li>在进程间切换使用（如鼠标和键盘）</li><li>使用虚拟设备把外设和应用隔开，只由虚拟设备来使用设备。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p>设备控制表(DCT)</p><p>每个设备一张</p></li><li><p>控制器控制表(COCT)</p><p>每个控制器一张</p></li><li><p>通道控制表(CHCT)</p><p>每个通道一张</p></li><li><p>系统设备表(SDT)</p><p>一个系统一张</p></li></ul><h4 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h4><ul><li>设备固有属性</li><li>分配算法</li><li>安全性：死锁问题<ul><li><strong>安全</strong>分配：同步I/O，破坏了死锁的保持和请求条件。</li><li><strong>不安全</strong>分配：异步I/O</li></ul></li></ul><h3 id="Spooling技术"><a href="#Spooling技术" class="headerlink" title="Spooling技术"></a>Spooling技术</h3><ul><li>假脱机技术：专门利用一道程序来管理I/O</li></ul><h4 id="实际I-O"><a href="#实际I-O" class="headerlink" title="实际I/O"></a>实际I/O</h4><ul><li>来自外设</li><li>来自应用</li></ul><h4 id="虚拟I-O"><a href="#虚拟I-O" class="headerlink" title="虚拟I/O"></a>虚拟I/O</h4><ul><li>统一管理I/O</li></ul><h4 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h4><ul><li><p>输入井和输出井：<strong>磁盘上</strong>的大存储空间</p><ul><li>输入井：暂存IO设备输入的数据</li><li>输出井：暂存用户程序输出的数据</li></ul></li><li><p>输入缓冲区和输出缓冲区：<strong>内存</strong>中的缓冲区</p><ul><li>输入设备-&gt;输入缓冲区-&gt;输入井</li><li>输出井-&gt;输出缓冲区-&gt;输出设备</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">输入设备--&gt;输入缓冲区</span><br><span class="line">输入缓冲区--&gt;输入井</span><br><span class="line"></span><br><span class="line">输出井--&gt;输出缓冲区</span><br><span class="line">输出缓冲区--&gt;输出设备</span><br></pre></td></tr></table></figure></li><li><p>输入进程SPi和输出进程SPo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">输入进程--&gt;输入井</span><br><span class="line">输入井--&gt;内存</span><br><span class="line"></span><br><span class="line">输出进程--&gt;内存</span><br><span class="line">内存--&gt;输出井</span><br><span class="line">输出井--&gt;内存</span><br><span class="line">内存--&gt;输出设备</span><br></pre></td></tr></table></figure></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>虚拟I/O速度快</li><li>实现设备共享</li></ul><h2 id="I-O性能问题"><a href="#I-O性能问题" class="headerlink" title="I/O性能问题"></a>I/O性能问题</h2><h3 id="I-O操作阶段"><a href="#I-O操作阶段" class="headerlink" title="I/O操作阶段"></a>I/O操作阶段</h3><ul><li><p><strong>磁盘</strong>把数据装载进<strong>内核</strong>的内存空间</p></li><li><p>把<strong>内核</strong>的内存空间的数据复制到<strong>用户</strong>的内存空间中</p><blockquote><p>用户的IO访问其实是一个系统调用，最后由<strong>内核</strong>通知返回结果并<strong>唤醒</strong>进程。</p></blockquote></li></ul><h3 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h3><p>调用结果返回之前，当前进程会被挂起。</p><h3 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h3><p>进程发起I/O调用，内核通知进程进行别的操作。（其实<strong>别的操作</strong>就是指轮询）</p><blockquote><ul><li>进程需要不停的发出检查请求</li><li>依然是<strong>同步</strong>的</li></ul></blockquote><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>在被一个I/O阻塞时依然可以接受其他I/O的阻塞，所以可以提高效率。</p><blockquote><p>同时阻塞在多个I/O上可以改善第一阶段的效率，但是第二阶段需要进程逐一参与，因此第二阶段的效率没有改变。</p></blockquote><h3 id="事件（信号）驱动I-O"><a href="#事件（信号）驱动I-O" class="headerlink" title="事件（信号）驱动I/O"></a>事件（信号）驱动I/O</h3><p>内核记录（回调函数）发起I/O的进程，在第一阶段完成后才通知进程，则进程在第一阶段就不需要忙等了。（第二阶段依然阻塞）</p><blockquote><p>第二阶段需要进程<strong>再次</strong>发起一个系统调用</p></blockquote><h3 id="异步I-O（效率最高）"><a href="#异步I-O（效率最高）" class="headerlink" title="异步I/O（效率最高）"></a>异步I/O（效率最高）</h3><p>内核通知进程数据已经完成拷贝（两个阶段都完成）之前，进程可以做自己的事情。</p><h3 id="五种模型比较"><a href="#五种模型比较" class="headerlink" title="五种模型比较"></a>五种模型比较</h3><ul><li>同步I/O：第二段阻塞，则是同步I/O.</li><li>I/O复用和事件驱动I/O会在第一阶段结束后<strong>再次发起</strong>调用。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li><p>同步/异步与阻塞/非阻塞</p><ul><li><p>同步/异步是针对<strong>I/O</strong>来说的，能够自己通知调用者（触发中断）的I/O是异步的，需要调用者反复确认的I/O是同步的。</p><blockquote><p>因此异步I/O可以在<strong>两个</strong>阶段执行的过程期间做其他的事，但是同步I/O<strong>最多</strong>只能在<strong>第一阶段</strong>自由发挥。（多路复用/信号驱动）</p></blockquote></li><li><p>阻塞/非阻塞是针对<strong>进程</strong>来说的，能够在由没完成的任务时做其他事的是非阻塞的，需要一直等着某个任务完成再做下一个的是阻塞的。</p></li></ul></li><li><p>I/O的五种实现方式和之前提到的<strong>设备中断处理程序</strong>之间有关系吗</p><p>除了名字相同之外<strong>没有关系</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">process--&gt;kernel</span><br><span class="line">kernel--&gt;peripheral</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>I/O的五种实现方式是在阐述两个阶段，对于同步和异步I/O，都是由<strong>内核</strong>作为中间层进行协调的。也就是说，内核怎么通知进程，涉及到的中断和外设的中断处理程序<strong>（设备通知内核）</strong>之间没有关系。</p><p>综上，外设的中断处理程序只在第一阶段起到作用，和I/O的五种实现方式中的<strong>通知</strong>机制关系不大。</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;全文共&lt;code&gt;4275&lt;/code&gt;字，推荐阅读时间&lt;code&gt;15~20&lt;/code&gt;分钟&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter4-1-inode解析</title>
    <link href="http://yoursite.com/2020/07/04/Chapter4-1-inode%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/07/04/Chapter4-1-inode%E8%A7%A3%E6%9E%90/</id>
    <published>2020-07-04T08:05:30.916Z</published>
    <updated>2020-07-04T08:11:38.623Z</updated>
    
    <content type="html"><![CDATA[<p>全文共<code>964</code>字，推荐阅读时间<code>7~10</code>分钟</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>文件存储<strong>以块为单位</strong>存储在硬盘上</li><li>文件的元信息（<strong>不是</strong>文件内容）存储在inode中</li><li>inode中文译名：索引节点</li><li><strong>每个</strong>文件都对应了<strong>一个</strong>inode</li></ul><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li>文件大小</li><li>拥有者ID</li><li>Group ID</li><li>读、写、执行权限</li><li>文件的时间戳<ul><li><code>ctime</code>:inode上一次变动的时间</li><li><code>mtime</code>:文件内容上一次变动的时间</li><li><code>atime</code>:文件上一次打开的时间</li></ul></li><li>连接数：有多少个文件名指向这个inode</li><li>文件数据的块地址</li></ul><blockquote><ul><li><code>stat</code>命令可以查看<code>inode</code>信息</li><li><strong>除了文件名</strong>以外的信息，都存储在inode之中。</li></ul></blockquote><h2 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h2><ul><li>硬盘格式化时，OS会将硬盘分成两个区域，一个是数据区，一个是<code>inode</code>区。</li><li><code>inode</code>大小一般是128或256字节，并且<strong>总数</strong>在格式化时就确定，一般是每$1KB$或每$2KB$就设置一个<code>inode</code>.</li></ul><blockquote><ul><li><code>df -i</code>：查看<code>inode</code>总数和已经使用的数量</li><li><code>sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot;</code>：查看每个<code>inode</code>结点的大小</li><li>发生<code>inode</code>用光但是硬盘未存满的情况时，<strong>无法</strong>在硬盘上继续创建新文件。</li></ul></blockquote><h2 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h2><p>系统内部不通过文件名进行文件相关操作，而是均通过<code>inode</code>号码来完成文件操作。</p><blockquote><p><code>ls -i example.txt</code>：查看文件的<code>inode</code>号码</p></blockquote><h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>目录也是一种文件，所以称为目录文件。</p><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>目录文件就是<strong>目录项的列表</strong></p><ul><li><p>目录项 = 文件名 + <code>inode</code>号码</p><blockquote><p>目录文件下的<code>inode</code>号码<strong>不止一个</strong></p></blockquote></li></ul><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul><li>一般情况下，文件名和<code>inode</code>号码一一对应。</li><li>特殊情况下，可能存在<strong>多个文件名</strong>指向<strong>同一个</strong><code>inode</code>号码的情况。</li></ul><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>可以使用不同的文件名访问同样的内容、对文件内容进行修改。（会影响到所有的文件名）</li><li>删除一个文件名，<strong>不影响</strong>其他文件名的访问。</li><li>目录项中的<code>inode</code>号就是文件数据的<code>inode</code>号</li></ul><blockquote><p><code>ln src det</code>：可以创建<strong>硬链接</strong></p></blockquote><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>对<strong>目录</strong>而言，创建目录时，默认会生成两个目录项<code>.</code>和<code>..</code>,其中<code>.</code>指向当前目录，<code>..</code>指向父目录。</p><blockquote><p>目录文件的<strong>硬链接</strong>总数 = 1 + 1 + 子目录总数（含隐藏目录）</p><ul><li>1：该文件本身的名字对应的目录项</li><li>1：<code>.</code></li></ul></blockquote><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>文件A和文件B是不同的文件（<code>inode</code>号码不同），但是文件A的内容是文件B的<strong>路径</strong>（文件名）。因此读取文件A时，系统会自动将访问者导向B.因此，<strong>无论打开哪一个文件</strong>，最终读取的都是文件B.此时，<strong>文件A就称为文件B的软链接</strong>（又称<strong>符号</strong>链接）。</li><li>目录项中的<code>inode</code>号是软链接文件A的<code>inode</code>号，A的数据块中存放有B的路径。</li></ul><blockquote><ul><li>文件A依赖于文件B,如果B被删除或者路径发生变化，那么打开A就会报错。</li><li>文件A指向文件B的<strong>文件名</strong>，而不是<code>inode</code>号码，因此B的<code>inode</code>链接数不会发生变化。</li><li><code>ln -s src dst</code>：创建软链接</li></ul></blockquote><h2 id="特殊作用"><a href="#特殊作用" class="headerlink" title="特殊作用"></a>特殊作用</h2><ul><li>删除<code>inode</code>来删除名字<strong>包含特殊字符</strong>的文件</li><li>移动文件或重命名文件时，<strong>只改变</strong>文件名，<strong>不改变</strong><code>inode</code>号码。</li><li>系统通常无法从<code>inode</code>号码获取文件名</li><li>打开文件后，系统对该文件的操作和文件名就无关了，均以<code>inode</code>号码指代。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2011/12/inode.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文共&lt;code&gt;964&lt;/code&gt;字，推荐阅读时间&lt;code&gt;7~10&lt;/code&gt;分钟&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Operating System" scheme="http://yoursite.com/categories/Operating-System/"/>
    
    
  </entry>
  
</feed>

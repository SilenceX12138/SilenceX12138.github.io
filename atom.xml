<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-23T12:45:34.737Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Silence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu18.04 no wifi adapter found 解决方案</title>
    <link href="http://yoursite.com/2021/06/23/Ubuntu18.04%20no%20wifi%20adapter%20found%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2021/06/23/Ubuntu18.04%20no%20wifi%20adapter%20found%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-06-23T12:45:04.907Z</published>
    <updated>2021-06-23T12:45:34.737Z</updated>
    
    <content type="html"><![CDATA[<p><strong>重要的事说在前面</strong></p><p><strong>很重要！很重要！很重要！</strong></p><p><strong>以下教程仅适用于<u>intel</u>系列无线网卡,至于其他例如broadcom等，只能提供一个参考思路。</strong></p><a id="more"></a><hr><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>terminal中输入<code>lspci</code>,得到类似如下结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ lspci</span><br><span class="line">00:14.3<span class="built_in"> Network </span>controller: Intel Corporation Device 02f0</span><br><span class="line">00:15.0 Serial bus controller [0c80]: Intel Corporation Device 02e8</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>其中Network controller本不应该对应笔记本的无线网卡，但是ubuntu系统和intel系列网卡兼容性一言难尽，导致系统误把网卡作为了controller。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li><p><strong>升级系统内核(optional)</strong></p><p>具体可以参见这篇<a href="https://www.jianshu.com/p/0c2e7a530cfe" target="_blank" rel="noopener">博客</a>，写的很好。</p><p>虽然这一步是选择性的，但还是建议内核版本5.3以下的朋友升级到最新版本，<del>少点bug不吃亏</del>。</p><p><strong>还有，intel官网上写的驱动的kernel版本要求似乎有点问题，笔者5.0.0内核版本亲测：必须要升级到5.3+后才能识别<u>“写着4.14+以上均适用”</u>网卡驱动。</strong></p><p>总而言之，建议大家尽量还是选择升级内核版本。</p></li><li><p><strong>安装网卡驱动</strong></p><ul><li><p>首先是确认网卡型号</p><p>建议在windows下按照这篇<a href="https://blog.csdn.net/myuhua/article/details/99446855" target="_blank" rel="noopener">博客</a>进行操作</p></li><li><p>登陆intel<a href="https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi" target="_blank" rel="noopener">驱动官网</a>:<a href="https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi!" target="_blank" rel="noopener">https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi!</a></p></li><li><p>查找到对应的型号后下载.tgz文件</p></li><li><p>解压文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span>  <span class="selector-tag">-zxvf</span>  下载的驱动的名字<span class="selector-class">.tgz</span></span><br></pre></td></tr></table></figure></li><li><p>安装驱动</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp iwlwifi-*.ucode /<span class="class"><span class="keyword">lib</span>/<span class="title">firmware</span></span></span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo reboot</span></span><br></pre></td></tr></table></figure></li><li><p>和wifi愉快拥抱吧～</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;重要的事说在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很重要！很重要！很重要！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下教程仅适用于&lt;u&gt;intel&lt;/u&gt;系列无线网卡,至于其他例如broadcom等，只能提供一个参考思路。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/MySQL%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/MySQL%20Learning%20Note/</id>
    <published>2021-06-23T12:43:39.116Z</published>
    <updated>2021-06-23T12:44:21.704Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of database operation technology MySQL.</strong></p><a id="more"></a><h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><p>全文共<code>348</code>字，推荐阅读时间<code>3~5</code>分钟。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>应用程序<strong>不需要</strong>自己管理数据，而是通过数据库软件提供的<strong>接口</strong>来读写数据。</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><ul><li>树形结构</li></ul><p><img src="https://i.loli.net/2020/07/01/wScTtsDdWhjIzL4.png" alt="XR@5HT3{ZYUZH}~HSF~HTWE" style="zoom:50%;" /></p><h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><ul><li>图结构</li></ul><p><img src="https://i.loli.net/2020/07/01/lK8DtykOrIJS5eA.png" alt="two" style="zoom:50%;" /></p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><ul><li>二维表格</li><li>通过行号和列号定位</li><li><strong>占数据库的主导地位</strong></li></ul><p><img src="https://i.loli.net/2020/07/01/ricl1Rg87oAECqd.png" alt="three" style="zoom:50%;" /></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>关系表中，除了每一列的名称，还需要定义每一列的<strong>数据类型</strong>。</li></ul><div class="table-container"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>INT</td><td>整型</td><td>4字节</td></tr><tr><td>BIGINT</td><td>长整型</td><td>8字节</td></tr><tr><td>REAL</td><td>浮点型</td><td>4字节</td></tr><tr><td>DOUBLE</td><td>浮点型</td><td>8字节</td></tr><tr><td>DECIMAL(M,N)</td><td>高精度小数</td><td>M表示数字总共多少位，N表示小数有多少位，常用于财务计算。</td></tr><tr><td>CHAR(N)</td><td>定长字符串</td><td>N表示字符串长度</td></tr><tr><td>VARCHAR(N)</td><td>变长字符串</td><td>N表示长度上限</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td><td>True/False</td></tr><tr><td>DATE</td><td>日期类型</td><td>2020-07-01</td></tr><tr><td>TIME</td><td>时间类型</td><td>12:20:25</td></tr><tr><td>DATETIME</td><td>日期和时间类型</td><td>2020-07-01 12:20:25</td></tr></tbody></table></div><blockquote><p><code>BIGINT</code>和<code>VARCHAR</code>是使用<strong>最广泛</strong>的两种类型</p></blockquote><h4 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h4><p>SQL关键字<strong>不区分</strong>大小写，但是规范如下：</p><ul><li>关键字统一使用<strong>大写</strong></li><li>表名和列名统一使用<strong>小写</strong></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="关系模型-1"><a href="#关系模型-1" class="headerlink" title="关系模型"></a>关系模型</h1><p>全文共<code>1315</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>关系数据库是建立在关系模型上的</li><li>关系模型本质上就是<strong>若干个</strong>存储数据的<strong>二维表</strong>（看作很多Excel表）</li><li>表的<strong>每一行</strong>称为<strong>记录</strong>(Record)，记录是一个<strong>逻辑意义</strong>上的数据。</li><li>表的<strong>每一列</strong>称为<strong>字段</strong>(Column)，同一个表的<strong>每一行</strong>记录都拥有<strong>相同类型</strong>的若干<strong>字段（列）</strong>。<ul><li>字段定义数据类型</li><li>字段定义数据是否可以为<code>NULL</code>，<code>NULL</code>表示数据<strong>不存在</strong>，<strong>不是</strong>0/空串。</li></ul></li></ul><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul><li>记录需要一个<strong>唯一</strong>的标识来进行区分</li><li>所有的记录的<strong>主键</strong>一定是不同的</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>主键是一个<strong>字段</strong></li><li>主键是用来区分记录的，各个记录的主键字段值<strong>不能相同</strong>。</li></ul><blockquote><p>主键在建立起字段后最后<strong>不要</strong>再进行修改</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>不能用业务相关的字段作为主键</p><blockquote><p>业务相关：变更不可控，例如身份证号的位数可能会发生<strong>变更</strong>。</p></blockquote></li><li><p>不应该允许NULL</p></li><li><p>主键常命名为id</p><ul><li><p>自增整数类型(<code>BIGINT NOT_NULL AUTO_INCREMENT</code>)</p><p>数据库会在插入数据时<strong>自动</strong>为每一条记录分配一个自增整数</p></li><li><p>全局唯一GUID类型</p><p>使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。</p></li></ul></li></ul><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><ul><li>关系数据库实际上还允许通过<strong>多个字段唯一标识记录</strong>，即<strong>两个或更多的字段</strong>都设置为主键，这种主键被称为联合主键。</li></ul><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li><p>在表1中增加表2的主键id，命名为<code>table2_id</code>，即可在<strong>表一</strong>中查找到记录在<strong>表二</strong>中相关字段的索引。</p><blockquote><p>通常用来实现实现<strong>一对多</strong>关系：例如一个班级（<strong>表2</strong>）对应多个学生（<strong>表1</strong>）。</p></blockquote></li></ul><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><ul><li><p><strong>正规外键</strong>不是通过新增字段实现的，而是通过定义外键约束实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><ul><li><code>fk_class_id</code>：外键约束的名称，可以任意。</li><li><code>FOREIGN KEY (class_id)</code>：指定<code>class_id</code>是<strong>外键</strong></li><li><code>REFERENCES classes (id)</code>：指定将<code>class_id</code>这个外键关联到<code>classes</code>的<code>id</code><strong>主键</strong>上</li></ul></li><li><p>通过定义外键约束，关系数据库可以保证<strong>无法插入</strong>无效的数据。即如果<code>classes</code>表<strong>不存在</strong><code>id=99</code>的记录，<code>students</code>表就<strong>无法</strong>插入<code>class_id=99</code>的记录。</p></li><li><p>由于外键约束会<strong>降低</strong>数据库的性能，可以采用变种外键，即<code>class_id</code>仅仅是一个<strong>普通的列</strong>，只是它<strong>起到了</strong>外键的作用而已。</p></li><li><p>删除外键约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><blockquote><p>删除外键约束<strong>并没有</strong>删除外键这一列。<strong>删除列</strong>是通过<code>DROP COLUMN ...</code>实现的。</p></blockquote></li></ul><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><ul><li><p>通过两个一对多关系实现</p><ul><li><p>通过一张中间表，关联两个一对多关系。</p><p>| id   | teacher_id | class_id |<br>| —— | ————— | ———— |<br>| 1    | 1          | 1        |<br>| 2    | 1          | 2        |<br>| 3    | 2          | 1        |<br>| 4    | 3          | 1        |</p></li></ul></li></ul><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><ul><li>一个表的记录对应到另一个表的<strong>唯一一个</strong>记录</li></ul><blockquote><p>一对一表理论上可以合并为一个表，但是一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得<strong>更高的性能</strong>。</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>为了在大数据库中取得较高的查找速度提出的方法</li><li>索引是关系数据库中对<strong>某一列</strong>或<strong>多个列</strong>的<strong>值</strong>进行<strong>预排序</strong>的数据结构（本质是为了缩小查找的范围）</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>情景：经常根据列表的<code>score</code>字段进行查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>索引名称是任意的，索引如果有多列，可以在括号里依次写上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果记录的列存在大量<strong>相同</strong>的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，此时对该列创建索引就<strong>没有意义</strong>。</li><li>索引越<strong>多</strong>，插入、更新和删除记录的速度就越<strong>慢</strong>。</li><li>对于<strong>主键</strong>，关系数据库会<strong>自动</strong>对其创建主键索引。使用主键索引的效率是<strong>最高</strong>的，因为主键会保证绝对唯一。</li></ul></blockquote><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul><li><p>当记录的该字段不会发生重复时，就可以为该列增加唯一索引。</p><p>例如不重名时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD UNIQUE INDEX uni_name (name);</span><br></pre></td></tr></table></figure></li><li><p>唯一索引<strong>不是</strong>主键，例如身份证号，就算位数变化，也不影响唯一性，但是会影响主键的查找。</p></li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会<strong>自动使用索引</strong>来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中<strong>逐步优化</strong>。</p><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><p>全文共<code>1349</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;table_name&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>SELECT</code>：表示要执行一个查询</li><li><code>*</code>：表示所有<strong>列</strong></li><li><code>FROM</code>：表示将要从哪个表查询、</li></ul><blockquote><ul><li><code>SELECT 1;</code>常用来测试数据库连接</li><li>查询结果是一个<strong>二维表</strong></li></ul></blockquote><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><ul><li><p><code>WHERE</code>引出条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE score &gt;&#x3D; 80;</span><br></pre></td></tr></table></figure></li><li><p><code>AND</code>/<code>OR</code>/<code>NOT</code>进行逻辑运算</p></li><li><p><code>=</code>（<strong>一个</strong>等号）表示相等判断</p></li><li><p><code>&lt;&gt;</code>表示<strong>不等</strong>判断（等价于<code>NOT xxx = xxx;</code>）</p></li><li><p><code>()</code>进行条件分组</p></li></ul><h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><ul><li><p><code>BETWEEN...AND...</code>（<strong>闭</strong>区间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WHERE score &gt;&#x3D; 60 AND score &lt;&#x3D;90;</span><br><span class="line">WHERE score BETWEEN 60 AND 90;</span><br></pre></td></tr></table></figure></li><li><p><code>LIKE</code>判断相似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name LIKE &#39;ab%&#39;</span><br></pre></td></tr></table></figure><ul><li><code>%</code>表示<strong>任意字符</strong>，可以为<strong>空</strong>字符。</li></ul></li></ul><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>只查询<strong>某些列</strong>的操作被称为<strong>投影查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score, name FROM students;</span><br></pre></td></tr></table></figure><ul><li><p>为列增加别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score points, name FROM students;</span><br></pre></td></tr></table></figure><blockquote><p><code>SELECT row1, row2 name2, row3 FROM ...</code></p></blockquote></li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li><p>数据库的查询结果默认按照<code>id</code>（主键）排序</p></li><li><p>使用<code>ORDER BY</code>子句将记录根据字段值<strong>从低到高</strong>进行排序（默认升序<code>ASC</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score;</span><br></pre></td></tr></table></figure><blockquote><p>增加<code>DESC</code>表示<strong>倒序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>多要素排序：将要素依次列出，逗号分隔即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</span><br></pre></td></tr></table></figure></li><li><p>多行查询语句（关键词换行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id &#x3D; 1</span><br><span class="line">ORDER BY score DESC;</span><br></pre></td></tr></table></figure></li><li><p><code>ORDER BY</code>放在查询语句的<strong>最后</strong></p></li></ul><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>当查询结果量很大时，进行分页显示。</p><ul><li><p>实质上就是从结果中<strong>截取</strong>一部分进行显示，进行多次查询即可得知所有结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure><ul><li><code>LIMIT M OFFSET N</code>：从<code>N</code>开始的<strong>最多</strong><code>M</code>条记录（少于<code>M</code>条也不会报错）</li><li>可以简写为<code>LIMIT M, N</code></li><li><code>LIMIT M</code>默认<code>N</code>为0</li></ul></li></ul><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>对于总数、平均数的计算，SQL内置了聚合函数，使用聚合函数进行查询就叫聚合查询。</p><ul><li><p>查询表中<strong>记录</strong>总数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM students;</span><br></pre></td></tr></table></figure><blockquote><p>为返回的表设置别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students;</span><br><span class="line"></span><br><span class="line">&#x2F;* output</span><br><span class="line">    +-----+</span><br><span class="line">    | num |</span><br><span class="line">    +-----+</span><br><span class="line">    |  10 |</span><br><span class="line">    +-----+</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>查询特定记录总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(id) boys FROM students WHERE gender &#x3D; &#39;M&#39;;</span><br></pre></td></tr></table></figure><ul><li><code>COUNT(*)</code>和<code>COUNT(id)</code>等价</li><li>没有匹配到行返回<code>0</code></li></ul></li></ul><h3 id="其他聚合函数"><a href="#其他聚合函数" class="headerlink" title="其他聚合函数"></a>其他聚合函数</h3><ul><li><p><code>SUM</code>：计算某一列的和</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul></li><li><p><code>AVG</code>：计算某一列的平均值</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(score) average FROM students WHERE gender &#x3D; &#39;M&#39;;</span><br></pre></td></tr></table></figure></li><li><p><code>MAX</code>：计算某一列的最大值</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul></li><li><p><code>MIN</code>：计算某一列的最小值</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul></li></ul><blockquote><p>后两个<strong>不限于</strong>数值类型</p></blockquote><ul><li><p><code>FLOOR</code>：向下取整函数</p></li><li><p><code>CEILING</code>：向上取整函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CEILING(COUNT(*) &#x2F; 3) FROM students;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li><p>根据字段值自动分组计数（不用多次查询）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><ul><li><p>为了区分输出的结果是哪个班的，可以多<code>SELECT</code>一个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><ul><li>注意只能<code>SELECT</code>用于分组的字段，加入其他字段可能会出现<strong>一个框内多个值</strong>的情况，MySQL会报错。</li></ul></li></ul></li><li><p>多字段分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, gender, COUNT(*) num </span><br><span class="line">FROM students </span><br><span class="line">GROUP BY class_id, gender;</span><br></pre></td></tr></table></figure></li><li><p>查询各个班级的平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, AVG(score) avg</span><br><span class="line">FROM students</span><br><span class="line">GROUP BY class_id;</span><br></pre></td></tr></table></figure></li><li><p>查出各个班级男生和女生的平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, gender, AVG(score) avg</span><br><span class="line">FROM students</span><br><span class="line">GROUP BY class_id, gender;</span><br><span class="line">-- ORDER BY gender;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>查询两个表的乘积，又称笛卡尔查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students, classes;</span><br></pre></td></tr></table></figure><ul><li><p>将两张表的行逐一进行枚举组合后拼在一起返回</p></li><li><p>结果集<strong>列数</strong>是两张表<strong>列数之和</strong></p></li><li><p>结果集<strong>行数</strong>是两张表<strong>行数之积</strong></p></li><li><p>查询时为了区分列，可以设置别名。（注意字段名的访问方式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">students.id sid,</span><br><span class="line">students.name,</span><br><span class="line">students.gender,</span><br><span class="line">students.score,</span><br><span class="line">classes.id cid,</span><br><span class="line">classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure><p>当表名过长时，可以选择给<strong>表</strong>再起一个别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">s.id sid,</span><br><span class="line">s.name,</span><br><span class="line">s.gender,</span><br><span class="line">s.score,</span><br><span class="line">c.id cid,</span><br><span class="line">c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure></li></ul><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>对多个表进行<code>JOIN</code>运算：先确定一个主表，然后从其他表中选择性地提取一些行加入到结果集中。</p><ul><li><p>查询学生信息的同时需要知道班级id对应的班级名</p><ul><li><p>内连接</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">ON s.class_id &#x3D; c.id;</span><br></pre></td></tr></table></figure><ul><li>确认主表(students)</li><li>确认连接表(classes)</li><li>确认连接条件(<code>ON</code>)：当条件满足时把主表和连接表的<strong>对应行</strong>连接起来</li><li>可以加上查询语句等辅助功能</li></ul></li><li><p>外连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id &#x3D; c.id;</span><br></pre></td></tr></table></figure><blockquote><p>相比于内连接会多出一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idnameclass_idclass_namegenderscore</span><br><span class="line">NULLNULLNULL四班   NULL    NULL</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>RIGHT OUTER JOIN</code>：返回<strong>右表</strong>（连接表）中存在的行（左表不存在无所谓）</li><li><code>LEFT OUTER JOIN</code>：返回<strong>左表</strong>（主表）中存在的行（右表不存在无所谓）</li><li><code>FULL OUTER JOIN</code>：两边表只要有一个存在就返回（<code>RIGHT</code>和<code>LEFT</code>的并集）</li><li><code>INNER JOIN</code>：返回两张表<strong>都存在</strong>的记录</li></ul></li></ul></li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><p>全文共<code>298</code>字，推荐阅读时间<code>3~5</code>分钟。</p><ul><li>关系数据库的基本操作：增删查改（CRUD）<ul><li>C：Create</li><li>R：Retrieve</li><li>U：Update</li><li>D：Delete</li></ul></li></ul><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><ul><li><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;xxx&#39;, &#39;M&#39;, 80);</span><br></pre></td></tr></table></figure><ul><li><p><strong>不需要</strong>列出<code>id</code>字段，这是一个由MySQL自己维护的自增字段。</p></li><li><p>语句中的字段顺序和表格中<strong>可以</strong>不一样，但是对应的值一定要按照<strong>语句中</strong>的顺序。</p></li><li><p>一次性添加多个记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">(1, &#39;A&#39;, &#39;M&#39;, 97),</span><br><span class="line">(2, &#39;B&#39;, &#39;M&#39;, 81);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><ul><li><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- UPDATE &lt;表名&gt; SET 字段1&#x3D;值1, 字段2&#x3D;值2, ... WHERE ...;</span><br><span class="line">UPDATE students SET name &#x3D; &#39;new_xxx&#39;, score&#x3D;66 WHERE id&#x3D;1;</span><br></pre></td></tr></table></figure><ul><li><p><code>WHERE</code>行为与<code>SELECT</code>中一致</p></li><li><p>更新多条记录（更改<code>WHERE</code>的判断条件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students SET name&#x3D;&#39;new_x&#39;, score&#x3D;77 WHERE id&gt;&#x3D;5 AND id&lt;&#x3D;7;</span><br></pre></td></tr></table></figure><ul><li>当没有匹配到记录时，<strong>不会</strong>报错。</li></ul></li><li><p>更新整个表（省略<code>WHERE</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students SET score&#x3D;60;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><ul><li><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- DELETE FROM &lt;表名&gt; WHERE ...;</span><br><span class="line">DELETE FROM students WHERE id&#x3D;1;</span><br></pre></td></tr></table></figure><ul><li><p><code>id=2</code>的记录<code>id</code><strong>不会</strong>变化</p></li><li><p>删除整个表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM students;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="MySQL操作"><a href="#MySQL操作" class="headerlink" title="MySQL操作"></a>MySQL操作</h1><p>全文共<code>664</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li><p><code>MySQL Client</code>是一个<strong>命令行</strong>客户端，对应的可执行程序是mysql.</p></li><li><p><code>MySQL Server</code>是真正的MySQL<strong>服务器</strong>，对应的可执行程序是mysqld.</p></li><li><p>Client通过TCP连接发送到Server，默认端口是3306，如果发送到本机的服务器，地址为<code>127.0.0.1:3306</code>.</p></li><li><p>连接到远程Server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h IP_addr_of_distant_server -u root -p</span><br></pre></td></tr></table></figure></li></ul><h2 id="管理MySQL"><a href="#管理MySQL" class="headerlink" title="管理MySQL"></a>管理MySQL</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>显示：<code>SHOW DATABASES;</code><ul><li><code>information_schema</code>/<code>mysql</code>/<code>performance_schema</code>/<code>sys</code>是系统库，不能改动，</li></ul></li><li>创建：<code>CREATE DATABASE test;</code></li><li>删除：<code>DROP DATABASE test;</code></li><li>切换：<code>USE test;</code></li></ul><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul><li><p>创建：<code>CREATE TABLE students(...);</code></p><ul><li>至少有一列，并且需要使用<code>PRIMARY KEY (xxx)</code>指定为主键列。</li></ul></li><li><p>删除：<code>DROP TABLE students;</code></p></li><li><p>显示：<code>SHOW TABLES;</code></p></li><li><p>查看结构：<code>DESC students;</code>/<code>SHOW CREATE TABLE students;</code></p></li><li><p>修改</p><ul><li><p>新增列<code>birth</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure></li><li><p>修改列名为<code>birthday</code>，并修改数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><ul><li><code>VARCHAR(xx) NOT NULL</code>：数据类型以及约束<strong>不能</strong>被省略</li></ul></li><li><p>删除列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="实用语句"><a href="#实用语句" class="headerlink" title="实用语句"></a>实用语句</h2><h3 id="插入或替换"><a href="#插入或替换" class="headerlink" title="插入或替换"></a>插入或替换</h3><p>插入记录时，<strong>如果</strong>需要对重复元素进行替换，直接使用<code>REPLACE</code>语句可以省略手动查询的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;C&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><ul><li>当<code>id=1</code>的记录不存在时会直接插入，如果存在则会删除后再插入。</li></ul><h3 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h3><p>插入记录时，<strong>如果</strong>记录已经存在，则对记录进行<strong>选择性</strong>更新，否则直接插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99) ON DUPLICATE KEY UPDATE name&#x3D;&#39;小明&#39;, gender&#x3D;&#39;F&#39;, score&#x3D;99;</span><br></pre></td></tr></table></figure><h3 id="插入或忽略"><a href="#插入或忽略" class="headerlink" title="插入或忽略"></a>插入或忽略</h3><p>插入记录时，<strong>如果</strong>记录已经存在，则不进行任何操作，否则直接插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>进行数据复制并创建新表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id&#x3D;1;</span><br></pre></td></tr></table></figure><ul><li>新表的结构和原表<strong>一致</strong></li></ul><h3 id="写入查询结果集"><a href="#写入查询结果集" class="headerlink" title="写入查询结果集"></a>写入查询结果集</h3><p>建立成绩统计表</p><ul><li><p>创建存储结果集的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE statistics (</span><br><span class="line">id BIGINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    class_id BIGINT NOT NULL,</span><br><span class="line">    average DOUBLE NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>写入各班平均成绩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(acore) FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure></li></ul><h3 id="强制使用指定索引"><a href="#强制使用指定索引" class="headerlink" title="强制使用指定索引"></a>强制使用指定索引</h3><p>解决数据库查询的索引<strong>不是</strong>最优解的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id&#x3D;1 ORDER BY id DESC;</span><br></pre></td></tr></table></figure><ul><li><code>idx_class_id</code>必须存在<strong>才能够</strong>使用强制索引</li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of database operation technology MySQL.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Backend" scheme="http://yoursite.com/categories/Backend/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB Course Note</title>
    <link href="http://yoursite.com/2021/06/23/MATLAB%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/MATLAB%20Course%20Note/</id>
    <published>2021-06-23T12:42:44.702Z</published>
    <updated>2021-06-23T12:43:13.208Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2020 BUAA MATLAB course.</strong></p><a id="more"></a><h1 id="Chapter0-概论"><a href="#Chapter0-概论" class="headerlink" title="Chapter0 概论"></a>Chapter0 概论</h1><p>全文<code>135</code>字，推荐阅读时间<code>3~5</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>MATLAB<strong>最初</strong>强调矩阵的运算</li></ul><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><ul><li><p><code>.m</code>：M文件</p><ul><li>命令文件：主程序/主函数</li><li>函数文件：子程序/被调函数</li></ul><blockquote><p>工具箱中所有的文件基本上是<strong>函数文件</strong></p></blockquote></li><li><p><code>.mat</code>：数据文件，保存了workspace中的变量数据</p></li><li><p><code>.fig</code>：图形文件，依然<strong>可以</strong>被修改。</p></li><li><p><code>.mex</code>/<code>.dll</code>：MATLAB的可执行文件</p></li><li><p><code>.mdl</code>：模型和仿真文件</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter1-数据类型"><a href="#Chapter1-数据类型" class="headerlink" title="Chapter1 数据类型"></a>Chapter1 数据类型</h1><p>全文共<code>1782</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li>每一种类型都以<strong>数组</strong>为基础</li><li>默认类型为<code>double</code>，可以利用转化函数改变类型。</li><li><strong>不用</strong>事先对变量的类型进行定义或说明</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>预定义的特殊变量</p><ul><li><code>ans</code>：<strong>未赋值运算</strong>结果自动赋值给<code>ans</code></li><li><code>eps</code>：容差变量，小于该值时可认为是0.</li><li><code>pi</code></li><li><code>i,j</code>：二者等价，虚数单位。</li><li><code>inf</code>：正无穷大，0作<strong>除数</strong>时出现。</li><li><code>NaN</code>：不合法数值，在$0*∞,0/0$等运算时产生。</li><li><code>version</code></li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li><code>clear name1 name2 name3;</code>：清除用户自定义的变量<ul><li><code>clear all;</code>：清除所有变量</li></ul></li><li>特殊常量的值可以在当前程序中被<strong>临时改变</strong></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>MATLAB中所有变量都以<strong>数组或矩阵</strong>形式保存</li></ul><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul><li>和C一致</li><li>对大小写敏感</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>变量查询<ul><li><code>who</code>：列出所有的变量名</li><li><code>whos</code>：给出所有变量及其大小、类别等性质。</li></ul></li><li><code>clear</code>：删除<strong>自定义</strong>变量，并重置<strong>除<code>eps</code>之外</strong>的常量。<ul><li><code>clear a*</code>：删除所有以<code>a</code>开头的变量</li></ul></li><li><code>pack</code>：重组和压缩已分配的内存碎块，在不影响变量的情况下腾出空间。<ul><li><code>pack filename</code>：自定义中间<code>mat</code>文件名（之后会被自动删掉）</li></ul></li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li><p>局部变量：函数内部定义的变量</p></li><li><p>全局变量：函数之间共享的变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> MAXLEN;MAXLEN=<span class="number">45</span>;</span><br></pre></td></tr></table></figure></li><li><p>永久变量：类似于<code>static</code>，在M文件中定义和使用，只在<code>clear</code>时被清除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">persistent</span> MAXLEN; MAXLEN=<span class="number">45</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><ul><li><p>整型：带符号&amp;无符号</p></li><li><p>浮点型：单精度(single)&amp;双精度(double)</p><blockquote><p>单精度<strong>不是</strong><code>float</code></p></blockquote></li><li><p>比较</p><ul><li><code>~=</code></li><li><code>==</code></li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x1 = int8(<span class="number">11</span>); <span class="comment">% 11</span></span><br><span class="line">x2 = int8(<span class="number">15.49</span>); <span class="comment">% 15</span></span><br><span class="line">x3 = int8(<span class="number">15.5</span>); <span class="comment">% 16</span></span><br><span class="line">x4 = int8(<span class="number">130</span>); <span class="comment">% 127</span></span><br><span class="line">x5 = uint8(<span class="number">-1</span>); <span class="comment">% 0</span></span><br></pre></td></tr></table></figure><ul><li><p>浮点型转换为整型是<strong>四舍五入</strong></p></li><li><p>超过类型边界<strong>则取边界值</strong></p></li><li><p><code>intmax</code>/<code>intmin</code>：查询整型边界</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intmax(<span class="string">'int8'</span>); <span class="comment">% 127</span></span><br></pre></td></tr></table></figure><blockquote><p>类型传入需要<strong>引号</strong></p></blockquote></li><li><p><code>realmax</code>/<code>realmin</code>：查询浮点型边界</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">realmax</span>(<span class="string">'single'</span>);</span><br></pre></td></tr></table></figure></li><li><p>数值默认为双精度浮点数，需要手动转换为<code>single</code>或其它类型.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">35</span>;</span><br><span class="line">y = single(X);</span><br><span class="line">class(x) <span class="comment">% double</span></span><br><span class="line">class(y) <span class="comment">% single</span></span><br></pre></td></tr></table></figure><ul><li><code>;</code>：变量后加<code>;</code>限制变量输出，不会打印到控制台，和C作用不同。</li></ul></li></ul><h4 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h4><ul><li><code>round(x)</code>：四舍五入（负数可能<strong>向下</strong>五入）</li><li><code>fix(x)</code>：向0取整</li><li><code>floor(x)</code>：向<strong>下</strong>取整</li><li><code>ceil(x)</code>：向<strong>上</strong>取整</li></ul><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul><li><p>创建</p><ul><li><p>直接输入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span><span class="number">-3</span><span class="built_in">i</span> <span class="comment">% ans = 2.0000-3.0000i</span></span><br></pre></td></tr></table></figure><blockquote><p><code>format</code>默认设置小数点后保留4位，当数字大于1000时，使用科学计数法。</p></blockquote></li><li><p><code>complex(a, b)</code>：a是实部，b是虚部，且b不指定时默认为0.</p></li></ul></li></ul><h3 id="逻辑型变量"><a href="#逻辑型变量" class="headerlink" title="逻辑型变量"></a>逻辑型变量</h3><ul><li><p><code>true</code>对应1，<code>false</code>对应0.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>] &gt; <span class="number">5</span> <span class="comment">% y = [1, 0, 1]</span></span><br></pre></td></tr></table></figure></li><li><p><code>logical</code>：数值转换为逻辑型</p></li><li><p><code>any</code>/<code>all</code>：矩阵传入一维真值矩阵</p></li><li><p><code>is*(isspace)</code>：测试运算</p></li><li><p>逻辑数组：利用逻辑运算构造矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">rand</span>(<span class="number">3</span>), A(A&lt;<span class="number">0.5</span>)=<span class="number">0</span> <span class="comment">% assign val &lt; 0.5 positions to zero</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h3><ul><li>数组的运算都是<strong>点运算</strong>（逐个元素运算）</li><li>矩阵的乘法、乘方、除法有特殊含义，其他和数组没有区别。</li><li><strong>MATLAB的下标从1开始</strong></li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><p>直接构造法</p><ul><li><code>[]</code></li><li><code>,</code>：间隔<strong>行内</strong>元素，或者使用空格。</li><li><code>;</code>：间隔<strong>行间</strong>元素，或者使用回车。</li><li>元素可以为值/表达式</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">3.8</span>, <span class="number">1e-3</span>, <span class="built_in">sqrt</span>(<span class="number">2</span>)]</span><br><span class="line">b = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>增量法</p><ul><li><p>利用冒号生成向量（包括<strong>右端点</strong>）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">i</span>:<span class="built_in">j</span> <span class="comment">% [i,j] as an array(including j)</span></span><br><span class="line">x = <span class="built_in">i</span>:<span class="built_in">j</span>:k <span class="comment">% j is stride</span></span><br></pre></td></tr></table></figure></li><li><p><code>linspace(a,b)</code>：生成等差向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>) <span class="comment">% from 2 to 8 with 10 numbers(default to 100 numbers)</span></span><br></pre></td></tr></table></figure></li><li><p><code>logspace(a,b)</code>：等比向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = logspace(2, 8) # default to produce 50 numbers</span><br><span class="line">y = <span class="built_in">logspace</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>利用小矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">C = [a, <span class="built_in">eye</span>(<span class="built_in">size</span>(A)); <span class="built_in">ones</span>(<span class="number">3</span>), A*<span class="number">2</span>]</span><br></pre></td></tr></table></figure><ul><li><code>size()</code>：返回行数和列数<ul><li><code>length()</code>：返回行数和列数中的最大值</li></ul></li><li><code>eye(size)</code>：返回单位矩阵</li><li><code>ones(size)</code>：返回全一矩阵</li></ul></li></ul><h4 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h4><ul><li><p>元素赋值</p><ul><li>超过边界时，内存会<strong>自动扩展</strong>。</li></ul></li><li><p>运算</p><ul><li><code>*</code>：数学意义上的<strong>矩阵乘法</strong></li><li><code>.*</code>：<strong>点运算</strong>的数组乘法，对应元素相乘。</li></ul><blockquote><p><code>^</code>等运算符同上</p></blockquote></li><li>拆分：利用冒号表达式获得子矩阵<ul><li><code>A(r,c)</code>：(r,c)位置的元素</li><li><code>A(r,:)</code>：A的第r行的所有元素</li><li><code>A(:,c)</code>：A的第c列的所有元素</li><li><code>A(:)</code>：<strong>列优先</strong>使A变为一维数组</li><li><code>A(i)</code>：访问<code>A(:)</code>中的第<code>i</code>个元素</li><li><code>A(r,c)=Sa</code>：元素赋值</li><li><code>A(:)=D(:)</code></li></ul></li><li><p>删除：利用<code>[]</code>赋值</p><ul><li><p>删除不是清零，而是<strong>改变</strong>矩阵结构。</p><blockquote><p><code>clear</code>后矩阵变量则消失，不能再通过变量名操作。</p></blockquote></li></ul></li><li><p>其他</p><ul><li><p><code>diag</code>：提取矩阵对角线元素生成对角矩阵</p></li><li><p><code>flipud</code>：上下翻转</p></li><li><p><code>fliplr</code>：左右翻转</p></li><li><p><code>reshape(name, length, width)</code>：第一个参数是原矩阵，改变形状。</p><ul><li>注意矩阵<strong>列优先</strong></li></ul></li><li><p><code>rot90</code>：<strong>逆时针</strong>旋转90度</p></li><li><p><code>det</code>：矩阵行列式的值</p></li><li><p><code>rank</code>：矩阵的秩</p></li><li><p><code>trace</code>：矩阵的迹</p></li><li><p><code>max</code>：包含<strong>每一列</strong>最大值的向量</p></li><li><p>数组逆序</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = A(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>); <span class="comment">% end is a special symbol for iteration</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>一维字符数组</li><li>用<strong>单引号</strong>括起</li><li>字符串的<code>class</code>是<code>char</code></li><li>索引访问时应该使用<code>()</code>而不是<code>[]</code></li></ul><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul><li><p>单引号赋值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">'BUAA'</span>;</span><br><span class="line">b = c(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = char(<span class="number">97</span>) <span class="comment">% a</span></span><br><span class="line">c2 = num2str(<span class="number">97</span>) <span class="comment">% 97</span></span><br></pre></td></tr></table></figure><ul><li><p><code>setstr</code>：将ASCII码转换成字符串</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setstr(<span class="built_in">abs</span>(<span class="string">'c'</span>) + <span class="built_in">abs</span>(<span class="string">'a'</span>) - <span class="built_in">abs</span>(<span class="string">'A'</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>abs</code>：将字符串转换为ASCII码</p></li></ul><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><ul><li><p>水平</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="string">'I '</span>, <span class="string">'Love '</span>, <span class="string">'Matlab!'</span>] <span class="comment">% str = I Love Matlab</span></span><br><span class="line">str2 = strcat(<span class="string">'I '</span>, <span class="string">'Love '</span>, <span class="string">'Matlab!'</span>) <span class="comment">% str = ILoveMatlab</span></span><br></pre></td></tr></table></figure><ul><li><code>strcat</code>会自动去掉<strong>结尾处</strong>的空格，头部的<strong>不会被</strong>去掉。</li></ul></li><li><p>垂直</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="string">'Matrix    '</span>;<span class="string">'Lab'</span>]</span><br><span class="line">str2 = strvcat(<span class="string">'Matrix    '</span>,<span class="string">'Lab'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>strvcat</code>自动去掉<strong>结尾</strong>的空格</li></ul></li></ul><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><ul><li><p><code>isstrprop(str, &#39;category&#39;)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isstrprop(pw, <span class="string">'alphanum'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li><code>strcmp</code>：相等返回1</li><li><code>==</code>：逐个字符比较，返回一维数组，相等的位为1.</li></ul><h4 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h4><div class="table-container"><table><thead><tr><th>编码方式</th><th>英文（单位：字节）</th><th>中文（单位：字节）</th></tr></thead><tbody><tr><td><code>ASCII</code></td><td>1</td><td>/</td></tr><tr><td><code>UTF-8</code></td><td>1</td><td>3</td></tr><tr><td><code>UTF-16</code></td><td>2</td><td>2/4</td></tr><tr><td><code>UTF-32</code></td><td>4</td><td>4</td></tr><tr><td><code>GBK</code></td><td>1</td><td>2</td></tr></tbody></table></div><blockquote><p>在<code>R202a</code>中测试，无论是英文还是中文均占用两个字节。</p></blockquote><h3 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h3><ul><li>提供间接调用函数方法的数据类型</li></ul><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><ul><li><p>在已有函数名前加符号<code>@</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1 = @funcname;</span><br></pre></td></tr></table></figure></li><li><p>提供匿名函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqr = @(x)x.^<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><ul><li>将函数句柄看作函数名，和函数调用相同。</li></ul><h3 id="元胞数组"><a href="#元胞数组" class="headerlink" title="元胞数组"></a>元胞数组</h3><ul><li>其中的元素类型、尺寸可以不相同</li><li>创建、访问时用<code>{}</code>表示索引</li></ul><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><ul><li><p><code>cell</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=cell(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li><p><code>deal</code>：<strong>列优先</strong>查看内容，返回一个长向量进行解析。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,b] = deal(a&#123;:&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>[]</code>：赋值，删除元素。</p></li><li><p><code>num2cell</code>/<code>mat2cell</code>：数组、矩阵和元胞的转换。</p></li><li><p><code>celldisp</code>：逐个显示元胞数组内容</p></li></ul><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; stu = struct(<span class="string">'username'</span>, &#123;&#125;, <span class="string">'password'</span>, &#123;&#125;, <span class="string">'name'</span>, &#123;&#125;, <span class="string">'gender'</span>, &#123;&#125;); <span class="comment">% an empty struct array</span></span><br><span class="line">&gt;&gt; stu(<span class="number">1</span>).name=<span class="string">'Silence'</span>;</span><br><span class="line">&gt;&gt; stu(<span class="number">1</span>).course=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  struct with fields:</span><br><span class="line"></span><br><span class="line">      name: <span class="string">'Silence'</span></span><br><span class="line">    course: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>struct</code>函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; student(<span class="number">3</span>)=struct(<span class="string">'name'</span>,<span class="string">'Lex'</span>,<span class="string">'course'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">student = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">3</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br></pre></td></tr></table></figure></li></ul><h4 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; stu(<span class="number">2</span>).name=<span class="string">'Anita'</span></span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br></pre></td></tr></table></figure><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu(<span class="number">2</span>).name</span><br></pre></td></tr></table></figure><h4 id="删除域"><a href="#删除域" class="headerlink" title="删除域"></a>删除域</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; rmfield(stu,&#123;<span class="string">'course'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line"></span><br><span class="line">&gt;&gt; stu</span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>不改变</strong>本来的结构数组</li></ul><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter2-程序设计"><a href="#Chapter2-程序设计" class="headerlink" title="Chapter2 程序设计"></a>Chapter2 程序设计</h1><p>全文共<code>869</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><ul><li><p>输入：<code>input(message, options)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">'What is your name'</span>,<span class="string">'s'</span>);</span><br></pre></td></tr></table></figure><ul><li><code>s</code>：允许用户输入一个字符串</li></ul></li><li><p>输出</p><ul><li><p><code>disp(messages)</code>：message可以是<strong>单独一个</strong>变量，按照默认<code>format</code>输出。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>([<span class="string">'x1='</span>,num2str(x(<span class="number">1</span>)),<span class="string">'x2='</span>,num2str(x(<span class="number">2</span>))]);</span><br></pre></td></tr></table></figure><ul><li>拼接时<strong>不会</strong>添加空格</li></ul></li><li><p><code>fprintf</code>：和C格式相同</p></li><li><p><code>magbox</code>：弹窗展示</p></li></ul></li><li><p>暂停：<code>pause(time)</code></p><ul><li>省略<code>time</code>则等待用户键入后继续执行</li></ul><blockquote><p>强行中止：<code>Ctrl+C</code></p></blockquote></li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">elseif</span> expression</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>expression</code>可以带括号，也可以不带。</li><li>为了<code>if</code>和<code>end</code>对称：<code>Ctrl+I</code>自动对齐</li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> expression</span><br><span class="line"><span class="keyword">case</span> const1</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">otherwise</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>switch</code>后的类型可以为任意类型，包括字符串、矩阵、数组。</li><li><strong>不</strong>需要<code>break</code>语句，每个<code>case</code>执行后会自动跳出。</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li><p><code>for</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=expression1:expression2:expression3</span><br><span class="line"> <span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>没有<code>()</code>和<code>;</code></p></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>步长为<strong>1</strong>时，表达式2可以省略。</p></li><li><p><code>a:b</code><strong>包括</strong>右端点</p></li></ul></li><li><p><code>while</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression)</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p><code>break</code>：跳出循环</p></li><li><code>continue</code>：跳过循环体剩余语句</li><li><code>return</code>：退出脚本或函数</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">lasterr;</span><br></pre></td></tr></table></figure><ul><li><code>lasterr</code>存储上一次错误的信息</li></ul><h2 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h2><ul><li>扩展名为<code>.m</code></li><li>MATLAB在初次运行时会将<code>.m</code>文件装入内存，之后运行的速度会变快。</li></ul><h3 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h3><ul><li><p>也称为命令文件</p></li><li><p>不接受输入参数也不返回输出参数的M文件</p><blockquote><p>这里的参数指的是在命令行中调用时，脚本文件只需要输入文件名，但是函数文件需要使用<code>()</code>传参数。</p></blockquote></li><li><p>脚本文件新建的变量能够保存在MATLAB的内存空间中</p><ul><li><p>所有的变量都是<strong>全局变量</strong></p><blockquote><p>全局变量可以直接被使用，<strong>不需要</strong>预先声明<code>global</code>.</p></blockquote></li><li><p>每个脚本开始前使用<code>clear all;</code></p></li></ul></li></ul><h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><ul><li><p>对用户就是黑盒，只有输入和输出。</p></li><li><p>MATLAB函数和命令实际上都是函数文件</p></li><li><p>产生的变量默认为<strong>局部变量</strong>，存放在函数自身的工作空间中。</p><blockquote><p>在函数文件中使用全局变量需要预先声明<code>global</code></p></blockquote></li><li><p>结构</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">return_var</span>=<span class="title">funcname</span><span class="params">(input_var)</span> % <span class="title">function</span> <span class="title">definition</span></span></span><br><span class="line"><span class="comment">% help info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% annotation</span></span><br><span class="line"><span class="comment">% ...</span></span><br></pre></td></tr></table></figure><ul><li><code>help info</code>：help文档中显示，即第一个非空行前的所有注释。</li></ul></li><li><p>变量检测</p><ul><li><p><code>nargin</code>：输入实参<strong>数目</strong></p></li><li><p><code>nargout</code>：输出实参<strong>数目</strong></p><blockquote><p>在函数体外可以通过<code>nargin(&#39;func&#39;)</code>调用</p></blockquote></li><li><p><code>inputname(n)</code>：第<code>n</code>个输入参数的实际调用变量名（即函数调用出传进的参数的名字）</p><blockquote><p>如果参数本来是常量，则会返回空字符串。</p></blockquote></li><li><p><code>varargin</code>：变长输入参数<strong>列表</strong></p></li><li><p><code>varargout</code>：变长输出参数列表（直接输出则是数目）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varargout</span> = <span class="title">foo</span><span class="params">(varargin)</span></span></span><br><span class="line">fprintf(<span class="string">'How many output arguments? %d\nAnd they are:\n'</span>, nargout);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:nargout</span><br><span class="line">varargout(k) = varargin(k); <span class="comment">% the same as &#123;varargin&#123;k&#125;&#125;;</span></span><br><span class="line">fprintf(<span class="string">'%s '</span>, num2str(varargout&#123;k&#125;));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="调试和优化"><a href="#调试和优化" class="headerlink" title="调试和优化"></a>调试和优化</h2><ul><li><p><code>keyboard</code>：中断程序，用户可以在命令窗口查询内存信息。</p><ul><li>对于函数文件，将函数头注释掉即可使用<code>keyboard</code>.</li></ul></li><li><p>断点</p><ul><li><p>标准断点（小红点）</p></li><li><p>条件断点（小黄点）</p><ul><li><p>使用函数设置</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbstop in filename <span class="keyword">if</span> expression</span><br></pre></td></tr></table></figure></li></ul></li><li><p>错误断点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbstop <span class="keyword">if</span> error</span><br></pre></td></tr></table></figure><p>使程序在错误的地方停下，并且自动进入调试模式。</p></li></ul></li><li><p>优劣分析</p><ul><li><p><code>profile</code>：计算相对耗时和瓶颈</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">profile on;</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line">profile viewer;</span><br></pre></td></tr></table></figure></li><li><p><code>tic</code>/<code>toc</code>：计算绝对耗时</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tic;</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line">toc;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>优化</p><ul><li>向量化操作：使用向量替换循环</li><li>数据的预定义：一次性申请足够大的空间</li></ul></li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter3-数值计算"><a href="#Chapter3-数值计算" class="headerlink" title="Chapter3 数值计算"></a>Chapter3 数值计算</h1><p>全文共<code>1380</code>字，推荐阅读时间<code>12~15</code>分钟。</p><h2 id="数据统计处理"><a href="#数据统计处理" class="headerlink" title="数据统计处理"></a>数据统计处理</h2><h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><p>以<code>max()</code>为例，<code>min()</code>用法相同。</p><ul><li><p>向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">max</span>(A);</span><br><span class="line">[c, idx] = <span class="built_in">max</span>(A); <span class="comment">% idx is the index of max value</span></span><br></pre></td></tr></table></figure></li><li><p>矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A); <span class="comment">% return a row vector of max values in every column</span></span><br><span class="line">c = <span class="built_in">max</span>(A, [], dim); <span class="comment">% dim can be 1 or 2, default to 1(column max).</span></span><br><span class="line"> <span class="comment">% [] cannot be neglected for overloading of max(A, n).</span></span><br><span class="line">[c, idx] = <span class="built_in">max</span>(A);</span><br></pre></td></tr></table></figure><ul><li><p>求矩阵的最大元素（降维）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A(:));</span><br></pre></td></tr></table></figure></li><li><p>比较</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">max</span>(A, B); <span class="comment">% u is matrix with all max values</span></span><br><span class="line">u = <span class="built_in">max</span>(A, n); <span class="comment">% n is scalar, and u's elements are all &gt;= n.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">mean</span>(A);</span><br><span class="line">m = <span class="built_in">mean</span>(A, dim);</span><br></pre></td></tr></table></figure><h3 id="中值"><a href="#中值" class="headerlink" title="中值"></a>中值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = median(A);</span><br><span class="line">m - median(A, dim);</span><br></pre></td></tr></table></figure><h3 id="加和"><a href="#加和" class="headerlink" title="加和"></a>加和</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = sum(A); <span class="comment">% return a row vector of production of column</span></span><br><span class="line">b = aum(A, dim);</span><br></pre></td></tr></table></figure><ul><li><p>累加和</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = cumsum(A); <span class="comment">% return a row vector of cumulative sum of column</span></span><br><span class="line">b = cumsum(A, dim);</span><br></pre></td></tr></table></figure></li></ul><h3 id="乘积"><a href="#乘积" class="headerlink" title="乘积"></a>乘积</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = prod(A); <span class="comment">% return a row vector of production of column</span></span><br><span class="line">b = prod(A, dim);</span><br></pre></td></tr></table></figure><ul><li><p>累乘积</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = cumprod(A);</span><br><span class="line">b = cumprod(A, dim);</span><br></pre></td></tr></table></figure></li></ul><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = std(A);</span><br><span class="line">s = std(A, flag, dim); <span class="comment">% flag can be 0 or 1, and 0 is (N-1) normal std while 1 is (N).</span></span><br></pre></td></tr></table></figure><h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = corrcoef(A); <span class="comment">% take every column as a variable to caculate correlate coefficient</span></span><br><span class="line">r = corrcoef(x, y)；</span><br><span class="line">r = corrcoef([x, y]);</span><br></pre></td></tr></table></figure><ul><li>相关系数矩阵的大小和原矩阵是相同的，其他时候则根据向量数确定，例如<code>corrcoef([x, y])</code>的结果是<code>2*2</code>矩阵。</li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">sort</span>(A);</span><br><span class="line">[b, idx] = <span class="built_in">sort</span>(A, dim); <span class="comment">% idx contains the positions of B's elements in A.</span></span><br></pre></td></tr></table></figure><h2 id="复数-1"><a href="#复数-1" class="headerlink" title="复数"></a>复数</h2><ul><li>虚部使用<code>i</code>或者<code>j</code>表示</li><li>构造<ul><li>直接表示</li><li><code>complex(a, b)</code></li></ul></li></ul><h3 id="特殊运算"><a href="#特殊运算" class="headerlink" title="特殊运算"></a>特殊运算</h3><ul><li>提取实部和虚部<ul><li><code>real</code></li><li><code>imag</code></li></ul></li><li>计算模<ul><li><code>abs</code></li></ul></li><li>计算辐角<ul><li><code>angle</code></li></ul></li><li>复数共轭<ul><li><code>conj</code></li></ul></li></ul><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>直角坐标绘图和其他相同，特殊的在于<strong>极坐标</strong>绘图。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polar(theta, rho);</span><br><span class="line">polar(theta, tho, LineSpec);</span><br></pre></td></tr></table></figure><ul><li><code>theta</code>：极角</li><li><code>rho</code>：极轴</li></ul><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h3><ul><li><p>多项式表达为一个<strong>系数</strong>行向量，并且其元素是降幂排列的。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = [an, ..., a2, a1, a0];</span><br></pre></td></tr></table></figure><ul><li>指数为0的项的系数<strong>不能</strong>省略</li></ul></li><li><p><code>poly</code>：根据<strong>解向量</strong>产生<strong>特征多项式</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = poly(a);</span><br></pre></td></tr></table></figure><ul><li><p><code>roots</code>：逆函数，根据<strong>系数向量</strong>求<strong>解向量</strong>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = roots(p);</span><br></pre></td></tr></table></figure><blockquote><p>系数（<strong>行</strong>向量）：<code>1 * n</code></p><p>根（<strong>列</strong>向量）：<code>n * 1</code></p></blockquote></li></ul></li><li><p><code>poly2str</code>：把多项式系数转换为<strong>字符形式</strong>的函数，省略一些不影响阅读的运算符，例如<code>2*x</code>会被表示为<code>2x</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = poly2str(p, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>poly2sym</code>：把系数数组转换为<strong>符号多项式</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = poly2sym(p, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;a =[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]; p = poly(a)</span><br><span class="line">p = <span class="number">1</span> <span class="number">-6</span> <span class="number">11</span> <span class="number">-6</span></span><br><span class="line">&gt;&gt; p1 = poly2str(p, <span class="string">'x'</span>) p2 = poly2sym(p, <span class="string">'x'</span>)</span><br><span class="line">p1 = x^<span class="number">3</span> - <span class="number">6</span> x^<span class="number">2</span> + <span class="number">11</span> x – <span class="number">6</span></span><br><span class="line">P2 = x^<span class="number">3</span> - <span class="number">6</span>*x^<span class="number">2</span> + <span class="number">11</span>*x - <span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="算数运算与求导"><a href="#算数运算与求导" class="headerlink" title="算数运算与求导"></a>算数运算与求导</h3><h4 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h4><ul><li>阶次不同时，<strong>低阶多项式</strong>必须用0填补系数数组，使其与高阶多项式有相同的阶次。</li></ul><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = conv(a, b);</span><br></pre></td></tr></table></figure><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = deconv(c, a);</span><br><span class="line">[d, r] = deconv(c, a);</span><br></pre></td></tr></table></figure><ul><li><code>d</code>：整数部分</li><li><code>r</code>：余数</li></ul><h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><ul><li><p>数组变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = polyval(p, x);</span><br></pre></td></tr></table></figure></li><li><p>矩阵变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = polyvalm(p, x);</span><br></pre></td></tr></table></figure><ul><li>变量<code>x</code>是一个<strong>方阵</strong></li></ul></li></ul><h3 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k = polyder(p);</span><br><span class="line">k = polyder(a, b); <span class="comment">% differentiate a * b</span></span><br><span class="line">[p, q] = polyder(a, b); <span class="comment">% differentiate a / b, and result is q(x)/p(x)</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/15/bPF6VulXij3ZUrz.png" alt="image-20201015133030937" style="zoom:50%;" /></p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polyint(p, k); <span class="comment">% p is coef vector, and k is const item.</span></span><br><span class="line">polyint(p); <span class="comment">% k is default to 0.</span></span><br></pre></td></tr></table></figure><h4 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I,n]=quad(<span class="string">'fname'</span>,a,b,tol,trace);</span><br><span class="line">[I,n]=quadl(<span class="string">'fname'</span>,a,b,tol,trace);</span><br></pre></td></tr></table></figure><ul><li><p><code>fname</code>可以是内联函数名</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun = inline(<span class="string">'-x.^2+115'</span>, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure><ul><li>此时如果x不是矩阵，次方需要使用<code>.^</code>.</li></ul></li><li><p><code>tol</code>用来控制积分精度，缺省时取<code>tol=0.001</code>.</p></li><li><p><code>trace</code>控制是否展现积分过程，若取非0则展现积分过程，取0则不展现，缺省时取<code>trace=0</code>.</p></li></ul><h3 id="部分分式展开"><a href="#部分分式展开" class="headerlink" title="部分分式展开"></a>部分分式展开</h3><p><img src="https://i.loli.net/2020/10/15/8k6I7hp54mGlRDT.png" alt="image-20201015115600614" style="zoom:50%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[r, p, k] = residue(b, a);</span><br></pre></td></tr></table></figure><ul><li>求<code>b/a</code>的分式展开<ul><li><code>r</code>：留数行向量</li><li><code>p</code>：部分分式极点</li><li><code>k</code>：常数项</li></ul></li><li>当多项式分母有重根时，使用<code>resi2</code>函数。</li></ul><h2 id="曲线拟合与插值"><a href="#曲线拟合与插值" class="headerlink" title="曲线拟合与插值"></a>曲线拟合与插值</h2><h3 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h3><ul><li><p><code>polyfit</code>：最小二乘拟合</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = polyfit(x, y, n);</span><br></pre></td></tr></table></figure></li></ul><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ul><li>利用已知点确定未知点</li><li>常用于图像旋转、缩放</li></ul><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yi = interp1(x, y, xi, method)</span><br></pre></td></tr></table></figure><ul><li><code>method</code><ul><li><code>nearest</code>：最近邻内插</li><li><code>linear</code>：线性内插（默认）</li><li><code>spline</code>：三次样条内插</li><li><code>cubic</code>：三次多项式内插</li></ul></li></ul><h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi = interp2(x, y, z, xi, yi, method);</span><br></pre></td></tr></table></figure><ul><li><p><code>method</code></p><ul><li><code>nearest</code></li><li><code>bilinear</code>：二维线性内插法（默认）</li><li><code>spline</code>：二维样条内插法</li><li><code>bicubic</code>：二维三次多项式内插法</li></ul></li><li><p>二维<strong>散布点</strong>插值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi = griddata(x, y, z, xi, yi);</span><br></pre></td></tr></table></figure></li></ul><h4 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi = interp3(x, y, z, v, x1, yi, zi, method)</span><br></pre></td></tr></table></figure><ul><li><code>method</code><ul><li><code>nearest</code></li><li><code>linear</code>：默认</li><li><code>spline</code></li><li><code>cubic</code></li></ul></li></ul><h4 id="高维"><a href="#高维" class="headerlink" title="高维"></a>高维</h4><ul><li><code>interpn()</code></li></ul><h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><ul><li><p><code>fminbnd</code>：无约束<strong>单变量</strong>寻优函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fminbnd(fname, x0, x1); <span class="comment">% fname is function name, and [x0, x1] is range.</span></span><br></pre></td></tr></table></figure><ul><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fminbnd(<span class="string">'sin'</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fminsearch</code>：多元函数极小值点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval, exitflag, output] = fminsearch(fun, x0);</span><br></pre></td></tr></table></figure><ul><li><code>exitflag</code>为1表示计算成功</li><li><code>fun</code>可以是外部函数，也可以直接用字符串作参数。</li><li>函数中的变量必须是<code>x(i)</code></li></ul></li></ul><h2 id="代数方程组"><a href="#代数方程组" class="headerlink" title="代数方程组"></a>代数方程组</h2><ul><li>$ax-b=0(a是m*n矩阵)$的方程类型<ul><li>恰定：$m=n$</li><li>超定：$m&gt;n$</li><li>欠定：$m&lt;n$</li></ul></li></ul><h3 id="恰定"><a href="#恰定" class="headerlink" title="恰定"></a>恰定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = inv(a)*b;</span><br><span class="line">x = a/b;</span><br></pre></td></tr></table></figure><ul><li>$x=a^{-1}b$</li><li>除解法的速度<strong>更快</strong></li></ul><h3 id="超定"><a href="#超定" class="headerlink" title="超定"></a>超定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = a/b; <span class="comment">% 最小二乘法求近似解</span></span><br><span class="line">x = (a'*a)^<span class="number">-1</span>*a'*b;</span><br></pre></td></tr></table></figure><ul><li><code>a&#39;</code>：矩阵<code>a</code>的<strong>转置</strong></li></ul><h3 id="欠定"><a href="#欠定" class="headerlink" title="欠定"></a>欠定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = a/b; <span class="comment">% 求出0最多的解</span></span><br><span class="line">x = pinv(a) * b; <span class="comment">% 求出最小范数解</span></span><br></pre></td></tr></table></figure><h2 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h2><p>$\begin{cases} \frac{dy}{dx}=f(x,y) \\ y(x_0)=y_0 \end{cases}$</p><h3 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = dsolve(<span class="string">'eq1, eq2, ...'</span>, <span class="string">'cond1, cond2,...'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>单个方程</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsolve(<span class="string">'Dy=x'</span>, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不指定<code>x</code>时默认为<code>t</code></p></blockquote></li><li><p>方程组</p><p><img src="https://i.loli.net/2020/10/15/zQwahvJC9MHmbLs.png" alt="image-20201015134613691" style="zoom: 67%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[X,Y]=dsolve(<span class="string">'Dx+2*x-Dy=10*cos(t)'</span>, <span class="string">'Dx+Dy+2*y=4*exp(-2*t)'</span>, <span class="string">'x(0)=2, y(0)=0'</span>, <span class="string">'t'</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值解"><a href="#数值解" class="headerlink" title="数值解"></a>数值解</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[t, y] = solver(odefun, tspan, y0);</span><br></pre></td></tr></table></figure><ul><li>在区间<code>tspan</code>上用初始条件<code>y0</code>求解显式常微分方程</li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter4-符号运算"><a href="#Chapter4-符号运算" class="headerlink" title="Chapter4 符号运算"></a>Chapter4 符号运算</h1><p>全文共<code>1986</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul><li><p>和数值运算对应，使用<strong>符号</strong>表示计算结果（不给未知数赋值）。</p><ul><li><p>求解方程：$ax^2+bx+c=0$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms a b c x;</span><br><span class="line">solve(a*x^<span class="number">2</span>+b*x+c); <span class="comment">% note there is no single quote</span></span><br><span class="line">solve(a*x^<span class="number">2</span>+b*x+c==<span class="number">0</span>); <span class="comment">% note '==' instead of '='</span></span><br></pre></td></tr></table></figure></li><li><p>辨析</p><p>以$2/5+1/3$为例，数值运算的结果为$0.7333$；而$sym(2)/sym(5)+sym(1)/sym(3)$的结果为$11/15$，且这里$11/15$仍然是属于<code>sym</code>类型, 是<strong>符号数</strong>。</p><blockquote><p>符号运算只会化简到<strong>没有误差</strong>的最简形式</p></blockquote></li></ul></li><li><p>支持可变精度运算，以指定精度返回数值结果。</p></li><li><p>相比数值运算，符号运算所需运行时间较长。</p></li></ul><h2 id="符号对象"><a href="#符号对象" class="headerlink" title="符号对象"></a>符号对象</h2><ul><li><p>符号对象是一种数据结构</p></li><li><p>分类</p><ul><li><p>符号常量</p></li><li><p>符号变量</p></li><li><p>符号表达式：含有符号对象的表达式</p><blockquote><p>在MATLAB中将其存储为<strong>字符串</strong></p></blockquote></li></ul></li><li><p>符号矩阵/数组：元素是符号表达式的矩阵/数组</p></li></ul><h3 id="创建-6"><a href="#创建-6" class="headerlink" title="创建"></a>创建</h3><ul><li><p><code>sym</code>：创建<strong>单个</strong>符号对象</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = sym(A, flag);</span><br></pre></td></tr></table></figure><ul><li><p><code>A</code>：常量、变量、函数、表达式</p></li><li><p><code>flag</code>：缺省为有理数<code>r</code></p><ul><li><code>d</code>：最接近的十进制数值</li><li><code>f</code>：最接近的浮点数值</li><li><code>r</code>：最接近的有理表示</li></ul></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = sym(<span class="string">'q'</span>)      <span class="comment">% 符号变量，指定a在表达式字符串中的形式。</span></span><br><span class="line">a_1 = sym(<span class="string">'pi'</span>)  <span class="comment">% 符号变量，指定a_1在表达式字符串中的形式。</span></span><br><span class="line">b = sym(<span class="number">1</span>/<span class="number">3</span>)      <span class="comment">% 符号常量，指定b在表达式中的取值。</span></span><br><span class="line">b_1 = sym(<span class="built_in">pi</span>)  <span class="comment">% 符号常量，指定b_1在表达式中的取值。</span></span><br><span class="line">c = sym(<span class="number">2</span>*a+b)    <span class="comment">% 符号表达式</span></span><br><span class="line">d = sym(<span class="built_in">sin</span>(<span class="number">1</span>))   <span class="comment">% 符号函数</span></span><br></pre></td></tr></table></figure><ul><li><p>用<code>&#39;pi&#39;</code>创建的符号变量在<code>sin(pi)</code>时不会得到0；但是<code>sym(&#39;4&#39;)</code>和<code>sym(4)</code>没有区别，都可以运算。</p></li><li><p>符号表达式和符号函数<strong>不能够</strong>使用字符串参数，因此在构造符号表达式之前需要构造好所有的符号常量和符号变量。</p><ul><li><p>如果想要直接通过字符串创建符号表达式，则应该使用<code>str2sym</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = str2sym(<span class="string">'a*x^4+b*x^3+c*x^2+d*x+e'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>str2sym</code>对<strong>所有</strong>用字符串构造符号表达式的方式<strong>都适用</strong></p></blockquote></li></ul></li><li><p>使用符号对象创建符号对象（拷贝构造）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = sym(<span class="number">10</span>);</span><br><span class="line">b = sym(a);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>syms</code>：一次性创建多个符号对象</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syms a b c; <span class="comment">% 只能用空格分隔</span></span><br><span class="line"><span class="comment">% equals to</span></span><br><span class="line">a = sym(<span class="string">'a'</span>);</span><br><span class="line">b = sym(<span class="string">'b'</span>);</span><br><span class="line">c = sym(<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></li><li><p>符号表达式</p><ul><li><p>单引号（不推荐）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="string">'sin(x)+cos(x)'</span>;</span><br></pre></td></tr></table></figure><blockquote><ul><li>字符间<strong>不能</strong>添加空格</li><li>在2020版本中不能够创建表达式，只能够表示单纯的字符串。</li></ul></blockquote></li><li><p><code>sym</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = sym(<span class="string">'sin(x)+cos(x)'</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用已经定义的符号变量组（推荐）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syms x</span><br><span class="line">f = <span class="number">3</span>*<span class="built_in">sin</span>(x)+<span class="built_in">cos</span>(x)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>符号矩阵</p><ul><li><p><code>sym</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = sym(<span class="string">'[1+x,sin(x);5,exp(x)]'</span>);</span><br></pre></td></tr></table></figure></li><li><p>数值矩阵转换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = [<span class="number">2</span>/<span class="number">3</span>, <span class="built_in">sqrt</span>(<span class="number">2</span>); <span class="number">5.2</span>, <span class="built_in">log</span>(<span class="number">3</span>)];</span><br><span class="line">C = sym(B);</span><br></pre></td></tr></table></figure></li><li><p>符号矩阵的引用和修改和数值矩阵相同</p></li></ul></li></ul><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>和数值运算中的规则、符号都相同。</p><h3 id="符号表达式"><a href="#符号表达式" class="headerlink" title="符号表达式"></a>符号表达式</h3><ul><li><p><code>numden</code>：通分并提取符号表达式的分子和分母</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N, D] = numden(f);</span><br></pre></td></tr></table></figure><ul><li><code>N</code>：通分后的<strong>分子</strong></li><li><code>D</code>：通分后的<strong>分母</strong></li></ul></li><li><p><code>factor</code>：因式分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = x^<span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">factor</span>(f);</span><br></pre></td></tr></table></figure><ul><li><p>可以用于<strong>正整数</strong>的分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">factor</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">% s = 2 2 5 5</span></span><br></pre></td></tr></table></figure></li><li><p>可以用于<strong>大正整数符号变量</strong>的分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">factor</span>(sym(<span class="string">'1234567891011121314'</span>));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>expand</code>：符号表达式展开</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = (x+<span class="number">1</span>)^<span class="number">6</span>;</span><br><span class="line">expand(f);</span><br></pre></td></tr></table></figure></li><li><p><code>collect</code>：合并同类项</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collect(s); <span class="comment">% 对符号表达式默认变量合并</span></span><br><span class="line">collect(s, v); <span class="comment">% 对符号表达式s按变量v合并</span></span><br></pre></td></tr></table></figure></li><li><p>化简</p><ul><li><p><code>simplify(f)</code></p><ul><li><p>获取最短的化简结果</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simplify(f, <span class="string">'IgnoreAnalyticConstraints'</span>, <span class="built_in">true</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>simple</code>：多种规则返回最少数目字符的字符</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[How, y] = simple(f);</span><br></pre></td></tr></table></figure><ul><li><code>How</code>：记录使用的方法</li><li><code>y</code>：最简短形式</li></ul></li></ul></li><li><p><code>horner</code>：求多项式的嵌套形式（秦九韶算法）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = x^<span class="number">4</span> + <span class="number">2</span>*x^<span class="number">3</span> + <span class="number">4</span>*x^<span class="number">2</span> + x + <span class="number">1</span>;</span><br><span class="line">g = horner(f);</span><br><span class="line"><span class="comment">% g = x*(x*(x*(x+2)+4)+1)+1</span></span><br></pre></td></tr></table></figure></li><li><p><code>pretty</code>：格式美化，转换为手写格式。</p></li><li><p>多项式转换</p><ul><li><p><code>sym2poly</code>：将符号表达式转换为<strong>降幂排列</strong>的<strong>系数行向量</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = sym(<span class="string">'2*x+3*x^2+1'</span>);</span><br><span class="line">sym2poly(f);</span><br></pre></td></tr></table></figure></li><li><p><code>poly2sym</code>：将行向量按<strong>幂降序</strong>转换为符号表达式，变量默认为<code>x</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = poly2sym([<span class="number">1</span> <span class="number">3</span> <span class="number">2</span>])</span><br><span class="line"><span class="comment">% x^2 + 3*x + 2</span></span><br></pre></td></tr></table></figure></li><li><p>只能对<strong>单符号</strong>表达式进行转换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">c = sym(<span class="number">1</span>);</span><br><span class="line">f = str2sym(<span class="string">'x+c'</span>);</span><br><span class="line">sym2poly(f);</span><br></pre></td></tr></table></figure><ul><li>尽管<code>c</code>是符号常量，但是依然不能够转换。</li></ul></li></ul></li><li><p><code>findsym</code>：查找符号<strong>变量</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findsym(s, n); <span class="comment">% 返回符号表达式s中的n个符号变量</span></span><br></pre></td></tr></table></figure><ul><li><p>当<code>n</code>不指定时，<strong>无序</strong>返回所有符号变量。</p></li><li><p>默认符号变量的选取：先选择<code>x</code>，如果<code>x</code>不存在，则选择在字母顺序中<strong>最接近</strong><code>x</code>的字符变量；如果距离相等，则选择<code>x</code><strong>后面</strong>的字符变量。</p><blockquote><p>注意：<strong>大写</strong>字母比<strong>小写</strong>字母都靠后（和ASCII码<strong>相反</strong>）</p></blockquote></li><li><p>符号常量<strong>不会</strong>被返回</p></li></ul></li><li><p><code>subs</code>：符号变量的替换</p><ul><li><code>subs(f, a)</code>：用<code>a</code>替换表达式<code>f</code>中的（第一）自由变量</li><li><code>subs(f, x, a)</code>：用<code>a</code>替换<code>f</code>中的指定符号变量<code>x</code></li></ul><blockquote><p>在数字信号处理中，进行移位、反褶、尺度变换。</p></blockquote></li><li><p><code>compose</code>：复合函数运算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compose(f, g); <span class="comment">% f(g(X))</span></span><br><span class="line">compose(f, g, z); <span class="comment">% f(g(z))</span></span><br></pre></td></tr></table></figure></li><li><p><code>finverse</code>：反函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = finverse(f);</span><br><span class="line">g = finverse(f, v); <span class="comment">% 指定默认变量</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h3><h4 id="运算方式"><a href="#运算方式" class="headerlink" title="运算方式"></a>运算方式</h4><ul><li>数值型</li><li>有理数型</li><li><code>VPA</code>型：Maple的任意精度运算</li></ul><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="number">2</span>/<span class="number">3</span>; <span class="comment">% 0.6667</span></span><br><span class="line">a2 = sym(<span class="number">2</span>/<span class="number">3</span>); <span class="comment">% 2/3</span></span><br><span class="line">a3 = vpa(<span class="string">'2/3'</span>, <span class="number">32</span>); <span class="comment">% 0.66666666666666666666666666666667</span></span><br></pre></td></tr></table></figure><ul><li><code>digits</code>：显示当前计算精度</li><li><code>digits(n)</code>：设置数值型计算精度</li><li><code>xr = vpa(x)</code>：在<code>digits</code>精度下的数值型结果<code>xr</code></li><li><code>xr = vpa(x, n)</code>：在指定精度<code>n</code>下的数值型结果<code>xr</code></li></ul><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><ul><li><code>sym</code>：数值型转换为有理数型的符号对象</li><li><code>vpa(x, n)</code>：转换为VPA型符号对象</li><li><code>double</code>：转换为数值对象</li></ul><h2 id="符号微积分"><a href="#符号微积分" class="headerlink" title="符号微积分"></a>符号微积分</h2><ul><li><p><code>limit</code>：符号极限</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">limit(f); <span class="comment">% 函数在x=0的极限值</span></span><br><span class="line">limit(f, x, a); <span class="comment">% 函数在x趋于a的极限值</span></span><br><span class="line">limit(f, x, a, <span class="string">'left'</span>); <span class="comment">% 左极限</span></span><br><span class="line">limit(f, x, a, <span class="string">'right'</span>); <span class="comment">% 右极限</span></span><br></pre></td></tr></table></figure></li><li><p><code>diff</code>：符号导数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = diff(f);</span><br><span class="line">g = diff(f, v);</span><br><span class="line">g = diff(f, n); <span class="comment">% 对默认变量求n阶导</span></span><br><span class="line">g = diff(f, v, n); <span class="comment">% 对指定变量v求n阶导</span></span><br></pre></td></tr></table></figure></li><li><p><code>int</code>：符号积分</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int(f);</span><br><span class="line">int(f, v);</span><br><span class="line">int(f, a, b); <span class="comment">% 定积分</span></span><br><span class="line">int(f, v, a, b);</span><br></pre></td></tr></table></figure><ul><li><p>与数值积分辨析</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">digits(<span class="number">128</span>);</span><br><span class="line">fun = inline(<span class="string">'-x.^2+115'</span>, <span class="string">'x'</span>);</span><br><span class="line"><span class="comment">% numerical</span></span><br><span class="line">rn_1 = polyint([<span class="number">-1</span>, <span class="number">0</span>, <span class="number">115</span>]);</span><br><span class="line">fn_2 = quad(fun, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">fn_3 = quadl(fun, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">% symbolic</span></span><br><span class="line">rs = int(str2sym(<span class="string">'-x^2+115'</span>), <span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fourier</code>：傅里叶变换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fourier(ft, t, w);</span><br><span class="line">ifourier(Fw, w, t)</span><br></pre></td></tr></table></figure></li><li><p><code>symsum</code>：级数求和</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">symsum(f, v, a, b);</span><br><span class="line">symsum(f, a, b);</span><br></pre></td></tr></table></figure></li><li><p><code>laplace</code></p></li><li><p><code>taylor</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taylor(f); <span class="comment">% 默认为6阶麦克劳林多项式</span></span><br><span class="line">taylor(f, n, v); <span class="comment">% (n-1)阶麦克劳林多项式</span></span><br><span class="line">taylor(f, n, v, a); <span class="comment">% 在a附近的(n-1)阶展开式</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="符号方程"><a href="#符号方程" class="headerlink" title="符号方程"></a>符号方程</h2><ul><li><p><code>solve</code>：解析解</p><ul><li><code>solve(f)</code></li></ul></li><li><p><code>solve(&#39;eq1&#39;, &#39;eq2&#39;, ..., &#39;v1&#39;, &#39;v2&#39;, ...)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">eq1 = str2sym(<span class="string">'x^2+2*x+1=0'</span>);</span><br><span class="line">solve(eql);</span><br><span class="line">solve(x^<span class="number">2</span>+<span class="number">2</span>*x+<span class="number">1</span>==<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p>如果用<code>=</code>则必须传入符号表达式对象，如果是现场构造则是<code>==</code>.</p><blockquote><p>如果是<code>=0/==0</code>则可以直接省略</p></blockquote></li></ul></li><li><p><code>dsolve</code>：微分方程解析解</p></li></ul><h2 id="符号函数可视化"><a href="#符号函数可视化" class="headerlink" title="符号函数可视化"></a>符号函数可视化</h2><ul><li><p><code>ezplot()</code>：绘制符号表达式的函数曲线</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ezplot(<span class="string">'x^2*y+y+2'</span>);</span><br></pre></td></tr></table></figure><ul><li><code>ezplot(3)</code>：三维曲线</li></ul></li><li><p><code>ezcontour</code>：绘制带填充颜色的等高线</p></li><li><p><code>ezmesh</code>：绘制带等位线的<strong>三维网格图</strong></p></li><li><p><code>ezsurf</code>：绘制带等位线的<strong>曲面图</strong></p></li><li><p><code>ezploar</code>：绘制极坐标曲线</p></li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter5-图形绘制"><a href="#Chapter5-图形绘制" class="headerlink" title="Chapter5 图形绘制"></a>Chapter5 图形绘制</h1><p>全文共<code>2134</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="二维图形"><a href="#二维图形" class="headerlink" title="二维图形"></a>二维图形</h2><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p><code>plot</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(Y) <span class="comment">% 以Y的索引/向量实部为横坐标</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y) <span class="comment">% X和Y的维度需要相同</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y, s) <span class="comment">% s设置线形 颜色 标记</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y, <span class="string">'PropName'</span>, PropVal) <span class="comment">% 设置图形属性</span></span><br><span class="line"><span class="built_in">plot</span>(X1, Y1, s1, X2, Y2, s2)</span><br></pre></td></tr></table></figure><ul><li><p>默认按照<strong>蓝色实线</strong>绘制，并做<strong>平滑</strong>处理。</p></li><li><p>统一<code>x</code>轴绘制</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(t,[y',y1',y2',y3',y4',y5'])</span><br></pre></td></tr></table></figure><blockquote><p>纵坐标<strong>行</strong>向量需要<strong>转置</strong>变成<strong>列</strong>向量</p></blockquote></li></ul></li><li><p><code>plotyy</code>：双<code>y</code>轴绘图，绘制横坐标相同，但是纵坐标对应的变量量纲、范围等不同的图形。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plotyy(X1, Y1, X2, Y2)</span><br><span class="line">plotyy(X1, Y1, X2, Y2, FUN) <span class="comment">% FUN指定绘图函数如@plot/@semilogx/@semilogy@loglog</span></span><br><span class="line">plotyy(X1, Y1, X2, Y2, fun1, fun2)</span><br></pre></td></tr></table></figure><ul><li><p><code>Y1</code>默认在左侧，<code>Y2</code>默认在右侧。</p></li><li><p><code>plotyy</code><strong>不能够</strong>直接对曲线属性进行设置，需要使用<strong>句柄图形</strong>控制完成。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">  y1 = <span class="number">200</span> * <span class="built_in">exp</span>(<span class="number">-0.05</span> * x) .* <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="number">0.8</span> * <span class="built_in">exp</span>(<span class="number">-0.5</span> * x) .* <span class="built_in">sin</span>(<span class="number">10</span> * x);</span><br><span class="line">  [AX, H1, H2] = plotyy(x, y1, x, y2, <span class="string">'plot'</span>);</span><br><span class="line">pause;</span><br><span class="line">  set(H1, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>AX(1)</code>和<code>AX(2)</code>对应两侧坐标轴的句柄，表示坐标轴属性。</p></li><li><p><code>H1</code>和<code>H2</code>是对应的曲线的句柄，可以根据函数的返回值进行操作。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(H1, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>)</span><br><span class="line">set(H2, <span class="string">'LineStyle'</span>, <span class="string">':'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>semilogx</code>：<code>x</code>轴取对数（<strong>10</strong>为底）的绘图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semilogx(x, y, <span class="string">'-*'</span>)</span><br><span class="line">semilogy(x, <span class="number">10.</span>^x)</span><br></pre></td></tr></table></figure></li><li><p><code>semilogy</code></p></li><li><p><code>loglog</code>：两个维度上都取对数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">logspace</span>(<span class="number">-1</span>,<span class="number">2</span>); <span class="comment">% 10^-1 ~ 10^2</span></span><br><span class="line">loglog(x,<span class="built_in">exp</span>(x),<span class="string">'-s'</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><ul><li><code>logspace</code>：对数空间中，以10为底数生成值（和<code>linspace</code>对应）。</li></ul></li><li><p><code>polar</code>：极坐标图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polar(theta, rho)</span><br><span class="line">polar(theta, rho, s)</span><br></pre></td></tr></table></figure><ul><li><p><code>theta</code>是<strong>弧度制</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="number">2</span> * <span class="built_in">pi</span> / <span class="number">90</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(<span class="number">4</span> * t);</span><br><span class="line">polar(t, y);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h3><h4 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h4><ul><li><code>-</code>：实线</li><li><code>--</code>：虚线</li><li><code>:</code>：点线</li><li><code>-.</code>：点划线</li><li><code>none</code>：无线</li></ul><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><ul><li><code>b</code>：蓝色</li><li><code>g</code>：绿色</li><li><code>m</code>：红紫色</li><li><code>w</code>：白色</li><li><code>c</code>：蓝绿色</li><li><code>k</code>：黑色</li><li><code>r</code>：红色</li><li><code>y</code>：黄色</li></ul><h4 id="标记符号"><a href="#标记符号" class="headerlink" title="标记符号"></a>标记符号</h4><p>对曲线上有值的点进行标记</p><ul><li><code>*</code>：星号</li><li><code>x</code>：叉号</li><li><code>s</code>：方块</li><li><code>p</code>：五角星</li><li><code>^</code>/<code>&gt;</code>/<code>.</code>/<code>O</code>/<code>d</code>/<code>h</code>/<code>v</code>/<code>&lt;</code></li></ul><h4 id="图形属性"><a href="#图形属性" class="headerlink" title="图形属性"></a>图形属性</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">tan</span>(<span class="built_in">sin</span>(x)) - <span class="built_in">cos</span>(<span class="built_in">tan</span>(x));</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">'--rp'</span>, <span class="string">'LineWidth'</span>, <span class="number">3</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'k'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'m'</span>, <span class="string">'MarkerSize'</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure><ul><li><code>LineStyle</code></li><li><code>LineWidth</code></li><li><code>Marker</code>：数据点标记符号</li><li><code>MarkerSize</code>：标记符大小</li><li><code>MarkerEdgeColor</code>：标记符<strong>边缘</strong>颜色</li><li><code>MarkerFaceColor</code>：标记符<strong>填充</strong>颜色</li></ul><h4 id="文字标注"><a href="#文字标注" class="headerlink" title="文字标注"></a>文字标注</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">y1 = <span class="built_in">sin</span>(t); y2 = <span class="built_in">cos</span>(t); <span class="built_in">plot</span>(t, y1, <span class="string">'r'</span>, t, y2, <span class="string">'b--'</span>);</span><br><span class="line">x = [<span class="number">1.7</span> * <span class="built_in">pi</span>; <span class="number">1.6</span> * <span class="built_in">pi</span>];</span><br><span class="line">y = [<span class="number">-0.3</span>; <span class="number">0.8</span>];</span><br><span class="line">s = [<span class="string">'sin(t)'</span>; <span class="string">'cos(t)'</span>];</span><br><span class="line">text(x, y, s);</span><br><span class="line">title(<span class="string">'正弦和余弦曲线'</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'正弦'</span>, <span class="string">'余弦'</span>)</span><br><span class="line">xlabel(<span class="string">'时间t'</span>), ylabel(<span class="string">'正弦、余弦'</span>)</span><br><span class="line">grid</span><br><span class="line">axis square</span><br></pre></td></tr></table></figure><ul><li><p><code>title(s)</code>：图标题</p></li><li><p><code>xlabel(s)</code>：横坐标名</p></li><li><p><code>ylabel(s)</code></p></li><li><p><code>legend(s, position)</code>：在指定位置建立<strong>图例</strong>，按照绘图函数的<strong>参数顺序</strong>生成。</p><ul><li><code>s</code>：图例中的文字注释，可用<code>s1,s2,...</code>表示。</li><li><code>position</code>：指定图例位置<ul><li><code>0</code>：自动最佳位置（<strong>不</strong>覆盖原图）</li><li><code>1</code>：右上角<strong>（默认）</strong></li><li><code>2</code>：左上角</li><li><code>3</code>：左下角</li><li><code>4</code>：右下角</li><li><code>-1</code>：图<strong>右侧</strong></li></ul></li></ul></li><li><p><code>text(x, y, s)</code>：在<code>x</code>轴和<code>y</code>轴的指定位置添加<strong>文字注释</strong></p><blockquote><p><code>x</code>和<code>y</code>是值列表</p></blockquote></li></ul><h4 id="重叠绘图"><a href="#重叠绘图" class="headerlink" title="重叠绘图"></a>重叠绘图</h4><ul><li><code>hold on</code>：保持当前图形</li><li><code>hold off</code>：<strong>取消</strong>当前图形的保持功能</li><li><code>hold</code>：<strong>双向</strong>切换开关（对当前状态取反）</li></ul><h4 id="多子图绘制"><a href="#多子图绘制" class="headerlink" title="多子图绘制"></a>多子图绘制</h4><ul><li><p><code>subplot</code>：在一图形中同时显示<strong>多幅独立</strong>的子图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplot(m, n, k) <span class="comment">% m行n列个子图 k是子图编号</span></span><br><span class="line">subplot(<span class="string">'Position'</span>, [left bottom width height]) <span class="comment">% 在指定位置上分割子图 并成为当前图</span></span><br></pre></td></tr></table></figure><ul><li><p>所有子图<strong>彼此独立</strong>，绘图命令可以在子图中使用。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">y0 = <span class="built_in">sin</span>(t); y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t); y3 = <span class="built_in">cos</span>(<span class="number">2</span> * t);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">% 左上</span></span><br><span class="line"><span class="built_in">plot</span>(t, y0)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">% 右上</span></span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">% 左下</span></span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">% 右下</span></span><br><span class="line"><span class="built_in">plot</span>(t, y3)</span><br></pre></td></tr></table></figure><blockquote><p>注意和<code>legend</code>中的位置进行区分</p></blockquote></li><li><p>非等比例子图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">y0 = <span class="built_in">sin</span>(t); y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t); y3 = <span class="built_in">cos</span>(<span class="number">2</span> * t);</span><br><span class="line">positionVector1 = [<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">0.3</span>];</span><br><span class="line">subplot(<span class="string">'Position'</span>, positionVector1)</span><br><span class="line"><span class="built_in">plot</span>(t, y0)</span><br><span class="line">positionVector2 = [<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.3</span>];</span><br><span class="line">subplot(<span class="string">'Position'</span>, positionVector2)</span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line">subplot(<span class="string">'Position'</span>, [<span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>])</span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="多窗口绘图"><a href="#多窗口绘图" class="headerlink" title="多窗口绘图"></a>多窗口绘图</h4><ul><li><p><code>figure(n)</code>：创建绘图窗口，<code>n</code>是窗口顺序号。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(t);</span><br><span class="line">y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(t, y)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br></pre></td></tr></table></figure><blockquote><p><code>figure1</code><strong>不需要</strong>单独指定</p></blockquote></li></ul><h4 id="坐标轴控制"><a href="#坐标轴控制" class="headerlink" title="坐标轴控制"></a>坐标轴控制</h4><ul><li><p><code>axis</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">x = <span class="built_in">cos</span>(t);</span><br><span class="line">y = <span class="number">2</span> * <span class="built_in">sin</span>(t);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="built_in">plot</span>(x, y); title(<span class="string">'nomal'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="built_in">plot</span>(x, y); axis equal; title(<span class="string">'equal'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="built_in">plot</span>(x, y); axis square; title(<span class="string">'square'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="built_in">plot</span>(x, y); axis image; title(<span class="string">'image'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="built_in">plot</span>(x, y); axis tight; title(<span class="string">'tight'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>); <span class="built_in">plot</span>(x, y); axis off; title(<span class="string">'axis off'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="网格线与坐标框"><a href="#网格线与坐标框" class="headerlink" title="网格线与坐标框"></a>网格线与坐标框</h4><ul><li><code>grid</code><ul><li><code>grid on</code></li><li><code>grid off</code></li><li><code>grid</code></li></ul></li><li><code>box</code>：确定当前坐标框是否呈封闭形式（省略上框线和右框线）<ul><li><code>box on</code></li><li><code>box off</code></li><li><code>box</code></li></ul></li></ul><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul><li><p><code>bar</code>：垂直条形图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Y = <span class="built_in">round</span>(<span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">3</span>)*<span class="number">10</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">bar(Y,<span class="string">'grouped'</span>)</span><br><span class="line">title <span class="string">'Group'</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">bar(Y,<span class="string">'stacked'</span>)</span><br><span class="line">title <span class="string">'Stack'</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">bar(Y,<span class="number">2.0</span>)</span><br><span class="line">title <span class="string">'Width = 2.0’</span></span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>和<code>.*</code>的区别</p><ul><li><p>对于矩阵运算来说，<code>*</code>是标准的矩阵点乘。</p></li><li><p>对于矩阵和数字的运算来说，二者<strong>没有</strong>区别。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[a b c d]</span><br><span class="line"><span class="number">2.</span>*A=[<span class="number">2</span>*a  <span class="number">2</span>*b  <span class="number">2</span>*c  <span class="number">2</span>*d]</span><br><span class="line"><span class="number">2</span>*A=[<span class="number">2</span>*a  <span class="number">2</span>*b  <span class="number">2</span>*c  <span class="number">2</span>*d]</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p><code>barh</code>：水平条形图（横向是<code>Y</code>轴）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">barh(x, y, <span class="string">'grouped'</span>); <span class="comment">% groups by row</span></span><br><span class="line">title(<span class="string">'Grouped Style'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">barh(x, y, <span class="string">'stacked'</span>); <span class="comment">% stacks values in each row together</span></span><br><span class="line">title(<span class="string">'Stacked Style'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">barh(x, y, <span class="string">'hist'</span>); <span class="comment">% centers bars over x values</span></span><br><span class="line">title(<span class="string">'hist Style'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>errorbar</code>：误差图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="built_in">pi</span>;</span><br><span class="line">Y = <span class="built_in">sin</span>(X);</span><br><span class="line">E = std(Y) * <span class="built_in">ones</span>(<span class="built_in">size</span>(X));</span><br><span class="line">errorbar(X, Y, E)</span><br></pre></td></tr></table></figure></li><li><p><code>area</code>：面积图，即填充曲线的积分面积。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="number">2</span> * <span class="built_in">sin</span>(t);</span><br><span class="line">area(t, y)</span><br></pre></td></tr></table></figure></li><li><p><code>hist</code>：柱形图，用于显示数据分布情况。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = <span class="built_in">randn</span>(<span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line">hist(y, x)</span><br><span class="line"><span class="comment">% 设置柱形图的效果</span></span><br><span class="line">h = findobj(gca, <span class="string">'Type'</span>, <span class="string">'patch'</span>);</span><br><span class="line">set(h, <span class="string">'FaceColor'</span>, <span class="string">'r'</span>, <span class="string">'EdgeColor'</span>, <span class="string">'w'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>柱形图和条形图的区别</p><ul><li>条形图用来表达数据间的比较关系，例如不同产品的销售情况。（自变量是产品种类）</li><li>柱形图用来展示数据的分布或趋势变化，自变量通常是<strong>量化数据</strong>。</li><li>柱形图不同柱一般<strong>不能</strong>重新排序，而条形图不同条<strong>可以任意</strong>重新排序。</li><li>柱形图各个柱之间通常<strong>没有</strong>空隙</li><li>柱形图的<strong>纵轴</strong>通常是横轴元素的<strong>计数结果</strong></li></ul></blockquote></li><li><p><code>stem</code>：火柴杆图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">25</span>;</span><br><span class="line">y = [<span class="built_in">exp</span>(<span class="number">-.07</span> * x) .* <span class="built_in">cos</span>(x); <span class="built_in">exp</span>(<span class="number">.05</span> * x) .* <span class="built_in">cos</span>(x)]';</span><br><span class="line">h = stem(x, y);</span><br><span class="line">set(h(<span class="number">1</span>), <span class="string">'MarkerFaceColor'</span>, <span class="string">'blue'</span>)</span><br><span class="line">set(h(<span class="number">2</span>), <span class="string">'MarkerFaceColor'</span>, <span class="string">'red'</span>, <span class="string">'Marker'</span>, <span class="string">'square'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>stairs</code>：阶梯图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-2</span> * <span class="built_in">pi</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(x);</span><br><span class="line">stairs(x, y);</span><br></pre></td></tr></table></figure></li><li><p><code>pie</code>：扇形图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2.5</span> <span class="number">4.5</span> <span class="number">1.5</span> <span class="number">0.5</span>];</span><br><span class="line">explode = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">pie(x, explode);</span><br><span class="line">colormap jet</span><br></pre></td></tr></table></figure></li><li><p><code>compass</code>：罗盘图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">randn</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">%实部对应的数据</span></span><br><span class="line">v = <span class="built_in">randn</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">%虚部对应的数据</span></span><br><span class="line">z = <span class="built_in">exp</span>(<span class="built_in">i</span> * <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">6</span>)); <span class="comment">%复数数组</span></span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">compass(u, v)<span class="comment">%利用实部与虚部绘制罗盘图</span></span><br><span class="line">xlabel(<span class="string">'(a) 利用实部与虚部绘制罗盘图'</span>);</span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">compass(z); <span class="comment">%利用复数绘制罗盘图</span></span><br><span class="line">xlabel(<span class="string">'(b) 利用复数绘制罗盘图'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>feather</code>：羽毛图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">theta = (<span class="number">-90</span>:<span class="number">10</span>:<span class="number">90</span>) * <span class="built_in">pi</span> / <span class="number">180</span>;</span><br><span class="line">r = <span class="number">2</span> * <span class="built_in">ones</span>(<span class="built_in">size</span>(theta));</span><br><span class="line"><span class="comment">%将极坐标系转换为笛卡儿坐标系</span></span><br><span class="line">[u, v] = <span class="built_in">pol2cart</span>(theta, r);</span><br><span class="line">feather(u, v);</span><br></pre></td></tr></table></figure></li></ul><h2 id="三维图形"><a href="#三维图形" class="headerlink" title="三维图形"></a>三维图形</h2><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p><code>plot3</code>：调用格式和<code>plot</code>一致</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot3</span>(x, y, z, <span class="string">'r*-'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>ezplot3</code>：对符号函数进行绘制</li></ul></li><li><p><code>mesh</code>：网格图函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x, y, z] = peaks(<span class="number">30</span>);</span><br><span class="line">mesh(x, y, z)</span><br></pre></td></tr></table></figure><ul><li><code>ezmesh</code>：符号函数的网格图绘制</li></ul></li><li><p><code>surf</code>：对网格进行填充</p><ul><li><code>ezsurf</code></li></ul></li><li><p><code>meshgrid</code>：生成二元函数$z=f(x,y)$中$X-Y$平面上的句型定义域中的数据点矩阵$X$和$Y$.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[X, Y] = <span class="built_in">meshgrid</span>(<span class="number">-2</span>:<span class="number">.2</span>:<span class="number">2</span>, <span class="number">-2</span>:<span class="number">.2</span>:<span class="number">2</span>);</span><br><span class="line">Z = X .* <span class="built_in">exp</span>(-X.^<span class="number">2</span> - Y.^<span class="number">2</span>);</span><br><span class="line">surf(X, Y, Z)</span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊情况-1"><a href="#特殊情况-1" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul><li><code>bar3</code></li><li><code>bar3h</code></li><li><code>cylinder</code></li><li><code>sphere</code></li><li><code>stem3</code></li><li><code>contour3</code></li><li><code>waterfall</code></li><li><code>pie3</code></li><li><code>surfnorm</code></li></ul><h3 id="修饰-1"><a href="#修饰-1" class="headerlink" title="修饰"></a>修饰</h3><ul><li><p><code>view</code>：控制三维图形的观察点和视角</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view(AZ, EL)</span><br></pre></td></tr></table></figure><ul><li><p><code>AZ</code>：方位角，<strong>角度制</strong>。</p><blockquote><p>绕<code>Z</code>轴<strong>顺时针为正</strong>，逆时针为负。</p></blockquote></li><li><p><code>EL</code>：仰角</p></li></ul></li><li><p><code>colormap</code>：图形颜色</p></li><li><p><code>alpha</code>：透明度</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha(v) <span class="comment">% v介于0和1之间 表示透明度大小</span></span><br><span class="line">alpha(<span class="string">'x'</span>) <span class="comment">% 随x变大透明度值变大</span></span><br><span class="line">alpha(<span class="string">'rand'</span>) <span class="comment">% 随机设置透明度</span></span><br></pre></td></tr></table></figure><ul><li>透明度值<strong>越大</strong>，图像越<strong>不透明</strong>。</li></ul></li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter6-图像处理"><a href="#Chapter6-图像处理" class="headerlink" title="Chapter6 图像处理"></a>Chapter6 图像处理</h1><p>全文共<code>3427</code>字，推荐阅读时间<code>25~30</code>分钟。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><p>采样（空间离散）：将连续图像变化为离散点的操作，即将图像划分为$M * N$网格，每个网格只提取出一个值。</p><blockquote><ul><li>上采样（图像插值、放大）：放大原图像，从而可以显示在更高分辨率的显示设备上。</li><li>下采样（池化、缩小）：使得图像符合显示区域的大小；生成对应图像的缩略图；降低特征的维度并保留有效信息，一定程度上避免过拟合，保持旋转、平移、伸缩不变形。</li></ul></blockquote></li><li><p>分辨率：采样划分网格矩阵的形状尺寸</p></li><li><p>量化（灰度离散）：确定离散点数值表示的位数，反映了采样的质量。</p><ul><li><p>灰度图：1个通道，每个离散点8bit(0-255).</p><blockquote><ul><li>256个值对应的是从黑到白的不同<strong>亮度</strong>等级，<code>0</code>是纯黑，<code>255</code>是纯白。</li><li>彩色图中的RGB值也并不是各个颜色的“浓度”，只是三个分量的灰度值，分别命名为R，G，B.也就是说，RGB图各分量<strong>并不是</strong>彩色的，而是三张灰度图，RGB只是一种来自三原色的命名。</li><li>当三色灰度”效果“相同时，产生不同灰度值的灰色调。<ul><li><code>Gray = R*0.299 + G*0.587 + B*0.114</code>（心理学公式）</li><li><code>Gray = (R*299 + G*587 + B*114 + 500) / 1000</code></li></ul></li></ul></blockquote></li><li><p>二值图：1个通道，每个离散点1bit(0-1).</p></li><li><p>彩色图：3个通道（3张灰度图），各个通道每个离散点8bit(0-255)，合成为24bit.</p><ul><li><p>以红色椅子的显示为例。</p><p>R分量的图上，椅子对应的部分比较浅（灰度值高），而在G分量和了B分量上很深。<br>随便在椅子上取一个样点，其灰度值分别是（R:179,G:45,B:9）。所以在显示的时候，红色通道里灰度值大，绿色通道和蓝色通道里的灰度值小，显示出来的就是红色。</p><blockquote><p>用灰度图的<strong>亮暗</strong>来表示三种颜色的浓度，每个通道就是指定了颜色的”颜料“，然后合并出不同的颜色，和自然界中的光的合成<strong>并不相同</strong>。</p></blockquote></li></ul></li></ul><blockquote><p>视频尺寸：时域离散*空域（空间）离散*灰度离散=<u>FPS</u>*<u>1080*720</u>*<u>3*8</u></p></blockquote></li><li><p>矢量图（图形）：一般由轮廓线构成，是用软件绘制的。不易失真，但是颜色相对没有那么丰富。</p></li><li><p>点阵图（位图，图像）：设备捕捉实际画面产生的数字矩阵，存储空间大，颜色丰富。</p></li></ul><h2 id="类型及转换"><a href="#类型及转换" class="headerlink" title="类型及转换"></a>类型及转换</h2><ul><li><p>格式</p><ul><li><p><code>double</code>：亮度值范围是<code>[0,1]</code></p><blockquote><p>通常使用<code>double</code>减少图像失真</p></blockquote></li><li><p><code>uint8</code>：亮度值范围是<code>[0,255]</code></p></li></ul></li><li><p>真彩色图像</p><ul><li>大小：<code>m*n*3</code></li><li>红色分量：<code>(:,:,1)</code>（绿色，蓝色同理）</li></ul></li><li><p>索引图像：创建调色板及对应的索引图，使用索引下标表示图像的每个像素点。</p><ul><li>调色板中色彩强度范围是<code>[0,1]</code>，大小和亮度成正比。</li><li>使用索引可以有效节省存储空间</li></ul></li><li><p>图像序列</p><ul><li><p>合并</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">cat</span> (<span class="number">1</span>，A1，A2，A3，A4，A5) <span class="comment">%按列连接（列数相同）</span></span><br><span class="line">A = <span class="built_in">cat</span> (<span class="number">2</span>，A1，A2，A3，A4，A5) <span class="comment">%按行连接（行数相同）</span></span><br><span class="line">A = <span class="built_in">cat</span> (<span class="number">3</span>，A1，A2，A3，A4，A5) <span class="comment">%按矩阵连接（行列数相同）</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cat</code>的参数是几就是<strong>改变</strong>第几维</p></blockquote></li></ul></li></ul><h2 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p><code>imread</code>：读入图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=imread(filename, fmt) <span class="comment">% imread('filename.fmt')</span></span><br><span class="line">[A, map]=imread(filename, fmt) <span class="comment">% index image</span></span><br></pre></td></tr></table></figure><ul><li>读入的图像大多数为<code>uint8</code>，对于索引图则将颜色映象表存储为双精度浮点型矩阵。</li><li>如果将<code>filename</code>和<code>fmt</code>合并，则需要保证<code>filename.fmt</code>后缀的合法性。</li></ul></li><li><p><code>imwrite</code>：输出图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imwrite(A, filename, fmt) <span class="comment">% imwrite(A, 'filename.fmt')</span></span><br><span class="line">imwrite(A, map, filename, fmt)</span><br></pre></td></tr></table></figure></li><li><p><code>imfinfo</code>：获取图片信息</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imfinfo(<span class="string">'filename.fmt'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>load/save</code>：使用<code>.mat</code>文件管理图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lena=imread(<span class="string">'lena.jpg'</span>); </span><br><span class="line">imshow(lena);</span><br><span class="line">save lena; <span class="comment">%保存图像数据，生成lena.mat</span></span><br><span class="line">clear;</span><br><span class="line">load lena;</span><br><span class="line"><span class="built_in">figure</span>, imshow(lena);</span><br></pre></td></tr></table></figure></li></ul><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><ul><li><p>灰度图</p><ul><li><p>格式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imshow(I)</span><br><span class="line">imshow(I, n) <span class="comment">% n为显示灰度级数目，缺省值为256.</span></span><br><span class="line">imshow(I, [low high]) <span class="comment">% [low high]为图像数据的值域，范围外的取0或255.</span></span><br><span class="line">imshow(I, []) <span class="comment">% 默认显示范围为[min(I(:);), max(I(:);)]</span></span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(I);</span><br><span class="line"><span class="comment">%设置显示的范围，低于100的全黑，高于200的全白</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,[<span class="number">100</span> <span class="number">200</span>]);</span><br><span class="line"><span class="comment">%设置灰度级别为2; 部分版本不支持</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%设置灰度级别为8 ; 同上</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">8</span>);</span><br><span class="line"><span class="comment">%设置灰度级别为全256 ; 同上</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二值图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BW=imread(<span class="string">'circles.png'</span>);</span><br><span class="line">imshow(BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(~BW);</span><br></pre></td></tr></table></figure></li><li><p>索引图像</p><ul><li><p>格式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imshow(X, map);</span><br></pre></td></tr></table></figure><ul><li><code>map</code>是一个p×3的矩阵，元素值均为[0, 1]之间双精度浮点型数据。每一行分别表示红、绿、蓝的颜色值。</li><li>如一幅包含256色的uint8<strong>索引图像</strong>，使用一个仅有16色的调色板显示，则所有索引值大于或等于15的像素都将被显示为调色板的最后一个颜色。</li><li>常用后缀名：<code>.tiff</code>/<code>.tif</code></li></ul></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X=imread(<span class="string">'cameraman.tif'</span>); </span><br><span class="line">imshow(X); </span><br><span class="line">colorbar;</span><br><span class="line">map=pink(<span class="number">256</span>); <span class="comment">%借助不同的调色板显示图像</span></span><br><span class="line"><span class="built_in">figure</span>, imshow(X,map); colorbar; <span class="comment">%显示颜色条</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>彩色图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%调整RGB的显示顺序</span></span><br><span class="line">img=imread(<span class="string">'i.png'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(img);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(img(:,:,[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]));</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>), imshow(img(:,:,[<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]));</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>), imshow(img(:,:,[<span class="number">3</span> <span class="number">1</span> <span class="number">2</span>]));</span><br></pre></td></tr></table></figure><blockquote><p>Q：RGB的顺序为什么对显示效果有影响</p><p>A：不同通道对应的”颜料“不同，成像时根据放进该通道的<strong>灰度图分量</strong>的灰度值，来决定显示的颜色。</p></blockquote></li></ul><h2 id="代数运算"><a href="#代数运算" class="headerlink" title="代数运算"></a>代数运算</h2><ul><li><p><code>imadd</code>：加法，数值变大。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line"><span class="comment">%图像整体亮度增加</span></span><br><span class="line">J=imadd(I, <span class="number">50</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(J);</span><br></pre></td></tr></table></figure><ul><li>超出范围的部分<strong>不会</strong>溢出，而是取<strong>边界值</strong>。</li></ul><blockquote><ul><li>图像增强</li><li>图像重叠</li><li>水印加密</li><li>图像去噪</li></ul></blockquote></li><li><p><code>imsubtract</code>：减法，数值变小。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line">J=imsubtract(I, <span class="number">50</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(J);</span><br></pre></td></tr></table></figure></li><li><p><code>immultiply</code></p><ul><li><p><code>immultiply(I, n)</code>：亮度缩放</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line">J = immultiply(I,<span class="number">0.5</span>);</span><br><span class="line">K = immultiply(I,<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>), imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>), imshow(J)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>), imshow(K)</span><br></pre></td></tr></table></figure></li><li><p><code>immultiply(I, mask)</code>：掩模</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Img=imread(<span class="string">'pears.png'</span>);</span><br><span class="line">subplot(<span class="number">131</span>), imshow(Img);</span><br><span class="line">Mask=imread(<span class="string">'PearMask.bmp'</span>);</span><br><span class="line">subplot(<span class="number">132</span>), imshow(Mask);</span><br><span class="line">PearR=immultiply(Img(:,:,<span class="number">1</span>),Mask);</span><br><span class="line">PearG=immultiply(Img(:,:,<span class="number">2</span>),Mask);</span><br><span class="line">PearB=immultiply(Img(:,:,<span class="number">3</span>),Mask);</span><br><span class="line">Pear=<span class="built_in">cat</span>(<span class="number">3</span>,PearR,PearG,PearB);</span><br><span class="line">subplot(<span class="number">133</span>), imshow(Pear);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>imdivide</code></p><ul><li><p><code>imdivide(I, n)</code>：亮度缩放</p></li><li><p><code>imdivide(I, J)</code>：去除背景</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'rice.png'</span>);</span><br><span class="line">subplot(<span class="number">131</span>),imshow(I);</span><br><span class="line">background = imopen(I,strel(<span class="string">'disk'</span>,<span class="number">15</span>));</span><br><span class="line">subplot(<span class="number">132</span>), imshow(background);</span><br><span class="line">Ip = imdivide(I,background);</span><br><span class="line">subplot(<span class="number">133</span>),imshow(Ip,[])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>直接线性运算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I)</span><br><span class="line">J=(double(I))*<span class="number">1.5</span>+<span class="number">30</span>;</span><br><span class="line"><span class="built_in">figure</span>, imshow(uint8(J))</span><br><span class="line">K=(double(I))*<span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">figure</span>, imshow(uint8(K));</span><br></pre></td></tr></table></figure></li></ul><h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><ul><li><p><code>imtransform(I, T, Interp)</code>：二维空间</p><ul><li><code>T</code>：变换结构，由<code>maketform</code>产生。</li><li><code>Interp</code>：插值方法</li></ul></li><li><p>仿射变换</p><p><img src="https://i.loli.net/2020/11/19/E5Sm6GgzvuiwZOn.png" alt="image-20201119133406026" style="zoom:50%;" /></p><ul><li><p>平移</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[height,width,dim]=<span class="built_in">size</span>(A);</span><br><span class="line">tform=maketform(<span class="string">'affine'</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">20</span> <span class="number">30</span> <span class="number">1</span>]); <span class="comment">% downward</span></span><br><span class="line">B = imtransform(A,tform,<span class="string">'nearest'</span>,<span class="string">'XData'</span>,[<span class="number">1</span></span><br><span class="line"><span class="built_in">size</span>(A,<span class="number">2</span>)],<span class="string">'YData'</span>,[<span class="number">1</span> <span class="built_in">size</span>(A,<span class="number">1</span>)])</span><br><span class="line">subplot(<span class="number">121</span>);imshow(A);</span><br><span class="line">subplot(<span class="number">122</span>); imshow(B);</span><br></pre></td></tr></table></figure></li><li><p>镜像</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[height,width,dim]=<span class="built_in">size</span>(A);</span><br><span class="line">tform=maketform(<span class="string">'affine'</span>,[<span class="number">-1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]); <span class="comment">% horizontal</span></span><br><span class="line">B=imtransform(A,tform,<span class="string">'nearest'</span>);</span><br><span class="line">tform2=maketform(<span class="string">'affine'</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]); <span class="comment">% vertical</span></span><br><span class="line">C=imtransform(A,tform2,<span class="string">'nearest'</span>);</span><br><span class="line">subplot(<span class="number">131</span>); imshow(A);</span><br><span class="line">subplot(<span class="number">132</span>); imshow(B);</span><br><span class="line">subplot(<span class="number">133</span>); imshow(C);</span><br></pre></td></tr></table></figure></li><li><p>旋转</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">transformtype = <span class="string">'affine'</span>;</span><br><span class="line">transformmatrix = [<span class="built_in">cos</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="number">0</span>;</span><br><span class="line">   -<span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="built_in">cos</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="number">0</span>;</span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]; <span class="comment">% rotate 30 degrees</span></span><br><span class="line">T = maketform(transformtype,transformmatrix);</span><br><span class="line">nI = imtransform(I,T);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(nI)</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>imrotate(A, angle)</code>，指定<code>crop</code>参数后会裁剪新图以维持画布大小不变，</p></blockquote></li><li><p>缩放</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>); <span class="built_in">figure</span>, imshow(I)</span><br><span class="line">transformtype = <span class="string">'affine'</span>;</span><br><span class="line">transformmatrix1 = [<span class="number">0.5</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0.5</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">transformmatrix2 = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">2</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">T1 = maketform(transformtype,transformmatrix1);</span><br><span class="line">T2 = maketform(transformtype,transformmatrix2);</span><br><span class="line">nI1 = imtransform(I,T1);</span><br><span class="line">nI2 = imtransform(I,T2);</span><br><span class="line"><span class="built_in">figure</span>,imshow(nI1)</span><br><span class="line"><span class="built_in">figure</span>,imshow(nI2)</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>imresize(A, times)</code>，默认等比例缩放。</p></blockquote></li></ul></li><li><p>投影变换：将二维图像按照“近大远小”的规则投影到一个平面，追求立体感。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">transformtype = <span class="string">'projective'</span>;</span><br><span class="line">transformmatrix1 =[<span class="number">0.8</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">-0.2</span> <span class="number">0.8</span> <span class="number">-0.003</span>; <span class="number">3.5</span> <span class="number">1.5</span> <span class="number">1.5</span>];</span><br><span class="line">T = maketform(transformtype,transformmatrix1);</span><br><span class="line">nI = imtransform(I,T);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(nI);</span><br></pre></td></tr></table></figure><blockquote><ul><li>对失真图像进行逆变换，就可以得到正常比例的图像。</li><li>仿射变换可看作是一种特殊的投影变换。它要求变换矩阵的最后一列除最后一个元素为<code>1</code>之外，其它的均为<code>0</code>。</li></ul></blockquote></li><li><p><code>imcrop</code>：图像裁剪</p><ul><li><p>指定区域</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = imread(<span class="string">'liftingbody.png'</span>);</span><br><span class="line">pc = imcrop(p,[<span class="number">80</span> <span class="number">180</span> <span class="number">260</span> <span class="number">220</span>]); <span class="comment">%输入矩形尺度进行选取</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>); imshow(p);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>); imshow(pc);</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>参数格式：<code>[left, bottom, width, height]</code></p></blockquote><ul><li><p><code>roipoly</code>：多边形裁剪</p><ul><li><p>人工选区</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Img=imread(<span class="string">'pears.png'</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(Img)</span><br><span class="line">bw=roipoly(Img); <span class="comment">%设定区域，用鼠标选择多边形区域</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(bw) <span class="comment">%用二值色彩显示多边形区域</span></span><br><span class="line">r=Img (:,:,<span class="number">1</span>); g=Img (:,:,<span class="number">2</span>);b=Img (:,:,<span class="number">3</span>);</span><br><span class="line">cr=bw.*double(r); cg=bw.*double(g);cb=bw.*double(b);</span><br><span class="line">J=<span class="built_in">cat</span>(<span class="number">3</span>,uint8(cr),uint8(cg),uint8(cb)); <span class="comment">%联结数组作为图像色彩</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(J)</span><br></pre></td></tr></table></figure></li><li><p>指定顶点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'eight.tif'</span>);</span><br><span class="line">c = [<span class="number">222</span> <span class="number">272</span> <span class="number">300</span> <span class="number">270</span> <span class="number">221</span> <span class="number">194</span>];</span><br><span class="line">r = [<span class="number">21</span> <span class="number">21</span> <span class="number">75</span> <span class="number">121</span> <span class="number">121</span> <span class="number">75</span>];</span><br><span class="line">BW = roipoly(I,c,r);</span><br><span class="line">Ic=immultiply(I, BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I)</span><br><span class="line"><span class="built_in">figure</span>, imshow(BW)</span><br><span class="line"><span class="built_in">figure</span>, imshow(Ic)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h2><ul><li><p><code>imadjust</code>：对某一区间内的灰度值进行变换，从而符合人眼的非线性特征。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'pout.tif'</span>); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>); imshow(I);</span><br><span class="line">J=imadjust(I); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>); imshow(J); <span class="comment">% default gamma = 1</span></span><br><span class="line">K=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>); imshow(K);</span><br><span class="line">L=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>], <span class="number">2</span>); <span class="comment">% gamma = 2</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); imshow(L);</span><br><span class="line">M=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>], <span class="number">0.3</span>); <span class="comment">% gamma = 0.3</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>); imshow(M);</span><br><span class="line">N=imadjust(I,[<span class="number">0</span> <span class="number">1</span>],[<span class="number">1</span> <span class="number">0</span>]); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>); imshow(N);</span><br></pre></td></tr></table></figure><ul><li>不指定参数时，默认处理最高和最低的<code>1%</code>，从而提高图像饱和度。</li><li><code>gamma</code>越大，图像亮度越大。</li></ul></li><li><p><code>imhist</code>：灰度分布直方图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), imhist(I);</span><br></pre></td></tr></table></figure><ul><li>可以通过参数指定灰度等级数</li><li>占满整个区间的图像通常质量更高</li></ul></li><li><p><code>histeq</code>：直方图均衡化</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'pout.tif'</span>);</span><br><span class="line">subplot(<span class="number">221</span>),imshow(I);title(<span class="string">'原图'</span>);</span><br><span class="line">subplot(<span class="number">222</span>),imhist(I);title(<span class="string">'原图直方图'</span>);</span><br><span class="line">hI=histeq(I);</span><br><span class="line">subplot(<span class="number">223</span>),imshow(hI);</span><br><span class="line">title(<span class="string">'原图均衡化处理'</span>);</span><br><span class="line">subplot(<span class="number">224</span>),imhist(hI);</span><br><span class="line">title(<span class="string">'均衡处理后直方图'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h2><ul><li><p>平滑</p><ul><li>低通滤波：低频段保留</li><li>均值滤波</li><li>中值滤波</li></ul></li><li><p>锐化</p><ul><li>高通滤波：高频段保留</li></ul></li><li><p><code>imnoise</code>：模拟图像噪声</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'coins.png'</span>);</span><br><span class="line">J=imnoise(I, <span class="string">'salt &amp; pepper'</span>,<span class="number">0.06</span>); <span class="comment">%添加椒盐噪声</span></span><br><span class="line">subplot(<span class="number">221</span>),imshow(I),title(<span class="string">'原图'</span>)</span><br><span class="line">subplot(<span class="number">222</span>),imshow(J),title(<span class="string">'含椒盐噪声图'</span>)</span><br><span class="line">H = fspecial(<span class="string">'average'</span>,[<span class="number">3</span> <span class="number">4</span>]); <span class="comment">%设计均值滤波器H</span></span><br><span class="line">am = imfilter(J,H);<span class="comment">%均值滤波</span></span><br><span class="line">subplot(<span class="number">223</span>),imshow(am),title(<span class="string">'均值滤波'</span>)</span><br><span class="line">zm=medfilt2(J);<span class="comment">%中值滤波</span></span><br><span class="line">subplot(<span class="number">224</span>),imshow(zm),title(<span class="string">'中值滤波‘)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="边缘检测与分割"><a href="#边缘检测与分割" class="headerlink" title="边缘检测与分割"></a>边缘检测与分割</h2><ul><li><p><code>edge</code>：边缘处值为1，否则为0.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[e1,s1] = edge(p,<span class="string">'sobel'</span>,<span class="number">0.03</span>,<span class="string">'both'</span>); <span class="comment">% sobel算子</span></span><br><span class="line">[e2,s2] = edge(p,<span class="string">'roberts'</span>,<span class="number">0.03</span>,<span class="string">'both'</span>); <span class="comment">% roberts算子</span></span><br><span class="line">[e3,s3] = edge(p,<span class="string">'prewitt'</span>,<span class="number">0.04</span>,<span class="string">'both'</span>); <span class="comment">% prewitt算子</span></span><br><span class="line">[e4,s4] = edge(p, <span class="string">'log'</span>,<span class="number">0.003</span>,<span class="number">2.10</span>); <span class="comment">% LoG算子</span></span><br><span class="line">[e5,s5] = edge(p, <span class="string">'canny'</span>,[<span class="number">0.05</span> <span class="number">0.12</span>],<span class="number">1.6</span>); <span class="comment">%canny算子</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>),imshow(p);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>),imshow(e1);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),imshow(e2);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);imshow(e3);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>),imshow(e4);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>),imshow(e5);</span><br></pre></td></tr></table></figure></li><li><p><code>imcontour</code>：轮廓提取函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">subplot(<span class="number">131</span>), imcontour(I,<span class="number">1</span>)</span><br><span class="line">subplot(<span class="number">132</span>), imcontour(I,<span class="number">2</span>)</span><br><span class="line">subplot(<span class="number">133</span>), imcontour(I,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>阈值分割</p><ul><li><p>极小值点</p></li><li><p>迭代</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p= imread(<span class="string">'bugs.bmp'</span>);</span><br><span class="line">p=rgb2gray(p); p=im2double(p); <span class="comment">%转换为double</span></span><br><span class="line">thresh = <span class="number">0.5</span>*(<span class="built_in">min</span>(p(:)) + <span class="built_in">max</span>(p(:))); <span class="comment">%初值为中间值</span></span><br><span class="line">flag = <span class="built_in">false</span>; <span class="comment">%迭代步长控制</span></span><br><span class="line"><span class="keyword">while</span> ~flag</span><br><span class="line">g = p&gt;=thresh; <span class="comment">%按当前阈值划分</span></span><br><span class="line">thresh_1= <span class="number">0.5</span>*(<span class="built_in">mean</span>(p(g)) + <span class="built_in">mean</span>(p(~g))); <span class="comment">%新阈值</span></span><br><span class="line">flag = <span class="built_in">abs</span>(thresh - thresh_1)&lt;<span class="number">0.5</span>; <span class="comment">%更新迭代标志</span></span><br><span class="line">thresh = thresh_1; <span class="comment">%更新阈值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>最大方差</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p= imread(<span class="string">'bugs.bmp'</span>);</span><br><span class="line">p1=rgb2gray(p);</span><br><span class="line">thresh = graythresh(p1); <span class="comment">%使用Ostu算法求得新阈值</span></span><br><span class="line">g = im2bw(p1,thresh); <span class="comment">%使用thresh对图像进行分割</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>), imshow(p);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>roifilt2</code>：特定区域增强</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'pout.tif'</span>);</span><br><span class="line">imshow(I)</span><br><span class="line">BW = roipoly(I);</span><br><span class="line">H = fspecial(<span class="string">'unsharp'</span>);</span><br><span class="line">J = roifilt2(H,I,BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(J)</span><br></pre></td></tr></table></figure></li><li><p><code>roifill</code>：区域填充</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I=ind2gray(X,map);</span><br><span class="line"><span class="built_in">figure</span>,imshow(I)</span><br><span class="line">J=roifill;</span><br><span class="line"><span class="built_in">figure</span>,imshow(J)</span><br></pre></td></tr></table></figure></li></ul><h2 id="直线检测"><a href="#直线检测" class="headerlink" title="直线检测"></a>直线检测</h2><ul><li><p>基本思想：点-线对偶性，<code>xy</code>平面上直线，对应参数<code>ab</code>平面上的一个点。</p><ul><li>过<code>xy</code>平面一个点<code>(x,y)</code>的所有直线，构成参数<code>ab</code>平面上的一条直线。</li><li>如果点<code>(x1,y1)</code>与点<code>(x2,y2)</code>共线，那么这两点在参数<code>ab</code>平面上的直线将有一个交点。</li><li>在参数<code>ab</code>平面上相交直线最多的点，对应的<code>xy</code>平面上的直线就是需要的解。</li></ul></li><li><p><code>hough</code>：霍夫变换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'circuit.tif'</span>);</span><br><span class="line">I = imrotate(I,<span class="number">33</span>,<span class="string">'crop'</span>);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I), <span class="built_in">hold</span> on</span><br><span class="line">BW = edge(I,<span class="string">'canny'</span>);</span><br><span class="line">[H,T,R] = hough(BW);</span><br><span class="line"><span class="built_in">figure</span>; imshow(H,[],<span class="string">'XData'</span>,T,<span class="string">'YData'</span>,R,<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);</span><br><span class="line">xlabel(<span class="string">'\theta'</span>), ylabel(<span class="string">'\rho'</span>);</span><br><span class="line">axis on, axis normal, <span class="built_in">hold</span> on;</span><br></pre></td></tr></table></figure></li><li><p><code>houghpeaks</code>：霍夫变换矩阵中的极值点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P = houghpeaks(H,<span class="number">3</span>,<span class="string">'threshold'</span>,<span class="built_in">ceil</span>(<span class="number">0.3</span>*<span class="built_in">max</span>(H(:))));</span><br><span class="line">x = T(P(:,<span class="number">2</span>));</span><br><span class="line">y = R(P(:,<span class="number">1</span>));</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">'s'</span>,<span class="string">'color'</span>,<span class="string">'white'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>houghlines</code>：从霍夫变换矩阵中提取线段</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lines = houghlines(BW,T,R,P,<span class="string">'FillGap'</span>,<span class="number">25</span>,<span class="string">'MinLength'</span>,<span class="number">40</span>);</span><br><span class="line">max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">length</span>(lines)</span><br><span class="line">xy = [lines(k).point1; lines(k).point2];</span><br><span class="line"><span class="built_in">plot</span>(xy(:,<span class="number">1</span>),xy(:,<span class="number">2</span>),<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'green'</span>);</span><br><span class="line"><span class="comment">% Plot beginnings and ends of lines</span></span><br><span class="line"><span class="built_in">plot</span>(xy(<span class="number">1</span>,<span class="number">1</span>),xy(<span class="number">1</span>,<span class="number">2</span>),<span class="string">'x'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'yellow'</span>);</span><br><span class="line"><span class="built_in">plot</span>(xy(<span class="number">2</span>,<span class="number">1</span>),xy(<span class="number">2</span>,<span class="number">2</span>),<span class="string">'x'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'red'</span>);</span><br><span class="line"><span class="comment">% Determine the endpoints of the longest line segment</span></span><br><span class="line">len = norm(lines(k).point1 - lines(k).point2);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; max_len)</span><br><span class="line">max_len = len; xy_long = xy;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% highlight the longest line segment</span></span><br><span class="line"><span class="built_in">plot</span>(xy_long(:,<span class="number">1</span>),xy_long(:,<span class="number">2</span>),<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'blue'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>拓展：霍夫变换同样可以适用于圆的检测，此时需要三个参数的参数空间。</p></blockquote><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2020 BUAA MATLAB course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/JavaScript%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/JavaScript%20Learning%20Note/</id>
    <published>2021-06-23T12:41:59.122Z</published>
    <updated>2021-06-23T12:44:32.912Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of frontend language JavaScript.</strong></p><a id="more"></a><h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><p>全文共<code>2099</code>字，推荐阅读时间<code>10~15</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">'Hello, world'</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>也可以把JavaScript代码放到一个单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src = &quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/js/abc.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li><p>语句以<code>;</code>结束，语句块用<code>{...}</code>.</p><blockquote><p>和Java相同</p></blockquote></li><li><p>注释</p><ul><li>行：<code>//</code></li><li>块：<code>/*...*/</code></li></ul></li></ul><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ul><li><p>Number</p><p>不区分整数和浮点数，统一用Number表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>;</span><br><span class="line"><span class="number">0.456</span>;</span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// Not a Number 表示无法计算的结果</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// 无限大</span></span><br></pre></td></tr></table></figure></li><li><p>字符串</p><p>单引号或双引号括起来的文本</p></li><li><p>布尔值</p><ul><li><p><code>true</code>/<code>false</code></p></li><li><p>逻辑运算：<code>&amp;&amp;</code>/<code>||</code>/<code>!</code></p></li><li><p>比较运算符</p><ul><li><p><code>==</code>：<strong>会自动转换</strong>数据类型，可能得到奇怪的结果。</p></li><li><p><code>===</code>：<strong>不会自动转换</strong>数据类型，类型不一致会返回<code>false</code>.</p><blockquote><p>使用<code>===</code>进行比较</p></blockquote></li><li><p><code>NaN</code>和其他所有值都不相等，<strong>包括自己</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>通过<code>isNaN</code>对NaN进行判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);</span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ul></li><li><p><code>null</code>/<code>undefined</code></p><p>  两者意义相近，通常使用<code>null</code>，<code>undefined</code>仅在<strong>判断函数参数是否传递</strong>的情况下有用。</p></li><li><p>数组</p><ul><li><p>可以包括任意数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li><li><p>创建数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象</p><p>  一组由键值对组成的<strong>无序</strong>集合</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">'js'</span>, <span class="string">'web'</span>],</span><br><span class="line">    zipcode: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>key都是<strong>字符串</strong>类型</li><li>value可以是<strong>任意</strong>数据类型</li><li>使用<code>person.name</code>访问值</li></ul></li><li><p>变量</p><p>  JavaScript是<strong>动态语言</strong></p><ul><li><p>声明变量</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// $ can be used as a part of var name</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>显示变量内容：<code>console.log(x)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>alert</code>会弹出对话框，但是<code>console.log</code>不会。</li><li><code>log</code>会自动增加<strong>换行</strong></li></ul></blockquote></li><li><p>strict模式</p><ul><li><p>如果声明变量时<strong>不</strong>使用<code>var</code>，则变量就会被声明为<strong>全局变量</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>strict模式在遇到<strong>未使用</strong><code>var</code>声明的变量时会报错</p></li><li><p>开启strict模式：在第一行写上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>尽量在所有的<code>.js</code>文件中都启用strict模式</p></blockquote></li></ul></li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>多行字符串</p><p>用反引号<strong>`</strong>表示</p></li><li><p>模板字符串</p><ul><li><p>字符串可以使用<code>+</code>号链接</p></li><li><p>使用<code>${}</code>进行字符串替换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>, I'm <span class="subst">$&#123;age&#125;</span> years old!`</span></span><br></pre></td></tr></table></figure><blockquote><p>反引号也可以引出<strong>单行</strong>字符串</p></blockquote></li></ul></li><li><p>操作字符串</p><ul><li><p>获取长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</span><br><span class="line">s.length; <span class="comment">// length是一个属性</span></span><br></pre></td></tr></table></figure></li><li><p>指定索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong>超过</strong>s长度（<strong>包括</strong>访问空字符<code>\0</code>位置）时返回<code>undefined</code></p></blockquote></li><li><p>字符串<strong>不可变</strong>，对<strong>索引</strong>赋值不会引起错误，但是也<strong>不会改变</strong>字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Test'</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'X'</span>;</span><br><span class="line">alert(s); <span class="comment">// 'Test'</span></span><br></pre></td></tr></table></figure><blockquote><p>但是如果对将字符串变量<strong>整个</strong>重新赋值，就会指向一个<strong>新的字符串</strong>。</p></blockquote></li><li><p>以下函数不会改变原有字符串，而是<strong>返回</strong>新字符串。</p><ul><li><p><code>toUpperCase</code>/<code>toLowerCase</code>：改变<strong>所有字符</strong>的大小写</p></li><li><p><code>indexOf</code>：搜索指定<strong>字符串</strong>出现的<strong>首字母</strong>位置</p><blockquote><p>没有找到时返回<code>-1</code></p></blockquote></li><li><p><code>substring</code>：字符串切片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'0123456789'</span>;</span><br><span class="line">s.substring(<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// 012</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 789</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>不包括<strong>右</strong>端点</li><li>超过字符串长度<strong>不会</strong>报错，而是返回一个<strong>空字符串</strong>。</li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>数组长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr.length;</span><br></pre></td></tr></table></figure><ul><li><p><code>arr.length</code><strong>可以</strong>直接被改变，多余的位置填充<code>undefined</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// [1, 2, 3, null, true, undefined]</span></span><br><span class="line">arr.length = <span class="number">1</span>;</span><br><span class="line">arr; <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组是<strong>可变</strong>的，因此可以直接对索引赋值改变数组。</p><ul><li><p>如果赋值时索引超过了长度返回，<strong>不会报错</strong>，数组长度同样会发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// [1, 2, 3, undefined, undefined, 99]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>indexOf</code>：搜索一个指定元素的位置</p></li><li><p><code>slice</code>：行为和substring类似</p><ul><li><p><strong>不指定</strong>索引参数时，可以进行数组<strong>深复制</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy === a; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>push</code>：向数组<strong>末尾</strong>添加元素（直接改变数组）</p><ul><li><p>可以一次性添加多个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>pop</code>：把<strong>最后</strong>一个元素删除掉（直接改变数组）</p><ul><li>空数组<code>pop</code><strong>不会</strong>报错，而是返回<code>undefined</code>.</li></ul></li><li><p><code>unshift</code>/<code>shift</code>：对数组<strong>首</strong>元素进行操作，和<code>push</code>/<code>pop</code>对应。</p></li><li><p><code>sort</code>：对数组排序并返回新数组（<strong>同时</strong>直接修改数组）</p></li><li><p><code>reverse</code>：反转数组（直接修改数组）</p></li><li><p><code>splice</code>：从指定索引开始<strong>删除</strong>若干元素<strong>并返回</strong>，然后再从该位置<strong>添加</strong>若干元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br></pre></td></tr></table></figure></li><li><p><code>concat</code>：连接两个数组，并返回新的数组。（<strong>不改变</strong>原数组）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">added; <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ul><li><p><code>concat</code>还可以接收多个数组并执行<strong>拆解后合并</strong>（不论多少层<strong>都会被</strong>拆开）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">added1 = arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line">added2 = arr.concat(<span class="number">1</span>, <span class="number">2</span>, [[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]); <span class="comment">// [1, 2, 3, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>join</code>：把数组元素都当作字符串，用<strong>指定字符</strong>连接起来，然后返回一个长字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure></li><li><p>多维数组：数组嵌套</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="string">'-'</span>];</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p>当属性名包含<strong>特殊字符</strong>时</p><ul><li>必须用<code>&#39;&#39;</code>括起来</li><li>访问时需要使用<code>[&#39;xxx&#39;]</code>表示</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">'小红'</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'No.1 Middle School'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaohong[<span class="string">'middle-school'</span>];</span><br></pre></td></tr></table></figure></li><li><p>访问不存在的值不会报错，而是返回<code>undefined</code>.</p></li><li><p>对象是动态类型，可以随时添加和删除属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">'name'</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure></li><li><p>检测对象是否拥有某一属性：使用<code>in</code>操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">'No.1 Middle School'</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">'grade'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>使用<code>in</code>时会同时<strong>包括继承</strong>得到的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不考虑继承</strong>属性时使用<code>hasOwnProperty</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li>JavaScript把<strong><code>null</code>/<code>undefined</code>/<code>0</code>/<code>NaN</code>和空字符串</strong>视为<code>false</code>，其他都是<code>true</code>.</li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li><p><code>for</code>循环</p></li><li><p><code>for-in</code>循环</p><ul><li><p>用于遍历一个对象的所有<strong>属性</strong></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 'name', 'age', 'city'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历数组</p><p>数组也是一个对象，<strong>key是索引</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// '0', '1', '2'</span></span><br><span class="line">    <span class="built_in">console</span>.log(a[i]); <span class="comment">// 'A', 'B', 'C'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map是一种键值对结构，查找速度快。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">18</span>); <span class="comment">// add element</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">20</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 18</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>);</span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>如果重复<code>set</code>，后面的值会把前面的值冲掉。</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是key的集合，并且key<strong>不能</strong>重复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a set</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// number and string are different</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add element</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete element</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h2><p>包括<code>Array</code>/<code>Map</code>/<code>Set</code>类型</p><ul><li><p><code>for-of</code>遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]); <span class="comment">// 0 stands for key and 1 stands for value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组遍历通常使用<code>for-of</code>而<strong>不是</strong><code>for-in</code></p></blockquote></li><li><p><strong><code>forEach</code>（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素</span></span><br><span class="line"><span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">    <span class="built_in">console</span>.log(element + <span class="string">', index = '</span> + index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(element); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// neglect some args</span></span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>全文共<code>3321</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="定义与调用"><a href="#定义与调用" class="headerlink" title="定义与调用"></a>定义与调用</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>返回值、函数参数<strong>不用</strong>标注类型</p></li><li><p>如果<strong>没有</strong><code>return</code>语句或<code>return</code>后没有值，函数执行完毕后返回<code>undefined</code>.</p><blockquote><p>相当于函数体最后默认添加<code>return undefined;</code></p></blockquote></li><li><p>函数实际上是一个函数对象，函数名可以视为指向该函数的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>此时<code>abs</code>是一个函数变量，指向的函数被称作<strong>匿名函数</strong>。</li><li>注意函数体后有一个<code>;</code></li><li>调用方式依然为<code>abs(x)</code></li></ul></li></ul><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><ul><li><p><code>JavaScript</code>允许传入任意多个参数，即使比规定的参数要多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abs(<span class="number">10</span>, <span class="string">'balabala'</span>); <span class="comment">// return 10</span></span><br><span class="line">abs();<span class="comment">// return NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>参数无效时返回<code>NaN</code>而不是<code>undefined</code></p></blockquote></li><li><p>无效参数的过滤方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x !== <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Not a number'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>arguments</code>：在函数内部存储所有参数的一个<strong>类数组</strong>（不是数组）</p><ul><li><p>过滤空参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rest</code>：用于存储变长参数的<strong>数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行<code>return</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号 因为&#123;表示语句尚未结束</span></span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>return</code>所在行一定要有<code>{</code>，否则引擎会自动添加分号导致<code>return</code>一个<code>undefined</code>.</p></blockquote></li></ul><h2 id="作用域和解构赋值"><a href="#作用域和解构赋值" class="headerlink" title="作用域和解构赋值"></a>作用域和解构赋值</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li><p>变量的作用域就在函数体内部，如果出现嵌套函数中<strong>变量重名</strong>的情况，则以<strong>内部函数自己</strong>的变量为准。(变量栈)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x in bar() = '</span> + x); <span class="comment">// 'A'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x in foo() = '</span> + x); <span class="comment">// 1</span></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><blockquote><p>内部函数的<code>x</code>值也<strong>不会</strong>影响外部函数</p></blockquote></li><li><p>变量提升：<strong>函数</strong>（普通代码段<strong>也是</strong>）在执行前会先扫描整个函数体的语句，并且把所有声明都移动到<strong>函数顶部</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>函数可以正常执行，但是输出是<code>Hello, undefined</code>.</p></li><li><p>提升的<strong>仅仅是</strong>变量的<strong>声明</strong>，而<strong>不是</strong>变量的<strong>赋值</strong>。</p></li><li><p>良好的编码习惯是<strong>手动</strong>在函数顶部就声明所有的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">    x = <span class="number">1</span>,</span><br><span class="line">    y = x + <span class="number">1</span>,</span><br><span class="line">        z, i; <span class="comment">// init as undefined</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>全局作用域：不在任何一个函数内定义的变量</p><ul><li><p>JavaScript默认有一个<strong>全局对象<code>window</code></strong>，全局作用域的变量实际上会被绑定为<code>window</code>的一个<strong>属性</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> course = <span class="string">'Learn JavaScript'</span>;</span><br><span class="line">alert(course); <span class="comment">// Learn JavaScript</span></span><br><span class="line">alert(<span class="built_in">window</span>.course); <span class="comment">// Learn JavaScript</span></span><br><span class="line">course === <span class="built_in">window</span>.course; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>顶层函数</strong>也会被视为一个全局变量绑定到<code>window</code>上</p></li></ul><blockquote><p><code>window.xxx</code>的效果和<code>xxx</code>的全局变量其实是一样的（与对象的<code>this</code><strong>无关</strong>）</p></blockquote></li><li><p>名字空间</p><ul><li><p>当不同文件使用了<strong>相同的</strong>全局变量（包括顶层函数）就会造成命名冲突</p></li><li><p>把自己的所有变量和函数全部绑定到<strong>一个自定义的全局变量</strong>中就可以解决命名冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MYAPP.name = <span class="string">'myapp'</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>MYAPP</code>被称作<strong>名字空间</strong></p></blockquote></li></ul></li><li><p>局部作用域</p><ul><li><p>for语句<code>var</code>定义的循环变量<strong>不是</strong>局部作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将<code>var</code>改为<code>let</code>就可以声明一个<strong>块级作用域</strong>的变量</p></blockquote></li></ul></li><li><p>常量：<code>const</code>定义，<strong>初始化后不能被修改</strong>，具有<strong>块级</strong>作用域。</p></li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul><li><p>同时对一组变量进行赋值的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">'hello'</span>, [<span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]];</span><br><span class="line">x; <span class="comment">// 'hello'</span></span><br><span class="line">y; <span class="comment">// 'JavaScript'</span></span><br><span class="line">z; <span class="comment">// 'ES6'</span></span><br></pre></td></tr></table></figure><ul><li>保证左右两边的<strong>结构相同</strong></li></ul></li><li><p>忽略元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]; <span class="comment">// 忽略前两个元素，只对z赋值第三个元素</span></span><br><span class="line">z; <span class="comment">// 'ES6'</span></span><br></pre></td></tr></table></figure></li><li><p>拆解对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>拆解对象时<strong>不是</strong>按照顺序，而是按照<strong>指定的属性名字</strong>。</p></li><li><p>变换赋值变量的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person; <span class="comment">// id's value is 'G-12345678'</span></span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>嵌套对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        city: <span class="string">'Beijing'</span>,</span><br><span class="line">        street: <span class="string">'No.1 Road'</span>,</span><br><span class="line">        zipcode: <span class="string">'100001'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>当属性不存在时，会得到<code>undefined</code>.</p></li><li><p>使用默认值可以避免<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>以上情况都是把变量声明和赋值放在一起执行的，当分开并且是<strong>对象间赋值时（大括号）</strong>，需要进行特殊处理，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量:</span></span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correction : add brackets</span></span><br><span class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>交换变量值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>JavaScript的对象方法设计存在缺陷，因此需要单独设立新的<strong>对象方法调用方式</strong>。</p><ul><li><p><code>apply</code>/<code>call</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 30</span></span><br><span class="line">getAge.apply(xiaoming,[]);</span><br><span class="line">getAge.call(xiaoming,); <span class="comment">// comma can be neglected</span></span><br></pre></td></tr></table></figure><ul><li><code>apply</code>的第一个参数是使用对象，第二个参数是所有函数参数组成的数组。</li><li><code>call</code>的方法参数<strong>不按数组</strong>传入，而是<strong>按照顺序</strong>传入。</li><li><code>obj.xxx()</code>的方式<strong>不推荐</strong>使用，因为对于嵌套函数，<code>this</code>在<strong>内层</strong>的指向是<code>undefined</code>/<code>window</code>（取决于是否打开strict模式）</li></ul></li><li><p>装饰器</p><p>使用apply动态改变函数的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>新的自定义函数<code>parseInt</code>可以统计函数调用次数</p></blockquote></li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>接受<strong>函数作为参数</strong>的函数叫做高阶函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">-3</span>, <span class="built_in">Math</span>.abs);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><p><code>map()</code>定义在<code>Array</code>上，调用<code>Array</code>的<code>map()</code>方法并传入我们自己的函数，作用于数组的每一个元素，就能得到一个新的<code>Array</code>并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow);</span><br><span class="line"><span class="built_in">console</span>.log(results); <span class="comment">// 1,4,9</span></span><br></pre></td></tr></table></figure><ul><li><p>整数数组转换为字符串数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.map(<span class="built_in">String</span>); <span class="comment">// ['1', '2', '3']</span></span><br></pre></td></tr></table></figure></li><li><p>字符串数组变为整数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">arr.map(<span class="built_in">parseInt</span>); <span class="comment">// 1,NaN,NaN</span></span><br><span class="line">arr,map(<span class="built_in">Number</span>); <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>map()</code>接收的回调函数可以有3个参数：<code>callback(currentValue, index, array)</code>，通常我们仅需要第一个参数，而忽略了传入的后面两个参数。不幸的是，<code>parseInt(string, radix)</code><strong>没有</strong>忽略第二个参数，导致实际执行的函数分别是：</p><ul><li>parseInt(‘1’, 0); // 1, 按十进制转换</li><li>parseInt(‘2’, 1); // NaN, 没有一进制</li><li>parseInt(‘3’, 2); // NaN, 按二进制转换不允许出现3</li></ul><p>可以改为<code>r = arr.map(Number);</code>，因为<code>Number(value)</code>函数仅接收<strong>一个</strong>参数。</p></blockquote></li></ul></li></ul><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul><li><p>二元参数函数的迭代运算</p><p>$[x1,\ x2,\ x3,\ x4].reduce(f)\ =\ f(f(f(x1,\ x2),\ x3),\ x4)$</p></li><li><p>数组求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>把某些元素过滤掉，返回剩下的元素组成的数组。</p><h4 id="过滤函数"><a href="#过滤函数" class="headerlink" title="过滤函数"></a>过滤函数</h4><p>返回值为<strong><code>true</code>则保留</strong>，返回值为<strong><code>false</code>则删除</strong>。（不能省略<code>return</code>）</p><ul><li><p>删除偶数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>删除空字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">'C'</span>, <span class="string">'  '</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s &amp;&amp; s.trim(); <span class="comment">// 注意：IE9以下的版本没有trim()方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>删除重复元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数通常有三个参数</p><ul><li><code>element</code>：数组元素</li><li><code>index</code>：数组索引</li><li><code>self</code>：数组本身</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul><li><p>JavaScript的<code>sort</code>方法默认把<strong>所有元素</strong>先转换为<code>String</code>再排序（整数数组也按<strong>字典序</strong>排序）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure></li><li><p><code>sort</code>方法接受自定义排序函数</p></li></ul><h3 id="其他高阶函数"><a href="#其他高阶函数" class="headerlink" title="其他高阶函数"></a>其他高阶函数</h3><ul><li><p><code>every</code>：判断所有元素是否满足测试条件，有一个不满足就返回<code>false</code>.</p></li><li><p><code>find</code>：查找符合条件的第一个元素，找到了返回该元素，否则返回<code>undefined</code>.</p></li><li><p><code>findIndex</code>：类似<code>find</code>，但是查找失败时返回<code>-1</code>.</p></li><li><p><code>forEach</code>：类似<code>map</code>但是<strong>不会</strong>返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>];</span><br><span class="line">arr.forEach(<span class="built_in">console</span>.log); <span class="comment">// 依次打印每个元素</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为<strong>返回值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当调用<code>lazy_sum()</code>时，返回的<strong>不是求和结果</strong>，而是<strong>求和函数</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure></li><li><p>调用函数<code>f</code>时才返回求和结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li>在<code>lazy_sum</code>中定义函数<code>sum</code>时虽然<code>arr</code>有效，但是此时<strong>是定义而不是调用</strong>，因此不会计算。</li><li>每次调用<code>lazy_sum</code>都会返回一个<strong>新函数</strong></li></ul></blockquote><h3 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h3><p>在<code>lazy_sum</code>返回<code>sum</code>后，<code>lazy_sum</code>中的<strong>参数和变量</strong>都保存在返回的函数中，这种程序结构被称作闭包。</p><ul><li><p>闭包中函数的调用时机</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 16</span></span><br><span class="line">f2(); <span class="comment">// 16</span></span><br><span class="line">f3(); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><ul><li>首先<code>var results = count();</code>，函数<code>count</code>已经被调用了，所以依次执行函数内的各段代码。</li><li>此时循环体执行了push方法，将一个个函数<code>function () { return i * i;}</code>添加到数组内，但是这个函数并没有被调用，还只是一个变量，所以for循环依次执行，直到<code>i = 4</code>.</li><li>因为闭包，内部函数<code>function () { return i * i;}</code>引用的<code>i</code>就是for循环中的<code>i = 4</code>。所以，之后数组<code>arr</code>内的函数的<code>i</code>都是4。</li><li>调用函数<code>count</code>后，变量<code>results</code>已经是数组<code>arr</code>了。数组里面元素依次是<ul><li><code>function f1() { return i * i;}</code></li><li><code>function f2() { return i * i;}</code> </li><li><code>function f3() { return i * i;}</code></li></ul></li><li>但是三个函数都没有被调用，<strong>直到</strong><code>f1()</code>.（闭包内函数的调用）</li><li>此时<code>function f1() { return i * i;}</code>开始执行，如上段所写，此时的<code>i = 4</code>，所以，返回值就<strong>都是</strong>16了。</li></ul></li><li><p>闭包函数调用注意事项</p><ul><li><p>返回函数不要引用任何<strong>循环变量</strong>，或者<strong>后续会发生变化的变量</strong>。</p></li><li><p>一定要引用循环变量时，用<strong>函数参数</strong>绑定<strong>循环变量</strong>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push((<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> n * n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 1</span></span><br><span class="line">f2(); <span class="comment">// 4</span></span><br><span class="line">f3(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><ul><li><p>创建匿名函数并<strong>绑定参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)(<span class="number">3</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><blockquote><p>注意函数部分（不包括参数）需要单独再多加<strong>一对括号</strong>。</p></blockquote></li></ul></li></ul></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>创建<strong>延迟执行</strong>的函数</p></li><li><p>在没有<code>class</code>机制的<code>JavaScript</code>中封装一个私有变量</p><p>利用闭包返回一个对象，在该对象中的变量无法通过外界访问到，相当于实现了私有变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = initial || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = create_counter();</span><br><span class="line">c1.inc(); <span class="comment">// 1</span></span><br><span class="line">c1.inc(); <span class="comment">// 2</span></span><br><span class="line">c1.inc(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</span><br><span class="line">c2.inc(); <span class="comment">// 11</span></span><br><span class="line">c2.inc(); <span class="comment">// 12</span></span><br><span class="line">c2.inc(); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><blockquote><p>此时只有<code>c1</code>/<code>c2</code>可以修改各自的<code>x</code></p></blockquote></li><li><p>利用闭包将<strong>多参数</strong>函数变为<strong>单参数</strong>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_pow</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>和装饰器不同，闭包封装函数并没有立即执行。</li></ul></li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li><p>结构</p><p>$(参数列表)+\{…\}$</p><ul><li>参数只有<strong>一个</strong>时可以<strong>不需要</strong>用括号把参数包起来</li></ul></li><li><p>返回对象时，因为对象的外层是<code>{}</code>和块结构语法冲突，所以需要<strong>单独</strong>加一层<code>()</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure></li><li><p>和匿名函数的区别：箭头函数内的<code>this</code>由词法作用域决定，而不是<code>window</code>或<code>undefined</code>.</p><ul><li>匿名函数中的<code>this</code>在没有开启<code>strict</code>模式时指向<code>window</code>对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anonymous function</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window或undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>箭头函数中的<code>this</code>指向词法作用域，也就是<code>obj</code>对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrow function</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>此时箭头函数在一个函数内，因此词法作用域是这个函数的作用域，因此<code>this</code>指向<code>obj</code>.</li><li>但是对于<code>toJSON</code>函数，因为箭头函数不在某个函数内，并且<strong>对象不能够定义作用域</strong>，此时的<code>this</code>指向的是<code>window</code>.（toJSON不建议使用箭头函数）</li></ul></blockquote></li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul><li>类似于函数，但是除了<code>return</code>外，还可以<code>yield</code>返回多次。</li><li>一个可以记住执行状态的函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>生成器实现fib数列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        arr = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (arr.length &lt; max) &#123;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        arr.push(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试:</span></span><br><span class="line">fib(<span class="number">5</span>); <span class="comment">// [0, 1, 1, 2, 3]</span></span><br><span class="line">fib(<span class="number">10</span>); <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = fib(<span class="number">5</span>);</span><br><span class="line">f.next(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> fib(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 依次输出0, 1, 1, 2, 3, ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次<code>next</code>调用就会返回一次<code>yield</code>对象</li><li>碰到<code>return</code>后返回的对象中<code>done</code>为<code>true</code></li><li>直接使用<code>for-of</code>循环遍历也可以得到结果</li></ul></li></ul><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h1><p>全文共<code>1397</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li><p>使用<code>typeof</code>操作符获取对象的类型（返回一个<strong>小写字符串</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'str'</span>; <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// 'function'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure><ul><li><code>null</code>的类型属于<code>object</code></li></ul></li><li><p>包装对象：类似Java中<code>int</code>和<code>Integer</code>的关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>) === <span class="string">'str'</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p>通常<strong>不使用</strong>包装对象</p></li><li><p>当不写<code>new</code>时，<code>Number()</code>/<code>Boolean()</code>/<code>String()</code>会被当作<strong>普通函数</strong>，把其他数据转换成自己的<strong>基本数据类型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">Number</span>(<span class="string">'123'</span>); <span class="comment">// 123，相当于parseInt()或parseFloat()</span></span><br><span class="line"><span class="keyword">typeof</span> n; <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Boolean</span>(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// 'boolean'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Boolean</span>(<span class="string">'false'</span>); <span class="comment">// true! 'false'字符串转换结果为true！因为它是非空字符串！</span></span><br><span class="line"><span class="keyword">var</span> b3 = <span class="built_in">Boolean</span>(<span class="string">''</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">String</span>(<span class="number">123.45</span>); <span class="comment">// '123.45'</span></span><br><span class="line"><span class="keyword">typeof</span> s; <span class="comment">// 'string'</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>类型判断</p><ul><li><code>Array</code>：<code>Array.isArray(arr)</code></li><li><code>null</code>：<code>myVar === null</code></li><li>全局变量是否存在：<code>typeof window.myVar === &#39;undefined&#39;</code></li><li>局部变量是否存在：<code>typeof myVar === &#39;undefined&#39;</code></li></ul></li><li><p>注意事项</p><ul><li><p><code>null</code>和<code>undefined</code>没有<code>toString()</code>方法</p><blockquote><p>尽管<code>null</code>是<code>object</code>类型</p></blockquote></li><li><p>数字转换为字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span>.toString(); <span class="comment">// two dots</span></span><br><span class="line">(<span class="number">123</span>).toString(); <span class="comment">// add brackets</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>不能</strong>使用<code>123.toStirng()</code></p></blockquote></li></ul></li></ul><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p><code>Date</code>对象表示日期和时间</p><ul><li><p>获取当前时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br><span class="line"><span class="built_in">Date</span>.now(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个指定日期和时间的<code>Date</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mannully set arguments</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</span><br><span class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// format string of ISO 8601</span></span><br><span class="line"><span class="keyword">var</span> timeStamp = <span class="built_in">Date</span>.parse(<span class="string">'2015-06-24T19:49:22.875+08:00'</span>);</span><br><span class="line">timeStamp; <span class="comment">// 1435146562875</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp);</span><br><span class="line">d; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">d.getMonth(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><ul><li><p>JavaScript中月份范围用整数表示是<code>0~11</code>，所以5表示6月。</p><blockquote><p>使用<code>Date.parse()</code>时传入的字符串使用实际月份<code>01~12</code>，转换为Date对象后<code>getMonth()</code>获取的月份值为<code>0~11</code>.</p></blockquote></li></ul></li><li><p>时区转换</p><p>Date显示的时间总是按<strong>浏览器所在时区</strong>显示的，也可以转换为UTC时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>);</span><br><span class="line">d.toLocaleString(); <span class="comment">// '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关</span></span><br><span class="line">d.toUTCString(); <span class="comment">// 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>通过<code>//</code>引出</p></li><li><p>通过<code>RegExp</code>声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ABC\\-001'</span>);</span><br><span class="line"></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure><blockquote><p>第二种写法要同时考虑<strong>字符串中<code>\</code>的转义问题</strong></p></blockquote></li></ul><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;</span><br><span class="line">re.test(<span class="string">'010-12345'</span>); <span class="comment">// true</span></span><br><span class="line">re.test(<span class="string">'010-1234x'</span>); <span class="comment">// false</span></span><br><span class="line">re.test(<span class="string">'010 12345'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a b   c'</span>.split(<span class="string">' '</span>); <span class="comment">// ['a', 'b', '', '', 'c']</span></span><br><span class="line"><span class="string">'a b   c'</span>.split(<span class="regexp">/\s+/</span>); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"><span class="string">'a,b, c  d'</span>.split(<span class="regexp">/[\s\,]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br><span class="line"><span class="string">'a,b;; c  d'</span>.split(<span class="regexp">/[\s\,\;]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>在正则中进行分组可以直接在字符串中提取出想要的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</span><br><span class="line">re.exec(<span class="string">'010-12345'</span>); <span class="comment">// ['010-12345', '010', '12345']</span></span><br><span class="line">re.exec(<span class="string">'010 12345'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><ul><li>匹配成功时，返回的数组的第一个元素的整个字符串。</li><li>匹配失败时，返回<code>null</code>.</li></ul><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>JavaScript默认采用贪婪匹配，也就是匹配尽可能多的字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '102300', '']</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p></blockquote><ul><li><p>开启非贪婪匹配：加一个<code>?</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '1023', '00']</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h3><p>全局匹配可以对同一个字符串进行多次匹配，并且下一次匹配的起点是这一次匹配终点的下一个字符索引。</p><h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'test'</span>, <span class="string">'g'</span>);</span><br></pre></td></tr></table></figure><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'JavaScript, VBScript, JScript and ECMAScript'</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s); <span class="comment">// ['JavaScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['VBScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['JScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['ECMAScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure><h3 id="其他标志"><a href="#其他标志" class="headerlink" title="其他标志"></a>其他标志</h3><ul><li><code>i</code>表示忽略大小写</li><li><code>m</code>表示执行多行匹配</li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是JavaScript Object Notation的缩写，是一种数据交换格式。</p><ul><li>JSON的序列集必须是UTF-8</li><li>JSON的<strong>字符串和Object的key</strong>必须使用<code>&quot;&quot;</code></li><li>JSON反序列化后即可成为JavaScript对象</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</span><br><span class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>普通序列化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);</span><br></pre></td></tr></table></figure></li><li><p>格式序列化：二、三参数只是为了<strong>占位</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">' '</span>);</span><br></pre></td></tr></table></figure><blockquote><p>输出一个键值对就换一次行</p></blockquote></li><li><p>筛选格式化：第二个参数传入数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, [<span class="string">'name'</span>, <span class="string">'skills'</span>], <span class="string">' '</span>);</span><br></pre></td></tr></table></figure><blockquote><p>只输出指定的属性</p></blockquote></li><li><p>预处理格式化：第二个参数传入函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, convert, <span class="string">'  '</span>);</span><br></pre></td></tr></table></figure></li><li><p>精确序列化：为对象增加<code>toJSON</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</span><br><span class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>],</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 只输出name和age，并且改变了key：</span></span><br><span class="line">            <span class="string">'Name'</span>: <span class="keyword">this</span>.name,</span><br><span class="line">            <span class="string">'Age'</span>: <span class="keyword">this</span>.age</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p><code>JSON.parse</code>可以把输入元素解析为JavaScript对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1,2,3,true]'</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>); <span class="comment">// Object &#123;name: '小明', age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'123.45'</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><ul><li><p>指定处理函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'name'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">'同学'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;name: '小明同学', age: 14&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>全文共<code>1107</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>不同于Java，JavaScript的OO中没有Class和实例的概念。</p><ul><li><p>在JavaScript中，通过<strong>原型</strong>实现OO编程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'Robot'</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Student;</span><br></pre></td></tr></table></figure><ul><li><p>定义一个模型变量<code>Student</code></p></li><li><p>通过修改对象的<code>__proto__</code>域可以实现对象的<strong>动态</strong>改变，但是在编程时<strong>不推荐</strong>使用这种方式创建对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Bird = &#123;</span><br><span class="line">    fly: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is flying...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Bird;</span><br></pre></td></tr></table></figure><blockquote><p>此时<code>xiaoming</code>就<strong>没有</strong><code>run</code>方法了</p></blockquote></li></ul></li><li><p>JavaScript中所有对象<strong>都是实例</strong></p></li><li><p>使用封装好的<code>Object.create()</code>方法改变对象继承的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'Robot'</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'is running...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</span><br><span class="line">    s.name = name;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">'xiaoming'</span>);</span><br><span class="line">xiaoming.run();</span><br><span class="line">xiaoming.__proto___ === Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>所有原型最后都会回到<code>null</code></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>如果不写<code>new</code>，则<code>Student</code>函数就是一个普通函数；如果写了<code>new</code>，则<code>Student</code>就是一个构造函数，它<strong>根据原型对象</strong>创建一个<strong>新对象</strong>并把<code>this</code>指向它，同时<strong>不需要</strong>显式<code>return</code>.</p></li><li><p><code>xiaoming</code><strong>从新对象</strong>得到了一个<code>constructor</code>属性，指向函数<code>Student</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.constructor === Student.prototype.constructor; <span class="comment">// true</span></span><br><span class="line">Student === Student.prototype.constructor; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(xiaoming) === Student.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>关系示意图<br><img src="https://static.liaoxuefeng.com/files/attachments/1024698721053600/l"  /></p><ul><li>某个对象即构造函数对应的<strong>唯一的原型对象</strong></li></ul></li><li><p>不同对象尽管由同一个原型对象创建得到，但是其中的属性除了<code>constructor</code>之外都是<strong>独立的</strong>。（但是访问<code>constructor</code>直接<code>xxx.constructor</code>，<strong>而不是</strong>使用<code>xxx.prototype.constructor</code>.）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.name; <span class="comment">// '小明'</span></span><br><span class="line">xiaohong.name; <span class="comment">// '小红'</span></span><br><span class="line">xiaoming.hello; <span class="comment">// function: Student.hello()</span></span><br><span class="line">xiaohong.hello; <span class="comment">// function: Student.hello()</span></span><br><span class="line">xiaoming.hello === xiaohong.hello; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p>对于可共享函数，可以采用直接对<strong>原型对象域</strong>操作的办法进行设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>此时所有的<code>Student</code>对象共享同一个<code>hello</code></p><blockquote><p>构造函数中的属性都是独立的，直接在<code>prototype</code>中修改的就是共享的。</p></blockquote></li><li><p>此时<code>this</code>指向调用<strong>该方法</strong>的对象</p></li><li><p><code>prototype</code>这个属性只有构造函数有，对象只有<code>__proto__</code>.</p></li></ul></li></ul></li><li><p>普通函数的首字母小写，构造函数的<strong>首字母大写</strong>。</p></li><li><p>为了省略显示<code>new</code>操作，可以进行封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = props.name || <span class="string">'匿名'</span>; <span class="comment">// 默认值为'匿名'</span></span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>; <span class="comment">// 默认值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Student(props || &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(&#123;</span><br><span class="line">    name: <span class="string">'xiaoming'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>使用<code>||</code>实现默认值操作</li><li>注意传入的参数是<strong>对象</strong></li></ul></li></ul><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><ul><li><p>定义新的构造函数，并在内部调用被继承的函数，并绑定<code>this</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Student构造函数，绑定this变量:</span></span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>借助中间函数<code>F</code>实现原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrimaryStudent构造函数:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空函数F:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把F的原型指向Student.prototype:</span></span><br><span class="line">F.prototype = Student.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span></span><br><span class="line">PrimaryStudent.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span></span><br><span class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建xiaoming:</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> PrimaryStudent(&#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    grade: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">xiaoming.name; <span class="comment">// '小明'</span></span><br><span class="line">xiaoming.grade; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型:</span></span><br><span class="line">xiaoming.__proto__ === PrimaryStudent.prototype; <span class="comment">// true</span></span><br><span class="line">xiaoming.__proto__.__proto__ === Student.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承关系:</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> PrimaryStudent; <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>一个函数本身就算不是构造函数，加了<code>new</code>也能正常执行。</p></blockquote><ul><li><p>关系图</p><p><img src="https://static.liaoxuefeng.com/files/attachments/1034288859918112/l" alt=""></p></li><li><p>为了简化，可以把继承封装为一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line">    Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在新的构造函数的原型上定义新方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = props.name || <span class="string">'Unnamed'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现原型继承链:</span></span><br><span class="line">inherits(PrimaryStudent, Student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h2><p>为了简化原型继承提出了新关键字<code>class</code></p><ul><li><p>使用<code>class</code>直接编写类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hello() &#123;</span><br><span class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义方法<strong>不需要</strong><code>function</code>关键字</li></ul></li><li><p>继承实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, grade) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myGrade() &#123;</span><br><span class="line">        alert(<span class="string">'I am at grade '</span> + <span class="keyword">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>class继承就是为了简化原型继承，但是可能会碰到不兼容的情况，可以使用<code>Babel</code>工具进行<code>class</code>继承到传统原型继承的转换。</p></blockquote></li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>全文共<code>4625</code>字，推荐阅读时间<code>30~45</code>分钟。</p><h2 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h2><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><ul><li><p><code>window</code>对象不但是全局作用域变量，而且表示<strong>浏览器窗口</strong>。</p></li><li><p><code>window</code>对象有<code>innerWidth</code>和<code>innderHeight</code>属性，分别表示浏览器窗口<strong>内部宽度和高度</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'window inner size: '</span> + <span class="built_in">window</span>.innerWidth + <span class="string">'*'</span> + <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure><ul><li><p>内部宽高需要去掉菜单栏、工具栏、边框等占位元素。</p></li><li><p>对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。</p></li></ul></li></ul><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p><code>navigator</code>表示浏览器的信息</p><ul><li><code>navigator.appName</code>：浏览器名称</li><li><code>navigator.appVersion</code>：浏览器版本</li><li><code>navigator.language</code>：浏览器设置的语言</li><li><code>navigator.platform</code>：操作系统类型</li><li><code>navigator.userAgent</code>：浏览器设定的<code>User-Agent</code>字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'appName = '</span> + navigator.appName);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'appVersion = '</span> + navigator.appVersion);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'language = '</span> + navigator.language);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'platform = '</span> + navigator.platform);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'userAgent = '</span> + navigator.userAgent);</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>navigator</code>的属性<strong>可以</strong>被用户修改，所以读到的值不一定是实际值。</p><p>例如判断浏览器版本</p><ul><li><p>使用if语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width;</span><br><span class="line"><span class="keyword">if</span> (getIEVersion(navigator.userAgent) &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    width = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    width = <span class="built_in">window</span>.innerWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当IE版本低于9时window没有<code>innerwidth</code>属性</p></blockquote></li><li><p>使用<code>undefined</code>的短路特性<strong>（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width = width.innerWidth || <span class="built_in">document</span>.body.clientWidth;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p><code>screen</code>表示屏幕的信息</p><ul><li><code>screen.width</code>：屏幕宽度，以像素为单位。</li><li><code>screen.height</code>：屏幕高度</li><li><code>screen.colorDepth</code>：返回屏幕颜色位数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Screen size = '</span> + screen.width + <span class="string">' x '</span> + screen.height);</span><br><span class="line"><span class="built_in">console</span>.log(screen.colorDepth);</span><br></pre></td></tr></table></figure><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p><code>location</code>表示<strong>当前页面</strong>的<code>URL</code>信息</p><ul><li><code>location.href</code>：完整的<code>URL</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location.href; <span class="comment">// 'http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP'</span></span><br><span class="line">location.protocol; <span class="comment">// 'http'</span></span><br><span class="line">location.host; <span class="comment">// 'www.example.com'</span></span><br><span class="line">location.port; <span class="comment">// '8080'</span></span><br><span class="line">location.pathname; <span class="comment">// '/path/index.html'</span></span><br><span class="line">location.search; <span class="comment">// '?a=1&amp;b=2'</span></span><br><span class="line">location.hash; <span class="comment">// 'TOP'</span></span><br></pre></td></tr></table></figure><ul><li><code>location.assign()</code>：接受<strong>新</strong><code>path</code>作为参数，加载一个页面。</li><li><code>location.reload()</code>：<strong>重新</strong>加载当前页面</li></ul><h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><p><code>document</code>表示当前页面，由于HTML以<strong>DOM(Document Object Model)</strong>形式表现为树结构，因此<code>document</code>对象就是整个DOM树的根节点。</p><ul><li><p><code>document.title</code>：当前页面的标题，<strong>可以被用户动态改变</strong>。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.title);</span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">'努力学习JavaScript!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.title);</span><br></pre></td></tr></table></figure></li><li><p><code>document.getElementById()</code>/<code>document.getElementsByTagName()</code>按照HTML的<code>id</code>获得一个DOM节点以及按<code>Tag</code>名称获取一组DOM节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span> <span class="attr">id</span>=<span class="string">"drink-menu"</span> <span class="attr">style</span>=<span class="string">"border:solid 1px #ccc;padding:6px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>摩卡<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>热摩卡咖啡<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>酸奶<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>北京老酸奶<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>果汁<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>鲜榨苹果汁<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'drink-menu'</span>);</span><br><span class="line"><span class="keyword">var</span> drinks = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'dt'</span>);</span><br><span class="line"><span class="keyword">var</span> i, s;</span><br><span class="line"></span><br><span class="line">s = <span class="string">'提供的饮料有:'</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;drinks.length; i++) &#123;</span><br><span class="line">    s = s + drinks[i].innerHTML + <span class="string">','</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure></li><li><p><code>document.cookie</code>：获取当前页面的<code>cookie</code>属性</p><blockquote><p>cookie的用途</p><ul><li><p>因为HTTP协议是无状态的，因此服务器使用cookie区分是哪个用户发来的请求。</p><p>当一个用户成功登录后，服务器发送一个cookie给浏览器，例如<code>user=ABC123XYZ</code>（加密字符串）。之后浏览器访问该网站时都会在<strong>请求头</strong>附上这个cookie.</p></li><li><p>因为JavaScript可以读取cookie，当引入恶意第三方代码时，就会造成信息泄露。为此，服务器设置cookie会加上<code>httpOnly</code>选项，此时JavaScript不能够读取cookie.</p></li></ul></blockquote></li></ul><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p><code>history</code>保存了浏览器的历史记录，<strong>是一个不应该继续使用的对象</strong>。</p><ul><li><code>history.back()</code>：相当于点了浏览器的后退按钮</li><li><code>history.forward()</code>：相当于点了浏览器的前进按钮</li></ul><h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>HTML文件解析后是一棵DOM树，因此JavaScript操作DOM就可以改变HTML的结构。</p><ul><li><p>获取节点（所有的操作都是针对某个节点）</p><ul><li><code>document.getElementById()</code>：可以直接获取<strong>唯一一个</strong>节点</li><li><code>document.getElementsByTagName()</code></li><li><code>document.getElementByClassName()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回ID为'test'的节点：</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：</span></span><br><span class="line"><span class="keyword">var</span> trs = <span class="built_in">document</span>.getElementById(<span class="string">'test-table'</span>).getElementsByTagName(<span class="string">'tr'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：</span></span><br><span class="line"><span class="keyword">var</span> reds = <span class="built_in">document</span>.getElementById(<span class="string">'test-div'</span>).getElementsByClassName(<span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下的所有直属子节点:</span></span><br><span class="line"><span class="keyword">var</span> cs = test.children;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下第一个、最后一个子节点：</span></span><br><span class="line"><span class="keyword">var</span> first = test.firstElementChild;</span><br><span class="line"><span class="keyword">var</span> last = test.lastElementChild;</span><br></pre></td></tr></table></figure><ul><li><p><code>querySelector()</code>/<code>querySelectorAll()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过querySelector获取ID为q1的节点：</span></span><br><span class="line"><span class="keyword">var</span> q1 = <span class="built_in">document</span>.querySelector(<span class="string">'#q1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span></span><br><span class="line"><span class="keyword">var</span> ps = q1.querySelectorAll(<span class="string">'div.highlighted &gt; p'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>低版本IE不支持</p></blockquote></li></ul></li><li><p>更新：更新DOM节点的内容，相当于更新DOM节点表示的HTML的内容。</p></li><li><p>遍历：遍历该DOM节点下的子节点</p></li><li><p>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点。</p></li><li><p>删除：将该节点从HTML删除，同时会删除它的子节点。</p></li></ul><blockquote><p>严格说，这里的DOM节点仅指<code>Element</code>，而不是<code>Node</code>.</p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-div"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c-red"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test-p"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c-red c-green"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ruby<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c-green"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择&lt;p&gt;JavaScript&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> js = <span class="built_in">document</span>.getElementById(<span class="string">'test-p'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c-red c-green'</span>)[<span class="number">0</span>].getElementsByTagName(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>].innerText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;Haskell&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> haskell = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c-green'</span>)[<span class="number">1</span>].getElementsByTagName(<span class="string">'p'</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(haskell.innerText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;JavaScript&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> js =  <span class="built_in">document</span>.querySelector(<span class="string">'#test-p'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c-red c-green'</span>)[<span class="number">0</span>].children;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;Haskell&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> haskell = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c-green'</span>)[<span class="number">1</span>].lastElementChild;</span><br></pre></td></tr></table></figure><ul><li><code>getElementsByClassName</code>是<strong>部分匹配查找</strong></li><li>查找到的DOM节点需要使用<code>innerText</code>获取内容</li></ul><h3 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h3><ul><li><p>直接修改<code>innerHTML</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC'</span>; <span class="comment">// &lt;p id="p-id"&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ'</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure><blockquote><p>直接修改<code>HTML</code>要小心<code>XSS</code>攻击</p></blockquote></li><li><p>修改<code>innerText</code>或<code>innerContent</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.innerText = <span class="string">'&lt;script&gt;alert("Hi")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id="p-id"&gt;&amp;lt;script&amp;gt;alert("Hi")&amp;lt;/script&amp;gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此时HTML会被自动编码，不会修改原有HTML.</p></blockquote><ul><li><code>innerText</code><strong>不返回</strong>隐藏元素的文本</li><li><code>textContent</code>返回所有文本（IE9前不支持）</li></ul></li><li><p>修改节点对应的CSS</p><p>修改节点的<code>style</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.style.color = <span class="string">'#ff0000'</span>;</span><br><span class="line">p.style.fontSize = <span class="string">'20px'</span>; <span class="comment">// font-size in CSS</span></span><br><span class="line">p.style.paddingTop = <span class="string">'2em'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>CSS中<code>font-size</code>这样的名称在JavaScript中需要变化为<strong>驼峰命名</strong>法</p></blockquote></li></ul><h3 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h3><ul><li><p>直接修改<code>innerHTML</code></p><p>仅仅适用于原节点内部是空的情况，例如<code>&lt;div&gt;&lt;/div&gt;</code>，否则会替换掉<strong>所有</strong>的子节点。</p></li><li><p><code>appendChild</code>：把一个子节点添加到父节点的最后一个子节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 Before --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"scheme"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML结构 After --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"scheme"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    js = <span class="built_in">document</span>.getElementById(<span class="string">'js'</span>),</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line">list.appendChild(js);</span><br></pre></td></tr></table></figure><ul><li><p>这个操作会先把原来的语句<strong>删除</strong>，然后在新的节点进行追加。</p></li><li><p>新建节点后再插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;p&gt;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>); <span class="comment">// choose type of DOM point</span></span><br><span class="line">haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">list.appendChild(haskell);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;style&gt;</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">d.setAttribute(<span class="string">'type'</span>, <span class="string">'text/css'</span>);</span><br><span class="line">d.innerHTML = <span class="string">'p &#123; color: red &#125;'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(d);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>insertBefore</code>：把元素插在<strong>指定位置之前</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"scheme"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在python之前插入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    ref = <span class="built_in">document</span>.getElementById(<span class="string">'python'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">list.insertBefore(haskell, ref);</span><br></pre></td></tr></table></figure><ul><li><p>当<code>ref</code>节点不能够直接得到时，可以通过遍历子节点实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">i, c,</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.children.length; i++) &#123;</span><br><span class="line">    c = list.children[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>按字符串顺序重新排序DOM节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">id</span>=<span class="string">"test-list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>Ruby<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort list:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"lang"</span>);</span><br><span class="line"><span class="keyword">var</span> arrList = <span class="built_in">Array</span>.from(list); <span class="comment">// transform Collection into Array</span></span><br><span class="line"></span><br><span class="line">arrList.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( x.innerText.toLowerCase() &gt; y.innerText.toLowerCase() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.innerText.toLowerCase() &lt; y.innerText.toLowerCase()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testList = <span class="built_in">document</span>.getElementById(<span class="string">"test-list"</span>);</span><br><span class="line">testList.innerHTML = <span class="string">""</span>;</span><br><span class="line">arrList.forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> testList.appendChild(x)); <span class="comment">// no need to create new elements</span></span><br></pre></td></tr></table></figure><h3 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h3><ul><li><p>找到待删除节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>);</span><br></pre></td></tr></table></figure></li><li><p>找到其<strong>父节点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br></pre></td></tr></table></figure></li><li><p>删除（返回被删除元素）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>删除多个节点时，注意索引可能在发生变化。（可以使用<strong>倒序</strong>删除）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>);</span><br><span class="line">parent.removeChild(parent.children[<span class="number">0</span>]);</span><br><span class="line">parent.removeChild(parent.children[<span class="number">1</span>]); <span class="comment">// &lt;-- 浏览器报错</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h2><p>因为表单本身也是DOM树，所以操作表单和操作DOM是类似的。不同的是，表单可以接收用户输入。</p><h3 id="输入控件"><a href="#输入控件" class="headerlink" title="输入控件"></a>输入控件</h3><ul><li><p>文本框：用于输入文本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"text"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>口令框：用于输入口令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"password"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>单选框：用于选择一项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"radio"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>复选框：用于选择多项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"checkbox"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>下拉框：用于选择一项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br></pre></td></tr></table></figure></li><li><p>隐藏文本：用户不可见，会把隐藏文本发送到服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"hidden"</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><ul><li><p>如果有一个<code>&lt;input&gt;</code>节点的引用，其<code>value</code>属性即对应<strong>输入值</strong>。<strong>（不是<code>innerText</code>）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type = "text" id = "email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value;</span><br></pre></td></tr></table></figure><blockquote><p>对<code>text</code>/<code>password</code>/<code>hidden</code>/<code>select</code>均适用</p></blockquote></li><li><p>对于<strong>单选框和复选框</strong>，<code>value</code>属性的值永远是<strong>默认值</strong>，含有<strong>有效信息</strong>的是<code>checked</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;</span></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="tuesday" value="2"&gt; Tuesday&lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">'monday'</span>);</span><br><span class="line"><span class="keyword">var</span> tue = <span class="built_in">document</span>.getElementById(<span class="string">'tuesday'</span>);</span><br><span class="line">mon.value; <span class="comment">// '1'</span></span><br><span class="line">tue.value; <span class="comment">// '2'</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br><span class="line">tue.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h3><ul><li><p>对于<code>text</code>/<code>password</code>/<code>hidden</code>/<code>select</code>，直接设置<code>value</code>即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" id="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value = <span class="string">'test@example.com'</span>; <span class="comment">// 文本框的内容已更新</span></span><br></pre></td></tr></table></figure></li><li><p>对于单选框和复选框，设置<code>checked</code>的布尔值即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type = "radio" name = "weekday" id = "monday" value = "1"&gt; Monday &lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">'monday'</span>);</span><br><span class="line">mon.checked = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTML5控件"><a href="#HTML5控件" class="headerlink" title="HTML5控件"></a>HTML5控件</h3><ul><li><p><code>date</code>：输入年月日</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"date"</span> value = <span class="string">"2020-07-09"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>datetime-local</code>：精确到秒的本地时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"datetime-local"</span> value = <span class="string">"2020-07-09T14:49:49"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>color</code>：显示一个色块供颜色选择</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input<span class="built_in"> type </span>= <span class="string">"color"</span> value = <span class="string">""</span>#ff0000<span class="string">"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><ul><li><p>通过AJAX实现</p></li><li><p>通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span> = <span class="string">"test-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span> = <span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"doSubmitForm()"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="actionscript"><span class="comment">// modify form here</span></span></span><br><span class="line">    form.submit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这种方式和浏览器默认的<code>&lt;button type = &quot;submit&quot;&gt;</code>重复</p></blockquote></li><li><p>响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span> = <span class="string">"test-form"</span> <span class="attr">onsubmit</span> = <span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span> = <span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// modify form here</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>返回<code>true</code>提醒浏览器继续提交</p></blockquote></li><li><p><code>hidden</code>元素的处理</p><p>在普通的密码输入表单中，提交表单时不输入明文口令，而是口令的MD5.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line">    pwd.value = toMD5(pwd.value);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当执行<code>toMD5</code>时，会出现密码框的几个<code>*</code>突然变成32个<code>*</code>的情况。</p></blockquote><p>使用<code>hidden</code>把存储<code>MD5</code>密码的输入端隐藏起来，就可以不改变用户本来输入的<code>*</code>的位数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"input-password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"md5-password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'input-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'md5-password'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line">    md5_pwd.value = toMD5(input_pwd.value);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>password</code>控件没有<code>name</code>属性，<strong>不会被</strong>上传。</p><blockquote><p>没有<code>name</code>的属性都不会被上传</p></blockquote></li><li><p>相当于用户输入<code>password</code>控件中，但是我们把处理的结果放在了<strong>被隐藏</strong>的<code>md5-password</code>中，<strong>而不是</strong>原来的<code>password</code>中，所以能够不影响用户本来的输入。</p></li></ul></li></ul><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul><li><p>在HTML表单中，上传文件的唯一控件是<code>&lt;input type = &quot;file&quot;&gt;</code></p><blockquote><p>当一个表单中含有该控件时，表单的<strong><code>enctype</code></strong>必须指定为<strong><code>multipart/form-data</code></strong>，<strong><code>method</code></strong>必须指定为<strong><code>post</code></strong>.</p></blockquote></li><li><p>JavaScript对控件的<code>value</code>修改不会造成影响，并且<strong>无法知道</strong>真实路径。</p></li><li><p>JavaScript可以在提交表单时对<strong>文件扩展名</strong>进行检查，防止无效文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>);</span><br><span class="line"><span class="keyword">var</span> filename = f.value;</span><br><span class="line"><span class="keyword">if</span> (!filename || !(filename.endsWith(<span class="string">'.jpg'</span>)) || filename.endsWith(<span class="string">'.png'</span>)) &#123;</span><br><span class="line">    alert(<span class="string">'Can only upload image file.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h3><p>HTML提供了<code>File</code>和<code>FileReader</code>两个主要对象，可以获取文件信息并读取文件。</p><ul><li><p>上传图片并解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-file'</span>),</span><br><span class="line">    info = <span class="built_in">document</span>.getElementById(<span class="string">'test-file-info'</span>),</span><br><span class="line">    preview = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-preview'</span>);</span><br><span class="line"><span class="comment">// 监听change事件:</span></span><br><span class="line">fileInput.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清除背景图片:</span></span><br><span class="line">    preview.style.backgroundImage = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">    <span class="keyword">if</span> (!fileInput.value) &#123;</span><br><span class="line">        info.innerHTML = <span class="string">'没有选择文件'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取File引用:</span></span><br><span class="line">    <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取File信息:</span></span><br><span class="line">    info.innerHTML = <span class="string">'文件: '</span> + file.name + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                     <span class="string">'大小: '</span> + file.size + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                     <span class="string">'修改: '</span> + file.lastModifiedDate;</span><br><span class="line">    <span class="keyword">if</span> (file.type !== <span class="string">'image/jpeg'</span> &amp;&amp; file.type !== <span class="string">'image/png'</span> &amp;&amp; file.type !== <span class="string">'image/gif'</span>) &#123;</span><br><span class="line">        alert(<span class="string">'不是有效的图片文件!'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件:</span></span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span></span><br><span class="line">            data = e.target.result; <span class="comment">// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            </span></span><br><span class="line">        preview.style.backgroundImage = <span class="string">'url('</span> + data + <span class="string">')'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 以DataURL的形式读取文件:</span></span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><ul><li><p>JavaScript永远是<strong>单线程</strong>模式执行的，因此JavaScript的多任务都是<strong>异步</strong>调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader.readAsDataURL(file);</span><br></pre></td></tr></table></figure><ul><li><p>发起一个<strong>异步操作</strong>读取文件内容，即原有JS代码<strong>继续</strong>执行。</p></li><li><p>因为是异步操作，所以不能确定什么时候操作结束。</p></li><li><p>增加一个<strong>回调函数</strong>解决上述问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// After reading file, this function will be called automatically.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>所谓回调函数就是在异步操作结束后会自动执行的程序片段</p></blockquote></li></ul></li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ul><li><p>Asynchronized JavaScript and XML, 使用JavaScript执行<strong>异步网络请求</strong>。</p></li><li><p>Web运作原理：一次HTTP请求对应一个页面</p><p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p></li><li><p>通过AJAX发送请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>创建<code>XMLHttpRequest</code>对象</p><p>通过检测<code>window</code>对象有没有<code>XMLHttpRequest</code>属性来确定浏览器是否支持，不要通过<code>navigator.userAgent</code>判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    request = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置<code>onreadystatechange</code>回调函数</p><ul><li>通过<code>readyState === 4</code>判断请求是否完成</li><li>通过<code>status === 200</code>判断相应是否成功</li></ul></li><li><p>设置<code>open</code>请求参数</p><ul><li><p><code>GET</code>/<code>POST</code></p></li><li><p>URL地址<strong>（相对路径）</strong></p><blockquote><p>默认情况下，JavaScript在发送AJAX请求时，URL<strong>域名</strong>必须和当前页面完全一致）</p><ul><li>域名要相同（<code>www.example.com</code>和<code>example.com</code>不同）</li><li>协议要相同（<code>http</code>和<code>https</code>不同）</li><li>端口号要相同（默认是<code>:80</code>）</li></ul></blockquote></li><li><p>操作是否异步，默认为<code>true</code>（异步）。</p></li></ul></li><li><p>使用<code>send</code>发送请求</p><ul><li><code>GET</code>请求不需要参数</li><li><code>POST</code>请求需要把body部分以字符串或者<code>FormDate</code>对象传进去</li></ul></li></ul></li></ul><h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><p>JavaScript访问外域网站</p><ul><li><p>通过Flash（不推荐）</p></li><li><p>通过在同源域名下架设一个代理服务器来转发，JavaScript可以把请求发送到代理服务器。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'<span class="string">/proxy</span>?url=http:<span class="string">//www.sina.com.cn</span>'</span><br></pre></td></tr></table></figure><ul><li>代理服务器把结果返回，这样就遵循了浏览器的同源策略。</li></ul></li><li><p>JSONP</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://example.com/abc.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>只能用<code>GET</code>请求，并且要求返回JavaScript</li></ul><p>获取股票指数</p><ul><li><p>创建回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshPrice</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'test-jsonp'</span>);</span><br><span class="line">    p.innerHTML = <span class="string">'当前价格：'</span> +</span><br><span class="line">        data[<span class="string">'0000001'</span>].name +<span class="string">': '</span> + </span><br><span class="line">        data[<span class="string">'0000001'</span>].price + <span class="string">'；'</span> +</span><br><span class="line">        data[<span class="string">'1399001'</span>].name + <span class="string">': '</span> +</span><br><span class="line">        data[<span class="string">'1399001'</span>].price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>触发请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPrice</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        js = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>),</span><br><span class="line">        head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">    js.src = <span class="string">'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice'</span>;</span><br><span class="line">    head.appendChild(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>CORS(HTML5推荐)：Cross-Origin Resource Sharing</p><p>跨域是否成功取决于：对方服务器是否为当前域请求设置一个正确的<code>Access-Control-Allow-Origin</code>.</p></li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>“承诺在将来会执行”的对象被称为<code>Promise</code>对象</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeOut = <span class="built_in">Math</span>.random() * <span class="number">2</span>;</span><br><span class="line">    log(<span class="string">'set timeout to: '</span> + timeOut + <span class="string">' seconds.'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            log(<span class="string">'call resolve()...'</span>);</span><br><span class="line">            resolve(<span class="string">'200 OK'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            log(<span class="string">'call reject()...'</span>);</span><br><span class="line">            reject(<span class="string">'timeout in '</span> + timeOut + <span class="string">' seconds.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test);</span><br><span class="line"><span class="keyword">var</span> p2 = p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = p2.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><code>p1</code>是一个<code>Promise</code>对象，它负责执行<code>test</code>函数。由于<code>test</code>函数在内部是异步执行的，当<code>test</code>函数执行成功时，执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当执行失败时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p2.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>Promise</code>对象可以串联起来进行代码简化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(test).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>Promise</code>可以按顺序执行若干个<strong>异步任务</strong>（都是<code>Promise</code>对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job1.then(job2).then(job3).catch(handleError);</span><br></pre></td></tr></table></figure><blockquote><p><code>job1</code>成功才会执行<code>job2</code>，以此类推。</p></blockquote></li><li><p><code>Promise</code>可以<strong>并行</strong>执行异步任务</p><ul><li><p>独立的并行任务（汇合）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 同时执行p1和p2，并在它们都完成后执行then:</span></span><br><span class="line">  <span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(results); <span class="comment">// 获得一个Array: ['P1', 'P2']</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>为了容错时，例如向两个URL读取用户的个人信息，只需要获得先返回的结果即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 'P1'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><ul><li><p>HTML5提供的控件，用于替代Flash.</p></li><li><p>一个<code>Canvas</code>定义了一个指定尺寸的矩形框，在这个范围内可以随意绘制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span> = <span class="string">"test-canvas"</span> <span class="attr">width</span> = <span class="string">"300"</span> <span class="attr">height</span> = <span class="string">"200"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>浏览器如果<strong>支持</strong><code>Canvas</code>，则会<strong>忽略</strong><code>Canvas</code>内的HTML代码。</li></ul></li></ul><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><ul><li><p>绘制2D图像</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br></pre></td></tr></table></figure></li><li><p>绘制3D图像</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gl = canvas.getContext(<span class="string">'webgl'</span>);</span><br></pre></td></tr></table></figure></li><li><p>绘制带阴影的文字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">'test-text-canvas'</span>),</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height); <span class="comment">// 擦除(0,0)位置大小为Canvas大小的矩形，擦除的意思是把该区域变为透明</span></span><br><span class="line">ctx.shadowOffsetX = <span class="number">2</span>;</span><br><span class="line">ctx.shadowOffsetY = <span class="number">2</span>;</span><br><span class="line">ctx.shadowBlur = <span class="number">2</span>;</span><br><span class="line">ctx.shadowColor = <span class="string">'#666666'</span>;</span><br><span class="line">ctx.font = <span class="string">'24px Arial'</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'#333333'</span>; <span class="comment">// 设置颜色</span></span><br><span class="line">ctx.fillText(<span class="string">'带阴影的文字'</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中。</li><li>尽量使用整数坐标而不是浮点数</li><li>创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图。</li><li>背景图片如果不变可以直接用<code>img</code>标签并放到<strong>最底层</strong></li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>全文共<code>5160</code>字，推荐阅读时间<code>30~45</code>分钟。</p><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><ul><li>消除浏览器差异</li><li>简化DOM操作</li><li>轻松实现动画、修改CSS等各种操作</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>在页面的<code>&lt;head&gt;</code>引入jQuery文件即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//code.jquery.com/jquery-1.11.3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>$</code>符号</p><p>jQuery把所有的功能都封装在一个全局变量<code>jQuery</code>中，而<code>$</code>就是它的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line"><span class="built_in">window</span>.$;</span><br><span class="line">$ === jQuery; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span>($); <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><ul><li><p><code>$</code>本质上就是一个对象，可以是函数，<strong>也有</strong>其他属性。</p></li><li><p>当原有代码<strong>已经</strong>使用了<script type="math/tex">`这个变量时，需要让`jQuery`放弃`</script>，并且之后仅能使用<code>jQuery</code>变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">jQuery.noConflict();</span><br><span class="line">$; <span class="comment">// undefined or old value</span></span><br><span class="line">jQuery; <span class="comment">// jQuery(selector, context)</span></span><br></pre></td></tr></table></figure><blockquote><p>原理是<code>jQuery</code>在占用<script type="math/tex">`之前会保存原有`</script>，当放弃<code>$</code>时会将原来保存的变量还原。</p></blockquote></li></ul></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>选择器是jQuery的核心</p><ul><li><p>按<code>id</code>查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找&lt;div id="abc"&gt;:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>返回对象是jQuery对象，<strong>类似数组</strong>（但不是数组），每个元素都是一个DOM对象的引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"abc"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>选择器<strong>不会返回</strong><code>undefined</code>或者<code>null</code></p></blockquote></li><li><p>jQuery和DOM对象转化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>); <span class="comment">// jQuery object</span></span><br><span class="line"><span class="keyword">var</span> divDom = div.get(<span class="number">0</span>); <span class="comment">// first DOM object</span></span><br><span class="line"><span class="keyword">var</span> another = $(divDom); <span class="comment">// DOM object -&gt; jQuery object</span></span><br></pre></td></tr></table></figure><ul><li>获取元素的value<ul><li>DOM:<code>xxx.value</code></li><li>jQuery:<code>xxx.get(xxx).value</code>/<code>xxx.val()</code></li></ul></li></ul><blockquote><p>通常<strong>直接使用</strong>jQuery对象更方便</p></blockquote></li></ul></li><li><p>按<code>tag</code>查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">'p'</span>); <span class="comment">// all &lt;p&gt; nodes</span></span><br><span class="line">ps.length; <span class="comment">// count of &lt;p&gt; nodes</span></span><br></pre></td></tr></table></figure></li><li><p>按<code>class</code>查找</p><ul><li>在<code>class</code>名称<strong>前</strong>加一个<code>.</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'.red'</span>);</span><br></pre></td></tr></table></figure><ul><li>查找有<strong>多个</strong><code>class</code>的节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'.red.green'</span>); <span class="comment">// no space between classnames</span></span><br></pre></td></tr></table></figure></li><li><p>按属性查找</p><ul><li>当属性的值包含<strong>空格</strong>等特殊字符时，需要使用双引号括起来。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> email = $(<span class="string">'[name=email]'</span>); <span class="comment">// find &lt;??? name="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> passwordInput = $(<span class="string">'[type=password]'</span>); <span class="comment">// 找出&lt;??? type="password"&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'[items="A B"]'</span>); <span class="comment">// 找出&lt;??? items="A B"&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以使用前缀查找和后缀查找</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'[name^=icon]'</span>); <span class="comment">// 找出所有name属性值以icon开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: name="icon-1", name="icon-2"</span></span><br><span class="line"><span class="keyword">var</span> names = $(<span class="string">'[name$=with]'</span>); <span class="comment">// 找出所有name属性值以with结尾的DOM</span></span><br><span class="line"><span class="comment">// 例如: name="startswith", name="endswith"</span></span><br></pre></td></tr></table></figure><ul><li>前后缀查找法<strong>不受</strong><code>class</code>个数的影响</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'[class^="icon-"]'</span>);</span><br><span class="line"><span class="comment">// 例如: class="icon-clock", class="abc icon-home"</span></span><br></pre></td></tr></table></figure></li><li><p>组合查找</p><p>解决查找结果混入表单外元素的情况，例如<code>$(&#39;[name=email]&#39;)</code>可能返回表单外的<code>&lt;div name=&quot;email&quot;&gt;</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emailInput = $(<span class="string">'input[name=email]'</span>); <span class="comment">// mix input and name</span></span><br><span class="line"><span class="keyword">var</span> tr = $(<span class="string">'tr.red'</span>); <span class="comment">// mix tag and class to find &lt;tr class = "red..."&gt;&lt;/tr&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>多项选择器</p><p>使用<code>,</code>组合多个选择器，结果取<strong>并集</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p,div'</span>); <span class="comment">// select all &lt;p&gt; and &lt;div&gt;</span></span><br><span class="line">$(<span class="string">'p.red,p.green'</span>); <span class="comment">// select all &lt;p class="red"&gt; and &lt;p class="green"&gt;</span></span><br></pre></td></tr></table></figure><ul><li>数组中的元素是按照他们在HTML中出现的顺序排列的，而且<strong>不会有重复</strong>元素。</li></ul></li></ul><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><p>如果两个DOM元素具有层级关系，就可以用<code>$(&#39;ancestor descendant&#39;)</code>进行选择，层级之间使用<strong>空格</strong>隔开。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"testing"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang-javascript"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang-python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang-lua"</span>&gt;</span>Lua<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用层级选择器选出JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.testing li.lang-javascript'</span>); <span class="comment">// &lt;li class="lang-javascript"&gt;javascript&lt;/li&gt;</span></span><br><span class="line">$(<span class="string">'ul.lang li.lang-javascript'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>只要是<strong>祖先</strong>节点，<strong>都</strong>可以查找到对应的DOM子节点。</p></li><li><p>选择所有的<code>&lt;li&gt;</code>节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li'</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>多层</strong>选择</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'form.test p input'</span>); <span class="comment">// 在form表单选择被&lt;p&gt;包含的&lt;input&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><p><code>$(&#39;parent&gt;child&#39;)</code>类层级选择器，但是限定了两个元素必须是<strong>父子</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang&gt;li.lang-javascript'</span>); <span class="comment">// 可以选出[&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]</span></span><br></pre></td></tr></table></figure><blockquote><p>使用<code>&lt;div.testing&gt;</code>当父节点则<strong>无法</strong>选出</p></blockquote><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>通常使用<code>:</code>附加在选择器上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li'</span>); <span class="comment">// 选出JavaScript、Python和Lua 3个节点</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'ul.lang li:first-child'</span>); <span class="comment">// 仅选出JavaScript</span></span><br><span class="line">$(<span class="string">'ul.lang li:last-child'</span>); <span class="comment">// 仅选出Lua</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(2)'</span>); <span class="comment">// 选出第N个元素，N从1开始</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(even)'</span>); <span class="comment">// 选出序号为偶数的元素</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(odd)'</span>); <span class="comment">// 选出序号为奇数的元素</span></span><br></pre></td></tr></table></figure><h4 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h4><p>使用格式：<code>$(&#39;:input&#39;)</code>/<code>$(&#39;form :input&#39;)</code></p><ul><li><p><code>:input</code>：可以选择<code>&lt;input&gt;</code>/<code>&lt;textarea&gt;</code>/<code>&lt;select&gt;</code>/<code>&lt;button&gt;</code></p></li><li><p><code>:file</code>：可以选择<code>&lt;input type=&quot;file&quot;&gt;</code>，等价于<code>input[type=file]</code>.</p></li><li><p><code>:checkbox</code>：选择复选框，等价于<code>input[type=checkbox]</code>.</p></li><li><p><code>:radio</code>：选择单选框</p></li><li><p><code>:focus</code>：选择当前输入焦点的元素，即当前光标所在的<code>&lt;input&gt;</code></p></li><li><p><code>:checked</code>：选择<strong>当前勾上</strong>的单选框和复选框，等价于<code>$(&#39;input[type=radio]:checked&#39;)</code>.</p><blockquote><p>复选框<code>&lt;checkbox&gt;</code>同理，但是有时候复选框内是<code>&lt;option&gt;</code>，则需要使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'option:checked'</span>).val();</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>:enabled</code>：正常的<code>&lt;input&gt;</code>/<code>&lt;select&gt;</code></p></li><li><p><code>:disabled</code>：选择不能输入的</p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><code>$(&#39;div:visible&#39;);</code>：选择所有可见的<code>&lt;div&gt;</code></li><li><code>$(&#39;div:hidden&#39;);</code>：选择所有隐藏的<code>&lt;div&gt;</code></li></ul><h3 id="查找和过滤"><a href="#查找和过滤" class="headerlink" title="查找和过滤"></a>查找和过滤</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>除了直接定位对象，还可以在拿到一个jQuery对象之后以它为基准进行查找。</p><ul><li><p><code>find()</code>：本身接收一个<strong>任意的选择器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js dy"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dy"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"swift"</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dy"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">"haskell"</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'ul.lang'</span>); <span class="comment">// 获得&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> dy = ul.find(<span class="string">'.dy'</span>); <span class="comment">// 获得JavaScript, Python, Scheme</span></span><br><span class="line"><span class="keyword">var</span> swf = ul.find(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> hsk = ul.find(<span class="string">'[name=haskell]'</span>); <span class="comment">// 获得Haskell</span></span><br></pre></td></tr></table></figure></li><li><p><code>parent()</code>：从当前节点<strong>向上</strong>查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swf = $(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> parent = swf.parent(); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = swf.parent(<span class="string">'.red'</span>); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象</span></span><br></pre></td></tr></table></figure></li><li><p><code>next()</code>/<code>prev()</code>：查找同一层级的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swift = $(<span class="string">'#swift'</span>);</span><br><span class="line"></span><br><span class="line">swift.next(); <span class="comment">// Scheme</span></span><br><span class="line">swift.next(<span class="string">'[name=haskell]'</span>); <span class="comment">// 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]</span></span><br><span class="line"></span><br><span class="line">swift.prev(); <span class="comment">// Python</span></span><br><span class="line">swift.prev(<span class="string">'.dy'</span>); <span class="comment">// Python，因为Python同时符合过滤器条件.dy</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p><code>filter()</code>可以<strong>过滤掉不符合</strong>选择器条件的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> a = langs.filter(<span class="string">'.dy'</span>); <span class="comment">// 拿到JavaScript, Python, Scheme</span></span><br></pre></td></tr></table></figure><ul><li><p>传入函数参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line">langs.filter(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML.indexOf(<span class="string">'S'</span>) === <span class="number">0</span>; <span class="comment">// 返回S开头的节点</span></span><br><span class="line">&#125;); <span class="comment">// 拿到Swift, Scheme</span></span><br></pre></td></tr></table></figure><ul><li><p><code>this</code>被绑定为<code>DOM</code>对象，而<strong>不是</strong>jQuery对象。</p></li><li><p>使用<code>map</code>将jQuery数组进行转化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> arr = langs.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML;</span><br><span class="line">&#125;).get(); <span class="comment">// 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']</span></span><br></pre></td></tr></table></figure><ul><li><strong>不带参数</strong>的<code>get()</code>可以得到jQuery类数组中<strong>所有的</strong>DOM元素组成的数组</li></ul></li></ul></li><li><p>其他操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> js = langs.first(); <span class="comment">// JavaScript，相当于$('ul.lang li:first-child')</span></span><br><span class="line"><span class="keyword">var</span> haskell = langs.last(); <span class="comment">// Haskell, 相当于$('ul.lang li:last-child')</span></span><br><span class="line"><span class="keyword">var</span> sub = langs.slice(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// Swift, Scheme, 参数和数组的slice()方法一致</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="操作DOM-1"><a href="#操作DOM-1" class="headerlink" title="操作DOM"></a>操作DOM</h2><h3 id="修改DOM节点"><a href="#修改DOM节点" class="headerlink" title="修改DOM节点"></a>修改DOM节点</h3><ul><li><p>修改Text和HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test-ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">"book"</span>&gt;</span>Java <span class="symbol">&amp;amp;</span> JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).text(); <span class="comment">// 'Java &amp; JavaScript'</span></span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).html(); <span class="comment">// 'Java &amp;amp; JavaScript'</span></span><br></pre></td></tr></table></figure><ul><li><p>无参数调用<code>text()</code>/<code>html()</code>是获取文本，传入参数就变成<strong>设置</strong>文本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j1.html(<span class="string">'&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;'</span>);</span><br><span class="line">j2.text(<span class="string">'JavaScript &amp; ECMAScript'</span>);</span><br></pre></td></tr></table></figure></li><li><p>对jQuery对象的修改会影响其中的<strong>所有</strong>DOM元素</p></li><li><p>当jQuery对象是<strong>空</strong>时尝试修改也<strong>不会报错</strong>（省略<code>if</code>判断）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'not-exist'</span>).text(<span class="string">'Hello'</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改CSS</p><p>利用jQuery<strong>批量修改</strong>的特点实现高亮显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test-css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang dy"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang dy"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang dy"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-css li.dy&gt;span'</span>).css(<span class="string">'background-color'</span>, <span class="string">'#ffd351'</span>).css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>css(&#39;name&#39;, &#39;value&#39;)</code>：作用于DOM节点的<code>style</code>属性，修改CSS样式表中对应域的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.css(<span class="string">'color'</span>); <span class="comment">// '#000033', 获取CSS属性</span></span><br><span class="line">div.css(<span class="string">'color'</span>, <span class="string">'#336699'</span>); <span class="comment">// 设置CSS属性</span></span><br><span class="line">div.css(<span class="string">'color'</span>, <span class="string">''</span>); <span class="comment">// 清除CSS属性</span></span><br></pre></td></tr></table></figure></li><li><p><code>background-color</code>和<code>backgroundColor</code>等价</p></li><li><p>修改DOM节点的<code>class</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.hasClass(<span class="string">'highlight'</span>); <span class="comment">// false， class是否包含highlight</span></span><br><span class="line">div.addClass(<span class="string">'highlight'</span>); <span class="comment">// 添加highlight这个class</span></span><br><span class="line">div.removeClass(<span class="string">'highlight'</span>); <span class="comment">// 删除highlight这个class</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>显示和隐藏DOM</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'a[target=_blank]'</span>);</span><br><span class="line">a.hide(); <span class="comment">// 隐藏</span></span><br><span class="line">a.show(); <span class="comment">// 显示</span></span><br></pre></td></tr></table></figure><blockquote><p>显示和隐藏<strong>不改变</strong>原有的DOM树结构</p></blockquote></li><li><p>获取DOM信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器可视窗口大小:</span></span><br><span class="line">$(<span class="built_in">window</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">window</span>).height(); <span class="comment">// 600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML文档大小:</span></span><br><span class="line">$(<span class="built_in">document</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">document</span>).height(); <span class="comment">// 3500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个div的大小:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.width(); <span class="comment">// 600</span></span><br><span class="line">div.height(); <span class="comment">// 300</span></span><br><span class="line">div.width(<span class="number">400</span>); <span class="comment">// 设置CSS属性 width: 400px，是否生效要看CSS是否有效</span></span><br><span class="line">div.height(<span class="string">'200px'</span>); <span class="comment">// 设置CSS属性 height: 200px，是否生效要看CSS是否有效</span></span><br></pre></td></tr></table></figure><ul><li><p><code>attr()</code>/<code>removeAttr()</code>常用于操作DOM节点的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id="test-div" name="Test" start="1"&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.attr(<span class="string">'data'</span>); <span class="comment">// undefined, 属性不存在</span></span><br><span class="line">div.attr(<span class="string">'name'</span>); <span class="comment">// 'Test'</span></span><br><span class="line">div.attr(<span class="string">'name'</span>, <span class="string">'Hello'</span>); <span class="comment">// div的name属性变为'Hello'</span></span><br><span class="line">div.removeAttr(<span class="string">'name'</span>); <span class="comment">// 删除name属性</span></span><br><span class="line">div.attr(<span class="string">'name'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><p><code>prop()</code>方法和<code>attr()</code>类似，但是在<code>checked</code>的处理上不同。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test-radio"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">checked</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test-radio"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>两种<code>checked</code>的表示都是合法的</p></li><li><p>两个方法的返回值<strong>不同</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radio = $(<span class="string">'#test-radio'</span>);</span><br><span class="line">radio.attr(<span class="string">'checked'</span>); <span class="comment">// 'checked'</span></span><br><span class="line">radio.prop(<span class="string">'checked'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>推荐</strong>使用<code>is()</code>判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radio = $(<span class="string">'#test-radio'</span>);</span><br><span class="line">radio.is(<span class="string">':checked'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>类似的<code>selected</code>使用<code>is(&#39;:selected&#39;)</code>处理</p></blockquote></li></ul></li></ul></li></ul></li><li><p>操作表单</p><p>jQuery对象统一使用<code>val()</code>方法<strong>获取和设置</strong>对应的<code>value</code>属性</p></li></ul><h3 id="修改DOM结构"><a href="#修改DOM结构" class="headerlink" title="修改DOM结构"></a>修改DOM结构</h3><ul><li><p>添加DOM</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-div"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>拿到节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'#test-div&gt;ul'</span>);</span><br></pre></td></tr></table></figure></li><li><p>调用<code>append</code>传入<code>HTML</code>片段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>append</code>还可以传入其他对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建DOM对象:</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">ps.innerHTML = <span class="string">'&lt;span&gt;Pascal&lt;/span&gt;'</span>;</span><br><span class="line"><span class="comment">// 添加DOM对象:</span></span><br><span class="line">ul.append(ps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加jQuery对象:</span></span><br><span class="line">ul.append($(<span class="string">'#scheme'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加函数对象:</span></span><br><span class="line">ul.append(<span class="function"><span class="keyword">function</span> (<span class="params">index, html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;li&gt;&lt;span&gt;Language - '</span> + index + <span class="string">'&lt;/span&gt;&lt;/li&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>在添加函数对象时，要求返回一个字符串/DOM对象/jQuery对象。</li></ul></li><li><p><code>prepend</code>和<code>append</code>相对</p></li><li><p><strong>同级节点</strong>的插入可以使用<code>before()</code>/<code>after()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = $(<span class="string">'#test-div&gt;ul&gt;li:first-child'</span>);</span><br><span class="line">js.after(<span class="string">'&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>删除节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> li = $(<span class="string">'#test-div&gt;ul&gt;li'</span>);</span><br><span class="line">li.remove(); <span class="comment">// delete all li DOM nodes</span></span><br></pre></td></tr></table></figure></li><li><p><code>innerText</code>&amp;<code>innerHTML</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>   This element has extra spacing     and contains <span class="tag">&lt;<span class="name">span</span>&gt;</span>a span element<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = $(<span class="string">'#demo'</span>).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>p.innerText</code>：<code>&quot;This element has extra spacing and contains a span element.&quot;</code></p><p>返回忽略<strong>所有的tag和多余空格</strong>的字符串</p></li><li><p><code>p.innerHTML</code>：<code>&quot;  This element has extra spacing   and contains &lt;span&gt;a span element&lt;/span&gt;.&quot;</code></p><p>返回<strong>原样</strong>字符串</p></li><li><p><code>p.textContent</code>：<code>&quot;  This element has extra spacing  and contains a span element.&quot;</code></p><p>返回<strong>含有多余空格</strong>的字符串</p></li></ul></li></ul><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>除了列出的3种语言外，请再添加Pascal、Lua和Ruby，然后按字母顺序排序节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-div"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    arr,</span><br><span class="line">    li,</span><br><span class="line">    ul = $(<span class="string">'#test-div ul'</span>);</span><br><span class="line"></span><br><span class="line">ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;Pascal&lt;/span&gt;&lt;/li&gt;'</span>).append(<span class="string">'&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'</span>).append(<span class="string">'&lt;li&gt;&lt;span&gt;Ruby&lt;/span&gt;&lt;/li&gt;'</span>);</span><br><span class="line">li = ul.find(<span class="string">'li'</span>);</span><br><span class="line">span = li.find(<span class="string">'span'</span>);</span><br><span class="line"></span><br><span class="line">span.each(<span class="function">(<span class="params">x, elem</span>) =&gt;</span> &#123;</span><br><span class="line">    arr.push(elem);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.innerText &gt; b.innerText) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a.innerText &lt; b.innerText) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ul.empty();</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;'</span>+ x.innerHTML +<span class="string">'&lt;/span&gt;&lt;/li&gt;'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>jQuery元素的遍历：<code>each(index, elem)</code></p><blockquote><p>可以先转换为DOM后遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.get().forEach(elem, index, array);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>数组的遍历<code>forEach(elem, index, array)</code>（和前者<strong>参数顺序</strong>区别）</p></li><li><p><code>sort</code>函数返回的<strong>不是</strong>布尔值，而是<code>-1 0 1</code>.</p></li><li><p>数据层次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">jQuery--&gt;DOM</span><br><span class="line">DOM--&gt;innerHTML&#x2F;innerText</span><br></pre></td></tr></table></figure></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li>页面加载后，一旦页面上默认执行的JS代码被执行完之后，就只能依赖触发事件来执行JS代码。</li></ul><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul><li>click：单击触发</li><li>dblclick：双击触发</li><li>mouseenter：鼠标进入触发</li><li>mouseleave：鼠标离开触发</li><li>mousemove：鼠标在DOM内移动触发</li><li>hover：相当于mouseenter加上mouseleave</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;a id="test-link" href="#0"&gt;点我试试&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取超链接的jQuery对象:</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'#test-link'</span>);</span><br><span class="line">a.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>事件捕捉可以简化<strong>（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p><strong>仅作用</strong>在当前焦点的DOM上，通常是<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>.</p><ul><li>keydown：键盘按下时触发</li><li>keyup：键盘松开时触发</li><li>keypress：按一次键后触发</li></ul><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><ul><li><p>focus：当DOM获得焦点时触发</p></li><li><p>blur：当DOM失去焦点时触发</p></li><li><p>change：当<code>&lt;input&gt;</code>/<code>&lt;select&gt;</code>/<code>&lt;textarea&gt;</code>的内容改变时触发</p></li><li><p>submit：当<code>&lt;form&gt;</code>提交时触发</p></li><li><p>ready：当页面被载入并且DOM树<strong>完成初始化</strong>后触发</p><ul><li><p>仅作用于<code>document</code>对象</p></li><li><p>常用来约束初始化的先后顺序</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 代码有误:</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">'#testForm'</span>).on(<span class="string">'submit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">'submit!'</span>);</span></span><br><span class="line">        &#125;);</span><br><span class="line"><span class="actionscript"><span class="comment">// correct:</span></span></span><br><span class="line"><span class="javascript">$(<span class="built_in">document</span>).on(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">'#testForm'</span>).on(<span class="string">'submit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">                alert(<span class="string">'submit!'</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testForm"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>不使用<code>ready</code>约束时，<code>testForm</code>表单还没有初始化，<code>submit</code>事件就发起了绑定请求，此时绑定不会成功。</p></li><li><p>使用<code>ready</code>和<code>submit</code>简化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testForm'</span>).submit(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'submit!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>直接省略<code>ready</code></strong>（常用且推荐）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testForm'</span>).submit(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'submit!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h3><p>所有的事件都会传入<code>Event</code>对象作为参数，可以从<code>Event</code>对象上获取更多信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testMouseMoveDiv'</span>).mousemove(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testMouseMoveSpan'</span>).text(<span class="string">'pageX = '</span> + e.pageX + <span class="string">', pageY = '</span> + e.pageY);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>此时<code>e</code>就是一个<code>Event</code>对象</p></blockquote><h4 id="解除绑定"><a href="#解除绑定" class="headerlink" title="解除绑定"></a>解除绑定</h4><p>一个被绑定的事件可以解除绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.click(hello);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">a.off(<span class="string">'click'</span>, hello);</span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>off</code>中的函数参数必须和绑定的函数<strong>完全一致</strong>，也就是说在<code>click</code>绑定时就<strong>不能使用</strong>匿名函数。</p></li><li><p>一次性移除<code>click</code>事件绑定的所有函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.off(<span class="string">'click'</span>);</span><br></pre></td></tr></table></figure></li><li><p>移除DOM绑定的所有函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.off();</span><br></pre></td></tr></table></figure></li></ul><h4 id="事件触发条件"><a href="#事件触发条件" class="headerlink" title="事件触发条件"></a>事件触发条件</h4><p>事件的触发<strong>总是</strong>由用户决定的</p><ul><li><p>监控文本框改动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.change(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'changed...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>这个函数只会被<strong>用户</strong>输入触发，使用JS修改不会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.val(<span class="string">'change it!'</span>); <span class="comment">// 无法触发change事件</span></span><br></pre></td></tr></table></figure><ul><li><p>特殊情况下，JS中无参数<code>change()</code>会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.val(<span class="string">'change it!'</span>);</span><br><span class="line">input.change(); <span class="comment">// input.trigger('change');</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="浏览器安全限制"><a href="#浏览器安全限制" class="headerlink" title="浏览器安全限制"></a>浏览器安全限制</h3><p>部分JS代码只能在<strong>用户触发</strong>下才能执行，例如<code>window.open()</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法弹出新窗口，将被浏览器屏蔽:</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">'/'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button1 = $(<span class="string">'#testPopupButton1'</span>);</span><br><span class="line"><span class="keyword">var</span> button2 = $(<span class="string">'#testPopupButton2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popupTestWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">'/'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button1.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    popupTestWindow();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">button2.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不立刻执行popupTestWindow()，3秒后执行:</span></span><br><span class="line">    setTimeout(popupTestWindow, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>对于<code>button1</code>，因为函数在事件中<strong>立即</strong>执行，因此可以成功。</li><li>对于<code>button2</code>，因为函数被<strong>延迟执行</strong>，当开始执行时<code>click</code>事件已经结束，故<strong>不会执行</strong>。（不同的浏览器行为存在差异，safari可以屏蔽，但是chrome存在打开情况）</li></ul><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>对如下的Form表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span> <span class="attr">action</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>请选择想要学习的编程语言：<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"selectAll"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"selectAll"</span>&gt;</span>全选<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">"deselectAll"</span>&gt;</span>全不选<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#0"</span> <span class="attr">class</span>=<span class="string">"invertSelect"</span>&gt;</span>反选<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"javascript"</span>&gt;</span> JavaScript<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"python"</span>&gt;</span> Python<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"ruby"</span>&gt;</span> Ruby<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"haskell"</span>&gt;</span> Haskell<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"scheme"</span>&gt;</span> Scheme<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绑定合适的事件处理函数，实现以下逻辑：</p><ul><li>当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选”；</li><li>当用户去掉“全不选”时，自动不选中所有语言；</li><li>当用户点击“反选”时，自动把所有语言状态反转（选中的变为未选，未选的变为选中）；</li><li>当用户把所有语言都手动勾上时，“全选”被自动勾上，并变为“全不选”；</li><li>当用户手动去掉选中至少一种语言时，“全不选”自动被去掉选中，并变为“全选”。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    form = $(<span class="string">'#test-form'</span>),</span><br><span class="line">    langs = form.find(<span class="string">'[name=lang]'</span>),</span><br><span class="line">    selectAll = form.find(<span class="string">'label.selectAll :checkbox'</span>),</span><br><span class="line">    selectAllLabel = form.find(<span class="string">'label.selectAll span.selectAll'</span>),</span><br><span class="line">    deselectAllLabel = form.find(<span class="string">'label.selectAll span.deselectAll'</span>),</span><br><span class="line">    invertSelect = form.find(<span class="string">'a.invertSelect'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置初始化状态:</span></span><br><span class="line">form.find(<span class="string">'*'</span>).show().off();</span><br><span class="line">form.find(<span class="string">':checkbox'</span>).prop(<span class="string">'checked'</span>, <span class="literal">false</span>).off();</span><br><span class="line">deselectAllLabel.hide();</span><br><span class="line"><span class="comment">// 拦截form提交事件:</span></span><br><span class="line">form.off().submit(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    alert(form.serialize());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    form = $(<span class="string">'#test-form'</span>),</span><br><span class="line">    langs = form.find(<span class="string">'[name=lang]'</span>),</span><br><span class="line">    selectAll = form.find(<span class="string">'label.selectAll :checkbox'</span>),</span><br><span class="line">    selectAllLabel = form.find(<span class="string">'label.selectAll span.selectAll'</span>),</span><br><span class="line">    deselectAllLabel = form.find(<span class="string">'label.selectAll span.deselectAll'</span>),</span><br><span class="line">    invertSelect = form.find(<span class="string">'a.invertSelect'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置初始化状态:</span></span><br><span class="line">form.find(<span class="string">'*'</span>).show().off();</span><br><span class="line">form.find(<span class="string">':checkbox'</span>).prop(<span class="string">'checked'</span>, <span class="literal">false</span>).off();</span><br><span class="line">deselectAllLabel.hide();</span><br><span class="line"><span class="comment">// 拦截form提交事件:</span></span><br><span class="line">form.off().submit(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    alert(form.serialize());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectAll.prop(<span class="string">'checked'</span>)) &#123;</span><br><span class="line">        selectAllLabel.hide();</span><br><span class="line">        deselectAllLabel.show();</span><br><span class="line">        langs.prop(<span class="string">'checked'</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        langs.prop(<span class="string">'checked'</span>, <span class="literal">false</span>);</span><br><span class="line">        deselectAllLabel.hide();</span><br><span class="line">        selectAllLabel.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selectAll.change(setAll);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invertSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    langs.get().forEach(<span class="function">(<span class="params">elem</span>) =&gt;</span> elem.checked = !elem.checked);</span><br><span class="line">    <span class="comment">// langs.each((i, elem) =&gt; &#123;elem.checked = !elem.checked&#125;);</span></span><br><span class="line">    checkAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invertSelect.click(invertSet);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> allLangs = langs.get().every(<span class="function">(<span class="params">x</span>) =&gt;</span> x.checked);</span><br><span class="line">    <span class="keyword">if</span> (allLangs) &#123;</span><br><span class="line">        selectAllLabel.hide();</span><br><span class="line">        deselectAllLabel.show();</span><br><span class="line">        selectAll.prop(<span class="string">'checked'</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        selectAllLabel.show();</span><br><span class="line">        deselectAllLabel.hide();</span><br><span class="line">        selectAll.prop(<span class="string">'checked'</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">langs.change(checkAll);</span><br></pre></td></tr></table></figure><ul><li>在使用箭头函数时，就算<strong>只有一条语句</strong>也最好加上<code>{}</code>，否则<code>each</code>会有异常。</li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>原理：以固定的时间间隔（如0.1s），每次把DOM元素的CSS样式修改一点，看起来就像动画了。</p><h3 id="show-hide"><a href="#show-hide" class="headerlink" title="show/hide"></a>show/hide</h3><p>调用<code>show()</code>和<code>hide()</code>时传进一个参数，就变成了动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-show-hide'</span>);</span><br><span class="line">div.hide(<span class="number">3000</span>); <span class="comment">// 3000ms</span></span><br><span class="line">div.show(<span class="string">'slow'</span>); <span class="comment">// 600ms</span></span><br></pre></td></tr></table></figure><ul><li><code>toggle</code>根据当前状态取反决定<code>show</code>还是<code>hide</code></li><li>动画都从<strong>左上角</strong>展开/收缩的</li></ul><h3 id="slideUp-slideDown"><a href="#slideUp-slideDown" class="headerlink" title="slideUp/slideDown"></a>slideUp/slideDown</h3><ul><li>动画像卷帘一样（上下）</li><li>一样有<code>slideToggle()</code>函数</li></ul><h3 id="fadeIn-fadeOut"><a href="#fadeIn-fadeOut" class="headerlink" title="fadeIn/fadeOut"></a>fadeIn/fadeOut</h3><ul><li>动画效果是<strong>原地淡入淡出</strong>（原理是设置<code>opacity</code>属性）</li><li>一样有<code>fadeToggle()</code>函数</li></ul><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><ul><li><p>通过<code>animate()</code>实现</p><p>参数是DOM元素<strong>最终的</strong>CSS状态和时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animate'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li><p>传入函数参数作为<strong>回调</strong>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animate'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"end of cartoon."</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="串行动画"><a href="#串行动画" class="headerlink" title="串行动画"></a>串行动画</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animates'</span>);</span><br><span class="line"><span class="comment">// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小</span></span><br><span class="line">div.slideDown(<span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'256px'</span>,</span><br><span class="line">       height: <span class="string">'256px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'128px'</span>,</span><br><span class="line">       height: <span class="string">'128px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AJAX-1"><a href="#AJAX-1" class="headerlink" title="AJAX"></a>AJAX</h2><ul><li><p>全局对象<code>jQuery</code>绑定了<code>ajax()</code>函数</p></li><li><p><code>ajax(url, settings)</code>接收一个URL和可选的<code>settings</code>对象</p><ul><li>async：异步执行AJAX，<strong>默认</strong>为<code>true</code>.（最好<strong>不要修改</strong>）</li><li>method：<strong>缺省</strong>为<code>&#39;GET&#39;</code>，可指定为<code>&#39;POST&#39;</code>/<code>&#39;PUT&#39;</code>.</li><li>contentType：发送POST请求所使用的格式</li><li>data：发送的数据，字符串/数组/object.</li><li>headers：发送额外的HTTP头，必须是一个object.</li><li>dataType：接收得数据格式，可以指定为html/xml/json/text.</li></ul></li><li><p>下例发送一个<code>GET</code>请求，并返回一个<code>JSON</code>格式的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'xxx'</span>, &#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用链式写法模拟回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxLog</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> txt = $(<span class="string">'#test-response-text'</span>);</span><br><span class="line">    txt.val(txt.val() + <span class="string">'\n'</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#test-response-text'</span>).val(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'/api/categories'</span>, &#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'成功, 收到的数据: '</span> + <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;).fail(<span class="function"><span class="keyword">function</span> (<span class="params">xhr, status</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'失败: '</span> + xhr.status + <span class="string">', 原因: '</span> + status);</span><br><span class="line">&#125;).always(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'请求完成: 无论成功或失败都会调用'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.<span class="keyword">get</span>('xxx', &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>第二个参数是对象时，会自动变成query string追加到url后面，不需要手动编码。</li></ul><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.post(<span class="string">'xxx'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>和<code>get</code>类似，只是第二个参数（对象）序列化方式不同。</li></ul><h3 id="getJSON"><a href="#getJSON" class="headerlink" title="getJSON"></a>getJSON</h3><p>用于快速获取一个JSON对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.getJSON(<span class="string">'xxx'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// data is already in JSON format</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="安全限制-1"><a href="#安全限制-1" class="headerlink" title="安全限制"></a>安全限制</h3><p>和AJAX的安全限制一致</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>通过扩展jQuery来实现自定义方法</p><h3 id="编写jQuery插件"><a href="#编写jQuery插件" class="headerlink" title="编写jQuery插件"></a>编写jQuery插件</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>通过向<code>$.fn</code>绑定新对象实现</li><li>插件函数最后要<code>return this;</code></li><li>插件函数要有默认值，绑定在<code>$.fn.&lt;pluginName&gt;.defaults</code>对象上。</li><li>用户在调用时可以传入自定义值覆盖调用值</li></ul><h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><ul><li><p>新增高亮插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, <span class="string">'#fffceb'</span>).css(<span class="string">'color'</span>, <span class="string">'#d85030'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>this</code>在调用时被绑定为<strong>jQuery对象</strong>，所有的jQuery对象都可以<strong>直接调用</strong>（不需要<code>,fn</code>）该方法。</p></li><li><p><code>return this;</code>是为了支持jQuery的链式操作特征</p></li><li><p>验证</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-highlight1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>什么是<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span>是目前最流行的<span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span>库。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-highlight1 span'</span>).highlight1();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>改进高亮插件，增加颜色自定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight2 = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bgcolor = options &amp;&amp; options.backgroundColor || <span class="string">'#fffceb'</span>;</span><br><span class="line">    <span class="keyword">var</span> color = options &amp;&amp; options.color || <span class="string">'#d85030'</span>;</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, bgcolor).css(<span class="string">'color'</span>, color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意过滤options本身及其属性为<code>undefined</code>的情况</p></li><li><p>验证</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-highlight2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>什么是<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Plugin<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>编写<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Plugin<span class="tag">&lt;/<span class="name">span</span>&gt;</span>可以用来扩展<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的功能。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-highlight2 span'</span>).highlight2(&#123;</span><br><span class="line">    backgroundColor: <span class="string">'#00a8e6'</span>,</span><br><span class="line">    color: <span class="string">'#ffffff'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>升级高亮插件，增加<strong>自定义缺省值</strong>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> opts = $.extend(&#123;&#125;, $.fn.highlight.defaults, options);</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, opts.backgroundColor).css(<span class="string">'color'</span>, opts.color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.fn.highlight.defaults = &#123;</span><br><span class="line">    color: <span class="string">'#d85030'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'#fff8de'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>$.extend(target, obj1, obj2, ...)</code>：<strong>高级短路操作</strong>，将<code>target</code>之后的对象拆开，将其属性求并集加入<code>target</code>中。对于同名属性，<strong>位置越靠后优先级越高</strong>。</p></li><li><p>验证</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-highlight"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>如何编写<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Plugin<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>编写<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Plugin<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，要设置<span class="tag">&lt;<span class="name">span</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，并允许用户修改<span class="tag">&lt;<span class="name">span</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，或者运行时传入<span class="tag">&lt;<span class="name">span</span>&gt;</span>其他值<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight.defaults.color = <span class="string">'#659f13'</span>;</span><br><span class="line">$.fn.highlight.defaults.backgroundColor = <span class="string">'#f2fae3'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#test-highlight p:first-child span'</span>).highlight();</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#test-highlight p:last-child span'</span>).highlight(&#123;</span><br><span class="line">    color: <span class="string">'#dd1144'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="针对特定元素扩展"><a href="#针对特定元素扩展" class="headerlink" title="针对特定元素扩展"></a>针对特定元素扩展</h3><p>让插件只能在特定的DOM元素上使用</p><h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4><p>为所有指向外链的超链接加上跳转提示</p><ul><li><p>用户调用代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#main a'</span>).external();</span><br></pre></td></tr></table></figure></li><li><p>编写<code>external</code>扩展</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.fn.external = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return返回的each()返回结果，支持链式调用:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="string">'a'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注意: each()内部的回调函数的this绑定为DOM本身!</span></span><br><span class="line">        <span class="keyword">var</span> a = $(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">var</span> url = a.attr(<span class="string">'href'</span>);</span><br><span class="line">        <span class="keyword">if</span>(url &amp;&amp; (url.indexOf(<span class="string">'https://'</span>) === <span class="number">0</span>) || url.indexOf(<span class="string">'https://'</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">            a.attr(<span class="string">'href'</span>, <span class="string">"#0"</span>)</span><br><span class="line">             .removeAttr(<span class="string">'target'</span>)</span><br><span class="line">             .append(<span class="string">' &lt;i class="uk-icon-external-link"&gt;&lt;/i&gt;'</span>)</span><br><span class="line">             .click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                 <span class="keyword">if</span>(confirm(<span class="string">'sure to go to '</span> + url + <span class="string">'?'</span>)) &#123;</span><br><span class="line">                     <span class="built_in">window</span>.open(url);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>全文共<code>633</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><ul><li><p>错误类型</p><ul><li><p>程序逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> len = s.length;</span><br></pre></td></tr></table></figure><ul><li><code>null</code>对象访问<code>length</code>对象会出错</li></ul></li><li><p>无法预测</p><ul><li>网络中断</li><li>文件不存在</li><li>权限问题</li></ul></li></ul></li><li><p>处理机制</p><p>和Java类似，采用<code>try...catch...finally</code>机制</p><ul><li><code>catch</code>和<code>finally</code>都可以省略</li></ul></li><li><p>错误类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">Error--&gt;TypeError</span><br><span class="line">Error--&gt;ReferenceError</span><br><span class="line">Error--&gt;...</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>) &#123;</span><br><span class="line">        alert(<span class="string">'Type error!'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">        alert(e.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'Error: '</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不同于Java，在JavaScript中只<code>catch</code><strong>一次</strong>，各个错误的分类处理通过<code>if</code>实现。</li></ul></li><li><p>抛出错误</p><p>和Java类似，使用<code>throw</code>语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r, n, s;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    s = prompt(<span class="string">'Please input a number:'</span>);</span><br><span class="line">    n = <span class="built_in">parseInt</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(n)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not a Number!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// Error: Not a Number!</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h2><ul><li>和Java类似，JavaScript的错误会逐层向上抛出，直到<strong>第一个</strong><code>try...catch</code>语句。</li><li>抛出错误的方法<strong>不需要</strong>特殊声明<code>throws ...</code></li></ul><h2 id="异步错误处理"><a href="#异步错误处理" class="headerlink" title="异步错误处理"></a>异步错误处理</h2><p>异步代码无法确保在调用时捕获错误，因为在捕获有效时，回调函数可能并未执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    setTimeout(printTime, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行时<strong>不会</strong>触发<code>catch</code>语句</p></li><li><p>同理，对于事件处理，在<strong>绑定事件的代码处</strong>处理错误是没有效果的。</p><ul><li><p>以下js代码在输入错误时按键<strong>不会</strong>报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $btn.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span></span><br><span class="line">            x = <span class="built_in">parseFloat</span>($(<span class="string">'#x'</span>).val()),</span><br><span class="line">            y = <span class="built_in">parseFloat</span>($(<span class="string">'#y'</span>).val()),</span><br><span class="line">            r;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(x) || <span class="built_in">isNaN</span>(y)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'输入有误'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r = x + y;</span><br><span class="line">        alert(<span class="string">'计算结果：'</span> + r);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    alert(<span class="string">'输入有误！'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题在于<code>try...catch</code>在按下按钮前已经执行完了，因此输入错误不能够找到对应的错误处理函数。</li></ul></li><li><p>修改后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        x = <span class="built_in">parseFloat</span>($(<span class="string">'#x'</span>).val()),</span><br><span class="line">        y = <span class="built_in">parseFloat</span>($(<span class="string">'#y'</span>).val()),</span><br><span class="line">        r;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(x) || <span class="built_in">isNaN</span>(y)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'输入有误'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    r = x + y;</span><br><span class="line">    alert(<span class="string">'计算结果：'</span> + r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callCal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cal();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        alert(<span class="string">'输入有误！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$btn.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cal();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        alert(<span class="string">'输入有误！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>修改的要点：<code>click</code>绑定的函数在每次<code>click</code>时<strong>都会执行</strong>，所以错误处理逻辑需要封装进<code>click</code>绑定的函数。</p></li><li><p><code>click</code>的参数列表是<code>[ [ data ,]  handler ]</code></p><p>因此如果传入的参数是<strong>匿名函数</strong>即<code>function(xxx){...}</code>，此时<code>click</code>把参数解析为<code>handler</code>.但是如果传入的是一个封装好的函数，就会被识别成<code>data</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$btn.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cal();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        alert(<span class="string">'输入有误！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// equals</span></span><br><span class="line">$btn.click(callCal, callCal);</span><br></pre></td></tr></table></figure><ul><li>第一个<code>callCal</code>是用来<strong>占位</strong>的</li></ul></li></ul></li></ul></li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="underscore"><a href="#underscore" class="headerlink" title="underscore"></a>underscore</h1><p>全文共<code>1858</code>字，推荐阅读时间<code>10~15</code>分钟。</p><h2 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h2><p>在<code>Object</code>上使用数组才有的<code>map()</code>/<code>filter()</code>等操作</p><ul><li>在<code>Object.prototype</code>中加上<code>mapObject()</code>等类似的方法</li><li>找一个成熟的第三方开源库，统一使用的函数。<ul><li>underscore就是这样一个库</li></ul></li></ul><p>与jQuery类似</p><ul><li><p>underscore把自己绑定在<code>_</code>上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x); <span class="comment">// Array</span></span><br><span class="line">_.map(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;, (value, key) =&gt; key + <span class="string">'='</span> + value); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><ul><li>注意箭头函数传入对象参数时，第一个参数是<code>value</code>，<strong>不是<code>key</code></strong>.</li></ul></li></ul><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>underscore支持集合类（Array/Object），不支持Map和Set.</p><h3 id="map-filter"><a href="#map-filter" class="headerlink" title="map/filter"></a>map/filter</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> upperArr = _.map(obj, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> upperObj = _.mapObject(obj, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">upperArr; <span class="comment">// ["BOB","NO.1 MIDDLE SCHOOL","XUEYUAN ROAD"]</span></span><br><span class="line">upperObj; <span class="comment">// &#123;"name":"BOB","school":"NO.1 MIDDLE SCHOOL","address":"XUEYUAN ROAD"&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意两种<code>map</code>操作的返回值类型<strong>不同</strong></p></blockquote><h3 id="every-some"><a href="#every-some" class="headerlink" title="every/some"></a>every/some</h3><ul><li><p>当集合的<strong>所有元素</strong>都满足条件时，<code>_.every()</code>返回<code>true</code>；当集合<strong>至少一个元素</strong>满足条件时，<code>_.some()</code>函数返回<code>true</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.every([<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x &gt; <span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line">_.some([<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x &lt; <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数获取对象的<code>value</code>和<code>key</code>的顺序和<code>map</code>一致</p></li><li><p>例子：判断对象中键值对的小写情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = _.every(obj, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cmp1 = key.toLowerCase() === key;</span><br><span class="line">    <span class="keyword">var</span> cmp2 = value.toLowerCase() === value;</span><br><span class="line">    <span class="keyword">return</span> cmp1 &amp;&amp; cmp2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> r2 = _.some(obj, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cmp1 = key.toLowerCase() === key;</span><br><span class="line">    <span class="keyword">var</span> cmp2 = value.toLowerCase() === value;</span><br><span class="line">    <span class="comment">// console.log(key + ' ' +cmp1 + ' ' + cmp2);</span></span><br><span class="line">    <span class="keyword">return</span> cmp1 || cmp2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>字符串之间的比较<strong>不能</strong>使用<code>-</code>，但是可以使用<code>&gt;</code>/<code>&lt;</code>.</li><li>字符串之间相等<strong>可以</strong>直接用<code>===</code>（和Java的引用相等不同）</li></ul></li></ul><h3 id="max-min"><a href="#max-min" class="headerlink" title="max/min"></a>max/min</h3><p>返回集合中最大/最小的数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">_.max(arr); <span class="comment">// 5</span></span><br><span class="line">_.min(arr); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li><p>空集合的返回结果是无穷，因此在使用<code>max</code>/<code>min</code>之前要判断集合是否为空。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.max([]); <span class="comment">// -Infinity</span></span><br><span class="line">_.min([]); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><ul><li>注意<code>max</code>返回的是<strong><code>-Infinity</code></strong></li></ul></li><li><p>当集合是对象时，<code>max()</code>和<code>min()</code><strong>只作用</strong>于<code>value</code>，忽略<code>key</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.max(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><p>把集合的元素按照<code>key</code>归类并返回一个<strong>对象</strong>，其中<code>key</code>由函数参数指定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = [<span class="number">20</span>, <span class="number">81</span>, <span class="number">75</span>, <span class="number">40</span>, <span class="number">91</span>, <span class="number">59</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">72</span>, <span class="number">88</span>, <span class="number">99</span>];</span><br><span class="line"><span class="keyword">var</span> groups = _.groupBy(scores, <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   A: [81, 91, 88, 99],</span></span><br><span class="line"><span class="comment">//   B: [75, 77, 66, 72],</span></span><br><span class="line"><span class="comment">//   C: [20, 40, 59]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="shuffle-sample"><a href="#shuffle-sample" class="headerlink" title="shuffle/sample"></a>shuffle/sample</h3><ul><li><p><code>shuffle()</code>随机打乱一个集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.shuffle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure></li><li><p><code>sample()</code>随机选择<strong>一个或多个</strong>元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.sample([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">_.sample([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>); <span class="comment">// pick up three elements</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="first-last"><a href="#first-last" class="headerlink" title="first/last"></a>first/last</h3><p>取第一个/最后一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line">_.first(arr); <span class="comment">// 2</span></span><br><span class="line">_.last(arr); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><p>接收一个<code>Array</code>，无论<code>Array</code>中嵌套了多少层，都全部拆开提取元素成为一维数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.flatten([<span class="number">1</span>, [<span class="number">2</span>], [<span class="number">3</span>, [[<span class="number">4</span>], [<span class="number">5</span>]]]]); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><ul><li><p><code>zip</code>把两个/多个数组的所有元素<strong>按索引</strong>合并成<strong>新数组</strong>，然后多个新数组一起组成<strong>大数组</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">85</span>, <span class="number">92</span>, <span class="number">59</span>];</span><br><span class="line">_.zip(names, scores);</span><br><span class="line"><span class="comment">// [['Adam', 85], ['Lisa', 92], ['Bart', 59]]</span></span><br></pre></td></tr></table></figure></li><li><p><code>unzip</code>是<code>zip</code>的逆过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameAndScores = [[<span class="string">'Adam'</span>, <span class="number">85</span>], [<span class="string">'Lisa'</span>, <span class="number">92</span>], [<span class="string">'Bart'</span>, <span class="number">59</span>]];</span><br><span class="line">_.unzip(nameAndScores);</span><br><span class="line"><span class="comment">// [['Adam', 'Lisa', 'Bart'], [85, 92, 59]]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>和<code>zip</code>类似，但是是直接转换成对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">85</span>, <span class="number">92</span>, <span class="number">59</span>];</span><br><span class="line">_.object(names, scores);</span><br><span class="line"><span class="comment">// &#123;Adam: 85, Lisa: 92, Bart: 59&#125;</span></span><br></pre></td></tr></table></figure><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>快速生成一个序列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从0开始小于10:</span></span><br><span class="line">_.range(<span class="number">10</span>); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从1开始小于11：</span></span><br><span class="line">_.range(<span class="number">1</span>, <span class="number">11</span>); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0开始小于30，步长5:</span></span><br><span class="line">_.range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>); <span class="comment">// [0, 5, 10, 15, 20, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0开始大于-10，步长-1:</span></span><br><span class="line">_.range(<span class="number">0</span>, <span class="number">-10</span>, <span class="number">-1</span>); <span class="comment">// [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span></span><br></pre></td></tr></table></figure><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>对数组元素去重</p><ul><li><p><code>_.uniq(array, [isSorted], [iteratee])</code></p><ul><li>如果数组已经排序，第二个参数传<code>true</code>可以进行加速。</li><li>如果想要<strong>自定义</strong>去重判断属性，传入<code>iteratee</code>.</li></ul></li><li><p>例子：对数组元素进行不区分大小写去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = _.uniq(arr, (x) =&gt; x.toLowerCase());</span><br></pre></td></tr></table></figure><ul><li><code>uniq</code><strong>不会</strong>改变原数组，而是返回一个没有重复元素的副本。</li></ul></li></ul><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>当使用一个变量<code>fn</code>指向一个对象的方法时，直接调用<code>fn()</code>因为<code>this</code>没有意义会失败，所以使用<code>bind</code>修复这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">' Hello '</span>;</span><br><span class="line"><span class="keyword">var</span> fn = _.bind(s.trim, s);</span><br><span class="line">fn(); <span class="comment">// Hello;</span></span><br></pre></td></tr></table></figure><ul><li><code>trim</code><strong>不会</strong>直接修改字符串</li></ul><h3 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h3><p>为一个函数创建<strong>偏函数</strong>，将原函数的某些参数固定住，方便调用常用的参数搭配。</p><ul><li><p>使用<code>pow</code>固定底数（第一个参数）为2来创建<code>pow2N</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pow2N = _.partial(<span class="built_in">Math</span>.pow, <span class="number">2</span>);</span><br><span class="line">pow2N(<span class="number">3</span>);</span><br><span class="line">pow2N(<span class="number">5</span>);</span><br><span class="line">pow2N(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>固定第二个参数：使用<code>_</code>占位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cube = _.partial(<span class="built_in">Math</span>.pow, _, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>多个参数时也用<code>_</code>占位</li></ul></li></ul><h3 id="memoize"><a href="#memoize" class="headerlink" title="memoize"></a>memoize</h3><ul><li><p><strong>不是</strong><code>memorize</code></p></li><li><p>用于缓存结果，可以在后续调用时直接获得。</p></li><li><p>例子：阶乘加速</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = _.memoize(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start calculate '</span> + n + <span class="string">'!...'</span>);</span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">1</span>, i = n;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        s = s * i;</span><br><span class="line">        i --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(n + <span class="string">'! = '</span> + s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用:</span></span><br><span class="line">factorial(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br><span class="line"><span class="comment">// 注意控制台输出:</span></span><br><span class="line"><span class="comment">// start calculate 10!...</span></span><br><span class="line"><span class="comment">// 10! = 3628800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次调用:</span></span><br><span class="line">factorial(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br><span class="line"><span class="comment">// 控制台没有输出</span></span><br></pre></td></tr></table></figure><ul><li><p>如果计算9的阶乘还是会重新计算，所以进行改进——变为递归调用，就可以记录下每一次的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = _.memoize(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="once"><a href="#once" class="headerlink" title="once"></a>once</h3><p>保证某个函数仅执行一次，用于解决一个函数有多个按键都可以索引到的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> register = _.once(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>让一个函数延迟执行，效果和<code>setTimeOut</code>是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.delay(alert, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><ul><li><p>函数有参数时，在时间参数后<strong>依次</strong>传入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = _.bind(<span class="built_in">console</span>.log, <span class="built_in">console</span>);</span><br><span class="line">_.delay(log, <span class="number">2000</span>, <span class="string">'Hello, '</span>, <span class="string">'World!'</span>); <span class="comment">// 2秒后打印'Hello, World!'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><h3 id="keys-allKeys"><a href="#keys-allKeys" class="headerlink" title="keys/allKeys"></a>keys/allKeys</h3><ul><li><p><code>keys()</code>返回一个object自身所有的key，但不包含从原型继承下来的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>, <span class="number">20</span>);</span><br><span class="line">_.keys(xiaoming); <span class="comment">// ['name', 'age']</span></span><br></pre></td></tr></table></figure></li><li><p><code>allKeys()</code>除了自身属性之外，还包含继承得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.school = <span class="string">'No.1 Middle School'</span>;</span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>, <span class="number">20</span>);</span><br><span class="line">_.allKeys(xiaoming); <span class="comment">// ['name', 'age', 'school']</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><p>与<code>keys()</code>对应，返回object自身的属性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'xiaoming'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.values(obj); <span class="comment">// ['xiaoming', 20]</span></span><br></pre></td></tr></table></figure><h3 id="mapObject"><a href="#mapObject" class="headerlink" title="mapObject"></a>mapObject</h3><p>object的<code>map()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.mapObject(obj, (v, k) =&gt; <span class="number">100</span> + v); <span class="comment">// &#123; a: 101, b: 102, c: 103 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="invert"><a href="#invert" class="headerlink" title="invert"></a>invert</h3><p>将key和value进行交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    Adam: <span class="number">90</span>,</span><br><span class="line">    Lisa: <span class="number">85</span>,</span><br><span class="line">    Bart: <span class="number">59</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.invert(obj); <span class="comment">// &#123; '59': 'Bart', '85': 'Lisa', '90': 'Adam' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="extend-extendOwn"><a href="#extend-extendOwn" class="headerlink" title="extend/extendOwn"></a>extend/extendOwn</h3><ul><li><p><code>extend</code>把多个对象合并到第一个对象参数中，返回合并后的对象，<strong>同时修改原对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.extend(a, &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">88</span>, <span class="attr">city</span>: <span class="string">'Beijing'</span>&#125;); <span class="comment">// &#123;name: 'Bob', age: 88, city: 'Beijing'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>extendOwn()</code>在获取每个对象参数的属性时，<strong>忽略</strong>继承得到的属性。</p></li></ul><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>实现对象<strong>浅复制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'CSS'</span>, <span class="string">'HTML'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> copied = _.clone(source);</span><br></pre></td></tr></table></figure><h3 id="isEqual"><a href="#isEqual" class="headerlink" title="isEqual"></a>isEqual</h3><p>对两个对象进行深度比较，如果<strong>内容完全相同</strong>就返回<code>true</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">name</span>: <span class="string">'Bob'</span>, <span class="attr">skills</span>: &#123; <span class="attr">Java</span>: <span class="number">90</span>, <span class="attr">JavaScript</span>: <span class="number">99</span> &#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">name</span>: <span class="string">'Bob'</span>, <span class="attr">skills</span>: &#123; <span class="attr">JavaScript</span>: <span class="number">99</span>, <span class="attr">Java</span>: <span class="number">90</span> &#125;&#125;;</span><br><span class="line"></span><br><span class="line">o1 === o2; <span class="comment">// false</span></span><br><span class="line">_.isEqual(o1, o2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><p><code>Array</code>也可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = [<span class="string">'Bob'</span>, &#123; <span class="attr">skills</span>: [<span class="string">'Java'</span>, <span class="string">'JavaScript'</span>] &#125;];</span><br><span class="line"><span class="keyword">var</span> o2 = [<span class="string">'Bob'</span>, &#123; <span class="attr">skills</span>: [<span class="string">'Java'</span>, <span class="string">'JavaScript'</span>] &#125;];</span><br><span class="line"></span><br><span class="line">o1 === o2; <span class="comment">// false</span></span><br><span class="line">_.isEqual(o1, o2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Chaining"><a href="#Chaining" class="headerlink" title="Chaining"></a>Chaining</h2><p>通过<code>chain()</code>函数实现underscore函数的链式调用</p><ul><li><p>例子</p><p>非链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.filter(_.map([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>], <span class="built_in">Math</span>.sqrt), (x) =&gt; x % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure><p>链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = _.chain([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>])</span><br><span class="line"> .map(<span class="built_in">Math</span>.sqrt)</span><br><span class="line"> .filter(<span class="function"><span class="params">x</span> =&gt;</span> x &amp; <span class="number">2</span> === <span class="number">1</span>)</span><br><span class="line"> .value();</span><br><span class="line">r; <span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>chain</code>函数后每一步都是<strong>包装对象</strong>，所以最后一步的结果需要使用<code>value</code>获取值。</li></ul></li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of frontend language JavaScript.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Frontend" scheme="http://yoursite.com/categories/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>Database Course Note</title>
    <link href="http://yoursite.com/2021/06/23/Database%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/Database%20Course%20Note/</id>
    <published>2021-06-23T12:39:10.027Z</published>
    <updated>2021-06-23T12:44:42.962Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2020 BUAA Database course.</strong></p><a id="more"></a><h1 id="Chapter0-概论"><a href="#Chapter0-概论" class="headerlink" title="Chapter0 概论"></a>Chapter0 概论</h1><p>全文共<code>430</code>字，推荐阅读时间<code>5~10</code>分钟。</p><h2 id="数据和信息"><a href="#数据和信息" class="headerlink" title="数据和信息"></a>数据和信息</h2><ul><li>信息是<strong>一种</strong>已经被加工为<strong>特定形式</strong>的数据</li><li>数据是信息的载体，是信息的具体表现形式。</li></ul><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ul><li>对数据进行加工得到信息的过程</li></ul><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><ul><li>数据处理的<strong>基本操作</strong></li><li>数据库技术就是一种数据管理技术<ul><li>提供数据共享</li></ul></li></ul><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><ul><li>建立在DBMS之上，以<strong>数据管理</strong>为<strong>主要功能</strong>的计算机软件系统。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;DBMS</span><br><span class="line">DBMS--&gt;数据库</span><br></pre></td></tr></table></figure><blockquote><p>DBS &gt; DBMS &gt; DB</p><ul><li>DBS包括了<strong>用户/应用程序</strong>构成的交互层</li></ul></blockquote><h3 id="架构-B-S"><a href="#架构-B-S" class="headerlink" title="架构(B/S)"></a>架构(B/S)</h3><ul><li>Browser</li><li>Server<ul><li>Web Server</li><li>DB Server(DBMS location)</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>数据模型</li><li>底层实现技术、事务处理、数据库安全、完整性控制</li><li>关系数据理论、数据库设计方法</li></ul><blockquote><p>事务处理（原子性）是DBMS的工作，不是DBS.</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>图书馆</li><li>电商</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter1-概述"><a href="#Chapter1-概述" class="headerlink" title="Chapter1 概述"></a>Chapter1 概述</h1><p>全文共<code>2102</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="数据管理技术发展"><a href="#数据管理技术发展" class="headerlink" title="数据管理技术发展"></a>数据管理技术发展</h2><ul><li><p>人工管理</p><ul><li><p>数据<strong>不在</strong>计算机上保存</p></li><li><p>程序决定数据的逻辑结构和物理结构，数据与程序之间<strong>不具有独立性</strong>。</p><blockquote><p>要改变数据的结构就要改变程序</p></blockquote></li><li><p>数据面向应用，程序之间<strong>不能共享</strong>数据。</p></li></ul></li><li><p>文件系统</p><ul><li><p>存取方法作为中介出现</p></li><li><p>数据以<strong>文件形式</strong>保存在<strong>外存</strong>上</p></li><li><p>数据的存取以<strong>记录</strong>为单位</p></li><li><p>程序和数据具有<strong>一定的独立性</strong></p></li><li><p>缺点：</p><ul><li>数据冗余度大（因为数据<strong>不能</strong>被程序共享，即不能够同时进行操作，必须创建多个副本），可能带来数据的不一致性。</li><li>数据和程序之间的独立性依然<strong>不</strong>明显，缺乏<strong>逻辑独立性</strong>。（改文件逻辑结构时还要修改程序）</li></ul><blockquote><p>文件系统是<strong>不具弹性</strong>的<strong>无结构</strong>的数据集合，<strong>数据之间</strong>（<strong>不是</strong>程序和数据）是孤立的，不能反映现实世界事物之间的内在联系。</p><ul><li>不具弹性：改变数据的结构就得改程序</li><li>无结构：数据之间孤立</li></ul></blockquote></li></ul></li><li><p>数据库系统</p><ul><li><p>数据结构化：描述数据时，不仅描述数据本身，还要描述数据之间的联系。</p><blockquote><p><strong>数据结构化</strong>是数据库与文件系统的<strong>根本区别</strong></p></blockquote></li><li><p>数据冗余度小，易扩充。</p></li><li><p>数据和程序的独立性<strong>较高</strong></p><ul><li><p>数据独立性</p><ul><li>物理：数据的物理结构改变时，数据的逻辑结构可以不变，从而程序也不用改变。</li><li>逻辑：数据的逻辑结构改变时，程序不用改变。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;局部逻辑结构</span><br><span class="line">局部逻辑结构--&gt;全局逻辑结构</span><br><span class="line">全局逻辑结构--&gt;物理结构</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据库映象：不同结构之间数据的<strong>转换关系</strong></p><p>物理结构发生变化时，可以通过调整数据库映象来确保逻辑结构不变。</p></li><li><p>统一的数据控制功能</p><ul><li><p>安全性控制</p></li><li><p>完整性控制：数据的正确性和相容性</p><blockquote><p>相容性：同一条数据在不同的程序应该是相同的</p></blockquote></li><li><p>并发控制</p></li><li><p>恢复</p></li><li><p>存取单位是数据项</p><p>可以存取一组记录，也可以取一组数据项。</p><blockquote><p>数据项的粒度小于文件</p><p>Q：数据项和记录的区别</p><p>A：数据项是列，记录是行。</p></blockquote></li></ul></li></ul></li></ul><h2 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>集成：本质是数据结构化</li><li>共享</li></ul><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul><li>DBMS</li><li>应用系统</li></ul><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>存储数据</li><li>运行系统</li></ul><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><ul><li>终端用户</li><li>应用程序员</li><li>数据库管理员</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul><li>用于抽象和表示现实世界中的<strong>数据和信息</strong></li><li>层次<ul><li>概念模型（信息模型）</li><li>数据模型（层次、网状、关系模型）</li></ul></li></ul><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">现实世界--&gt;信息世界</span><br><span class="line">信息世界--&gt;机器世界</span><br></pre></td></tr></table></figure><ul><li>信息世界就是<strong>概念</strong>模型：E-R图</li><li>机器世界就是<strong>数据</strong>模型：数据表</li></ul><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><ul><li>基于信息世界的主要概念，表达语义。</li><li>语义表达能力强</li><li>清晰</li><li>最常用的表示方法：E-R法(Entity-Relation)</li></ul><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>实体(Entity)：客观存在并可以<strong>相互区分</strong>的食物，在E-R图中为<strong>矩形</strong>。</p></li><li><p>属性(Attribute)：实体具有的某一<strong>特性</strong>，在E-R图中为<strong>椭圆形</strong>。</p></li><li><p>码(Key)：<strong>唯一</strong>的标识实体的<strong>属性集</strong>（至少一个，最多由属性集大小确定）</p></li><li><p>域(Domain)：某些属性的<strong>取值范围</strong></p></li><li><p>实体型(Entity Type)：表示一类实体(Class)</p><ul><li>用名称和属性集表示</li></ul></li><li><p>联系(Relation)：实体型之间的联系，在E-R图中为<strong>菱形</strong>。</p><ul><li>名称：产品<strong>由</strong>若干零件<strong>构成</strong></li><li>类型<ul><li>一对一(1:1)</li><li>一对多(1:n)</li><li>多对多(m:n)</li></ul></li></ul><blockquote><ul><li>联系可以具有<strong>属性</strong>，例如产品-组装-零件中，组装可以有<strong>零件数</strong>属性。</li><li>联系是有方向的，一对多<strong>不等价于反向</strong>的多对一。</li></ul></blockquote></li></ul><h4 id="E-R"><a href="#E-R" class="headerlink" title="E-R"></a>E-R</h4><ul><li>用E-R图描述现实世界</li><li>将E-R图转换为数据模型</li></ul><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul><li>实体</li><li>属性<ul><li>作为Key的属性<ul><li>在属性下画线，多个属性就都画。</li><li>在无向边上画两条杠</li><li>组合属性作为Key：在两条无向边之间画一条弧之后，在弧上画两条杠。</li></ul></li></ul></li><li>联系：无向边旁需要标注联系的类型（三选一）<ul><li>可能存在<strong>自相联</strong>关系</li><li>三个或多个实体可能通过<strong>一个联系</strong>建立关系</li><li>两个实体之间可能存在多种联系<ul><li>工人使用/维修仪器</li></ul></li></ul></li></ul><h5 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h5><ul><li>存在依赖：<strong>有向边</strong>指向<strong>弱实体</strong>（依赖于其他实体的实体）<ul><li>弱实体是双层框</li></ul></li><li>标识依赖：<strong>有向边</strong>指向<strong>被标识实体</strong>（不能由自己的属性来唯一标识，需要和其他实体的属性组合起来作为Key）</li><li>实体的子类：<strong>无向边</strong>上画一个圆<ul><li>子类是外侧框加两条竖线</li><li>子类的交<strong>不一定</strong>为空</li></ul></li></ul><h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><ul><li>数据结构</li><li>数据操作</li><li>完整性约束</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>描述对象的相关性质</li><li>描述对象之间的联系，如关系模型中的关系。</li><li>数据<strong>静态特征</strong>的描述</li><li>三要素中<strong>最重要</strong>的方面</li></ul><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><ul><li><p>操作及操作规则</p></li><li><p>操作符号、操作规则、操作语言</p><blockquote><p>SQL就是一种操作语言</p></blockquote></li><li><p>数据<strong>动态特征</strong>的描述</p></li><li><p>数据库中主要有<strong>检索和更新</strong>两大类操作</p></li></ul><h4 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h4><ul><li>完整性规则的集合</li><li>模型通用的完整性约束条件</li><li>针对具体数据的特定语义的约束条件</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>层次模型：树<ul><li>最早出现</li><li>有向树，连线表示一对多的联系（包含一对一）。</li><li>结构简单，效率高，但是支持的联系的种类太少（只能直接表示<strong>二元一对多</strong>联系）</li></ul></li><li>网状模型：图<ul><li>有向图，连线表示一对多的联系（包含一对一）。</li><li>结构复杂，效率高。</li></ul></li><li>关系模型：二维表<ul><li>用二维表格表示实体及实体之间的联系</li><li><strong>规范化关系</strong>：每个分量（域）是<strong>不可分割</strong>的数据项，并且不能出现表中套表的情况。</li><li>有数学基础</li></ul></li></ul><h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><ul><li>三级模式<ul><li>外模式</li><li>模式</li><li>内模式</li></ul></li><li>两级映象<ul><li>外模式/模式映象</li><li>模式/内模式映象</li></ul></li><li>优点<ul><li>数据独立性</li><li>简化用户接口</li><li>有利于数据共享（外模式可以相互覆盖）</li><li>利于数据的安全保密</li></ul></li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li><strong>逻辑模式/概念模式</strong></li><li><strong>全体数据</strong>的逻辑结构和特性的描述，例如所有关系模式构成的集合。</li><li><strong>三级模式的核心</strong></li><li>模式描述语言(DDL, Data Description Language)</li></ul><h3 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h3><ul><li><p>个别用户的数据<strong>视图</strong>（与某一应用有关的数据逻辑表示）</p></li><li><p>通常是<strong>模式的子集</strong>（子模式）</p></li><li><p>不同的外模式可以相互覆盖，<strong>一个</strong>应用只能启用<strong>一个</strong>外模式。</p><blockquote><p>外模式和应用是<strong>一对多</strong>的关系</p></blockquote></li><li><p>外模式DDL，通常和应用具有相同的语法。</p></li></ul><h3 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h3><ul><li>存储模式，数据的物理结构和存储方式的描述。</li><li>内模式DDL</li></ul><h3 id="两级映象"><a href="#两级映象" class="headerlink" title="两级映象"></a>两级映象</h3><ul><li>数据<strong>逻辑</strong>独立性：外模式/模式映象</li><li>数据<strong>物理</strong>独立性：模式/内模式映象</li></ul><h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul><li>数据库的定义功能<ul><li>使用DDL语言描述外模式、模式、内模式（源模式）</li></ul></li><li>数据存取功能<ul><li>提供DML(Data Manipulation Language)语言进行CRUD</li></ul></li><li>数据库运行管理<ul><li>并发控制</li><li>存取控制</li><li>完整性</li><li>日志组织和管理</li><li>事务管理</li><li>自动恢复</li></ul></li></ul><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>语言编译处理程序</li><li>系统运行控制程序</li><li>系统建立和维护</li><li>数据字典（数据目录）：由若干个表组成</li></ul><h3 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h3><p>数据库管理员</p><ul><li>建库</li><li>用库</li></ul><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter2-关系数据库"><a href="#Chapter2-关系数据库" class="headerlink" title="Chapter2 关系数据库"></a>Chapter2 关系数据库</h1><p>全文共<code>1694</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>关系理论建立在集合代数（离散数学）理论之上</li></ul><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>关系模型的数据结构：关系</p></li><li><p>域(Domain)：一组具有<strong>相同数据类型</strong>的值的集合</p></li><li><p>元组和分量</p><blockquote><p>多个<strong>域</strong>进行笛卡尔积运算可以表示为<strong>二维表</strong></p></blockquote></li><li><p>关系：笛卡尔积$D_1 \times D_2 \times …\times D_n$的<strong>子集</strong>叫做这些域上的关系，用$R(D_1,D_2,…,D_n)$表示。</p><ul><li><p>$R$：关系名</p></li><li><p>$n$：度/目</p></li><li><p><strong>关系二维表</strong></p><ul><li><p>每个列附加一个名称，被称为<strong>属性</strong>(Attribute)。</p><blockquote><p>属性的名字需要<strong>唯一</strong></p></blockquote></li><li><p>关系是元组构成的集合</p></li></ul></li><li><p>关系的列是<strong>同质</strong>的</p></li><li><p>不同的列可以出自同一域（自相关）</p></li><li><p>列的顺序可以互换</p></li><li><p>任何两个元组（行）<strong>不能</strong>完全相同</p></li><li><p>规范性：分量不可再分，即1NF（First Normal Form，第一范式）</p></li></ul></li></ul><h2 id="数据模型-2"><a href="#数据模型-2" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>数据结构：关系</p></li><li><p>码</p><ul><li><p>候选码(Candidate Key)：具有<strong>最小性</strong>和唯一标识功能的<strong>属性组</strong></p><ul><li>最小性：指候选码的子集不能够唯一标识当前记录，和候选码的<strong>属性个数</strong>无关。例如候选码A中可能只有一个属性，但是在候选码B中可能有两个其他的属性。</li></ul><blockquote><p>属性组中<strong>可以</strong>只有一个属性</p></blockquote></li><li><p>主码(Primary Key)：简称为码，在多个候选码中选定一个为主码。</p></li></ul></li><li><p>属性</p><ul><li>主属性：<strong>所有候选码</strong>中的属性</li><li>非主属性：<strong>不包含</strong>在任何候选码中的属性</li></ul><blockquote><p>属性<strong>要么为</strong>主属性，<strong>要么为</strong>非主属性。</p></blockquote></li><li><p>关系模式：$R(U,D,dom,F,I)$</p><ul><li><p>$U$：属性名集合</p></li><li><p>$D$：域集合</p></li><li><p>$dom$：属性$\rightarrow$域的映象集合</p></li><li><p>$F$：数据依赖关系集合</p></li><li><p>$I$：完整性约束集合</p></li><li><p>关系是关系模式在<strong>某一时刻</strong>的<strong>状态或内容</strong></p><blockquote><p>关系模式相对稳定，可以理解成<strong>设计表</strong>；关系是动态的，是一张表的<strong>具体内容</strong>。</p></blockquote></li></ul></li></ul><h3 id="语义约束"><a href="#语义约束" class="headerlink" title="语义约束"></a>语义约束</h3><p>前两个是<strong>模型</strong>必须支持的约束条件</p><ul><li><p>实体完整性</p><ul><li><p>主码必须存在，<strong>其中任何一个域</strong>都不能为空。</p><blockquote><p>空：不知道/不存在的值</p></blockquote></li></ul></li><li><p>参照完整性</p><ul><li><p>外部码(Foreign Key)如果有效，则对应的外表必须存在对应记录。</p><blockquote><ul><li>外部码可以是<strong>同一个关系</strong>之间的联系（即同<strong>一张表</strong>中<strong>不同</strong>元组之间的联系）</li><li>外部码可以为空</li><li>外部码可以是<strong>属性组</strong></li></ul></blockquote></li></ul></li><li><p>用户定义完整性</p><ul><li>用户根据特定的应用环境定义的完整性约束条件</li></ul></li></ul><h3 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li><p>集合操作：操作的对象和结果<strong>都是</strong>集合</p></li><li><p>关系运算</p><ul><li>关系代数（代数方式）</li><li>关系演算（逻辑方式）<ul><li>元组关系</li><li>域关系</li></ul></li></ul><blockquote><p>各种运算之间等价，可以相互转换。</p></blockquote></li></ul><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><ul><li><p>常规集合运算：并、差、交、广义笛卡尔积</p><ul><li><p>广义笛卡尔积</p><p>对度为<code>n</code>、<code>m</code>的两个集合，元组数分别为<code>k1</code>、<code>k2</code>，它们笛卡尔积的结果</p><ul><li><p>度为$(n+m)$</p></li><li><p>元组共$k1*k2$个</p></li><li><p>当出现重名属性时，需要进行重命名。</p><blockquote><p>通常使用<code>Tablename.Fieldname</code>的组合进行重命名</p></blockquote></li></ul></li></ul></li><li><p>特殊关系运算：选择、投影、连接、自然连接、除法</p><ul><li><p>选择：在关系R中选择<strong>满足给定条件</strong>的元组，记为$\sigma_F(R)=\{t|t\in R,F(t)=True\}$.</p></li><li><p>投影：从关系中取若干属性列，并删去重复行，组成新的关系，记为$\Pi_A(R)=\{t[A]|t \in R, A \subseteq U\}$.</p></li><li><p>连接：在两个关系的<strong>广义笛卡尔积</strong>中，指定属性<strong>组</strong>$X,Y$，并且选择其中满足条件$\theta$的<strong>元组</strong>并返回<strong>整条组合记录</strong>构成的集合。</p><ul><li><p>$\theta$</p><ul><li><code>=</code>：等值连接</li><li><code>&lt;</code>：小于连接</li><li><code>&gt;</code>：大于连接</li></ul></li><li><strong>一个元组</strong>可能和<strong>多个元组</strong>进行连接</li></ul></li></ul></li><li><p>自然连接（更常用）：在笛卡尔积中选取在<strong>相同属性组列</strong>上<strong>取值相等</strong>的记录，并<strong>去掉重复</strong>的列。</p><ul><li>不能自定义$X,Y$</li><li>不能更换连接条件$\theta$</li></ul></li><li><p>除法：对关系$R(X,Y),S(Z)$，它们的除法记为：</p><p>$R \div S=\{t|t \in \Pi_X(R) \and \forall s\in S \and <t,s> \in R\}$.</p><ul><li>要求$Y,Z$域等价<ul><li>属性数相同</li><li>对应属性出自同样的域</li></ul></li><li>除法$A \div B$的意义就是<strong>A包含了多少个B</strong></li><li>通俗地说，把B认为是组别，除法的意义就是得到A中指定属性满足<strong>同时在B中所有组</strong>的<strong>投影</strong>。</li></ul></li><li><p>运算组合</p><ul><li>从内套外嵌套</li><li>（自然）连接的语义：指定域后跨表查找，同时<strong>保留其他域</strong>。</li><li>除法：解决<strong>“任意”</strong>问题</li><li>先投影再运算效率更高</li></ul></li><li><p>基本运算（可以推出其他运算）</p><ul><li>并</li><li>差</li><li>笛卡尔积</li><li>选择</li><li>投影</li></ul></li></ul><h2 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h2><ul><li>将<strong>谓词演算</strong>应用到关系运算中就是关系演算</li></ul><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul><li>以元组为变量</li><li>基本结构：元组演算表达式$\{t|\Phi(t)\}$表示所有使$\Phi$为真的<strong>元组</strong>集合</li><li>优先级<ul><li>算术比较</li><li>量词($\exists &gt; \forall$)</li><li>逻辑运算符</li></ul></li><li>例子<ul><li>$R1=\{t|R(t) \and t[3] \geq 4\}$：关系R中第三个域大于等于4的元组集合<ul><li>$R(t)$：$t$是关系$R$中的元组</li></ul></li><li>$R2=\{(\exists u)(R(t) \and W(u) \and t[3] &lt; u[3])\}$</li></ul></li></ul><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><ul><li>变量对应元组各个分量的域变量<ul><li>$R(t) \Rightarrow R(x_1,x_2,…x_n)$</li></ul></li><li>例子<ul><li>$R1=\{xyz|R(xyz) \and Z&lt;8 \and x=d\}$</li></ul></li></ul><h2 id="安全约束"><a href="#安全约束" class="headerlink" title="安全约束"></a>安全约束</h2><ul><li>关系代数是安全的，但是关系演算<strong>不一定</strong>安全。</li><li>无限关系：$\{t|\neg R(t)\}$集合有无穷多个元素</li><li>无穷运算：$\forall t(R(t))$，当$t$域无穷时，即为无穷验证运算。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对$\Phi$定义一个有限符号集$DOM(\Phi)$，使$\Phi$中的运算结果和中间过程中产生的元组及其分量均属于$DOM(\Phi)$</li><li>在实现安全约束后，三种运算方式<strong>才是</strong>等价并且可以相互转换的。</li></ul><h2 id="关系数据语言"><a href="#关系数据语言" class="headerlink" title="关系数据语言"></a>关系数据语言</h2><ul><li>核心是查询，所以也称为查询语言。</li></ul><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>数据定义（描述）语言(DDL)：包括模式DDL、外模式DDL、内模式DDL.</li><li>数据模拟语言(DML)：CRUD<ul><li>联机交互：独立于系统存在</li><li>宿主语言：嵌入在高级语言中</li></ul></li><li>数据控制语言(DCL)：安全性和完整性控制</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>一体化：例如SQL将DDL、DML、DCL的功能集成在一起</li><li>非过程化：用户不需要关注底层的实现细节</li><li>面向集合的存取方式<ul><li>操作对象是一个或多个关系</li><li>操作结果是新的关系</li></ul></li><li>可独立也可嵌套</li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter3-SQL"><a href="#Chapter3-SQL" class="headerlink" title="Chapter3 SQL"></a>Chapter3 SQL</h1><p>全文共<code>3006</code>字，推荐阅读时间<code>25~30</code>分钟</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>综合统一</li><li>高度<strong>非过程化</strong>（只注重交互结果，而不是具体的实现）</li><li>面向集合操作</li><li>同一个语法结构可以实现关系代数和关系演算两种使用方式</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>基本表：独立、实际存在的，有对应的实体文件。</p><blockquote><p>在SQL中，一个关系对应一个表。</p></blockquote></li><li><p>导出表：从<strong>一个或多个</strong>基本表导出的表，分为视图(View)和快照(Snapshot).</p><ul><li><p>视图</p><ul><li>虚表，只在数据字典中存储视图的定义。</li><li>视图可以进行CRUD基本操作，也可以用来定义新的视图。</li></ul><blockquote><p>SQL可以直接操作基本表（模式）和导出表（外模式）</p></blockquote></li></ul></li></ul><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q;</span><br></pre></td></tr></table></figure><ul><li><p>从目标表<code>T</code>中选择符合条件<code>Q</code>的目标列<code>C</code></p><blockquote><p><code>WHERE</code>相当于是<code>filter()</code></p></blockquote></li><li><p>表的水平方向：根据检索条件选择<strong>元组</strong>（记录）</p></li><li><p>表的垂直方向：对<strong>目标列</strong>进行投影</p></li></ul><h3 id="投影检索"><a href="#投影检索" class="headerlink" title="投影检索"></a>投影检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT C</span><br><span class="line">FROM T;</span><br></pre></td></tr></table></figure><ul><li><code>DISTINCT</code>删去结果中的重复行</li></ul><h3 id="选取检索"><a href="#选取检索" class="headerlink" title="选取检索"></a>选取检索</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><code>=</code>/<code>&lt;</code>等</li><li><code>AND</code>/<code>OR</code>/<code>NOT</code></li><li><code>()</code></li><li><code>BETWEEN ... AND ...</code></li></ul><blockquote><p><code>WHERE</code>子句<code>Q</code>中出现的列通常会在<code>SELECT C</code>中出现</p></blockquote><h3 id="排序检索"><a href="#排序检索" class="headerlink" title="排序检索"></a>排序检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q</span><br><span class="line">ORDER BY A ASC&#x2F;DESC;</span><br></pre></td></tr></table></figure><ul><li><p><code>ASC</code>：根据<code>A</code>升序（<strong>缺省</strong>）</p></li><li><p><code>DESC</code>：根据<code>A</code>降序</p></li><li><p>多列排序，按照<strong>语句顺序</strong>进行多要素排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S</span><br><span class="line">ORDER BY SD ASC, SA DESC;</span><br></pre></td></tr></table></figure></li><li><p>排序语句通常放在<code>SELECT</code>语句的<strong>最后</strong></p></li></ul><h3 id="连接（连表）检索"><a href="#连接（连表）检索" class="headerlink" title="连接（连表）检索"></a>连接（连表）检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T1, T2</span><br><span class="line">WHERE T1.c1 &#x3D; T2.c2;</span><br></pre></td></tr></table></figure><ul><li><code>c1</code>/<code>c2</code>被称为<strong>连接字段</strong></li><li>本质就是将<code>T1</code>，<code>T2</code>进行<strong>笛卡尔积</strong>操作，然后对新的表的符合条件的元组进行筛选。</li></ul><h4 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT X.SN, X.SA</span><br><span class="line">FROM S X, S Y</span><br><span class="line">WHERE X.SA&gt;Y.SA AND Y.SN&#x3D;&#39;xxx&#39;;</span><br></pre></td></tr></table></figure><ul><li>连接后选取的属性（<code>SELECT</code>选择的属性）中如果有重名属性，<strong>也要加上表名</strong>用以区分。同时，在查询的时候不会被起别名，即返回结果中依然是<code>SN</code>/<code>SA</code>.</li><li>起别名后，原有的<code>S</code><strong>不能够</strong>再使用。</li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S, SC</span><br><span class="line">WHERE S.S &#x3D; SC.S(*);</span><br></pre></td></tr></table></figure><ul><li>单纯使用连接语句可能造成信息丢失，例如没有选课的学生在连接学生表和选课表时会被忽略。</li><li>增加<code>*/+</code>的表中会<strong>增加</strong>万能空行与<strong>另一个表</strong>进行连接</li></ul><h3 id="嵌套检索"><a href="#嵌套检索" class="headerlink" title="嵌套检索"></a>嵌套检索</h3><ul><li>子查询（嵌套查询）：<code>WHERE</code>中包含的另一个查询块<ul><li>普通：与外部查询无关，<strong>可以单独执行</strong>获得一组值。</li><li>相关：把<strong>外查询的值</strong>作为检索的条件值，<strong>不可以</strong>单独执行。</li></ul></li><li>外部查询：包含子查询的语句</li></ul><h4 id="自身嵌套"><a href="#自身嵌套" class="headerlink" title="自身嵌套"></a>自身嵌套</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM s</span><br><span class="line">WHERE S.SA &#x3D; (SELECT SA FROM S WHERE S.SN &#x3D; &#39;xxx&#39;);</span><br></pre></td></tr></table></figure><blockquote><p>嵌套运算的效率<strong>高于</strong>连表运算，空间开销也更低。</p></blockquote><ul><li><p>子查询返回<strong>单值</strong>时可以直接使用<strong>运算符</strong>进行连接</p></li><li><p>子查询返回<strong>一组值</strong>，则需要在子查询结果前加上<code>ANY</code>/<code>ALL</code>.</p><ul><li><p><code>IN</code>可以替代<code>=ANY</code></p></li><li><p><code>NOT IN</code>可以替代<code>!=ALL</code>，<strong>不是</strong><code>!=ANY</code>.</p><blockquote><p><code>!=ALL</code>和<code>!=ANY</code>的区别</p><ul><li><code>!=ALL</code>：当左值和<strong>任意</strong>右值<strong>都不相等</strong>的时候为真</li><li><code>!=ANY</code>：当左值和<strong>某个</strong>右值<strong>不相等</strong>的时候为真</li></ul></blockquote></li><li><p><code>EXISTS</code>：当仅当<strong>子查询</strong>结果为<strong>非空</strong>时为真，即<code>filter()</code>的拓展，可以在<code>filter()</code>中放更加复杂的筛选条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE EXISTS</span><br><span class="line">(SELECT * FROM SC WHERE SC.S&#x3D;S.S AND C&#x3D;&#39;xxx&#39;);</span><br></pre></td></tr></table></figure><blockquote><ul><li>相当于遍历S表中的每一个学生，然后利用学号在SC中进行检索。</li><li><strong>相关</strong>子查询，因为子查询的<code>S</code>不独立。</li><li><code>EXISTS</code>判定的方式决定了<code>SELECT</code><strong>不需要</strong>明确某一列</li></ul></blockquote></li><li><p><code>NOT EXISTS</code>：在子查询结果为<strong>空</strong>时返回真，可以使用<code>NOT EXISTS</code>表示谓词逻辑。</p><ul><li><p>单层<code>NOT EXISTS</code>：即<code>exclude()</code>，排除掉所有满足嵌套条件的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM C</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM SC WHERE SC.C &#x3D; C.S);</span><br></pre></td></tr></table></figure></li><li><p>全称量词$\forall$：$(\forall x)P=\neg(\exist x(\neg P))$</p><ul><li><p>对命题和子命题都取反，把任意变成存在，然后根据等价命题进行SQL语句构造。</p></li><li><p><strong>检索选修所有课程的学生的姓名</strong></p><ul><li><p>$Given\ s,\forall cP(s,c).$</p><p>其中$P(s,c)$表示学生选上了这门课，为了能够返回布尔值，我们使用$EXISTS$语句进行包装。</p><p>将其转换为$Given\ s, \neg\exist c(\neg P(s,c))$（其中$\neg$就是<code>NOT</code>）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM C</span><br><span class="line">     WHERE NOT EXISTS</span><br><span class="line">      (SELECT * FROM SC WHERE SC.S&#x3D;S.S AND SC.C&#x3D;C.C))</span><br></pre></td></tr></table></figure><blockquote><p>命题等价于：不存在没有选修的课程的学生的姓名，即排除没有全部选修的学生。</p></blockquote></li></ul></li><li><p>蕴涵：$p \rightarrow q = \neg p \or q$</p><ul><li><p><strong>检索至少选修了学生S2选修的全部课程的学生学号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT S</span><br><span class="line">FROM SC SCX</span><br><span class="line">WHERE NOT EXISTS # 不存在S2选了但是该学生没选的课程，所以下面是S2选了但是他没选的。</span><br><span class="line">(SELECT * FROM SC SCY</span><br><span class="line">     WHERE SCY.S&#x3D;S2 AND NOT EXISTS ( # 他没有选择这门课</span><br><span class="line">     SELECT * FROM SC SCZ WHERE SCZ.S&#x3D;SCX.S AND SCZ.C&#x3D;SCY.C))</span><br></pre></td></tr></table></figure><ul><li><code>p</code>：S2选修了某门课</li><li><code>q</code>：该学生也要选修这门课</li></ul><blockquote><p>命题等价于：不存在S2选修但是他没有选修的课程</p></blockquote></li></ul></li></ul><blockquote><p>用<code>NOT EXISTS</code>表示谓词逻辑：</p><ul><li>使用纯数理逻辑进行推导，但是对于谓词过多的情况可能出现问题。</li><li><strong>把命题改写成“不存在…”的形式，然后逐层使用<code>NOT EXISTS</code>.</strong></li></ul></blockquote></li></ul></li></ul><h3 id="并、差、交检索"><a href="#并、差、交检索" class="headerlink" title="并、差、交检索"></a>并、差、交检索</h3><p>操作对象必须是<strong>相容</strong>的：有相同的属性列。</p><ul><li><p>UNION</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c1&#39;</span><br><span class="line">UNION</span><br><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c2&#39;;</span><br></pre></td></tr></table></figure></li><li><p>MINUS</p></li><li><p>INTERSECT</p></li></ul><h3 id="库函数检索"><a href="#库函数检索" class="headerlink" title="库函数检索"></a>库函数检索</h3><ul><li><p><code>COUNT()</code>：按<strong>列值</strong>计数，统计<strong>属性数</strong>。</p><blockquote><p><code>COUNT(*)</code>：对<strong>行</strong>计数，统计<strong>记录数</strong>。</p></blockquote></li><li><p><code>SUM()</code>：对数值列求总和</p></li><li><p><code>AVG()</code>：对数值列求平均</p></li><li><p><code>MAX()</code>：在列中找出最大值</p></li><li><p><code>MIN()</code>：在列中找出最小值</p></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>只能在<code>SELECT</code>和<code>HAVING</code>子句中出现</p></li><li><p>检索学生总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM S;</span><br></pre></td></tr></table></figure></li><li><p>检索选择了课程的学生总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT S)</span><br><span class="line">FROM SC;</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>DISTINCT</code>的位置</p></blockquote></li><li><p>求S4的总分和平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(G), AVG(G)</span><br><span class="line">FROM SC</span><br><span class="line">WHERE SC.S&#x3D;&#39;S4&#39;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组检索"><a href="#分组检索" class="headerlink" title="分组检索"></a>分组检索</h3><p>按<strong>属性列</strong>将记录分组，每组具有某个共同特征，然后对每一组进行<code>SELECT</code>操作。（相当于对记录进行了<strong>打包</strong>）</p><ul><li><p>分组子句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GROUP BY C</span><br><span class="line">[HAVING conditionExpression]</span><br></pre></td></tr></table></figure><ul><li><p><code>WHERE</code>是对<strong>行</strong>进行过滤，去掉不符合条件的行。</p></li><li><p><code>HAVING</code>只能对<strong>分组</strong>进行过滤，必须建立在<code>GROUP BY</code>之上.</p><blockquote><p><code>WHERE-&gt;GROUP BY-&gt;HAVING</code></p></blockquote></li></ul></li><li><p>检索至少选修了三门课的学生学号和选课门数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, COUNT(*)</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY S</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 3;</span><br></pre></td></tr></table></figure><blockquote><p><code>GROUP BY</code>同时影响了<code>SELECT</code>的范围，相当于是<code>FROM SC GROUP BY S</code>.</p></blockquote></li></ul><h3 id="算术表达式值检索"><a href="#算术表达式值检索" class="headerlink" title="算术表达式值检索"></a>算术表达式值检索</h3><ul><li><p>为算术表达式起别名提高可读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT EMPN, BONUS&#x2F;SALARY BS</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><ul><li><p><code>LIKE/NOT LIKE</code>：对字符型列适用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># &lt;列名&gt; LIKE&#x2F;NOT LIKE &lt;字符串常量&gt;</span><br><span class="line">SELECT S, SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE SN LIKE &#39;刘%&#39;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;字符串常量&gt;</code>可包含特殊符号<ul><li><code>%</code>：通配<strong>0或多个</strong>字符</li><li><code>_</code>：通配<strong>单个</strong>字符</li></ul></li></ul></li></ul><h3 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h3><ul><li><p>MySQL目前不支持</p></li><li><p>出现在<code>FROM</code>中的子查询生成的表叫做派生表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, C</span><br><span class="line">FROM SC, (SELECT S, AVG(G) FROM SC GROUP BY S) AS AVG_SC(AVG_S,AVG_G)</span><br><span class="line"># WHERE ...</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><ul><li>基本表：定义、删除、<strong>修改</strong></li><li>视图：定义、删除</li><li>索引：定义、删除</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><code>char(n)</code>：固定长度的字符串</li><li><code>varchar(n)</code>：可变长字符串</li><li><code>numeric(p, q)</code>：定点数共<code>p</code>位，小数点右边<code>q</code>位。</li><li><code>interval</code>：两个<code>date</code>或<code>time</code>类型数据之间的差</li></ul><h3 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;tablename&gt; (&lt;columnname&gt;&lt;datatype&gt;[&lt;columnintegrity&gt;],...);</span><br><span class="line">ALTER TABLE &lt;tablename&gt; (ADD&#x2F;DROP&#x2F;MODIFY);</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li><p>创建学生表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(S CHAR(5) NOT NULL UNIQUE,</span><br><span class="line"> SN CHAR(50) NOT NULL,</span><br><span class="line"> SA INT NOT NULL,</span><br><span class="line"> PRIMARY KEY(S),</span><br><span class="line"> CHECK (SA&gt;&#x3D;18 AND SA&lt;&#x3D;45));</span><br></pre></td></tr></table></figure></li><li><p>修改属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE S ADD SCOME DATE;</span><br><span class="line">ALTER TABLE S MODIFY SA SMALLINT; # modify the data type</span><br></pre></td></tr></table></figure></li><li><p>删除基本表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE S;</span><br></pre></td></tr></table></figure></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>为了对<strong>经常查询的属性</strong>的存取进行<strong>加速</strong>而提出的策略</p><ul><li>索引项：属性组取值</li><li>位置指针：索引对应的记录存储的位置</li><li>索引文件是<strong>排序文件</strong>，进而加快了查找速度。</li></ul><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE][CLUSTER] INDEX &lt;indexname&gt; ON &lt;tablename&gt; (&lt;columnname&gt;[sequence]);</span><br><span class="line">DROP UNIQUE INDEX &lt;indexname&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>CLUSTER</code>：索引项的指针所指的<strong>内存顺序</strong>和<strong>实际数据库</strong>中的顺序是相同的（不常使用）</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX Scno ON SC (S ASC, C DESC);</span><br><span class="line">DROP INDEX Scno ON S;</span><br></pre></td></tr></table></figure><ul><li><p><code>DROP INDEX</code>可以作为<code>ALTER TABLE</code>的子句使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON tablename;</span><br><span class="line">ALTER TABLE tablename DROP INDEX index_name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>视图是一个虚表，属于外模式。</li><li>视图消解(View Resolution)：对视图的操作会被等价的转化为对<strong>基本表</strong>的操作，然后再执行。</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>简化用户操作</li><li>为同样的原始数据提供不同的角度（为一间房子在不同的方向开了窗）</li><li>逻辑独立性（数据的逻辑结构改变时，应用程序对数据的操作不需要改变）</li><li>安全保护（权限管理）</li></ul><h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW &lt;viewname&gt; [&lt;columnname&gt;] AS &lt;subquery&gt; [WITH CHECK OPTION];</span><br><span class="line">DROP VIEW &lt;viewname&gt; [IF EXISTS &lt;viewname&gt;];</span><br></pre></td></tr></table></figure><ul><li><code>WITH CHECK OPTION</code>：让用户只能对视图中的数据进行CRUD，从而保护了数据库中的其他数据。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW CS_Student</span><br><span class="line">AS</span><br><span class="line">SELECT S, SN, SA FROM S</span><br><span class="line">WHERE SD&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure><ul><li><p>在视图上查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S,SA</span><br><span class="line">FROM CS_Student</span><br><span class="line">WHERE SA&lt;20;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><p>单个元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;tablename&gt; (&lt;columnname1&gt;,...) VALUES (&lt;value1&gt;,...);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO S VALUES (&#39;xxx&#39;, &#39;yyy&#39;, &#39;zzz&#39;);</span><br><span class="line">INSERT INTO SC (S, C) VALUES (&#39;xxx&#39;, &#39;yyy&#39;);</span><br></pre></td></tr></table></figure></li><li><p>子查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO DA(SD, Aveage)</span><br><span class="line">SELECT SD, AVG(SA) FROM S GROUP BY SD;</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;tablename&gt; SET &lt;columnname&gt;&#x3D;&lt;expression&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE SC</span><br><span class="line">SET G&#x3D;666</span><br><span class="line">WHERE &#39;CS&#39;&#x3D;(SELECT SD FROM S</span><br><span class="line">           WHERE S.S&#x3D;SC.S);</span><br></pre></td></tr></table></figure><blockquote><p><code>WHERE</code>中可以把常量放在等号<strong>左边</strong></p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;tablename&gt; [WHERE &lt;conditions&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>注意<strong>不是</strong><code>DROP</code></p></blockquote><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><ul><li><p>空值用<code>NULL</code>表示</p><ul><li>不能确定的值</li><li>属性不应该被赋值</li><li>属性值不方便填写</li></ul></li><li><p>属性有<code>NOT NULL</code>或者<code>UNIQUE</code>约束的，以及主属性不能够为<code>NULL</code>.</p><blockquote><p>部分系统允许<code>UNIQUE</code>为空</p></blockquote></li></ul><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li>算数运算：<code>NULL</code></li><li>比较运算：<code>UNKNOWN</code></li><li>逻辑运算：除了<code>False AND NULL</code>和<code>True OR NULL</code>可以确定之外，其余都为<code>UNKNOWN</code>.</li></ul><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><ul><li>使用<code>IS NULL</code>或<code>IS NOT NULL</code>判断</li></ul><h2 id="数据控制"><a href="#数据控制" class="headerlink" title="数据控制"></a>数据控制</h2><ul><li><p>完整性约束</p></li><li><p>事务操作</p></li><li><p>安全控制</p><ul><li><p>授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; TO &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure></li><li><p>收回权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; FROM &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h2><ul><li><p>将SQL的特性和程序设计语言的<strong>过程处理能力</strong>结合起来</p></li><li><p>预编译</p><ul><li>把嵌入在程序中的SQL语句翻译为高级语言源码，然后再编译、链接、执行。</li></ul></li><li><p>实现</p><ul><li><p>区分SQL和高级语言：在SQL语句前加<code>EXEC SQL</code></p></li><li><p>数据库工作单元和程序工作单元之间的通信：通过主变量（主程序语言变量）的值来传递</p></li><li><p>SQL和主语言之间操作方式的协调：通过游标(<code>Cursor</code>)解决，由游标进行记录的操作，然后将结果传递给主变量。</p><blockquote><p>游标时系统开辟的存放SQL执行结果的缓冲区</p></blockquote></li></ul></li><li><p>动态SQL：允许嵌入式语句的某些参数不确定，在运行时动态生成<code>SQL</code>语句。</p></li><li><p>ODBC/JDBC</p><ul><li><p>执行效率相比嵌入式SQL低，但是开发效率高。</p></li><li><p>组件</p><ul><li>应用程序</li><li>驱动程序管理器</li><li>驱动程序</li><li>数据源</li></ul><blockquote><p>不同的数据库提供相同的API接口，通过驱动管理程序即可以实现程序的移植性。</p></blockquote></li></ul></li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter4-数据库设计"><a href="#Chapter4-数据库设计" class="headerlink" title="Chapter4 数据库设计"></a>Chapter4 数据库设计</h1><p>全文共<code>2640</code>字，推荐阅读时间<code>20~25</code>分钟。</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><ul><li>直接设计法（手工试凑）<ul><li>高度依赖开发人员经验</li><li>后期维护困难</li><li>移植困难</li><li>难以合作设计</li></ul></li><li>规范设计法<ul><li>将设计过程分为若干个阶段，每个阶段只解决整个设计中的部分问题。<ul><li>需求分析：调查应用环境</li><li>概念结构设计（在三级模式两级映象中<strong>没有</strong>对应的部分）：形成可以<strong>用E-R图</strong>表示的模型</li><li>逻辑结构设计（<strong>概念模型</strong>，即模式、信息世界）：将E-R图转换成DBMS的模式和子模式</li><li>物理结构设计（<strong>数据模型</strong>，即内模式、机器世界）：存储结构（内模式）和存取方法（例如索引）</li><li>数据库实施：建立数据库</li><li>数据库运行和维护</li></ul></li></ul></li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>处理要求</li><li>信息要求</li><li>安全性和完整性要求</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>和用户交流</p></li><li><p>分析、表达用户需求</p><ul><li><p>用<strong>数据流图</strong>表达数据和处理之间的关系</p><ul><li>数据流图(Data Flow Diagram, DFD)：表达系统逻辑功能和数据逻辑流向和逻辑变换<ul><li><strong>自顶向下</strong></li></ul></li></ul></li><li><p>用<strong>数据字典</strong>描述系统中各类数据</p><ul><li><p>数据字典：对数据进行集中的说明，包含数据元素的名字、含义等。</p><ul><li>从数据流图中提取原子数据项</li><li>把有联系的数据项组合为数据组</li></ul><blockquote><p>上述数据字典和在数据库实施阶段的数据字典<strong>不同</strong>，前者可以看作是现实世界的<strong>数据元素表</strong>，后者是数据库系统的组成部分。</p></blockquote></li></ul></li></ul></li></ul><h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><ul><li>概念结构是信息世界的结构，即概念模型。</li></ul><h3 id="E-R法"><a href="#E-R法" class="headerlink" title="E-R法"></a>E-R法</h3><ul><li>描述概念模型</li><li>组成部分<ul><li>E-R图</li><li>转换E-R图为对应的数据模型</li></ul></li></ul><h4 id="E-R图概述"><a href="#E-R图概述" class="headerlink" title="E-R图概述"></a>E-R图概述</h4><ul><li>组成<ul><li>实体（方框）</li><li>属性（椭圆框）</li><li>联系（菱形框）<ul><li>联系也可以有属性，例如学生和课程的选修联系可以拥有成绩属性。</li><li>两个实体型之间可以具有多种联系，例如机器和工人可以有使用、维修两种联系。</li><li>语义扩充<ul><li>存在依赖(<code>E</code>)</li><li>标识依赖(<code>E&amp;I</code>)</li><li>实体的子类（连线上有一个圈）</li></ul></li></ul></li></ul></li></ul><h3 id="E-R图设计"><a href="#E-R图设计" class="headerlink" title="E-R图设计"></a>E-R图设计</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li><p>自顶向下</p></li><li><p>自底向上<strong>（最常用）</strong></p><blockquote><p>自顶向下需求分析，自底向上概念设计。</p></blockquote></li><li><p>逐步扩张：先定义核心概念结构</p></li><li><p>混合策略</p></li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>以自底向上为例</p><h5 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h5><ul><li>分类</li><li>聚集：定义某个实体型的组成成分</li><li>概括：定义类型之间的子集联系</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li><p>设计<strong>局部</strong>E-R图</p><ul><li><p>选择局部应用</p></li><li><p>利用数据抽象建立实体模型</p></li><li><p>确定实体之间的联系</p></li><li><p>必要调整（属性上升为实体）</p><ul><li><p>属性规范化（不可分割）：E-R图中属性不能和其他属性有<strong>关系</strong>（包括联系）</p></li><li><p>一个属性不能和多个实体之间有联系</p></li><li><p>属性和实体之间应该是“一对一”或者“多对一”的关系，不能“多对多”或者“一对多”。（即实体的某个属性取值是否确定）</p><blockquote><p>例如学生和课程号可能是“多对多”的关系，因此需要将课程号上升为实体。</p><ul><li>这里的多对多和<strong>实体</strong>之间的多对多不同，后者是靠<strong>联系</strong>体现的。但前者指<strong>取值的个数</strong>，例如存在一个学生有多门课，那么课程号的取值有多个，即一对多。</li></ul></blockquote></li></ul></li></ul></li><li><p>综合<strong>局部</strong>E-R图</p><ul><li><p>集成</p><ul><li>一次集成</li><li>逐步集成：累加</li></ul></li><li><p>消除冲突</p><ul><li><p>属性：类型、取值范围、取值单位</p><blockquote><p>协商讨论</p></blockquote></li><li><p>命名</p><blockquote><p>建立命名表</p></blockquote></li><li><p>结构</p><ul><li><p>同一个对象在不同应用中抽象层次不同，例如一个为实体，在另一个中为属性。</p><blockquote><p>实体上升或属性下降，通常为前者。</p></blockquote></li><li><p>同一个实体在不同应用中描述不同，例如属性个数、次序不同。</p><blockquote><p>取并集</p></blockquote></li><li><p>联系类型不同</p><blockquote><p>根据语义综合</p></blockquote></li></ul></li></ul></li><li><p>消除冗余：集成得到的初步E-R图可能存在<strong>数据冗余</strong>和<strong>联系冗余</strong>，调整过后得到<strong>基本E-R图</strong>。</p><ul><li>分析法<ul><li>重点考察<strong>联系的属性</strong>（可能由其他的属性表示，<strong>不一定成环</strong>）</li></ul></li><li>规范化方法</li></ul><blockquote><p>冗余危害：数据不一致。当某个属性变化时，需要更改所有相关的冗余属性，少改任何一个就会出问题。</p></blockquote></li></ul></li></ul><h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><ul><li><p>把概念模型（E-R图）转换为DBMS支持的数据模型（模式）的过程</p></li><li><p>任务</p><ul><li><p>形成初始关系数据库模式：关系</p><blockquote><p>其他的数据库可能是网状、层次等结构。</p></blockquote></li><li><p>关系模式规范化：特定DBMS支持下的数据模型</p></li><li><p>关系模式优化</p></li><li><p>子模式定义（定义外模式）</p><blockquote><p>模式是很多张表的<strong>规范</strong>（设计表），关系是具体的<strong>数据内容</strong>。</p></blockquote></li></ul></li></ul><h3 id="E-R图与关系模型"><a href="#E-R图与关系模型" class="headerlink" title="E-R图与关系模型"></a>E-R图与关系模型</h3><h4 id="普适转换规则"><a href="#普适转换规则" class="headerlink" title="普适转换规则"></a>普适转换规则</h4><blockquote><p>一个关系模式就是一种<strong>数据模型</strong></p></blockquote><ul><li><p>前提：确定每个关系模式的<strong>码</strong></p></li><li><p>一个实体型转换为一个关系模式</p></li><li><p>一个联系转换为一个关系模式</p><ul><li><p><code>1:1</code>：每个实体的码均是该联系的候选码，任意选择一个作为联系模型的主码即可。</p><blockquote><p><strong>不可以</strong>同时选，因为不满足码的<strong>最小性</strong>。</p></blockquote></li><li><p><code>1:n</code>：关系的码是<strong><code>n</code>端实体</strong>的码</p><blockquote><ul><li><code>n</code>端实体码才有唯一标识作用</li><li><strong>不是<code>n</code>端所有实体码的组合</strong></li></ul></blockquote></li><li><p><code>m:n</code>：关系的码是<strong>两端所有</strong>实体码的组合</p></li></ul><blockquote><ul><li>一般只有<code>n:m</code>关系才有属性，其他的联系都可以整合进属性，例如<code>1:n</code>可以在<code>n</code>端实体增加存放<code>1</code>端的码。</li><li>只选择一端实体的码<strong>不代表</strong>只存储一端实体的属性</li></ul></blockquote></li><li><p>多元联系转换为一个关系模式</p></li><li><p>具有相同的码的关系可以<strong>合并</strong>。例如消耗关系和零件的码都是零件号，就可以合并为一个关系。</p><blockquote><p>合并后可能和概念模型E-R图规范不符，但是在逻辑结构设计环节是合法的。</p></blockquote></li></ul><h4 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h4><p>存在依赖中依赖别的实体的实体</p><ul><li>为每个弱实体创建新的关系</li><li>将<strong>被依赖关系的码</strong>作为新关系的<strong>外码</strong></li><li>新关系的主码是<strong>被依赖实体的码</strong>和<strong>自身部分标识属性</strong>的组合</li></ul><h4 id="超类-子类联系"><a href="#超类-子类联系" class="headerlink" title="超类/子类联系"></a>超类/子类联系</h4><ul><li><p>为超类和每个子类创建单独的关系</p></li><li><p>超类关系中，<strong>包含所有子类共有的属性</strong>，包括<strong>主码</strong>。</p></li><li><p>在超类中选定属性组作为子类的判定符</p></li><li><p>子类关系中，包含超类主码以及子类特有的属性。（<strong>没有</strong>共有属性）</p><blockquote><p>子类使用超类的主码作为自己的主码</p></blockquote></li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul><li>确定范式等级（通常需要达到3NF）</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>模式的合并和分解</li><li>关系模式的分解可以提高存取效率和存储空间的利用率</li></ul><h4 id="水平分解"><a href="#水平分解" class="headerlink" title="水平分解"></a>水平分解</h4><ul><li><p>选取操作</p></li><li><p><code>2-8</code>原则：常使用的部分提取出来作为一个关系</p></li><li><p>数据分片：根据不相交的事务将关系分解为多个子关系</p><blockquote><p>事务：一组相对独立的操作</p></blockquote></li><li><p>恢复：并运算</p></li></ul><h4 id="垂直分解"><a href="#垂直分解" class="headerlink" title="垂直分解"></a>垂直分解</h4><ul><li><p>投影操作</p></li><li><p>将经常使用的属性提取出来作为一个子关系模式</p></li><li><p>垂直分解需要保证<strong>无损连接性</strong>和<strong>保持函数依赖</strong>（能够完全复原关系）</p><blockquote><p>完全复原的必要条件：垂直分解得到的子关系模式保留了主码</p></blockquote></li><li><p>恢复：连表运算</p></li></ul><h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><ul><li>用户需求</li><li>具体DBMS的特点，例如MySQL是<code>CREATE VIEW</code>.<ul><li>根据不同的用户设置不同的列名</li><li>权限管理保证系统的安全性</li><li>降低复杂查询的难度</li></ul></li></ul><h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><ul><li>确定数据库的存储结构（内模式）</li><li>存取方法</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>存放位置<ul><li>冷热数据分开存放</li><li>数据和日志备份放在<strong>不同的磁盘</strong>上</li></ul></li><li>系统配置<ul><li>存储分配参数</li><li>物理优化</li></ul></li></ul><h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><ul><li><p>索引记录/索引项：索引文件的记录</p><ul><li>索引域：数据文件中属性组的<strong>一个取值</strong></li><li>指针：指向索引域对应的磁盘块地址</li></ul><blockquote><p>在MySQL的底层，在发起查询时会先查找记录索引域的数据区，然后确定是否对索引进行查找。</p></blockquote></li><li><p>分类</p><ul><li>稀疏索引：把所有数据记录按索引值分组，每组设立一个索引项。</li><li>稠密索引：为每个记录设置一个索引项，记录的存放是任意的，但是<strong>索引是有序</strong>的。</li></ul></li><li><p>多级索引</p><ul><li>（排序）二叉树索引</li><li>多叉树索引：每个结点有<code>D</code>个值作为分界点，共<code>(D+1)</code>个指针。</li><li>平衡树索引：限制每个结点放置的关键字和指针最小/最大个数，从而使所有的叶子结点都在一层。</li><li><code>B+</code>树索引（常用）：把树中所有关键字按<strong>递增次序</strong>从左到右安排在叶结点上，并<strong>链接</strong>起来。</li></ul></li><li><p>索引域选择</p><ul><li>经常被查询的属性</li><li>经常作为库函数的参数</li><li>经常作为连接属性</li></ul><blockquote><p>索引并非越多越好</p></blockquote></li></ul><h4 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h4><ul><li><p>将关系中<strong>某个属性组值相同</strong>的记录集中存放在<strong>连续的物理块</strong>中，可以提高查询速度。</p><blockquote><p>就像同学院的同学安排在一栋宿舍楼中</p></blockquote></li><li><p><strong>一个</strong>关系<strong>只能</strong>参与<strong>一个</strong>聚集（一个关系只能被存储一次）</p></li><li><p>选择原则</p><ul><li>经常进行连接操作的关系</li><li>单个关系中经常比较的属性组</li><li>关系<strong>属性组值</strong>重复率高的属性组</li><li>更新操作较多时<strong>不应该</strong>使用聚集方法</li></ul></li></ul><h4 id="HASH文件"><a href="#HASH文件" class="headerlink" title="HASH文件"></a>HASH文件</h4><ul><li><p>通过HASH函数将记录关键字转换成地址，并将这个地址作为<strong>记录</strong>的存储地址。</p></li><li><p>选择原则</p><ul><li><p>关系大小可预知，并且不变。</p><blockquote><p>如果大小会变化，DBMS需要提供对应的动态HASH存取方法。</p></blockquote></li></ul></li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter5-关系数据理论"><a href="#Chapter5-关系数据理论" class="headerlink" title="Chapter5 关系数据理论"></a>Chapter5 关系数据理论</h1><p>全文共<code>4341</code>字，推荐阅读时间<code>30~45</code>分钟。</p><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul><li>数据依赖：影响<strong>模式质量</strong>的因素<ul><li>关系内部属性之间的约束关系</li><li>分类<ul><li>函数依赖</li><li>多值依赖</li></ul></li></ul></li><li>范式理论：衡量模式质量的标准</li><li>规范化方法与算法：提升模式质量的办法</li></ul><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>给定属性集$U$，及其子集$X$，$Y$，$R(U)$是其上的<strong>关系模式</strong>（域名元组），$r$是$R$的<strong>任意一个</strong>具体关系（填入了任意的具体内容），$t$，$s$是$r$中<strong>任意</strong>两个元组。</p><ul><li>如果$t[X]=s[X]$，则$t[Y]=s[Y]$.此时称“$X$函数确定$Y$”或“$Y$函数依赖于$X$”，记作$X\rightarrow Y$.</li></ul><blockquote><p>等价定义：对于$X$的每个具体值，$Y$有唯一的值与之对应。</p></blockquote></li><li><p>函数依赖属于<strong>语义</strong>范畴</p></li><li><p>函数依赖具有时间稳定性，<strong>不随</strong>时间改变。</p><blockquote><p><code>r</code>（具体关系）可能会发生变化，但是函数依赖<strong>不会</strong>发生改变。</p></blockquote></li></ul><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>平凡依赖：若$Y\subseteq X$，则$X\rightarrow Y$是平凡依赖。</li><li>非平凡</li><li>决定因素：$X$被称为决定因素</li></ul><h4 id="属性联系"><a href="#属性联系" class="headerlink" title="属性联系"></a>属性联系</h4><ul><li><code>1:1</code>：$X\rightarrow Y,Y \rightarrow X$，即两者<strong>相互决定</strong>。</li><li><code>1:n</code>：<code>n</code>端项($X$)决定<code>1</code>端项($Y$)，即$X\rightarrow Y$.</li><li><code>m:n</code>：两者之间<strong>不存在</strong>函数依赖</li></ul><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li><p>完全：$X$的<strong>任意</strong>真子集（除空集）都<strong>不能够</strong>确定$Y$，记为$X \rightarrow Y$（箭头上有一个<code>f</code>）。</p></li><li><p>部分：$X\rightarrow Y$（箭头上有一个<code>p</code>）</p></li><li><p>传递：若$X\rightarrow Y(Y\nsubseteq X),Y\rightarrow Z(Z\nsubseteq Y)$，且$Y$<strong>不确定</strong>$X$，则称为$Z$对$X$<strong>传递</strong>函数依赖（箭头上有一个<code>t</code>）。</p><blockquote><ul><li>如果$Y$可以确定$X$，则$Z$对$X$是<strong>直接</strong>依赖（因为可以归为以上三种类型之一，因此<strong>不是</strong>独立的类型）。</li><li>注意传递依赖要求两个函数依赖都是<strong>非平凡</strong>的</li></ul></blockquote></li></ul><h3 id="关系键"><a href="#关系键" class="headerlink" title="关系键"></a>关系键</h3><ul><li>候选码：设$K$是$R<U,F>$（$F$是属性集$U$上的函数依赖<strong>集</strong>）的属性或属性组合，若$U$<strong>完全依赖</strong>于$K$，则称$K$是$R$的候选码。当候选码多于一个时，选定其中一个作为主码。</li><li>性质<ul><li>唯一性</li><li>最小性</li></ul></li><li>属性分类<ul><li>主属性：包含在<strong>任一候选码</strong>中的属性</li><li>非主属性：不包含在任何候选码中的属性</li></ul></li><li>外码：关系模式$R$中的属性或属性组$X$并非$R$的码，但$X$是另一个关系模式的码，则称$X$是$R$的外码。</li></ul><h3 id="逻辑蕴涵"><a href="#逻辑蕴涵" class="headerlink" title="逻辑蕴涵"></a>逻辑蕴涵</h3><ul><li>通过函数依赖集$F$能够推出$X\rightarrow Y$，则称$F$逻辑蕴涵$X\rightarrow Y$.</li><li>$F$的闭包：$F$蕴涵的<strong>全体函数依赖</strong>称为$F$的闭包，记为$F^+$.</li></ul><h3 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h3><ul><li><p>定律（可从蕴涵定义出发证明）</p><p>对$R<U,F>$</p><ul><li><p>自反律：属性集蕴涵其<strong>子集</strong></p></li><li><p>增广率：对属性$Z\subseteq U$，若$X\rightarrow Y$，则$XZ\rightarrow YZ$.</p><blockquote><p>$XZ$：将两个属性组<strong>直接拼接</strong></p></blockquote></li><li><p>传递率</p></li></ul></li><li><p>推论</p><ul><li>合并：若$X\rightarrow Y, X\rightarrow Z$，则$X\rightarrow YZ$.</li><li>伪传递：若$X \rightarrow Y, WY\rightarrow Z$，则$WX\rightarrow Z$.</li><li>分解：若$X\rightarrow Y$且$Z\subseteq Y$，则$X \rightarrow Z$.</li></ul></li><li><p>定理</p><p>$X\rightarrow A_1A_2…A_k \Longleftrightarrow X\rightarrow A_i(i=1,2,…,k)$</p></li><li><p>属性集闭包：$X\subseteq U$，将所有从$X$出发，通过$F$能够导出的<strong>属性的集合</strong>，记为$X_F^+$.</p><ul><li>$K_F^+=U$，即通过主码能够推出全体属性。</li><li>定理：$X\rightarrow Y \Longleftrightarrow Y\subseteq X_F^+$</li></ul></li><li><p>有效性（正确性）：从$F$出发，根据Armstrong公理导出的所有函数依赖一定在$F$蕴涵的<strong>全体函数依赖</strong>中</p></li><li><p>完备性（实用性）：$F^+$一定可以由Armstrong公理系统导出</p><blockquote><p>证明逆否命题：如果$X\rightarrow Y$不能用Armstrong公理从$F$中导出，则它一定不被$F$逻辑蕴涵。（即不属于该函数依赖集合下的关系模式）</p></blockquote></li></ul><blockquote><p>Armstrong公理系统是一种操作$F$的方式，还可以有其他公理系统，<strong>不</strong>影响$F$本身的存在。</p></blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>算法：求$X_F^+$</p><ul><li>以$X$为起始属性集，对其所有<strong>子集</strong>（不只是元素）进行迭代推导。</li><li>属性集在某一次迭代中没有更新或者等于全集$U$时终止算法</li></ul><blockquote><p>闭包表示</p><ul><li>函数依赖闭包$F^+$：<code>{}</code></li><li>属性集闭包$X_F^+$：<strong>直接列举元素</strong>，外层不需要<code>{}</code>或<code>()</code>修饰。</li></ul></blockquote><h3 id="函数依赖集"><a href="#函数依赖集" class="headerlink" title="函数依赖集"></a>函数依赖集</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>对于$F,G$，若$F^+=G^+$，即两者能推出的全体函数依赖相同，则称两者等价。<ul><li>此时称$F$和$G$相互覆盖</li><li>$F^+=G^+\Longleftrightarrow F \subseteq G^+ \Longleftrightarrow G \subseteq F^+$</li></ul></li><li>最小依赖集<ul><li>右部单属性化：$F$中任一函数依赖$X\rightarrow A$，$A$必是单属性。</li><li>函数依赖<strong>左部</strong>没有多余属性：<strong>不存在</strong>部分函数依赖</li><li>没有多余的函数依赖：$F$中<strong>不存在</strong>可以被其他函数依赖导出的函数依赖</li></ul></li></ul><h4 id="极小化"><a href="#极小化" class="headerlink" title="极小化"></a>极小化</h4><ul><li><p>定理：每个函数依赖集$F$<strong>均等价于</strong>一个极小函数依赖集$Fm$</p></li><li><p>算法</p><ul><li><p>对于<strong>右部</strong>是属性集合的函数依赖进行分解，转换为<strong>多个</strong>单属性依赖。</p></li><li><p>对于<strong>左部</strong>是属性集合的函数依赖，对左侧进行消融检查。对于消融后函数依赖不受影响属性，均从左侧属性集中删除<strong>并更新迭代集</strong>。</p><blockquote><p>也可能消融实验后，左部依然是属性组。</p></blockquote></li><li><p>对于<strong>每个函数依赖</strong>做消融检查，如果消融某个依赖后依然可以推导出该函数依赖，则可以将该函数依赖删除<strong>并更新迭代集</strong>。</p><ul><li>算法一：转化为图的连通性判定</li><li>算法二：求该函数依赖左侧属性<strong>新的属性集闭包</strong>，判断是否包含该消融函数依赖的右侧元素。</li></ul></li></ul><blockquote><p>对于算法的2，3步而言，如果消融的顺序不一样，可能会得到不一样的$Fm$，即$Fm$不唯一。</p></blockquote></li></ul><h2 id="规范化-1"><a href="#规范化-1" class="headerlink" title="规范化"></a>规范化</h2><ul><li>目的：消除冗余和异常</li><li>思想：“一事一地”，一个关系只描述一个实体或者实体间的一种联系。</li><li>消除部分函数依赖和传递函数依赖</li></ul><h3 id="范式-Normal-Form"><a href="#范式-Normal-Form" class="headerlink" title="范式(Normal Form)"></a>范式(Normal Form)</h3><ul><li>一个关系满足的某个<strong>指定的约束集</strong></li><li>各级范式联系：$5NF \sub 4NF\sub BCNF \sub 3CNF \sub 2NF \sub 1NF$（反证法）</li><li>规范化：通过<strong>模式分解</strong>将低级范式的关系模式提升到更高的范式等级</li></ul><h4 id="分级"><a href="#分级" class="headerlink" title="分级"></a>分级</h4><ul><li><p>第一范式(1NF)：最低要求，满足的关系被称为<strong>规范化关系</strong>。</p><ul><li>一个关系只包含原子值（属性<strong>不可</strong>再分）</li></ul></li><li><p>第二范式(2NF)</p><ul><li><p>$R\in 1NF$，并且每个<strong>非主属性完全依赖</strong>于码，则称$R\in2NF$.</p></li><li><p><strong>允许主属性部分依赖于码</strong></p><blockquote><ul><li>任一主属性<strong>均部分依赖</strong>于码</li><li>某些所有属性都是主属性，但是码<strong>不是</strong>全体主属性的情况，例如<code>STC(S, T, C)</code>.</li></ul></blockquote></li><li><p>如果$R$的全体属性都是主属性，则$R\in 2NF$.</p></li><li><p>从$1NF$中消除非主属性对码的部分函数依赖即可升级为2NF</p><ul><li>画函数依赖图</li><li>投影分解法（选择部分列）</li></ul></li></ul></li><li><p>第三范式(3NF)</p><ul><li><p>若$R\in2NF$，并且每个<strong>非主属性</strong>都<strong>不传递依赖</strong>于$R$的任何码，则$R\in3NF$.</p><ul><li><p>推论：若非主属性$Z$<strong>部分依赖</strong>于码$X$，则$R\notin 3NF$.</p><blockquote><p>此时$R\notin 2NF$</p></blockquote></li></ul></li><li><p>投影分解法</p></li></ul></li><li><p>BCNF</p><ul><li><p>3NF<strong>没有限制主属性</strong>对码的<strong>部分及传递函数依赖</strong>，依然会在某些情况下带来异常。</p></li><li><p>若$R\in 1NF$，对任意函数依赖$X\to Y$，且$Y\nsubseteq X$时，$X$必含有码，则$R\in BCNF$.</p><blockquote><p>等价定义：BCNF中任意<strong>非平凡</strong>函数依赖的<strong>左部</strong>含有码</p></blockquote></li><li><p>性质（反证法）</p><ul><li><p><strong>所有</strong>非主属性<strong>完全函数依赖</strong>于任一候选码(2NF)</p></li><li><p><strong>所有</strong>主属性<strong>完全函数依赖</strong>于每个<strong>不包含它</strong>的候选码(BCNF)</p></li><li><p><strong>没有</strong>属性<strong>完全函数依赖</strong>于非码的任意属性组(3NF, BCNF)</p><blockquote><p>如果没有完全函数依赖，则不可能有部分函数依赖。</p></blockquote></li><li><p>全码（所有属性一起作为码的关系模式）关系就是BCNF</p></li></ul></li><li><p>BCNF是只考虑函数依赖的<strong>最高标准</strong></p><blockquote><p>和多值依赖对应，不是指保持函数依赖。</p></blockquote></li></ul></li></ul><h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li><p>给定属性组$X$，$Y$，$Z$，满足$Z=U-X-Y$.当给定一组$(x,z)$可以得到一个$Y$的取值集合，若该集合与$X$有关而与$Z$无关，则称$Y$多值依赖于$X$，记为$X\to \to Y$.</p><blockquote><ul><li>即$(x,z)$中$z$任意变化对$Y$的取值集合<strong>没有</strong>影响，由$X$确定了$Y$的一组取值。</li><li>因为一个自变量对应了多个因变量，因此叫做多值依赖而不是函数依赖。</li><li>函数依赖是多值依赖的特殊情况。</li></ul></blockquote></li><li><p>有效性范围</p></li><li><p>现实场景：各个域之间均为多对多关系，即<strong>不能够</strong>提取出函数依赖关系的模式。</p></li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>给定$Z=U-X-Y$</p><ul><li><p>对称性：若$X\to \to Y$，则$X\to\to Z$.</p></li><li><p>若$X\to Y$，则$X\to\to Y$，即函数依赖可以看作多值依赖的特例。</p></li><li><p>平凡：若$X\to\to Y$，且$Z= \phi$.</p><blockquote><p>即$U$只被划分为了$X$和$Y$</p></blockquote></li><li><p>非平凡：若$X\to\to Y$，且$Z\neq \phi$.</p></li></ul><h3 id="第四范式-4NF"><a href="#第四范式-4NF" class="headerlink" title="第四范式(4NF)"></a>第四范式(4NF)</h3><ul><li><p>对任意<strong>非平凡</strong>多值依赖$X\to\to Y(Y\nsubseteq X)$，$X$都含有码，则称$R\in 4NF$.</p><blockquote><p>若关系已经满足BCNF，且所有的多值依赖都是平凡的，则关系也满足4NF.</p></blockquote></li><li><p>意义：降低数据冗余程度，减少修改异常。</p></li></ul><h2 id="模式分解理论"><a href="#模式分解理论" class="headerlink" title="模式分解理论"></a>模式分解理论</h2><ul><li><p>目的：通过模式分解，将关系模式的范式等级提高，同时保有原关系模式的一定信息。</p><blockquote><p>如果不保有信息，分解是没有意义的。因此，所有的分解算法都和性质的保持有关。</p></blockquote></li></ul><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>分解$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>,…,R_n<U_n,F_n>\}$，满足：</p><ul><li><p>$U=\bigcup_{i=1}^n U_i$，且$\forall 1\leq i,j \leq n,U_i\nsubseteq U_j$.</p><blockquote><p>可以相交但<strong>不能</strong>包含</p></blockquote></li><li><p>$F_i$是$F$在$U_i$上的一个投影，即选择了$F^+$中相关属性<strong>都在</strong>$U_i$中($XY\subseteq U_i)$的函数依赖作为$F_i$.（可以只选择一部分，不一定全选）</p></li><li><p>表示</p><p>$\rho=\{R_1&lt;\{Sno,Sdept\},\{Sno \to Sdept\}&gt;,R_2&lt;\{Sno,Mname\},\{Sno \to Mname\}&gt; \}$</p></li></ul><h3 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性"></a>无损连接性</h3><ul><li><p>将分解后的关系模式做<strong>自然连接</strong>得到合成的新关系模式，如果新关系模式中的关系和分解前的原关系模式中的关系逐一相等，则称该分解$\rho$具有无损连接性，记为<strong>无损分解</strong>。</p></li><li><p>判定</p><ul><li><p>算法</p></li><li><p>定理（无损连接性的充要条件）：以分解为两个子模式为例，若$R_1$和$R_2$的共同属性<strong>至少构成二者之一</strong>的候选码，则为无损分解。</p><blockquote><p>扩展为<code>n</code>个子关系模式：将子模式间<strong>两两进行比较</strong>，若<strong>所有</strong>的比较都满足以上条件，则该分解无损连接性。（每一次都是无损连接，则合成后的连接也是无损连接）</p></blockquote></li></ul></li></ul><h3 id="保持函数依赖性"><a href="#保持函数依赖性" class="headerlink" title="保持函数依赖性"></a>保持函数依赖性</h3><ul><li>若$F^+=(\bigcup_{i=1}^nF_i)^+$，即两个函数依赖集等价，则称$\rho$是保持函数依赖性的分解。</li><li>判定：设$G=(\bigcup_{i=1}^nF_i)$，$G\subseteq F^+$一定成立，则只需要判断$F^+\subseteq G$是否成立。<ul><li>$\forall (X\to Y) \in F$，判断$Y$是否属于$X_G^+$.</li><li>对于$F$中的每个函数依赖，判断是否可以从$G$中的函数依赖导出。</li></ul></li></ul><blockquote><p>分解$\rho$可以无损连接性和保持函数依赖性，也可以只满足其中一个，也可以同时都不满足。</p></blockquote><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>规范化过程中采用的投影分解可能不唯一，但是好的无损分解应该无损连接并且保持函数依赖。</li><li>若要保持函数依赖，则最高可能只能到3NF.（BCNF的粒度过小，可能<strong>不保持</strong>函数依赖）</li><li>若要进行无损分解，则可以到达4NF或更高。</li></ul><blockquote><ul><li>模式分解是在求当前模式的“数据等价子集”，在保证<strong>数据完整性（无损连接）</strong>的条件下尽可能地减小单个模式的复杂度，因此某些不影响数据完整性的函数依赖可能被舍弃。</li><li>大多数情况下，3NF是最为合适的规范化等级，因为它是能够无损连接并且保持函数依赖的最高等级。</li></ul></blockquote><h3 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h3><ul><li><p>3NF+函数依赖</p><ul><li><p>对$F$进行<strong>极小化</strong>处理，记为$F$.</p></li><li><p>将<strong>不在</strong>$F$中出现的属性从$U$中删除，记为$U$.</p><blockquote><p>删除了部分元素，所以<strong>不具有</strong>无损连接性。</p></blockquote></li><li><p>若$F$只有一个函数依赖，则$\rho=\{R\}$.</p></li><li><p>对$F$按照<strong>“具有相同左部”</strong>的原则进行分组，由$F_i$求出$U_i$，则$\rho=\{R_1<U_1,F_1>,…R_k<U_k,F_k>\}$为所求。</p></li></ul></li><li><p>3NF+无损连接性+函数依赖</p><p>从<strong>满足保持函数依赖</strong>的分解$\rho$出发，设$X$是$R<U,F>$的码。</p><ul><li><p>若$\exist U_i, X\subseteq U_i$，则$\rho$为所求。</p></li><li><p>否则，令$\tau=\rho \cup\{R^*<X,F_X>\}$，则$\tau$为所求。</p><blockquote><ul><li>$F_X$是以$X$为属性集的函数依赖的投影</li><li>$X_F$是属性$X$蕴涵的属性集</li><li>在满足函数依赖的算法中，删去了<strong>不出现</strong>在$F$中的属性，但是它们是<strong>主属性</strong>，因此通过$X$对无损连接性进行了恢复。</li><li>注意，$\tau$求解时是直接把$R^<em>$并入，而<em>*不是</em></em>把$X$添加进$U_i$.</li></ul></blockquote></li></ul></li><li><p>BCNF+无损连接性</p><p>设$\rho$中$R_i<U_i,F_i>\notin BCNF$</p><ul><li>则$R_i$中存在$X\to A\in F_i^+(A\notin X)$，且$X$不是$R_i$的码（也不含有），则$XA$是$U_i$的真子集，将$R_i$分解为$\sigma=\{S_1,S_2\}$，其中$U_{S_1}=XA$，$U_{S_2}=U_i-\{A\}$.</li></ul><blockquote><p>$A$是<strong>单属性</strong>，而<strong>不是</strong>属性组。</p></blockquote><ul><li><p>使用$\sigma$进行迭代，直到$\sigma \in BCNF$.</p><blockquote><p>相当于逐步分离不符合BCNF的函数依赖</p></blockquote></li></ul></li></ul><h2 id="候选码求解"><a href="#候选码求解" class="headerlink" title="候选码求解"></a>候选码求解</h2><h3 id="单属性"><a href="#单属性" class="headerlink" title="单属性"></a>单属性</h3><h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><ul><li>$L$：<strong>仅</strong>出现在左部</li><li>$R$：<strong>仅</strong>出现在右部</li><li>$N$：两边均未出现</li><li>$LR$：两边均出现</li></ul><blockquote><p>以上是<strong>属性</strong>分类，而不是<strong>属性组</strong>分类。</p><p>例如，$BC\to A$和$C\to B$均成立时，$BC\notin L$.</p></blockquote><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><ul><li>L类属性一定是<strong>所有候选码</strong>中的成员（<strong>强于</strong>主属性）<ul><li>若L类属性能够推出全体属性，则该属性单独作为候选码，且由码的极小性，该候选码唯一，即<strong>主码</strong>为该属性。</li></ul></li><li>R类属性一定<strong>不是</strong>任意候选码成员</li><li>N类属性一定是<strong>所有候选码</strong>中的成员<ul><li>若L和N类属性组成的集合能够推出全体属性，则该属性集是<strong>主码</strong>。</li></ul></li></ul><h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><p>将<strong>单属性依赖</strong>关系模式转换为图$G(U,F)$，其中$F$为有向边集合，表示<strong>单属性</strong>函数依赖。</p><ul><li>关键点（原始点+孤立点）对应的属性必在$R$的任何候选码中</li><li>属性集$X$是$R$的唯一候选码$\Leftrightarrow$X能到达$G$中的任一结点<ul><li>在单属性条件下，即不存在独立回路。</li></ul></li><li>对途中点而言，成为候选码成员$\Leftrightarrow$途中点是独立回路中的结点。</li><li>对于存在独立回路的关系模式而言，候选码=关键属性集+独立回路笛卡尔积中的任意元素。</li></ul><h3 id="多属性"><a href="#多属性" class="headerlink" title="多属性"></a>多属性</h3><ul><li><p>$X=L\cup N，Y=LR$.</p></li><li><p>判断$X$是否可以推出全体属性集，如果不可以的话就从$Y$中取一个并进$X$，然后再次判断。</p></li><li><p>依次迭代取的个数，直到能够推出全体属性。</p><blockquote><ul><li>这是一个穷举算法，取两个不只是在取的第一个的基础上再取，而是遍历所有取两个的情况。</li><li>证明了独立回路存在时，主码$K\neq L\cup N$.</li></ul></blockquote></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>通过最小函数依赖集消除<strong>冗余</strong>联系</li><li>$D=F-F_m$中的函数依赖<strong>不一定</strong>是冗余的，因此除了$F_m$中的函数依赖外，可能$D$中也有需要保留的函数依赖。</li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter6-关系查询处理与查询优化"><a href="#Chapter6-关系查询处理与查询优化" class="headerlink" title="Chapter6 关系查询处理与查询优化"></a>Chapter6 关系查询处理与查询优化</h1><p>全文共<code>448</code>字，推荐阅读时间<code>3~5</code>分钟。</p><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul><li>分析</li><li>检查<ul><li>将查询转换为<strong>查询树</strong>（语法分析树）</li></ul></li><li>优化<ul><li>代数：恒等变换</li><li>物理：根据数据规模、分布等确定对应的底层存储策略。</li></ul></li><li>执行</li></ul><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><ul><li>查询代价=I/O代价<strong>（主要）</strong>+CPU代价+内存代价</li></ul><h3 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h3><ul><li>变换规则：主要是优化<strong>连接</strong>（笛卡尔积为主）运算。<ul><li>交换律</li><li>结合律</li></ul></li><li>特殊优化：先缩小范围再运算一般效率更高<ul><li>投影、选择的串接：合并操作减小遍历次数</li><li>投影、选择的交换律：先投影再选择</li><li>选择、笛卡尔积的交换律：能先投影时，先投影再作笛卡尔积。</li></ul></li><li>查询树的启发式优化<ul><li>减少<strong>中间</strong>（临时）关系：选择、投影尽可能先做。</li><li>减少扫描次数：投影、选择并行等操作。</li><li>减少操作总数：连接=笛卡尔积+选择</li><li>中间结果复用：使用中间文件存储公共表达式的结果</li></ul></li></ul><h3 id="物理优化"><a href="#物理优化" class="headerlink" title="物理优化"></a>物理优化</h3><ul><li><p>存取路径选择</p><ul><li><p>选择操作</p><ul><li>小关系：全表扫描</li><li>大关系：索引扫描</li></ul></li><li><p>连接操作</p><ul><li><p>排序-合并</p></li><li><p>索引连接：为连接属性建立索引</p></li><li><p>Hash Join：为小表建Hash文件</p></li><li><p>嵌套循环：小表在外层</p><blockquote><p>原因：分配时通常给外表的内存更大</p><ul><li><p>设外表分配$(K-1)$块，内表$1$块。</p><p>$Cost=Cost_{out}+Cost_{in}*\frac{B_{out}}{K-1}$</p></li></ul></blockquote></li></ul></li></ul></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul><li>将查询转换成语法树</li><li>代数优化</li><li>物理优化，确定底层的存储路径</li><li>生成查询计划</li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter7-事务处理技术"><a href="#Chapter7-事务处理技术" class="headerlink" title="Chapter7 事务处理技术"></a>Chapter7 事务处理技术</h1><p>全文共<code>2870</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ul><li>事务(Transaction)：用户定义的数据库操作序列，这些操作要么一起做，要么都不做，是一个不可分割的<strong>工作单位</strong>。<ul><li>应用程序可以包含<strong>多个</strong>事务</li><li>事务的开始和结束可以由用户显式控制（DBMS也会缺省定义一部分事务划分），从而保证数据的<strong>完整性</strong>。</li></ul></li><li>事务是<strong>数据库恢复</strong>及<strong>并发控制</strong>的基本单位</li></ul><h3 id="特性-ACID"><a href="#特性-ACID" class="headerlink" title="特性(ACID)"></a>特性(ACID)</h3><ul><li><p>原子性</p><ul><li>基础：恢复机制<ul><li>回退，将已经执行的部分进行撤销。</li></ul></li></ul></li><li><p>一致性：事务执行前后数据库均为一致性状态</p><ul><li>基础：原子性</li></ul><blockquote><p>Q：什么是一致性状态</p><p>A：满足数据库约束的状态</p></blockquote></li><li><p>隔离性：并发事务之间不能相互影响</p><ul><li>基础：并发控制机制</li></ul></li><li><p>持久性：事务<strong>提交后</strong>对数据库的改变应该是永久的，故障等情况不应该有影响。</p><ul><li>基础：恢复机制</li></ul></li></ul><blockquote><p><code>ACID</code>里的<code>AID</code>都是数据库的特征,也就是<strong>依赖数据库的具体实现</strong>。而唯独这个C，实际上它依赖于<strong>应用层</strong>，也就是依赖于开发者。做个比喻事务就好比一个保镖，我们提到事务就会说ACID，而我们提到保镖会说强壮、保护安全、好功夫、踏实。这里强壮、好功夫和踏实都是保镖自己的特征，而安全是属于你的，即你通过保镖的特征来保护你的安全。</p></blockquote><h4 id="破坏"><a href="#破坏" class="headerlink" title="破坏"></a>破坏</h4><ul><li><p>事务并行时，不同事务的操作交叉进行。（隔离性）</p><blockquote><p>交叉是指<strong>完整</strong>事务间，而<strong>不是</strong>在某个事务中进行切换。</p></blockquote></li><li><p>事务运行时被强行停止（持久性）</p></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li><p>开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br></pre></td></tr></table></figure></li><li><p>结束</p><ul><li><p>正常结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT</span><br></pre></td></tr></table></figure></li><li><p>非正常结束：撤销全部更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h2><ul><li>从<strong>错误</strong>状态恢复到某一已知<strong>正确</strong>状态</li><li>通过DBMS的<strong>恢复子系统</strong>完成</li></ul><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><ul><li>事务<ul><li>可预期：事务根据<strong>内部</strong>测试条件而触发的回滚</li><li>不可预期：不能由应用程序处理</li></ul></li><li><p>系统</p><ul><li><p>事务异常中断：数据库本身不会受到破坏。</p><blockquote><p>指数据不会丢失，而<strong>不是数据的正确性</strong>。</p></blockquote></li></ul></li><li><p>介质</p><ul><li>数据库本身受到破坏及正在使用这部分数据的相关事务</li></ul></li><li><p>病毒</p><ul><li>对数据进行非法修改</li></ul></li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><ul><li><p>基本原理：冗余</p></li><li><p>建立冗余</p><ul><li><p>数据转储（备份）</p><ul><li>静态：保证一致性，但是可用性低。</li><li>动态：不影响可用性，不能保证一致性。<ul><li>建立日志文件，在使用副本进行数据库恢复时，需要经过一遍日志处理。</li></ul></li><li>海量：每次转储全部数据库</li><li>增量：每次只转储上一次转储后更新的部分</li></ul></li><li><p>登录日志文件：记录事务对数据库的更新操作</p><ul><li>记录单位：事务驱动</li><li>数据块单位：数据驱动</li></ul><blockquote><ul><li>事务、系统故障必须使用日志文件</li><li>写入规则<ul><li>按照并发事务的时间顺序</li><li><strong>先写</strong>日志文件，<strong>再写</strong>数据库。</li></ul></li></ul></blockquote></li></ul></li></ul><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>事务：UNDO<ul><li><strong>反向</strong>扫描日志，对更新执行逆操作，直到事务开始标志。</li></ul></li><li>系统：UNDO+REDO<ul><li>未完成的事务已经修改了数据库，此时采取<strong>撤销</strong>操作。</li><li>已经提交的事务还留在缓冲区中，没有写入数据库，此时采取<strong>重做</strong>操作。<ul><li><strong>正向</strong>扫描日志，获得撤销队列和重做队列。</li><li>对队列中的事务分别执行<strong>撤销</strong>和<strong>重做</strong>操作</li></ul></li></ul></li><li>介质：REDO<ul><li>装入最新数据库的后备副本</li><li>装入日志文件副本，重做已完成的事务。</li></ul></li></ul><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><ul><li><p>缩小日志文件的检查范围</p></li><li><p>新增“重新开始”文件记录检查点在日志的位置</p></li><li><p>在日志文件增加检查点记录</p><ul><li><p>存储检查点时正在运行的事务清单</p></li><li><p>维护</p><ul><li><p>将<strong>日志缓存</strong>写入磁盘，同时增加一个检查点记录。</p></li><li><p>将<strong>数据缓存</strong>写入磁盘</p><blockquote><p>由此，检查点<strong>之前</strong>的提交的缓存事务<strong>不需要</strong>被加入正在执行的事务清单。</p></blockquote></li><li><p>将检查点记录的地址写入“重新开始”文件</p></li></ul></li><li><p>恢复</p><ul><li><p>从检查点开始进行日志扫描，从而对事务清单进行分类，得到撤销列表和重做列表。</p><blockquote><p>在正向扫描的过程中，可能会存在检查点之后才开始的事务。对于这些事务，一样需要把它们加入<strong>正在执行</strong>的事务清单。</p></blockquote></li><li><p>对两个列表中的事务采取不同操作</p></li></ul></li></ul></li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul><li>利用镜像来维护原始数据库</li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul><li>并发(Concurrency)：<strong>单</strong>处理器，<strong>逻辑</strong>并列。</li><li>并行(Parallel)：<strong>多</strong>处理器，<strong>物理</strong>并列。</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>主要：数据不一致</p><ul><li>丢失更新(Lost Update)：并发事务的结果出现了“不正常”覆盖</li><li>脏数据读出(Dirty Read)：数据处理未完成时被读出</li><li>不能重复读(Non-Repeatable Read)：数据在相邻读之间被更新，导致读操作无法复现。</li></ul><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li>合理调度并发事务，避免事务之间的互相干扰造成数据的不一致。</li></ul><h3 id="基本手段"><a href="#基本手段" class="headerlink" title="基本手段"></a>基本手段</h3><ul><li><p>封锁（上锁）</p></li><li><p>分类</p><ul><li><p>排它锁（<code>X</code>锁、独占锁）：<strong>只允许</strong>上锁事务<strong>读取和修改</strong>数据对象</p></li><li><p>共享锁（<code>S</code>锁）：上锁事务<strong>只能读</strong>数据对象，其他事务能够继续上<code>S</code>锁，但是不能上<code>X</code>锁。</p><blockquote><p>同一个数据对象可以有多个<code>S</code>锁，但是只能有一个<code>X</code>锁，并且两个锁不能同时出现。</p></blockquote></li></ul></li><li><p>相容矩阵</p><p><img src="https://i.loli.net/2020/11/20/VgGK16P2QrdtBqf.png" alt="image-20201120114606476" style="zoom:50%;" /></p></li><li><p>封锁协议：各级协议间是<strong>包含关系</strong>，<strong>不是并列</strong>。</p><ul><li><p>一级：事务在修改数据对象之前必须上<code>X</code>锁，等到<strong>事务结束</strong>后再释放锁。</p><blockquote><ul><li><p>事务结束$\neq$修改完成，因为可能是<strong>非正常结束(ROLLBACK)</strong>。</p></li><li><p>限制写，解决<strong>写间冲突</strong><code>Lost Update</code>；因为没有限制读操作，所以没有解决<strong>读写冲突</strong><code>Dirty Read</code>和<code>Non-Repeatable Read</code>.</p></li><li><p>Q：上了<code>X</code>锁不也限制了其他事务的读吗？</p><p>A：上<code>X</code>锁<strong>并不是不允许</strong>其他事务读，而是限制了其他事务上<code>S</code>锁。因此如果读之前不进行上锁操作，则不会受到<code>X</code>锁的限制，一样能够读到脏数据。</p></li></ul></blockquote></li><li><p>二级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>读完之后</strong>释放。</p><blockquote><p>解决了<code>Dirty Read</code>，但是由于<strong>上锁时间较短</strong>，所以依然可能出现<code>Non-Repeatable Read</code>.</p></blockquote></li><li><p>三级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>事务结束之后</strong>释放。</p><blockquote><p>解决了三种数据不一致问题</p></blockquote></li></ul></li><li><p>粒度：封锁对象的大小（被上锁的对象的大小）</p><ul><li><p>常见封锁对象：属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库、物理页、块等。</p></li><li><p>多粒度封锁：一个系统的封锁机制可以提供多种粒度</p><ul><li><p>多粒度树：根据数据对象及其之间的关系构造的树</p><ul><li><p>显式：锁<strong>直接</strong>加在事务需要的数据对象上 </p></li><li><p>隐式：锁加在事务需要的<strong>数据对象的上级结点</strong>上</p></li><li><p>上锁检查：显式锁和隐式锁都需要检查</p><ul><li>隐式锁需要检查<strong>所有</strong>的上级节点</li></ul><blockquote><p>包括<strong>下级结点的显式锁</strong>（下级结点的隐式锁在对当前结点的检查中就已经被判断了）</p></blockquote></li></ul></li></ul></li></ul></li><li><p>意向锁：表示<strong>下级节点</strong>被上了相应类型的锁（优化多粒度树上锁检查）</p><ul><li><p>在为对象上锁时，需要先对其<strong>所有</strong>上级节点添加意向锁。</p></li><li><p>在为对象解锁时，需要向上逐级为上级节点释放锁。</p><blockquote><p><strong>不能</strong>优化当前结点的<strong>隐式锁</strong>检查</p></blockquote></li><li><p>分类</p><ul><li><p>意向共享锁(<code>IS</code>, Intent Share Lock)</p></li><li><p>意向排它锁(<code>IX</code>, Intent Exclusive Lock)</p></li><li><p>意向共享排它锁(<code>SIX</code>, Share Intent Exclusive Lock)：对该对象加<code>S</code>锁后，再加<code>IX</code>锁。</p><blockquote><p><strong>不是</strong>下级对象的<code>IS</code>和<code>IX</code>的叠加</p></blockquote></li></ul></li><li><p>相容矩阵</p><p><img src="https://i.loli.net/2020/11/20/8KL7aMQVrhPAmRF.png" alt="image-20201120115143845" style="zoom:50%;" /></p><ul><li><p>上了<code>IS</code>后，可以上<code>IX</code>，反之亦然。</p><blockquote><p>意向锁来自不同的结点，所以<code>S</code>和<code>X</code>能够“同时出现”。</p></blockquote></li><li><p>可以多次上<code>IS</code>和<code>IX</code>锁</p></li><li><p>上了<code>IS</code>后，还可以上<code>S</code>和<code>IX</code>变成<code>SIX</code>；但是上了<code>IX</code>之后，<strong>不能</strong>再上<code>S</code>和<code>IX</code>变成<code>SIX</code>了。</p><blockquote><p>上了<code>IX</code>后<strong>不能</strong>再为下级结点隐式上<code>S</code>锁了</p></blockquote></li><li><p>上了<code>SIX</code>之后，还可以上<code>IS</code>，但是不能再上<code>IX</code>了。</p><blockquote><p>因为下级结点已经隐式上了<code>S</code>，不能再上<code>X</code>了。</p></blockquote></li></ul></li></ul></li></ul><h3 id="活锁和死锁"><a href="#活锁和死锁" class="headerlink" title="活锁和死锁"></a>活锁和死锁</h3><ul><li><p>活锁：系统正常运行，但是有些事务可能永远不能得到上锁机会。</p><ul><li>采用<code>FCFS</code>解决</li></ul></li><li><p>死锁</p><ul><li><p>预防</p><ul><li><p>一次封锁法：事务执行前为<strong>所有</strong>需要的资源上锁</p><ul><li>降低系统并发度</li></ul></li><li><p>顺序封锁法：为资源编号，事务执行时必须按照顺序对所需的资源上锁。</p><ul><li>实现难度大</li></ul><blockquote><p>不是按照顺序获取<strong>所有</strong>资源，而是在获取所需对象时按照顺序进行。</p></blockquote></li></ul></li><li><p>检测</p><ul><li>超时法：事务等待时间过长时认为发生死锁</li><li>等待图法：结点表示事务，边指向等待的事务，出现回路则发生死锁。</li></ul></li><li><p>恢复（解除）</p><ul><li><p>选择代价小的事务撤销</p><blockquote><p>撤销后，需要回滚该事务的所有操作</p></blockquote></li></ul></li></ul></li></ul><h3 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h3><ul><li><p>调度的单位是事务的<strong>操作</strong>，而<strong>不是</strong>事务本身。</p></li><li><p>事务执行正确性：保证数据库<strong>一致性</strong>的都是正确的执行结果</p><blockquote><p>不同执行顺序可能有不一样的执行结果（随机性），但可能都是正确的。</p></blockquote></li><li><p>可串行化：事务的并发执行正确$\Leftrightarrow$按照某一次序<strong>串行执行</strong>的结果和<strong>并发执行</strong>结果相同</p><ul><li>可串行化的并发调度是正确调度</li></ul></li><li><p>判定</p><ul><li><p><strong>冲突可串行化</strong>调度：调度$Sc$交换<strong>事务间不冲突</strong>操作的次序后，得到<strong>串行调度</strong>$Sc’$.</p><ul><li>不能交换<strong>事务间</strong>的冲突操作</li><li>不能交换<strong>一个事务内</strong>的操作</li></ul></li><li><p>冲突操作：读-写、写-写</p></li><li><p>充分条件：冲突可串行化调度$\Rightarrow$可串行化调度</p><blockquote><p>冲突可串行化调度$\Rightarrow$可串行化调度$\Rightarrow$正确调度</p></blockquote></li></ul></li><li><p>两段锁协议：保证并发调度可串行</p><ul><li>扩展阶段：读写操作执行前需要上锁</li><li>收缩阶段：开始释放锁之后，事务不再获取其他任何锁。</li></ul><blockquote><p>依然可能发生死锁</p></blockquote></li></ul><h2 id="Reference-7"><a href="#Reference-7" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li><a href="https://www.zhihu.com/question/31346392" target="_blank" rel="noopener">https://www.zhihu.com/question/31346392</a></li></ul><h1 id="Chapter8-数据库保护"><a href="#Chapter8-数据库保护" class="headerlink" title="Chapter8 数据库保护"></a>Chapter8 数据库保护</h1><p>全文共<code>732</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul><li>安全性(<code>security</code>)：防止不合法的使用造成的<strong>数据泄露</strong>、<strong>更改</strong>、<strong>破坏</strong>。</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul><li><p>用户标识和认证（最外层）</p><ul><li>常用：用户名和密码（口令）</li></ul></li><li><p>存取控制</p><ul><li><p>权限定义</p></li><li><p>权限检查</p></li><li><p>方法</p><ul><li><p>自主(<code>DAC</code>)：用户可以将权限转授</p><ul><li><p>权限=数据对象+操作类型</p></li><li><p>SQL</p><ul><li>用户级：操作数据库，例如创建外模式、创建会话、创建表等。</li><li>关系级：操作某个关系和视图，针对具体的对象，例如在某个表中进行CRUD操作。</li></ul></li><li><p>角色：一组权限的集合，可以授给<strong>用户或其他角色</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT CREATE SESSION to xxx; # 用户级</span><br><span class="line">GRANT CREATE TABLE to xxx; # 用户级</span><br><span class="line">REVOKE CREATE TABLE FROM xxx; # 用户级</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>强制(<code>MAC</code>)：不同数据对象有不同的加密等价，每个用户的许可证级别决定了能够访问哪些数据，由系统<strong>直接指定</strong>级别。</p><ul><li>实体=主体+客体</li><li>主体：实际用户</li><li>客体：系统中的被动实体，包括文件、基本表、索引、视图等。</li><li>许可证级别(<code>Label</code>，敏感度标记)<ul><li>主体<strong>大于等于</strong>客体：读</li><li>主体<strong>等于</strong>客体：写</li></ul></li></ul></li></ul></li><li><p>操作系统/网络安全保护</p></li><li><p>数据加密</p></li><li><p>其他</p><ul><li>视图：不同用户有不同的视图</li><li>审计：将用户对数据库的操作记录在审计日志中，出现安全问题时进行审查。</li></ul></li></ul><h3 id="可信系统评测"><a href="#可信系统评测" class="headerlink" title="可信系统评测"></a>可信系统评测</h3><ul><li>TCSEC</li><li>TDI</li></ul><h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul><li>完整性=正确性+相容性<ul><li>正确性：类型、取值范围</li><li>相容性：同一个事实的值应该相同</li></ul></li><li>确保数据库语义正确</li></ul><h3 id="约束条件-1"><a href="#约束条件-1" class="headerlink" title="约束条件"></a>约束条件</h3><ul><li>作用对象<ul><li>列：对属性进行约束</li><li>元组：元组间的<strong>字段</strong>约束（属性间约束）</li><li>关系：元组之间、关系之间的约束，例如实体完整性、参照完整性。</li></ul></li><li>时机<ul><li>静态：数据库在每一确定状态应该满足的约束</li><li>动态：新、旧值之间的约束，例如年龄只能上升不能下降。</li></ul></li></ul><blockquote><p>总共可以组合出3*2=6种约束条件</p></blockquote><h3 id="控制-1"><a href="#控制-1" class="headerlink" title="控制"></a>控制</h3><ul><li><p>定义</p></li><li><p>检查</p><ul><li>立即执行：<strong>语句</strong>执行完后立即检查</li><li>延迟执行：<strong>事务</strong>执行完毕后再进行检查</li></ul></li><li><p>违约相应</p></li><li><p>规则：$(D,O,A,C,P)$</p><ul><li><code>D</code>：数据本身</li><li><code>O</code>：操作</li><li><code>A</code>：断言</li><li><p><code>C</code>：<code>A</code>指定的谓词（自然语言约束的主语）</p></li><li><p><code>P</code>：违反规则时触发的过程</p></li></ul></li><li><p>SQL</p><ul><li><p><code>CREATE TABLE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NULL</span><br><span class="line">NOT NULL</span><br><span class="line">UNIQUE</span><br><span class="line">PRIMARY KEY</span><br><span class="line">FOREIGN KEY</span><br><span class="line">CHECK</span><br></pre></td></tr></table></figure></li><li><p><code>CREATE ASSERTION</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSERTION ASSE_NAME</span><br><span class="line">CHECK (60 &gt;&#x3D; ALL(SELECT COUNT(*) FROM SD GROUP BY C));</span><br></pre></td></tr></table></figure></li><li><p><code>CREATE TRIGGER</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Reference-8"><a href="#Reference-8" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li></ul><h1 id="Chapter9-数据库新技术"><a href="#Chapter9-数据库新技术" class="headerlink" title="Chapter9-数据库新技术"></a>Chapter9-数据库新技术</h1><p>全文共<code>2031</code>字，推荐阅读时间<code>10~15</code>分钟。</p><h2 id="数据仓库-Data-Warehouse"><a href="#数据仓库-Data-Warehouse" class="headerlink" title="数据仓库(Data Warehouse)"></a>数据仓库(<code>Data Warehouse</code>)</h2><ul><li><p>支持管理决策过程</p><blockquote><p>不同于数据库提供的<strong>日常业务查询</strong>服务</p></blockquote></li><li><p>面向主题</p><ul><li>从大量的历史数据中提取</li></ul></li><li><p>持久数据集合</p></li><li><p>业务</p><ul><li>OLAP：数据<strong>仓库</strong>联机<strong>分析</strong>处理</li><li>OLTP：数据<strong>库</strong>联机<strong>事务</strong>处理</li></ul></li><li><p>数据仓库系统</p><ul><li><p>数据源</p><ul><li>数据库</li><li>数据文件</li></ul></li><li><p>数据仓库管理工具</p><ul><li><p>数据建模工具：根据主题确定，例如学生就业情况。</p></li><li><p>抽取、转换、装载(<code>ETL</code>)</p></li><li><p>元数据库：描述数据的数据</p><blockquote><p>类似数据库中的数据字典</p></blockquote></li></ul></li><li><p>数据仓库</p><ul><li>高度综合数据：准决策数据</li><li>轻度综合数据：来自近期基本数据</li><li>当前数据：最近时期业务数据</li><li>历史数据：早期基本数据</li></ul></li><li><p>分析工具</p><ul><li>用户查询工具</li><li>OLAP工具</li><li>DM工具</li></ul></li><li><p>比较</p><ul><li><p>数据库</p><p><img src="https://pic4.zhimg.com/80/v2-bdc235fbdd1825c1b67ef7d609f81adb_1440w.jpg?source=1940ef5c" alt="img" style="zoom: 33%;" /></p><ul><li>一种事务处理技术</li><li>表格结构复杂，存储结构紧致，冗余数据少。</li><li>读写均进行优化</li><li>查询要求较简单，单次作用的数据量小。</li><li>常见：MySQL, Oracle, SqlServer.</li></ul></li><li><p>数据仓库</p><p><img src="https://pic4.zhimg.com/80/v2-ccefb7a678de237560cc4df80c11cca3_1440w.jpg?source=1940ef5c" alt="img" style="zoom:33%;" /></p><ul><li>一种体系结构</li><li>表格结构简单，存储结构松散，冗余数据多。</li><li>通常只优化读</li><li>查询要求较复杂，单次作用的数据量大。</li><li>常见：AWS Redshift, Hive.</li></ul><blockquote><ul><li>数据仓库是为某种特定的查询而设置的，是对数据库中多张表的整合，因此可以承担相应的分析工作。</li><li>数据仓库来自于“分析型数据库”，但也因此不满足数据库的一些规范，所以被改叫“数据仓库”。</li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="分布式数据库系统"><a href="#分布式数据库系统" class="headerlink" title="分布式数据库系统"></a>分布式数据库系统</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><p>基础：网络+数据库</p></li><li><p>结构</p><ul><li>全局应用=局部应用+网络，操作<strong>两个及以上</strong>节点中的数据库。</li><li>局部应用=数据库+服务器，操作<strong>一个</strong>节点中的数据库。</li></ul><blockquote><p>结构必须完整，缺一不可。</p></blockquote></li><li><p>前提：数据分布存储</p><ul><li>场地自治性</li><li>场地协作性</li></ul></li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>数据独立性<ul><li>逻辑</li><li>物理</li><li><strong>分布</strong>（分布透明性）：数据的存储特征（分片、位置等）和用户/应用程序无关</li></ul></li><li>控制结构：集中和自治相结合<ul><li>共享<ul><li>局部</li><li>全局</li></ul></li></ul></li><li>适当增加数据冗余：在不同节点存储同一数据的多个副本<ul><li>提高系统可靠性、可用性</li><li>提高系统性能</li><li>不利于更新，增大了系统维护代价。</li></ul></li><li>全局一致性、可串行性、可恢复性</li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">全局外模式--&gt;|映象1|全局概念模式</span><br><span class="line">全局概念模式--&gt;|映象2|分片模式</span><br><span class="line">分片模式--&gt;|映象3|分布模式</span><br><span class="line">分布模式--&gt;|映象4|局部概念模式</span><br></pre></td></tr></table></figure><ul><li>全局概念模式定义了数据库的整体逻辑结构</li><li>分片模式定义了数据库关系的全局关系的分片方式</li><li>分布模式定义了各片段的存储位置，进而决定了数据库是否冗余。</li><li>各级映像中存储了上级模式到下级模式的映射关系</li></ul><blockquote><p>映象的作用类似虚拟地址和物理地址的转换。例如，映象1为外模式在概念模式中选取合适的部分进行构造；映象2的作用就是为每个关系指定合适的分片方式；映象3则是为每个分片方式确定合适的存储位置（虚拟，类似数据库1、2、3…）；映象4将分布模式中的虚拟存储位置映射到现实中的物理存储位置。</p><p>综上，模式是<strong>“原则/方法/定义”</strong>的集合，映象是集合间的映射关系，通常是在下级映象中进行选择，然后返回结果由上级映象使用。</p></blockquote><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul><li><p>水平：关系模式不变，将元组进行分割。</p></li><li><p>垂直：对属性集合进行划分</p><blockquote><p>为了具有可复原性，<strong>通常</strong>让各个片段都具有原关系的码。（不是必要条件）</p></blockquote></li><li><p>导出：利用其他关系模式的属性对某一关系进行水平分片。</p><blockquote><p>连表后选择，然后再去掉多余属性。</p></blockquote></li><li><p>混合</p></li></ul><h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5><ul><li>完全性：各个片段的并需要涵盖全局关系的所有信息</li><li>不相交性</li><li>可重构性：片段可以重构全局关系<ul><li>水平：并</li><li>垂直：自然连接</li></ul></li></ul><h4 id="分布透明性"><a href="#分布透明性" class="headerlink" title="分布透明性"></a>分布透明性</h4><ul><li><strong>分片</strong>透明性（分片模式）</li><li><strong>位置</strong>透明性（分布模式）</li><li>局部数据模型透明性（局部概念模式）：用户/应用程序不关心节点的DBMS类型（使用统一的查询语言）</li></ul><h4 id="DDBMS"><a href="#DDBMS" class="headerlink" title="DDBMS"></a>DDBMS</h4><ul><li>LDBMS：场地自治，执行局部应用及全局查询的<strong>子查询</strong></li><li>GDBMS：提供分布透明性，保证数据库的全局一致性。<ul><li>协调全局事务的执行</li><li>协调局部DBMS</li><li>并发控制</li><li>更新同步</li><li>全局恢复</li></ul></li><li>GDD<ul><li>全局概念模式、分片模式、分布模式、各级映象</li><li>用户权限定义</li><li>完整性约束条件</li></ul></li><li>CM：通信管理</li></ul><h5 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5><ul><li>全局控制<strong>集中</strong>：GDD和GDBMS集成在一起<ul><li>控制简单</li><li>易形成<strong>性能</strong>瓶颈</li><li>可靠性低</li></ul></li><li>全局控制<strong>分散</strong><ul><li>完全：GDBMS和GDD分布在<strong>每个</strong>节点上<ul><li>节点独立</li><li>自治性强</li><li>控制复杂</li></ul></li><li>部分：GDBMS和GDD分布在<strong>某些</strong>节点上</li></ul></li><li>同构型：各个节点的DBMS相同</li><li>异构型：各个节点的DBMS不同</li></ul><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><h5 id="分类-5"><a href="#分类-5" class="headerlink" title="分类"></a>分类</h5><ul><li>局部</li><li>远程</li><li>全局</li></ul><blockquote><p>局部和远程查询<strong>只</strong>涉及<strong>单个</strong>节点，全局查询涉及<strong>多个</strong>节点。</p></blockquote><h5 id="处理-1"><a href="#处理-1" class="headerlink" title="处理"></a>处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">查询分解--&gt;确定操作次序</span><br><span class="line">确定操作次序--&gt;选择操作执行方法</span><br></pre></td></tr></table></figure><h5 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h5><p>查询开销=I/O代价+CPU代价+通信代价（主要）</p><ul><li><p>分类</p><ul><li><p>分布优化（<strong>更重要</strong>）</p><ul><li><p>传送时间T=总传输延迟（由网络本身决定）+总数据量/传输速度</p><blockquote><p>问答方式中通常会<strong>忽略</strong>传送时间而<strong>只考虑</strong>传输延迟</p></blockquote></li></ul></li><li><p>局部优化</p></li></ul></li><li><p>目标：减小通信代价</p><blockquote><p>通信代价通常来自于不同节点间的<strong>连接和并</strong>操作</p></blockquote></li><li><p>技术</p><ul><li><p>半连接：在连接之前，先对其中某个关系进行所需属性的投影，然后再进行连接。</p><p>$R_3=R_1{\ltimes}_{A=B} R_2=R_1{\bowtie}_{A=B}(\Pi_B(R_2))$</p><ul><li><p>得到的结果是<strong>没有投影</strong>的关系$R_1$的子集</p><blockquote><p>从$R_1$中提取出了<strong>有用</strong>的元组</p></blockquote></li><li><p>$R_1\bowtie R_2=(R_1\ltimes R_2)\bowtie R_2$</p><blockquote><p>连接=半连接+连接=投影+连接+连接</p></blockquote></li><li><p>在使用优化技术之前，需要进行估算。</p></li></ul></li></ul></li><li><p>分布事务处理</p><ul><li><p><code>NewSQL</code></p></li><li><p>原子性：全局事务的子事务要么一起提交，要么全部回滚。</p></li><li><p>可串行性：多用户系统</p></li><li><p>恢复：两段提交协议</p><ul><li>局部事务管理<ul><li>协调者（一个）</li><li>参与者（多个）</li></ul></li><li>第一阶段：协调者征求意见做决定</li><li>第二阶段：参与者执行决定</li></ul></li><li><p>并发控制：封锁技术</p><ul><li><p>写操作需要申请<strong>所有</strong>副本的<code>X</code>锁，读操作<strong>只要</strong>申请一个副本的<code>S</code>锁。</p></li><li><p>读/写操作均对<strong>大多数</strong>副本申请<code>X</code>和<code>S</code>锁</p><blockquote><p>大多数指“<strong>大于</strong>一半”，所以上锁时一定会出现相交情况。</p></blockquote></li><li><p>设置主副本，所有读/写都需要对主副本上锁。</p></li><li><p>全局死锁解决（<strong>两个及以上</strong>场地发生死锁）</p><ul><li>检测及解除</li><li>预防</li></ul></li></ul></li></ul></li></ul><h2 id="Reference-9"><a href="#Reference-9" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2020 BUAA Database course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Backend" scheme="http://yoursite.com/categories/Backend/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/C++%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/C++%20Learning%20Note/</id>
    <published>2021-06-23T12:34:24.552Z</published>
    <updated>2021-06-23T12:37:05.831Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全文共<code>2981</code>字，为暑期C++学习记录，推荐按照顺序阅读。</strong></p><a id="more"></a><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li><p>每个<code>.h</code>文件智能定义一个<code>class</code></p></li><li><p>函数主体放在<code>.cpp</code>中</p></li><li><p><code>.h</code>文件需要使用标准头文件格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NAME_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NAME_H_</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul><li>变量是对象自己的</li><li>函数是类的<ul><li>隐藏了<code>this</code>参数将对象传进类的函数</li></ul></li><li>私有变量通过<code>::</code>也<strong>不能</strong>访问</li></ul><h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><p>创建对象时使用</p></li><li><p>和类同名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    A(); <span class="comment">// no return type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A()</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>没有参数</strong>的构造函数<strong>都叫</strong><code>default constructor</code>，不一定是编译器默认创造的。</p></blockquote></li><li><p>参数化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree::Tree(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">t</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass c1;<span class="comment">//表示使用不带参数的构造函数，或者有默认参数值的构造函数。</span></span><br><span class="line"><span class="function">MyClass <span class="title">c2</span><span class="params">()</span></span>;<span class="comment">//不会调用无参构造函数,各种情况下该处是声明一个返回值为MyClass类型的函数而已</span></span><br><span class="line"><span class="function">MyClass <span class="title">c3</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//调用参数为int的构造函数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li><p>销毁对象时使用</p><blockquote><p>对象的生存周期是<strong>大括号</strong></p></blockquote></li><li><p>无参数，在构造函数前加一个<code>~</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> height; <span class="comment">// default to be private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> initialHeight);</span><br><span class="line">    ~Tree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> years)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new&amp;delete"></a>new&amp;delete</h2><ul><li><p>delete不能操作没有new的空间</p></li><li><p>delete对同一个对象不能连续使用两次</p></li><li><p>delete[]和new[]需要<strong>成对</strong>使用</p></li><li><p>在delete之前最好判断一下是否是空指针（是空指针<strong>大多数情况</strong>也安全）</p></li><li><p>new创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------对于new关键字加括号和不加括号的区别---</span></span><br><span class="line"><span class="comment">1.对于自定义类型来说没有区别，都是使用默认构造函数</span></span><br><span class="line"><span class="comment">2.对于内置类型来说加括号会初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">MyClass *c4 = <span class="keyword">new</span> MyClass();</span><br><span class="line">c4-&gt;MyMethod();</span><br><span class="line">MyClass *c5 = <span class="keyword">new</span> MyClass(<span class="number">1</span>);</span><br><span class="line">c5-&gt;MyMethod();</span><br><span class="line">MyClass *c6 = <span class="keyword">new</span> MyClass;</span><br><span class="line">c6-&gt;MyMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *pint1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> *pint2 = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// *pint2 is 0</span></span><br><span class="line"><span class="keyword">int</span> *pint3 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// *pint3 is a random number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*pint1&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint2&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint3&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><code>new</code>创建对象需要<strong>指针</strong>接收</li><li><code>new</code>创建对象需要<code>delete</code>销毁</li><li><code>new</code>创建的对象在<strong>堆</strong>上，不使用<code>new</code>创建的对象在<strong>栈</strong>上。</li></ul></li></ul><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul><li><p><code>private</code>的变量在类的函数中可以被<strong>其他的对象</strong>访问，即同类对象可以相互访问私有变量。</p><blockquote><p><code>private</code>只在编译时有限制</p></blockquote></li><li><p>使用<code>friend</code>授权某些函数访问<strong>私有变量</strong></p></li><li><p>class的访问属性默认为<code>private</code>，struct默认为<code>public</code>.</p></li></ul><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> x, y;</span><br><span class="line">    Point(<span class="keyword">float</span> xa = <span class="number">0.0</span>, <span class="keyword">float</span> ya = <span class="number">0.0</span>): x(xa), y(ya)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>初始化列表在构造函数<strong>之前</strong>执行</p></li><li><p>和构造器赋值的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(String s): name(s)&#123;&#125;</span><br><span class="line">Student::Student(String s) &#123;name = s;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>推荐使用初始化列表进行对象的初始化。</p><p>在构造器赋值时，如果有一个成员变量是自定义类的对象，并且该类没有无参数构造函数，那么在构造函数中对该对象赋值时就会报错。（因为在<strong>构造函数</strong>中，会默认调用无参数构造函数）</p></blockquote></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>名称隐藏：当子类覆写父类函数时，所有的父类函数都会被子类屏蔽。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> ii) : i(ii) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : A(<span class="number">15</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.print(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>b</code><strong>没有</strong>无参数的<code>print</code>方法</p></blockquote></li></ul><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><ul><li><p>只能在<code>.h</code>（函数声明）时设置默认值，<strong>不可以</strong>在函数定义处使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j=<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>和Python不同的是，修改<code>j</code>时直接传数据即可，<strong>不需要</strong>写参数名称。</p></li><li><p>尽量<strong>不使用</strong>默认参数值</p></li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li><p>在调用的地方直接展开，减少调用函数时的栈操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b = f(a); <span class="comment">// int b = a * 2;</span></span><br><span class="line">    <span class="keyword">int</span> c = f(<span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内联函数的定义<strong>不在</strong><code>.cpp</code>文件中，而应该和声明<strong>都放在</strong><code>.h</code>中</p><blockquote><p>因为<code>inline</code>告诉编译器这是个<strong>函数声明</strong>而不是定义，在<strong>使用函数</strong>的地方再进行展开。</p></blockquote></li><li><p>当<code>inline</code>函数太大时（例如递归），编译器可能会拒绝展开。</p></li><li><p>类的<code>.h</code>文件中直接写出函数体的函数<strong>都是</strong>内联函数，在<code>.h</code>中也可以单独声明内联函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is a inline function defined in header file."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环体中的<strong>小函数</strong>推荐使用内联函数</p></li><li><p>和宏相比，内联函数可以做类型检查，更加安全。</p></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li><p><strong>不可修改</strong>机制是在编译时确定的，因此是编译器进行检查。</p><ul><li><p>编译时确定的值可以用来声明数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_size = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> finalGrade[class_size];</span><br></pre></td></tr></table></figure></li><li><p><code>const</code>在<code>*</code>前后对指针的影响</p><ul><li><p>在<code>*</code>前：<strong>对象</strong>是<code>const</code>（<strong>不能</strong>通过该指针改变对象，但是<strong>可以</strong>通过其他指针）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;a;</span><br><span class="line">*p2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person *p = &amp;p1;</span><br><span class="line">Person <span class="keyword">const</span> *p = &amp;p1;</span><br></pre></td></tr></table></figure></li><li><p>在<code>*</code>后：<strong>指针</strong>是<code>const</code>（<strong>不能</strong>改变该指针的指向）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *<span class="keyword">const</span> p = &amp;p1;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>普通指针<strong>不能</strong>指向<code>const</code>变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">3</span>;</span><br><span class="line">ip = &amp;ci; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>不可</strong>修改对象的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::get_day</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    day++; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在声明和定义处要重复<code>const</code></p></li><li><p>便于编译器对<code>const</code>对象调用方法时进行安全检查</p></li><li><p>本质是将<code>this</code>设置为<code>const</code></p></li><li><p><code>const</code>可以实现重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : i(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    ~A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f() with const"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> A a;</span><br><span class="line">    a.f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>const</code>对象<strong>只能</strong>调用<code>const</code>函数</li></ul></li></ul></li><li><p><code>const</code>成员变量必须在<strong>初始化列表</strong>中初始化（<strong>不可以</strong>在构造函数中进行）</p></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p>一种访问对象的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;p = c;</span><br></pre></td></tr></table></figure><ul><li>引用<strong>必须</strong>初始化（成员变量、函数参数除外）</li><li>引用相当于是<strong>别名</strong></li><li>引用的目的就是为了减少代码中的<code>*</code></li></ul></li><li><p>引用和指针的比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">(<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>不同于</strong>指针，引用在执行过程中<strong>不能</strong>改变对象。</p></li><li><p>引用<strong>不能</strong>是<code>NULL</code></p></li><li><p>传入的<code>x</code>在两种情况中<strong>都会</strong>被修改</p></li><li><p>传入函数的参数<strong>不是指针</strong>时，也<strong>可能</strong>被修改。</p></li><li><p>引用是由<code>const</code>指针实现的</p></li><li><p>引用的引用实际上<strong>不存在</strong>，只是改变了引用的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> &amp;a = x;</span><br><span class="line"><span class="keyword">int</span> &amp;b = y; </span><br><span class="line"></span><br><span class="line">b = a; <span class="comment">// y = x, but not b refer to a.</span></span><br></pre></td></tr></table></figure><blockquote><p>Java的引用实际上对应C++的指针</p></blockquote></li><li><p>引用的指针可以存在，但是指针的引用不存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;*p1; <span class="comment">// illegal</span></span><br><span class="line"><span class="keyword">int</span> *&amp;p2; <span class="comment">// reference to pointer</span></span><br></pre></td></tr></table></figure><blockquote><p>引用<strong>没有</strong>地址</p></blockquote></li><li><p><strong>没有</strong>引用数组（因为引用并不是实体，<strong>没有</strong>地址）</p></li></ul></li><li><p>引用作为成员变量时，需要在初始化列表中写上这个引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> &amp;b): a(b) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为返回值时，最好<strong>不是</strong>局部变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> &amp;<span class="title">subscript</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为函数参数传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">int</span>&amp;z)</span></span>&#123;</span><br><span class="line">    z *= <span class="number">5</span>; <span class="comment">// OK</span></span><br><span class="line">    y += <span class="number">8</span>; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>传<strong>非</strong><code>const</code>引用时<strong>不可以</strong>是算式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li><p>动态调用的方法需要使用<code>virtual</code>关键字声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在父类中声明一次<code>virtual</code>后，所有子类中的函数都是虚函数，可以省略<code>virtual</code>，但是推荐加上。</li><li>所有含虚函数的类的对象都会增加一个<code>vptr</code>指针，指向类自己的<code>vtable</code>，存储了<strong>该类</strong>所有的虚函数。</li></ul></li><li><p>继承关系对象的赋值<strong>不改变</strong><code>vtable</code>（与指针赋值不同）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a = b;</span><br><span class="line">a.f(); <span class="comment">// A's f() instead of B's</span></span><br></pre></td></tr></table></figure></li><li><p>析构函数需要是<code>virtual</code>的</p></li><li>多态需要使用指针实现，<strong>不能</strong>通过<code>.</code>实现。</li></ul><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><ul><li><p>编译器默认的拷贝构造是浅拷贝</p><ul><li><p>当字符串是<code>char *</code>时，内存会被<code>delete</code>两次，这样会发生错误。因此Cpp通常使用<code>string</code>类来定义字符串。</p><blockquote><p>尽管是浅拷贝，标准库中的类<strong>也不会</strong>出现内存问题。</p></blockquote></li></ul></li><li><p>拷贝构造和<strong>初始化</strong>的形式相同，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = p;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>一个类必须声明的三个函数</p><ul><li><p>默认构造函数（参数列表为空）</p></li><li><p><code>virtual</code>的析构函数</p></li><li><p>自定义的拷贝构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(<span class="keyword">const</span> ClassName &amp;p) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>Cpp保证对象只被构造一次</li><li><code>static</code>让对象变成全局的</li></ul><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><ul><li><p>通过<code>static</code>成为和对象<strong>无关</strong>的变量</p></li><li><p>类中只是<strong>声明</strong>，需要单独定义后才能使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;i = <span class="number">0</span>;&#125; <span class="comment">// A():i(0) &#123;&#125; is illegal</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::i; <span class="comment">// not static int A::i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a, b;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">    b.print();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化列表只能对<strong>非静态</strong>成员变量使用</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>调用<ul><li>对象：<code>a.f()</code></li><li>类：<code>A::f()</code></li></ul></li><li>在静态函数中<strong>没有</strong><code>this</code>参数</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>在Cpp中，几乎所有的运算符都可以被重载，除了<code>./.*/::/?:</code>.</li><li>重载只能在类/枚举类发生</li><li>优先级、运算格式<strong>不能</strong>改变。</li><li><p>关键字<code>operator</code>+运算符表示重载函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> *(...);</span><br><span class="line"><span class="keyword">const</span> String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String &amp;that);</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp;n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(i + n.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z = x + y; <span class="comment">// OK</span></span><br><span class="line">z = x + <span class="number">3</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + <span class="number">7</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + y; <span class="comment">// Error!</span></span><br><span class="line">z = x + <span class="number">3.5</span> <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li><p>设置全局函数解决<code>z=3+y</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(l.i + r.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一元运算符<strong>不需要</strong>设置参数，应该是成员的。</li><li><code>=/()/[]/-&gt;/-&gt;*</code><strong>必须是</strong>成员的</li><li>其他二元运算符<strong>最好是</strong>全局的</li></ul></li></ul></li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><p><code>+-*/%^&amp;|~</code>:<code>const T operatorX(const T &amp;l, const T&amp;r) const;</code></p></li><li><p><code>!/&amp;&amp;/||/&lt;/&lt;=/==/&gt;=/&gt;</code>:<code>bool operatorX(const T &amp;l, const T &amp;r) const;</code></p></li><li><p><code>[]</code>:<code>T &amp;T::operator[](int index);</code></p></li><li><p><code>++/--</code>：参数填一个占位<code>int</code>表示<strong>后置</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Integer &amp;<span class="keyword">operator</span>++() <span class="comment">// ++a</span></span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>++(<span class="keyword">int</span>) <span class="comment">// a++</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName a = b; <span class="comment">// copy construct</span></span><br><span class="line">a = b; <span class="comment">// assign</span></span><br></pre></td></tr></table></figure><ul><li><p>标准写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T &amp;T::<span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;r) &#123;</span><br><span class="line">        <span class="comment">// assign</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自己和自己相等进行赋值时，若成员中有指针，可能出现指针被改变后导致原来的内容无法访问，从而赋值失败的问题。</li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>禁止<strong>隐式</strong>类型转换：<code>explicit</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Two</span><span class="params">(class One &amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">one = two <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li>定义在<code>Two</code>中</li></ul></li><li><p>强制类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassName::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>定义在<code>One</code>中（不是<code>double</code>）</li><li><strong>没有</strong>返回类型</li></ul><blockquote><ul><li>两者地位相同，有哪种用哪种。</li><li>两种类型转换<strong>只能</strong>存在一种，除非第一种加了<code>explicit</code>.</li></ul></blockquote></li><li><p>不推荐使用默认转换，应该写成显式的转换方法<code>toXXX()</code>.</p></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>重用代码的一种方式，类似于Java中的泛型编程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // &lt;class Key, class Value&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">foo</span>(<span class="title">void</span>) &#123;</span><span class="comment">/* ... */</span>&#125;</span><br><span class="line">foo&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// type for T is int</span></span><br><span class="line">foo&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure></li><li><p>指定其他参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">bounds</span> = 100&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>继承</p><ul><li><p>模板之间不能继承，只能用来指定父类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> List&lt;A&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125; <span class="keyword">catch</span> (VectorIndexError &amp;e) &#123;</span><br><span class="line">    <span class="comment">// throw;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>不带对象的<code>throw</code>就是抛出<strong>原异常</strong></p></li><li><p><code>catch(...)</code>捕捉<strong>所有的</strong>异常，但是没有办法确定具体是哪一种。</p></li><li><p>函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a)</span> : <span class="title">throw</span><span class="params">(MathErr)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数抛异常之前，使用<code>delete this;</code>防止出现内存垃圾。</p></li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li><p>自定义类的输入流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>&gt;&gt;(istream &amp;is, T &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// construct obj</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul><li>包含常见的数据结构和算法<ul><li><code>Vector</code></li><li><code>List</code></li><li><code>Deque</code></li><li><code>Sets &amp; Maps</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;全文共&lt;code&gt;2981&lt;/code&gt;字，为暑期C++学习记录，推荐按照顺序阅读。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm Course Note</title>
    <link href="http://yoursite.com/2021/06/23/Algorithm%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/Algorithm%20Course%20Note/</id>
    <published>2021-06-23T12:31:27.612Z</published>
    <updated>2021-06-23T12:43:18.938Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2020 BUAA Algorithm course.</strong></p><a id="more"></a><h1 id="Chapter0-Introduction"><a href="#Chapter0-Introduction" class="headerlink" title="Chapter0 Introduction"></a>Chapter0 Introduction</h1><p>Total Count: <code>161</code> words</p><p>Preferred Reading Time: <code>3~5</code> minutes</p><h2 id="Syllabus"><a href="#Syllabus" class="headerlink" title="Syllabus"></a>Syllabus</h2><ul><li>Basics</li><li>Divide and Conquer</li><li>DP</li><li>Greedy</li><li>Graph</li><li>Hard Problems</li></ul><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ul><li>Design</li><li>Analyze</li></ul><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><ul><li>Computational Problem</li><li>Instance</li><li>Algorithm</li></ul><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><ul><li>Memory</li><li>Running time(focus of course)<ul><li>computer</li><li>implementation details</li><li>input(size etc.)</li></ul></li></ul><h3 id="Machine-independent-running-time"><a href="#Machine-independent-running-time" class="headerlink" title="Machine-independent running time"></a>Machine-independent running time</h3><ul><li>depend on quantity of <strong>primitive operations</strong><ul><li>addition</li><li>multiplication</li><li>comparison</li></ul></li><li>$T(n)$:denote the running time of n-size input<ul><li>n<ul><li>sorting: items to be sorted</li><li>graph: vertices and edges</li></ul></li></ul></li><li>Best Case: an instance for given size <code>n</code> results in the most efficient situation<ul><li>eg. A sorted list for insertion sort</li></ul></li><li>Worst Case<strong>(Mostly Used)</strong>: opposite to Best Case<ul><li>eg. A rev-sorted list for insertion sort</li></ul></li><li>Average Case: based on probability of all situations </li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li><p>$Θ(n)$ notation</p><ul><li><p>a supplement of <code>T(n)</code> notation</p><blockquote><p>$T(n)$ is exact while $Θ(n)$ is approximate</p></blockquote></li><li><p>eg. Mergesort</p><p>$T(n) = 2T(n/2) + Θ(n)\ (n&gt;1)$</p><p>$T(n)=Θ(1)\ (n=1)$</p><blockquote><p>Recursive notation</p></blockquote></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter1-Asymptotic-Notations-And-Recurrence"><a href="#Chapter1-Asymptotic-Notations-And-Recurrence" class="headerlink" title="Chapter1 Asymptotic Notations And Recurrence"></a>Chapter1 Asymptotic Notations And Recurrence</h1><p>Total Count: <code>291</code> words</p><p>Preferred Reading Time: <code>5~10</code> minutes</p><h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><h3 id="Big-Oh"><a href="#Big-Oh" class="headerlink" title="Big-Oh"></a>Big-Oh</h3><ul><li><p><strong>Upper</strong> bounds</p></li><li><p>$f(n)=O(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\leq{c*g(n)}\ (c&gt;0, n&gt;n0)$</p></li><li><p>Example</p><ul><li>$sin(n)=O(1)$</li><li>$log(n!)=O(nlog(n))$</li><li>$\sum{1/n}=O(log(n))$</li></ul></li><li><p>$log_{b_1}(n)=O(log_{b_2}(n))$</p><blockquote><p>Bases in <code>O</code> notation are usually omitted.</p></blockquote></li></ul><h3 id="Big-Omega"><a href="#Big-Omega" class="headerlink" title="Big-Omega"></a>Big-Omega</h3><ul><li><p><strong>Lower</strong> bounds</p></li><li><p>$f(n)=Ω(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\geq{c*g(n)}\ (c&gt;0,n&gt;n0)$</p></li><li><p>Example</p><ul><li><p>$\sum{1/n}=Ω(log(n))$</p><blockquote><p><code>log(n)</code> is both bounds above and below, the difference is coefficient.</p></blockquote></li></ul></li></ul><h3 id="Big-Theta"><a href="#Big-Theta" class="headerlink" title="Big-Theta"></a>Big-Theta</h3><ul><li><strong>Tight</strong> bounds</li><li>$f(n)=Θ(g(n))$ when $f(n)=O(g(n))$ and $f(n)=Ω(g(n))$</li></ul><h2 id="Recurrence"><a href="#Recurrence" class="headerlink" title="Recurrence"></a>Recurrence</h2><script type="math/tex; mode=display">\begin{cases} T(n)=3T(n/4)+n^2&(n>1) \\ 1&(n=1) \tag{1} \end{cases}</script><ul><li>$n^2$ is workload of first level</li></ul><h3 id="Recursion-tree-Method"><a href="#Recursion-tree-Method" class="headerlink" title="Recursion-tree Method"></a>Recursion-tree Method</h3><p>$T(n) \leq n^2+3/16n^2+(3/16)^2n^2 + … =O(n^2)$</p><h3 id="Substitution-Method"><a href="#Substitution-Method" class="headerlink" title="Substitution Method"></a>Substitution Method</h3><p>Prove $T(n) \leq cn^2$.</p><p>$T(n)=3T(n/4)+n^2 \le3c(n/4)^2 =cn^2-(13c/16-1)n^2 \leq cn^2 (c\geq16/13)$</p><p>So when $c\geq16/13$, we can prove $T(n)\leq cn^2$.</p><blockquote><p>Since $T(n) \geq n^2$, then $Θ(n)=Ω(n)=O(n)$.</p></blockquote><h3 id="Master-Method-and-Master-Theorem"><a href="#Master-Method-and-Master-Theorem" class="headerlink" title="Master Method and Master Theorem"></a>Master Method and Master Theorem</h3><p>If $T(n)=aT(upper(\frac{n}{b}))+O(n^d)(a&gt;0,b&gt;1,d\geq0)$, then</p><script type="math/tex; mode=display">T(n)=\begin{cases} O(n^d)&d>lob_ba,b^d>a \\ O(n^dlogn)&d=lob_ba,b^d=a \\ O(n^{log_b{a}})&d<lob_ba,b^d<a \end{cases}</script><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter2-Divide-and-Conquer"><a href="#Chapter2-Divide-and-Conquer" class="headerlink" title="Chapter2 Divide and Conquer"></a>Chapter2 Divide and Conquer</h1><p>Total Count: <code>559</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><h2 id="MCS"><a href="#MCS" class="headerlink" title="MCS"></a>MCS</h2><ul><li>Maximum Contiguous Subarray<ul><li>Find the span of years in which the company earned most</li></ul></li></ul><h3 id="Exhaustive-Search"><a href="#Exhaustive-Search" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_Val</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^3)$</li></ul><h3 id="Data-Reuse"><a href="#Data-Reuse" class="headerlink" title="Data-Reuse"></a>Data-Reuse</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_val</span></span><br></pre></td></tr></table></figure><ul><li>$V(i,j)=V(i,j-1)+A[j]$</li><li>$O(n^2)$</li></ul><h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input A[s...t]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s == t:</span><br><span class="line">    retun A[s] <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    MCS(A, s, mid) <span class="comment"># T(n/2)</span></span><br><span class="line">    MCS(A, mid, t) <span class="comment"># T(n/2)</span></span><br><span class="line">    <span class="comment"># find the max_val of cut position containing A[mid] and A[mid+1]</span></span><br></pre></td></tr></table></figure><ul><li>Be cautious the array may be at the cut position.</li><li>When finding the <code>max_val</code> containing <code>A[mid]</code> and <code>A[mid+1]</code>, we can do it from <code>mid</code> to <code>0</code>.</li><li>$T(n)=2T([n/2])+n$</li><li>$O(nlogn)$</li></ul><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, temp, ans, temp_sum;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">    temp_sum = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// When temp_sum &lt; 0, it means last temp &lt; 0, and last temp has already been compared with ans to decide whether to update the start point of the sub-array.</span></span><br><span class="line">        temp_sum = max(<span class="number">0</span>, temp_sum); </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        temp_sum += temp;</span><br><span class="line">        ans = max(temp_sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Counting-inversions"><a href="#Counting-inversions" class="headerlink" title="Counting inversions"></a>Counting inversions</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># count inversion</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^2)$</li></ul><h3 id="Merge-Sort-Idea"><a href="#Merge-Sort-Idea" class="headerlink" title="Merge Sort Idea"></a>Merge Sort Idea</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(L) == <span class="number">0</span>:</span><br><span class="line">    reutrn <span class="number">0</span>, L</span><br><span class="line">cnt_a, A = sort_and_count(L[l, mid])</span><br><span class="line">cnt_b, B = sort_and_count(L[mid+<span class="number">1</span>, r])</span><br><span class="line">cnt_c, L = merge_and_count(L[l, mid], L[mid+<span class="number">1</span>, r])</span><br><span class="line"><span class="keyword">return</span> cnt_a + cnt_b + cnt_c, L</span><br></pre></td></tr></table></figure><ul><li>Increase inversion count when merging sorted two list.</li><li>$O(nlogn)$</li></ul><h2 id="Polynomial-Multiplication"><a href="#Polynomial-Multiplication" class="headerlink" title="Polynomial Multiplication"></a>Polynomial Multiplication</h2><h3 id="Brute-Force-1"><a href="#Brute-Force-1" class="headerlink" title="Brute Force"></a>Brute Force</h3><ul><li>compute all coefficients and merge them at last<ul><li>multiplications:$O(n^2)$</li><li>addition:$O(n^2)$</li><li>complexity:$O(n^2)$</li></ul></li></ul><h3 id="Divide-and-Conquer-1"><a href="#Divide-and-Conquer-1" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><ul><li>extract $x^{\frac{n}{2}}$ to make size <code>n</code> problem into $2*2$ problem</li><li>$O(n^2)$</li></ul><h4 id="Improve"><a href="#Improve" class="headerlink" title="Improve"></a>Improve</h4><ul><li>We need $A_0B_1+A_1B_0$ instead of $A_0B_1$and$A_1B_0$.<ul><li>$\begin{cases} U=A_0B_0 \\ V=A_0B_1 \\ W=A_1B_0 \\ Z=A_1B_1\end{cases}$</li><li>Take $Y=(A_0+A_1)(B_0+B_1)$, then we can get $A_0B_1+A_1B_0=Y-U-Z$.</li><li>$T(n)=\begin{cases} 3T(n/2) + n&amp;(n&gt;1) \\ 1&amp;(n=1) \end{cases}$</li></ul></li></ul><h2 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h2><ul><li>partition with pivot as a benchmark</li><li>place pivot into right place</li><li>above can be a recursive process</li><li>$O(nlogn)$: the average complexity</li></ul><h3 id="Improve-1"><a href="#Improve-1" class="headerlink" title="Improve"></a>Improve</h3><ul><li><p>The normal complexity of quicksort is $O(n^2)$ because the array may be partially sorted.</p><p>$T(n)=T(0)+T(n-1)+O(n)$</p><blockquote><ul><li>The complexity of quick sort is $O(n^2)$ instead of $O(nlogn)$.</li><li>$O(n)$ comes from the count of key comparisons.</li></ul></blockquote></li><li><p>Adopt random pivot to get randomized partition</p><ul><li>Swap random position with the last position for reuse the partition function</li><li>This action can validly lower the probability to encounter unlucky array partition</li></ul></li></ul><h4 id="Expected-Case"><a href="#Expected-Case" class="headerlink" title="Expected Case"></a>Expected Case</h4><ul><li>Analysis for randomization algorithm</li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter3-Dynamic-Programming"><a href="#Chapter3-Dynamic-Programming" class="headerlink" title="Chapter3 Dynamic Programming"></a>Chapter3 Dynamic Programming</h1><p>Total Count: <code>906</code> words</p><p>Preferred Reading Time: <code>20~25</code> minutes</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><p>Similar to Divide and Conquer, but when subproblems overlap, DP is preferred.</p><blockquote><ul><li>Recurrence is from top to bottom, while DP is from bottom to top.</li><li>Recurrence is efficient when subproblems are independent, while DP requires overlapped subproblems.</li><li>DP trades space for time.</li></ul></blockquote></li><li><p>DP is used for <strong>optimization</strong> problems</p></li><li><p><strong>Core: As long as all subproblems are optimized, the merged problem can be optimized.</strong></p><blockquote><p>Prerequisite: All subproblems cannot be completely individual, and in other words,  they have to affect each other’s solution.</p></blockquote></li></ul><h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ul><li>model subproblems</li><li>establish value connections between subproblems</li><li>bottom-up computation to get result</li><li>trace to get format answer</li></ul><h2 id="0-1-knapsack"><a href="#0-1-knapsack" class="headerlink" title="0-1 knapsack"></a>0-1 knapsack</h2><h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h3><ul><li>try all $2^n$ methods and compare them.</li></ul><h4 id="Simple-Recursion"><a href="#Simple-Recursion" class="headerlink" title="Simple Recursion"></a>Simple Recursion</h4><ul><li><p>$V[i,w]=max(V[i-1,w], v_i+V[i-1,w-w_i])$</p><ul><li><p>$V[i,w]$ denote any subset of items $\{1, 2, 3, …i\}$ value sum with <strong>at most</strong> weight $w$.</p><blockquote><p>Real weight may be smaller than $w$.</p></blockquote></li></ul></li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li>State of subproblems<ul><li>establish formal description for problem requirements</li></ul></li><li><p>Relate a problem to its subproblems</p><ul><li>establish recurrence equation</li><li>set boundary cases</li></ul></li><li><strong>Bottom-up</strong> computation of $V[i,w]$</li><li>initialize boundary cases<ul><li>Save trace when calculating $V[i,j]$, and till the end we can use recorded result to get $V[i,w]$.</li></ul></li><li>Add <code>keep[i,w]</code> to record for a specific w, whether an item is taken.</li></ul><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>DP save duplicate computation.</li><li>DP trades space for time.</li><li>Strategy<ul><li>Structure</li><li>Recursion</li><li>Bottom-up computation</li><li>Construct optimal solution: trace the table</li></ul></li></ul><h2 id="Rod-Cutting"><a href="#Rod-Cutting" class="headerlink" title="Rod Cutting"></a>Rod Cutting</h2><h3 id="brute-force-1"><a href="#brute-force-1" class="headerlink" title="brute force"></a>brute force</h3><ul><li>$r_n=max(p_n,r_1+r_{n-1},…,r_{n-1}+r_1)$<ul><li>$r_n$ is the optimal revenue of length <code>n</code> rod.</li><li>$p_n$ is the price of length <code>n</code> rod.</li><li>simpler definition:  $r_n=max_{1\leq i \leq n}(p_i+r_{n-i})$</li></ul></li><li>Even recurrence equation is established, the recursive method still contains duplicate computation.</li></ul><h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><ul><li>one-dimension array <code>r[]</code> to store max revenue of length from 0 to n.</li><li><code>r[i] = max(r[i], p[j] + r[i - j])</code></li></ul><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>$O(n^2)$</li></ul><h2 id="Chain-Matrix-Multiplication"><a href="#Chain-Matrix-Multiplication" class="headerlink" title="Chain Matrix Multiplication"></a>Chain Matrix Multiplication</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>C(<code>p*q</code> and <code>q*r</code> matrix to multiply, each entry takes $O(q)$ to calculate): $O(pqr)$</p></li><li><p>$A_1A_2A_3=(A_1A_2)A_3=A_1(A_2A_3)$</p><blockquote><p>cause of different complexity</p></blockquote></li></ul><h3 id="Exhaustive-Search-1"><a href="#Exhaustive-Search-1" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><ul><li>$\Omega(\frac{4^n}{n^{\frac{3}{2}}})$</li></ul><h3 id="DP-2"><a href="#DP-2" class="headerlink" title="DP"></a>DP</h3><p>for matrix $A_i$, it has dimension of $p_{i-1}*p_i$.</p><ul><li><p>model subproblems</p></li><li><p>establish <strong>value</strong> connection between subproblems</p><p>$m[i,j]=\begin{cases}0, &amp; i=j\\min_{i\leq k&lt;j}(m[i,k]+m[k+1,j])+p_{i-1}p_kp_j, &amp; i&lt;j\end{cases}$</p></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$<ul><li>Outlying loop layer is for traverse multiply-array’s length from 2 to n.</li></ul></li><li>space: $O(n^2)$</li></ul><h2 id="Longest-Common-Subsequence-Problem"><a href="#Longest-Common-Subsequence-Problem" class="headerlink" title="Longest Common Subsequence Problem"></a>Longest Common Subsequence Problem</h2><h3 id="Basic-Concepts-1"><a href="#Basic-Concepts-1" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>subsequence: not necessarily continuous</li><li>substring: <strong>must</strong> be continuous</li></ul><h3 id="DP-3"><a href="#DP-3" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ the length of LCS in $A[1..i]$ of $A[1..m]$ and $B[1..j]$ of $B[1..n]$</p><ul><li>$d_{i,j}=\begin{cases} 0, &amp; i,j=0 \\ d_{i-1,j-1}+1, &amp; x_i=y_j \\ max(d_{i-1.j},d_{i,j-1}), &amp; x_i\neq y_j\end{cases}$</li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(mn)$</p></li><li><p>space: $O(n^2)$</p><ul><li><p>optimization for solution matrix: only save two rows</p><blockquote><p>The trace matrix needs totally preserving.</p></blockquote></li></ul></li><li><p>Different trace may lead to different subsequence.</p></li></ul><h2 id="Longest-Common-Substring-Problem"><a href="#Longest-Common-Substring-Problem" class="headerlink" title="Longest Common Substring Problem"></a>Longest Common Substring Problem</h2><h3 id="Basic-Concepts-2"><a href="#Basic-Concepts-2" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>Different from subsequence, substring must be contiguous.</li></ul><h3 id="DP-4"><a href="#DP-4" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ to be the length of the longest common substring of $X[1..i]$ and $Y[1..j]$</p><ul><li>$d_{i,j}=\begin{cases} d_{i-1,j-1}+1, &amp;x_i=y_j\\ 0, &amp;x_i\neq y_j\end{cases}$</li><li>$maxSubstring(X,Y)=max(d_{i,j})$</li></ul><h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Without saving DP direction, we can still trace the whole substring by knowing the <strong>end index</strong> of substring $(X_i|Y_j)$ and its length $d_{i,j}$.</li><li>time: $O(mn)$</li><li>Subsequence algorithm can be used to solve this problem by only outputting diagonal $LU$ elements.</li></ul><h2 id="Minimum-Edit-Distance"><a href="#Minimum-Edit-Distance" class="headerlink" title="Minimum Edit Distance"></a>Minimum Edit Distance</h2><h3 id="Basic-Concepts-3"><a href="#Basic-Concepts-3" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><ul><li>“Spell Correction” in search engine</li><li>Computational Biology such as comparing DNA</li><li>Machine Translation, Information Extraction, Speech Recognition etc.</li></ul><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>calculate the smallest number of edit operations</p><ul><li><p>edit operations</p><ul><li>insertion: add a letter</li><li>deletion: delete a letter</li><li>substitution: replace a character</li></ul><blockquote><p>All operations’ cost is usually (throughout the course) counted as <code>1</code>, but the cost can be adjusted.</p></blockquote></li></ul><h3 id="DP-5"><a href="#DP-5" class="headerlink" title="DP"></a>DP</h3><p>define $D[i,j]$ the edit distance of $X[1..i]$ and $Y[1..j]$</p><ul><li>$D[i,j]=min\begin{cases} D[i-1,j]+1, &amp;delete\ X[i] \\ D[i,j-1]+1, &amp;insert\ Y[j] \\ D[i-1,j-1] +0, &amp;X[i]=Y[j] \\ D[i-1,j-1]+1, &amp;X[i] \neq Y[j] \end{cases}$</li></ul><blockquote><ul><li>All edit operations take place on $X[1..i]$.</li><li>When operation cost changes, the constant in equation will be changed as well.</li><li>When the problem can be depicted as a state graph, <strong>shortest path algorithm</strong> can be used to solve the problem. In other words, the problems degrades to shortest path problem.</li></ul></blockquote><h3 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>When tracing the edit process, <code>L</code>/<code>U</code>/<code>LR</code> stand for four different operations(<strong>including doing nothing</strong>).</li><li>time: $O(mn)$</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>multi-stage strategy problem</li><li>DP is not a specific method but a way of thinking.</li><li>Key to DP: basic equations and boundary conditions</li><li>DP’s effect is also called Markova effect for there’s no effect on future events. </li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter4-Mid-term-Review"><a href="#Chapter4-Mid-term-Review" class="headerlink" title="Chapter4 Mid-term Review"></a>Chapter4 Mid-term Review</h1><p>Total Count: <code>413</code> words</p><p>Preferred Reading Time: <code>15~20</code> minutes</p><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2><h3 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h3><ul><li><p>Any comparison-based sorting algorithm requires $\Omega(nlogn)$ comparisons.</p><blockquote><p>proved by binary decision tree</p></blockquote></li><li><p>Thus, in order to break the lower bound, we should take other methods except comparison.</p></li><li><p>counting sort isn’t based on comparison.</p></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>When inputting numbers, count occurrences of all numbers.</p><blockquote><p>counting array’s length is based on boundary value of inputting array.</p></blockquote></li><li><p>Fill sorted array with the counting array.</p></li></ul><h3 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n)$</li><li>counting sort is a <strong>stable</strong> sort as long as the final filling loop is from raw array’s <strong>end</strong> to its <strong>head</strong>.</li></ul><h2 id="Randomized-Selection-Problem"><a href="#Randomized-Selection-Problem" class="headerlink" title="Randomized Selection Problem"></a>Randomized Selection Problem</h2><h3 id="Basic-Concepts-4"><a href="#Basic-Concepts-4" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>find the <code>i-th</code> smallest element in a given array</li></ul><h3 id="brute-force-2"><a href="#brute-force-2" class="headerlink" title="brute force"></a>brute force</h3><ul><li>sort the array and index specific element</li></ul><h3 id="Partition-and-Selection"><a href="#Partition-and-Selection" class="headerlink" title="Partition and Selection"></a>Partition and Selection</h3><ul><li>The same as quick sort, part the array into two subarrays, and then make sure the index of selected separator number.</li><li>When the index is greater than <code>i</code>, handle another branch and abandon this one, vice versa.</li></ul><h3 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(n)$</p><blockquote><p>Different from quick sort’s $O(nlogn)$, this algorithm only deals with one branch of subproblems, while quick sort handles both branches.</p></blockquote></li></ul><h2 id="Optimal-Binary-Search-Tree"><a href="#Optimal-Binary-Search-Tree" class="headerlink" title="Optimal Binary Search Tree"></a>Optimal Binary Search Tree</h2><h3 id="Basic-Concepts-5"><a href="#Basic-Concepts-5" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>construct a BST with smallest search cost</p></li><li><p>height</p><ul><li>$node_height=max(children_height + 1)$</li><li>$leave_ height=0$</li><li>$tree_height=root_height$</li><li>$empty_tree_height = -1$</li></ul><blockquote><p><code>root_height</code> is the <strong>biggest</strong> one.</p></blockquote></li><li><p>$depth=H(root)-H(n)+1$</p><ul><li>$root_depth=1$</li></ul></li><li><p>balanced binary tree: the height difference of two subtrees cannot go beyond 1.</p><ul><li>$balance_factor = H(right)-H(left)$</li></ul></li><li><p>AVL tree: besides balanced binary tree, every node will store the height of two subtrees.</p></li></ul><h3 id="DP-6"><a href="#DP-6" class="headerlink" title="DP"></a>DP</h3><ul><li><p>subproblem: find an optimal BST containing $keys<a href="1 \leq i \leq j \leq n">i..j</a>$</p></li><li><p>$e[i,j]$: the expected search cost of a subtree with $k[i..j]$.</p><ul><li>$e[i, j] =\begin{cases} q_{i-1}, &amp;j=i-1 \\ min_{i\leq r\leq j}(e[i, r-1]+e[r+1, j]+w[i, j]), &amp;i\leq j\end{cases}$</li><li>$w[i,j]=E_r=w[i,r-1]+p_r+w[r+1,j]=w[i,j-1]+p_j+q_j$</li></ul></li><li><p>diagonal traverse template</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>): <span class="comment"># length of fixed diagnals</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n-l+<span class="number">1</span>):</span><br><span class="line">        j = i + l - <span class="number">1</span> <span class="comment"># (n-l+1, n) is always on f(i, j)</span></span><br></pre></td></tr></table></figure><blockquote><p>Due to $i\leq j$, then the traverse should be diagonal.</p></blockquote></li></ul><h3 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$</li><li>space: $O(n^2)$</li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter5-Greedy-Algorithms"><a href="#Chapter5-Greedy-Algorithms" class="headerlink" title="Chapter5 Greedy Algorithms"></a>Chapter5 Greedy Algorithms</h1><p>Total Count: <code>522</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li><p>Greedy algorithms don’t always produce the optimal solution.</p></li><li><p>As a result, if the result is optimal, we need to prove its correctness.</p><blockquote><p>The usual way is to prove that any other optimal solution can be converted into the greedy one.</p></blockquote></li></ul><h2 id="Fraction-Knapsack-Problem"><a href="#Fraction-Knapsack-Problem" class="headerlink" title="Fraction Knapsack Problem"></a>Fraction Knapsack Problem</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Different from 0-1 problem, knapsack can take only a fraction of an item.</li></ul><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><ul><li>calculate value-per-pound of every item</li><li>sort items by <strong>decreasing</strong> value-per-pound</li><li>put as much as possible weight of an item into knapsack from the starting point to the end of the sorted array</li></ul><h3 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$, the time complexity of sort process.</li><li>Different from DP, all subproblems of greedy algorithms are optimal no matter whether they are connected with each other.</li></ul><h2 id="Huffman-Coding-Problem"><a href="#Huffman-Coding-Problem" class="headerlink" title="Huffman Coding Problem"></a>Huffman Coding Problem</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>Encode characters according to its frequency so that the variable length can save the memory space compared with fixed length.</p><blockquote><p>especially useful when storing images</p></blockquote></li><li><p>Uniquely Decodable: In order to decode correctly, the encoding method should avoid one character’s code being the prefix of another character, and then the code can be named after <strong>prefix (free) code</strong>.</p></li><li><p>Huffman coding targets at the <strong>minimized binary prefix code</strong>.</p></li></ul><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><ul><li>pick two least-occur characters from alphabet and build a subtree</li><li>the subtree’s frequency is the sum of its sub-subtrees</li><li><strong>note that the Huffman tree can be a complete binary tree as well</strong></li></ul><h3 id="Analysis-10"><a href="#Analysis-10" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$<ul><li>Every update of the priority queue is $O(logn)$ and the total operation count is $n$.</li></ul></li></ul><h2 id="Activity-Selection-Problem"><a href="#Activity-Selection-Problem" class="headerlink" title="Activity Selection Problem"></a>Activity Selection Problem</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Given activities that may overlap with each other, take part in as many activities as possible.</li><li>core: find a maximized compatible activity set</li></ul><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>sort activities list in ascending order of finishing time</p></li><li><p>select the first activity: the one <strong>finishes at the earliest time</strong></p><blockquote><p>not the one starting earliest or the shortest one</p></blockquote></li><li><p>advance the time and update sort activities until the head activity’s starting time is still valid</p></li><li><p>select next activity</p></li></ul><h3 id="Analysis-11"><a href="#Analysis-11" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>Time: $O(nlogn)$ to sort activity list.</p></li><li><p>The correctness can be proved that greedy algorithms produce the optimal solution of this problem.</p><blockquote><p>Proof: we can convert any other optimal solution($P’$) to the greedy algorithm solution($P$) by replacing different elements in $P’$ with corresponding elements in $P$.</p></blockquote></li></ul><h2 id="Weighted-Activity-Selection-Problem"><a href="#Weighted-Activity-Selection-Problem" class="headerlink" title="Weighted Activity Selection Problem"></a>Weighted Activity Selection Problem</h2><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Every activity is given a weight, and the goal is to construct the set with maximized weight sum.</li></ul><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>Greedy algorithm is correct when weight are all equal.</p></li><li><p>DP can still work in this weight-varied scenario.</p><ul><li><p><strong>First of all, sort activity with its finishing time.</strong></p></li><li><p>$p(j)$ : the largest index $i&lt;j$ guaranteeing $a_i$ compatible with $a_j$.</p><blockquote><p><strong>index</strong> is the one of <strong>sorted</strong> activity array.</p></blockquote></li><li><p>$OPT(j)$: the max weight sum of any subset in $a[1..j]$</p><script type="math/tex; mode=display">OPT(j)=\begin{cases} 0,& j=0 \\ max(OPT(i-1), w_j+OPT(p(j)), & j>0\end{cases}</script></li></ul></li></ul><h3 id="Analysis-12"><a href="#Analysis-12" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$ to sort the activity list</li><li>Greedy algorithms never reconsider its previous choices, while DP construct its solution by comparing all possible previous choices.</li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter6-Graph-Algorithms"><a href="#Chapter6-Graph-Algorithms" class="headerlink" title="Chapter6 Graph Algorithms"></a>Chapter6 Graph Algorithms</h1><p>Total Count: <code>1887</code> words</p><p>Preferred Reading Time: <code>30~45</code> minutes</p><h2 id="Basic-Concepts-6"><a href="#Basic-Concepts-6" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><ul><li><p>complete graph</p><ul><li>undirected: $|E|=n(n-1)/2$</li><li>directed: $|E|=n(n-1)$</li></ul></li><li><p>dense &amp; sparse graph: not quantitative defined</p></li><li><p>degree: number of edges incident on a vertex</p><ul><li>degree of a graph is the sum of degrees of all vertices</li></ul></li><li><p>leave node</p><ul><li>directed graph: no out degree</li><li>undirected graph: degree is <code>1</code></li></ul></li><li><p>path length: <strong>edges’</strong> count(not vertex)</p></li><li><p>simple path: all <strong>vertices</strong> are distinct on the path(no cycle, acyclic)</p></li><li><p>cycle: requires all <strong>edges</strong> are distinct with multi-exist vertices</p><blockquote><ul><li><p>an edge cannot be used twice in a cycle</p></li><li><p>Q: self-to-self edge can produce cycle?</p><p>A: Yes, that’s why a legal tree <strong>cannot</strong> have self-to-self edge.</p></li></ul></blockquote></li><li><p>connected component</p><ul><li><p><strong>disconnected</strong> graph’s biggest connected subgraph</p><blockquote><p>a disconnected graph can have <strong>more than one</strong> connected components</p></blockquote></li><li><p>connected graph itself</p></li></ul></li><li><p>included subgraph: As long as <strong>both</strong> endpoints are preserved, the edges should be preserved.</p></li><li><p>leaf</p><ul><li>directed graph: out-degree is zero</li><li>undirected graph: degree is one</li></ul></li></ul><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><ul><li>Adjacency List<ul><li>space complexity: $O(V+E)$</li><li>$adj[u]$: hold all vertices adjacent to $u$, usually a linked list.</li><li>mostly for sparse graph</li></ul></li><li>Adjacency Matrix<ul><li>space complexity: $O(V^2)$</li><li>undirected graphs always have <strong>symmetric</strong> adjacency matrix</li><li>mostly for dense graph</li></ul></li></ul><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul><li><p>data structure</p><ul><li><code>color[u]</code>: state of vertex <code>u</code><ul><li><code>undiscovered</code></li><li><code>discovered but not finishing processing</code></li><li><code>finished processing</code></li></ul></li><li><code>pred[u]</code>: the predecessor of vertex <code>u</code></li><li><code>d[u]</code>: distance from starting point to <code>u</code></li></ul></li><li><p>end-loop condition: the vertex queue is empty</p></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><blockquote><p>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</p></blockquote></li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li><p>tree-like traverse process</p></li><li><p>data structure</p><ul><li><code>color[u]</code></li><li><code>pred[u]</code></li><li><code>d[u]</code>: discovery time of vertex <code>u</code></li><li><code>f[u]</code>: finishing time of vertex <code>u</code></li></ul></li><li><p><code>u</code> is a descendant of <code>v</code> if and only if $[d[u],f[u]]\subset[d[v],f[v]]$</p><ul><li><p>tree edge$(u,v)$: $u$ is the predecessor in a DFS path</p></li><li><p>back edge$(u,v)$: $v$ is the predecessor in a DFS path</p><blockquote><p>As long as the graph is acyclic, there is no back edge.</p></blockquote></li><li><p>cross edge$(u,v)$: both vertices are endpoints of a DFS path</p></li></ul></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><ul><li>Different from normal complexity calculation, we can think it in this way: as for each vertex, $O(1)$ is needed to update the timestamp, and $O(degree(u))$ is required to run the for loop. Therefore, the total time complexity is the sum of every single time complexity.</li></ul><blockquote><ul><li>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</li><li>The time complexity is the same as the one of BFS under adjacency list.</li></ul></blockquote></li><li><p>White-path theorem: As long as $v$ is a descendant(direct or indirect) of $u$, then there is a white path between them in DFS algorithm.</p></li></ul><h2 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h2><h3 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Topological sort is adopted for <strong>directed acyclic graph(DAG)</strong>.<ul><li>$G$ doesn’t need to be connected, for the order of disconnected parts won’t break the rule.</li></ul></li><li>find a sequence based on edge $(u,v)$ that $u$ must be ahead of $v$</li><li>If no “zero in-degree” vertex is found, the graph must contain cycle.</li></ul><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><ul><li>BFS<ul><li>find all vertices with in-degree as 0</li><li>delete them and their outgoing edges(decrease in-degree of its direct descendants)</li><li>repeat above steps</li></ul></li><li>DFS<ul><li>traverse all vertices and build a DFS tree</li><li>Once a vertex cannot span the tree anymore, add it into $L$.<ul><li>all direct descendants are added into $L$</li><li>no direct descendant exists</li></ul></li><li>next DFS tree traverse won’t reach vertices in $L$</li><li>Tasks with <strong>later</strong> finishing time should be down <strong>earlier</strong>, so $L$ needs reversing to be correct order.</li></ul></li></ul><h3 id="Analysis-13"><a href="#Analysis-13" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>BFS<ul><li>time: $O(|V|+|E|)$</li></ul></li><li>DFS<ul><li>time: $O(|V|+|E|)$</li></ul></li></ul><h2 id="Strongly-Connected-Components"><a href="#Strongly-Connected-Components" class="headerlink" title="Strongly Connected Components"></a>Strongly Connected Components</h2><h3 id="Definition-6"><a href="#Definition-6" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>SCC is a subset of a <strong>directed</strong> graph, in which all vertices can reach each other, <strong>and</strong> the subset should be <strong>maximal</strong>(no more vertex can be added).</p><ul><li>SCC can contain <strong>only one</strong> vertex.</li></ul></li><li><p>Theorem: Suppose $S_1$ and $S_2$ are both SCCs of $G$, then the intersection must be $\Phi$.</p><blockquote><p>Proof: Any vertex in intersection can make $S_1\cup S_2$ a bigger SCC.</p><ul><li>After finding a SCC, all vertices within can be taken as a single vertex.</li></ul></blockquote></li><li><p>Finding all SCC of $G$ is to find a partition with all subset are SCC.</p></li><li><p>Sink SCC: SCC with no outgoing edge</p><ul><li><p>$G^{SCC}$ is a graph taking all SCC as a single vertex.</p></li><li><p>$G^{SCC}$ is a DAG</p><blockquote><p>Proof: As long as there is a cycle, the element of $SCC$ can be merged.</p></blockquote></li><li><p>$G^{SCC}$ must contain at least one <strong>SSCC</strong>.</p><blockquote><p>Proof: The DAG graph can be topological sorted, so the last vertex in the topological order has no outgoing edge, which means the vertex is a SSCC.</p></blockquote></li></ul></li></ul><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><ul><li>generate reverse graph $G^R$</li><li>Operate topological sort on $G^R$, and the result is $L^R$.</li><li>reverse $L^R$ to get $L$</li><li>execute DFS on $G$ with starting point as white ones in $L$</li><li>Every DFS on $G$ can produce a SCC, and corresponding vertices should be marked black.<ul><li>Starting from a SSCC, then the component won’t contain vertices of other SCC.</li></ul></li></ul><h3 id="Analysis-14"><a href="#Analysis-14" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(V+E)$</li></ul><h2 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a>Spanning Tree</h2><h3 id="Definition-7"><a href="#Definition-7" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>An <strong>undirected</strong> graph’s subgraph containing all vertices.</p><blockquote><p>Q: Can spanning tree has cycle?</p><p>A: No,  tree is an <strong>acyclic</strong> graph.</p></blockquote></li><li><p>Every connected graph has at least one spanning tree.</p></li><li><p>Minimum Spanning Tree: the subgraph with smallest weight sum in a weighted undirected graph</p><ul><li><p>minimum spanning tree may <strong>not</strong> be unique</p><blockquote><p>Only when weight varies from one to another, the minimum spanning tree is unique.</p></blockquote></li></ul></li><li><p>safe edge: After adding safe edge to a subset of MST, the new set is still a subset of MST.</p><ul><li><p>Find the light edge of a cut respecting subset A, and then the light edge is the sage edge.</p><blockquote><p>Subset contains only edges, which means <strong>not all</strong> edges needs selecting even though their endpoints are with in the subset.</p></blockquote></li></ul></li><li><p>min heap</p><ul><li>root has min value</li><li>any vertex’s sons have <strong>greater</strong> value than its own value.</li></ul></li></ul><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><ul><li><p><strong>focus on vertex</strong></p></li><li><p>start with a randomly picked up <strong>vertex</strong></p></li><li><p>iterate to find the <strong>lightest</strong> edge outside the tree and add it (and its <strong>endpoint</strong>) into tree</p><ul><li><p>priority queue</p><ul><li><p>insert: insert at tail and <strong>reverse up</strong></p></li><li><p>extract min</p><ul><li><p>After extracting the first element, the last element needs swapping to the first.</p><blockquote><p>Only the last element won’t influence the tree structure.</p></blockquote></li><li><p><strong>roll down</strong> new first element to construct a new heap</p></li><li><p>time complexity is $O(logn)$</p></li></ul></li><li><p>update value: <strong>reverse up</strong> to respect the heap</p></li></ul></li></ul></li><li><p>When adding an new edge and its vertex into SMT, loop over its adjacent vertices to update key values.</p></li></ul><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><ul><li><strong>focus on edges</strong></li><li>Construct many forests, and finally they will be merged.<ul><li>When selecting edges, be cautious there cannot be cycles.<ul><li>disjoint set</li></ul></li></ul></li></ul><h3 id="Analysis-15"><a href="#Analysis-15" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time</p><ul><li><p>Prim: $O(VlogV+ElogV)=O(ElogV)$</p><ul><li>Usually, $E$ is greater than $V$ and sometimes may be $V^2$, which means $E=O(V^2)$.</li></ul><blockquote><p>As for loops like <code>while Q.size() &gt; 0</code>, and <code>Q</code> is changed within, we can consider it based on every single operation instead of every loop.</p></blockquote></li><li><p>Kruskal: $O(ElogE)=O(ElogV)$</p><blockquote><p>$logE\leq logV^2 \leq 2logV \leq O(logV)$</p><ul><li>Usually place $E$ outside $log$, and $V$ is placed inside.</li></ul></blockquote></li></ul></li></ul><h2 id="Shortest-Path"><a href="#Shortest-Path" class="headerlink" title="Shortest Path"></a>Shortest Path</h2><h3 id="Definition-8"><a href="#Definition-8" class="headerlink" title="Definition"></a>Definition</h3><ul><li>distance is the <strong>minimal</strong> length between two vertices</li><li>lemma: Any sub-path of a shortest path must also be a shortest path.</li></ul><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><ul><li><p>single source problem</p></li><li><p>can only handle <strong>no-negative-edge</strong> graph</p></li><li><p>greedy algorithm</p></li><li><p>maintain <code>d[v]</code> and <code>S</code></p><ul><li><p><code>d[v]</code>: upper bound of length <code>l(source, v)</code></p><ul><li><p>can be optimized by priority queue</p></li><li><p>relax</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[v] &lt;- min(d[v], d[u] + w(u, v));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>S</code>: set of distance-settled vertices</p></li></ul></li></ul><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><ul><li><p>single source problem</p></li><li><p>relax according to <strong>edges</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to <span class="params">|V|</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> E <span class="keyword">do</span></span><br><span class="line">        relax(e.p1, e.p2, e.w);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>Every iteration will settle an edge in the shortest paths.</p></li><li><p>The shortest path can at <strong>most</strong> contain <code>(|V|-1)</code> edges.</p></li><li><p>Iteration at most runs for <code>(|V|-1)</code> times.</p><blockquote><p><code>ith</code> iteration settle the paths containing <code>i</code> edges</p></blockquote></li></ul></li><li><p>If relaxation still happens after <code>(|V|-1)</code> iterations, there must be negative cycles in graph.</p></li></ul><h4 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h4><ul><li><p>all-pairs problem</p></li><li><p>dynamic programming algorithm</p><ul><li><p>$f[k][i][j]=min\{f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j]\}$</p><ul><li><p>using rolling array to optimize</p><p>$f[i][j]=min\{f[i][j],f[i][k]+f[k][j]\}$</p></li></ul></li></ul></li><li><p>The sequence to traverse <code>k</code>(intermediate vertex) isn’t important.</p><blockquote><p>Proof: Mathematics Induction(<a href="https://blog.csdn.net/dypdypdyp123/article/details/50492894" target="_blank" rel="noopener">https://blog.csdn.net/dypdypdyp123/article/details/50492894</a>)</p></blockquote></li></ul><h3 id="Analysis-16"><a href="#Analysis-16" class="headerlink" title="Analysis"></a>Analysis</h3><p>time</p><ul><li><p>Dijkstra: $O(VlogV+ElogV)=O(ElogV)$</p></li><li><p>Bellman-Ford: $O(EV)$</p></li><li><p>Floyd-Warshall: $O(V^3)$</p><blockquote><p>Apart from data structure, Floyd’s traversal decides the $n^3$ complexity.</p></blockquote></li></ul><h2 id="Maximum-Flow-amp-Minimum-Cut"><a href="#Maximum-Flow-amp-Minimum-Cut" class="headerlink" title="Maximum Flow &amp; Minimum Cut"></a>Maximum Flow &amp; Minimum Cut</h2><h3 id="Definition-9"><a href="#Definition-9" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>a flow network <code>G</code> with source <code>s</code>, sink <code>t</code> and no parallel edges.</p></li><li><p>capacity is nonnegative: $c(e) \geq 0$</p></li><li><p>cut’s capacity: $cap(A, B)=\sum_{e\ out\ of\ A}c(e)$</p><ul><li>a cut requires $s \in A$ and $t \in B$</li></ul></li><li><p>minimum cut: output a cut of minimum capacity</p></li><li><p>maximum flow: output a flow of maximum value</p></li><li><p>Except <code>s</code> and <code>t</code>, every vertex’s <code>out</code> equals <code>in</code>, which means it cannot store any water.</p></li><li><p>flow value: $val(f)=\sum_{e\ out\ of\ s}f(e)$, and <code>s</code> is the source.</p><blockquote><p><code>value</code> may not be the sum of capacity</p></blockquote></li></ul><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Heuristic-Algorithm"><a href="#Heuristic-Algorithm" class="headerlink" title="Heuristic Algorithm"></a>Heuristic Algorithm</h4><ul><li>initialize all <code>f(e)</code> to zero</li><li>find a <code>s-t</code> path where each edge meets $f(e)&lt;c(e)$</li><li>augment flow along <code>s-t</code> path</li><li>iterate above steps until no <code>s-t</code> path can be found</li></ul><blockquote><p><code>Heuristic Algorithm</code> <strong>cannot</strong> guarantee the optimal answer</p></blockquote><h4 id="Ford-Fulkerson-Method"><a href="#Ford-Fulkerson-Method" class="headerlink" title="Ford-Fulkerson Method"></a>Ford-Fulkerson Method</h4><ul><li><p>residual network: add reverse edges to dynamically adjust the flow of an edge</p><ul><li>residual capacity: $c_f(e)=\begin{cases} c(e)-f(e), &amp; c(e)&gt;f(e) \\ f(e), &amp;f(e)&gt;0 \end{cases}$</li></ul><blockquote><p>Once and residual capacity is zero, there is <strong>only one</strong> edge between two vertices.(even no edge at all)</p></blockquote></li><li><p>augment(ing) path: a simple <code>s-t</code> path in $G_f$</p><ul><li><p>bottleneck capacity: minimum residual capacity of any edge in augment path</p></li><li><p>key property: $val(f’)=val(f)+bottoleneck(G_f, P)$</p><ul><li>As for specific edge, the flow may decrease. However, the overall flow will increase.</li></ul></li><li><p>$val(f’)&gt;val(f)$</p><blockquote><p>the out edges of <code>s</code> must have the <strong>same</strong> direction as that in augment path</p></blockquote></li></ul></li><li><p>Process</p><ul><li>start with all <code>f(u, v) = 0</code></li><li>randomly choose an augment path to update <code>f</code> and $G_f$.</li><li>iterate until there is <strong>no</strong> augment path $\Leftrightarrow$ no <code>s-t</code> path in $G_f$</li></ul></li></ul><h3 id="Analysis-17"><a href="#Analysis-17" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(|E||f^<em>|)$, $f^</em>$ is the max flow of graph $G$.</p><ul><li><p>BFS/DFS: $O(|V| + 2|E|)=O(|E|)$</p><blockquote><p>the worst case: one edge in $G$ has two corresponding edges in $G_f$</p></blockquote></li><li><p>The time complexity is determined by $|f^*|$, so the method to pick up an augment path is important.</p><ul><li>EK Algorithm: ignore all edges’ weight and find a shortest path</li><li>In a flow network, EK’s time complexity is $O(|V||E|)$.<ul><li>an edge <strong>at most</strong> can be critical for $|V|/2$ times</li></ul></li><li>new time complexity of Ford-Fulkerson Algorithm: $O(|V||E|^2)$</li></ul></li></ul></li><li><p>Augmenting Path Theorem: A flow of $f$ is a max-flow $\Leftrightarrow$ <strong>no</strong> augment path in $G_f$</p></li><li><p>Max Flow &amp; Min Cut Theorem</p><ul><li>$val(f)=cap(min_cut)$</li><li>$f$ is the max flow</li><li>$f$ has no augmenting path</li></ul></li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li><li>BUAA Algorithm MOOC, Autumn of 2020.</li><li>OI Wiki</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2020 BUAA Algorithm course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-23T12:39:39.563Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Silence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Database Course Note</title>
    <link href="http://yoursite.com/2021/06/23/Database%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/Database%20Course%20Note/</id>
    <published>2021-06-23T12:39:10.027Z</published>
    <updated>2021-06-23T12:39:39.563Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2020 BUAA Database Course.</strong></p><a id="more"></a><h1 id="Chapter0-概论"><a href="#Chapter0-概论" class="headerlink" title="Chapter0 概论"></a>Chapter0 概论</h1><p>全文共<code>430</code>字，推荐阅读时间<code>5~10</code>分钟。</p><h2 id="数据和信息"><a href="#数据和信息" class="headerlink" title="数据和信息"></a>数据和信息</h2><ul><li>信息是<strong>一种</strong>已经被加工为<strong>特定形式</strong>的数据</li><li>数据是信息的载体，是信息的具体表现形式。</li></ul><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ul><li>对数据进行加工得到信息的过程</li></ul><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><ul><li>数据处理的<strong>基本操作</strong></li><li>数据库技术就是一种数据管理技术<ul><li>提供数据共享</li></ul></li></ul><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><ul><li>建立在DBMS之上，以<strong>数据管理</strong>为<strong>主要功能</strong>的计算机软件系统。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;DBMS</span><br><span class="line">DBMS--&gt;数据库</span><br></pre></td></tr></table></figure><blockquote><p>DBS &gt; DBMS &gt; DB</p><ul><li>DBS包括了<strong>用户/应用程序</strong>构成的交互层</li></ul></blockquote><h3 id="架构-B-S"><a href="#架构-B-S" class="headerlink" title="架构(B/S)"></a>架构(B/S)</h3><ul><li>Browser</li><li>Server<ul><li>Web Server</li><li>DB Server(DBMS location)</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>数据模型</li><li>底层实现技术、事务处理、数据库安全、完整性控制</li><li>关系数据理论、数据库设计方法</li></ul><blockquote><p>事务处理（原子性）是DBMS的工作，不是DBS.</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>图书馆</li><li>电商</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter1-概述"><a href="#Chapter1-概述" class="headerlink" title="Chapter1 概述"></a>Chapter1 概述</h1><p>全文共<code>2102</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="数据管理技术发展"><a href="#数据管理技术发展" class="headerlink" title="数据管理技术发展"></a>数据管理技术发展</h2><ul><li><p>人工管理</p><ul><li><p>数据<strong>不在</strong>计算机上保存</p></li><li><p>程序决定数据的逻辑结构和物理结构，数据与程序之间<strong>不具有独立性</strong>。</p><blockquote><p>要改变数据的结构就要改变程序</p></blockquote></li><li><p>数据面向应用，程序之间<strong>不能共享</strong>数据。</p></li></ul></li><li><p>文件系统</p><ul><li><p>存取方法作为中介出现</p></li><li><p>数据以<strong>文件形式</strong>保存在<strong>外存</strong>上</p></li><li><p>数据的存取以<strong>记录</strong>为单位</p></li><li><p>程序和数据具有<strong>一定的独立性</strong></p></li><li><p>缺点：</p><ul><li>数据冗余度大（因为数据<strong>不能</strong>被程序共享，即不能够同时进行操作，必须创建多个副本），可能带来数据的不一致性。</li><li>数据和程序之间的独立性依然<strong>不</strong>明显，缺乏<strong>逻辑独立性</strong>。（改文件逻辑结构时还要修改程序）</li></ul><blockquote><p>文件系统是<strong>不具弹性</strong>的<strong>无结构</strong>的数据集合，<strong>数据之间</strong>（<strong>不是</strong>程序和数据）是孤立的，不能反映现实世界事物之间的内在联系。</p><ul><li>不具弹性：改变数据的结构就得改程序</li><li>无结构：数据之间孤立</li></ul></blockquote></li></ul></li><li><p>数据库系统</p><ul><li><p>数据结构化：描述数据时，不仅描述数据本身，还要描述数据之间的联系。</p><blockquote><p><strong>数据结构化</strong>是数据库与文件系统的<strong>根本区别</strong></p></blockquote></li><li><p>数据冗余度小，易扩充。</p></li><li><p>数据和程序的独立性<strong>较高</strong></p><ul><li><p>数据独立性</p><ul><li>物理：数据的物理结构改变时，数据的逻辑结构可以不变，从而程序也不用改变。</li><li>逻辑：数据的逻辑结构改变时，程序不用改变。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;局部逻辑结构</span><br><span class="line">局部逻辑结构--&gt;全局逻辑结构</span><br><span class="line">全局逻辑结构--&gt;物理结构</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据库映象：不同结构之间数据的<strong>转换关系</strong></p><p>物理结构发生变化时，可以通过调整数据库映象来确保逻辑结构不变。</p></li><li><p>统一的数据控制功能</p><ul><li><p>安全性控制</p></li><li><p>完整性控制：数据的正确性和相容性</p><blockquote><p>相容性：同一条数据在不同的程序应该是相同的</p></blockquote></li><li><p>并发控制</p></li><li><p>恢复</p></li><li><p>存取单位是数据项</p><p>可以存取一组记录，也可以取一组数据项。</p><blockquote><p>数据项的粒度小于文件</p><p>Q：数据项和记录的区别</p><p>A：数据项是列，记录是行。</p></blockquote></li></ul></li></ul></li></ul><h2 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>集成：本质是数据结构化</li><li>共享</li></ul><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul><li>DBMS</li><li>应用系统</li></ul><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>存储数据</li><li>运行系统</li></ul><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><ul><li>终端用户</li><li>应用程序员</li><li>数据库管理员</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul><li>用于抽象和表示现实世界中的<strong>数据和信息</strong></li><li>层次<ul><li>概念模型（信息模型）</li><li>数据模型（层次、网状、关系模型）</li></ul></li></ul><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">现实世界--&gt;信息世界</span><br><span class="line">信息世界--&gt;机器世界</span><br></pre></td></tr></table></figure><ul><li>信息世界就是<strong>概念</strong>模型：E-R图</li><li>机器世界就是<strong>数据</strong>模型：数据表</li></ul><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><ul><li>基于信息世界的主要概念，表达语义。</li><li>语义表达能力强</li><li>清晰</li><li>最常用的表示方法：E-R法(Entity-Relation)</li></ul><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>实体(Entity)：客观存在并可以<strong>相互区分</strong>的食物，在E-R图中为<strong>矩形</strong>。</p></li><li><p>属性(Attribute)：实体具有的某一<strong>特性</strong>，在E-R图中为<strong>椭圆形</strong>。</p></li><li><p>码(Key)：<strong>唯一</strong>的标识实体的<strong>属性集</strong>（至少一个，最多由属性集大小确定）</p></li><li><p>域(Domain)：某些属性的<strong>取值范围</strong></p></li><li><p>实体型(Entity Type)：表示一类实体(Class)</p><ul><li>用名称和属性集表示</li></ul></li><li><p>联系(Relation)：实体型之间的联系，在E-R图中为<strong>菱形</strong>。</p><ul><li>名称：产品<strong>由</strong>若干零件<strong>构成</strong></li><li>类型<ul><li>一对一(1:1)</li><li>一对多(1:n)</li><li>多对多(m:n)</li></ul></li></ul><blockquote><ul><li>联系可以具有<strong>属性</strong>，例如产品-组装-零件中，组装可以有<strong>零件数</strong>属性。</li><li>联系是有方向的，一对多<strong>不等价于反向</strong>的多对一。</li></ul></blockquote></li></ul><h4 id="E-R"><a href="#E-R" class="headerlink" title="E-R"></a>E-R</h4><ul><li>用E-R图描述现实世界</li><li>将E-R图转换为数据模型</li></ul><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul><li>实体</li><li>属性<ul><li>作为Key的属性<ul><li>在属性下画线，多个属性就都画。</li><li>在无向边上画两条杠</li><li>组合属性作为Key：在两条无向边之间画一条弧之后，在弧上画两条杠。</li></ul></li></ul></li><li>联系：无向边旁需要标注联系的类型（三选一）<ul><li>可能存在<strong>自相联</strong>关系</li><li>三个或多个实体可能通过<strong>一个联系</strong>建立关系</li><li>两个实体之间可能存在多种联系<ul><li>工人使用/维修仪器</li></ul></li></ul></li></ul><h5 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h5><ul><li>存在依赖：<strong>有向边</strong>指向<strong>弱实体</strong>（依赖于其他实体的实体）<ul><li>弱实体是双层框</li></ul></li><li>标识依赖：<strong>有向边</strong>指向<strong>被标识实体</strong>（不能由自己的属性来唯一标识，需要和其他实体的属性组合起来作为Key）</li><li>实体的子类：<strong>无向边</strong>上画一个圆<ul><li>子类是外侧框加两条竖线</li><li>子类的交<strong>不一定</strong>为空</li></ul></li></ul><h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><ul><li>数据结构</li><li>数据操作</li><li>完整性约束</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>描述对象的相关性质</li><li>描述对象之间的联系，如关系模型中的关系。</li><li>数据<strong>静态特征</strong>的描述</li><li>三要素中<strong>最重要</strong>的方面</li></ul><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><ul><li><p>操作及操作规则</p></li><li><p>操作符号、操作规则、操作语言</p><blockquote><p>SQL就是一种操作语言</p></blockquote></li><li><p>数据<strong>动态特征</strong>的描述</p></li><li><p>数据库中主要有<strong>检索和更新</strong>两大类操作</p></li></ul><h4 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h4><ul><li>完整性规则的集合</li><li>模型通用的完整性约束条件</li><li>针对具体数据的特定语义的约束条件</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>层次模型：树<ul><li>最早出现</li><li>有向树，连线表示一对多的联系（包含一对一）。</li><li>结构简单，效率高，但是支持的联系的种类太少（只能直接表示<strong>二元一对多</strong>联系）</li></ul></li><li>网状模型：图<ul><li>有向图，连线表示一对多的联系（包含一对一）。</li><li>结构复杂，效率高。</li></ul></li><li>关系模型：二维表<ul><li>用二维表格表示实体及实体之间的联系</li><li><strong>规范化关系</strong>：每个分量（域）是<strong>不可分割</strong>的数据项，并且不能出现表中套表的情况。</li><li>有数学基础</li></ul></li></ul><h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><ul><li>三级模式<ul><li>外模式</li><li>模式</li><li>内模式</li></ul></li><li>两级映象<ul><li>外模式/模式映象</li><li>模式/内模式映象</li></ul></li><li>优点<ul><li>数据独立性</li><li>简化用户接口</li><li>有利于数据共享（外模式可以相互覆盖）</li><li>利于数据的安全保密</li></ul></li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li><strong>逻辑模式/概念模式</strong></li><li><strong>全体数据</strong>的逻辑结构和特性的描述，例如所有关系模式构成的集合。</li><li><strong>三级模式的核心</strong></li><li>模式描述语言(DDL, Data Description Language)</li></ul><h3 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h3><ul><li><p>个别用户的数据<strong>视图</strong>（与某一应用有关的数据逻辑表示）</p></li><li><p>通常是<strong>模式的子集</strong>（子模式）</p></li><li><p>不同的外模式可以相互覆盖，<strong>一个</strong>应用只能启用<strong>一个</strong>外模式。</p><blockquote><p>外模式和应用是<strong>一对多</strong>的关系</p></blockquote></li><li><p>外模式DDL，通常和应用具有相同的语法。</p></li></ul><h3 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h3><ul><li>存储模式，数据的物理结构和存储方式的描述。</li><li>内模式DDL</li></ul><h3 id="两级映象"><a href="#两级映象" class="headerlink" title="两级映象"></a>两级映象</h3><ul><li>数据<strong>逻辑</strong>独立性：外模式/模式映象</li><li>数据<strong>物理</strong>独立性：模式/内模式映象</li></ul><h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul><li>数据库的定义功能<ul><li>使用DDL语言描述外模式、模式、内模式（源模式）</li></ul></li><li>数据存取功能<ul><li>提供DML(Data Manipulation Language)语言进行CRUD</li></ul></li><li>数据库运行管理<ul><li>并发控制</li><li>存取控制</li><li>完整性</li><li>日志组织和管理</li><li>事务管理</li><li>自动恢复</li></ul></li></ul><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>语言编译处理程序</li><li>系统运行控制程序</li><li>系统建立和维护</li><li>数据字典（数据目录）：由若干个表组成</li></ul><h3 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h3><p>数据库管理员</p><ul><li>建库</li><li>用库</li></ul><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter2-关系数据库"><a href="#Chapter2-关系数据库" class="headerlink" title="Chapter2 关系数据库"></a>Chapter2 关系数据库</h1><p>全文共<code>1694</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>关系理论建立在集合代数（离散数学）理论之上</li></ul><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>关系模型的数据结构：关系</p></li><li><p>域(Domain)：一组具有<strong>相同数据类型</strong>的值的集合</p></li><li><p>元组和分量</p><blockquote><p>多个<strong>域</strong>进行笛卡尔积运算可以表示为<strong>二维表</strong></p></blockquote></li><li><p>关系：笛卡尔积$D_1 \times D_2 \times …\times D_n$的<strong>子集</strong>叫做这些域上的关系，用$R(D_1,D_2,…,D_n)$表示。</p><ul><li><p>$R$：关系名</p></li><li><p>$n$：度/目</p></li><li><p><strong>关系二维表</strong></p><ul><li><p>每个列附加一个名称，被称为<strong>属性</strong>(Attribute)。</p><blockquote><p>属性的名字需要<strong>唯一</strong></p></blockquote></li><li><p>关系是元组构成的集合</p></li></ul></li><li><p>关系的列是<strong>同质</strong>的</p></li><li><p>不同的列可以出自同一域（自相关）</p></li><li><p>列的顺序可以互换</p></li><li><p>任何两个元组（行）<strong>不能</strong>完全相同</p></li><li><p>规范性：分量不可再分，即1NF（First Normal Form，第一范式）</p></li></ul></li></ul><h2 id="数据模型-2"><a href="#数据模型-2" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>数据结构：关系</p></li><li><p>码</p><ul><li><p>候选码(Candidate Key)：具有<strong>最小性</strong>和唯一标识功能的<strong>属性组</strong></p><ul><li>最小性：指候选码的子集不能够唯一标识当前记录，和候选码的<strong>属性个数</strong>无关。例如候选码A中可能只有一个属性，但是在候选码B中可能有两个其他的属性。</li></ul><blockquote><p>属性组中<strong>可以</strong>只有一个属性</p></blockquote></li><li><p>主码(Primary Key)：简称为码，在多个候选码中选定一个为主码。</p></li></ul></li><li><p>属性</p><ul><li>主属性：<strong>所有候选码</strong>中的属性</li><li>非主属性：<strong>不包含</strong>在任何候选码中的属性</li></ul><blockquote><p>属性<strong>要么为</strong>主属性，<strong>要么为</strong>非主属性。</p></blockquote></li><li><p>关系模式：$R(U,D,dom,F,I)$</p><ul><li><p>$U$：属性名集合</p></li><li><p>$D$：域集合</p></li><li><p>$dom$：属性$\rightarrow$域的映象集合</p></li><li><p>$F$：数据依赖关系集合</p></li><li><p>$I$：完整性约束集合</p></li><li><p>关系是关系模式在<strong>某一时刻</strong>的<strong>状态或内容</strong></p><blockquote><p>关系模式相对稳定，可以理解成<strong>设计表</strong>；关系是动态的，是一张表的<strong>具体内容</strong>。</p></blockquote></li></ul></li></ul><h3 id="语义约束"><a href="#语义约束" class="headerlink" title="语义约束"></a>语义约束</h3><p>前两个是<strong>模型</strong>必须支持的约束条件</p><ul><li><p>实体完整性</p><ul><li><p>主码必须存在，<strong>其中任何一个域</strong>都不能为空。</p><blockquote><p>空：不知道/不存在的值</p></blockquote></li></ul></li><li><p>参照完整性</p><ul><li><p>外部码(Foreign Key)如果有效，则对应的外表必须存在对应记录。</p><blockquote><ul><li>外部码可以是<strong>同一个关系</strong>之间的联系（即同<strong>一张表</strong>中<strong>不同</strong>元组之间的联系）</li><li>外部码可以为空</li><li>外部码可以是<strong>属性组</strong></li></ul></blockquote></li></ul></li><li><p>用户定义完整性</p><ul><li>用户根据特定的应用环境定义的完整性约束条件</li></ul></li></ul><h3 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li><p>集合操作：操作的对象和结果<strong>都是</strong>集合</p></li><li><p>关系运算</p><ul><li>关系代数（代数方式）</li><li>关系演算（逻辑方式）<ul><li>元组关系</li><li>域关系</li></ul></li></ul><blockquote><p>各种运算之间等价，可以相互转换。</p></blockquote></li></ul><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><ul><li><p>常规集合运算：并、差、交、广义笛卡尔积</p><ul><li><p>广义笛卡尔积</p><p>对度为<code>n</code>、<code>m</code>的两个集合，元组数分别为<code>k1</code>、<code>k2</code>，它们笛卡尔积的结果</p><ul><li><p>度为$(n+m)$</p></li><li><p>元组共$k1*k2$个</p></li><li><p>当出现重名属性时，需要进行重命名。</p><blockquote><p>通常使用<code>Tablename.Fieldname</code>的组合进行重命名</p></blockquote></li></ul></li></ul></li><li><p>特殊关系运算：选择、投影、连接、自然连接、除法</p><ul><li><p>选择：在关系R中选择<strong>满足给定条件</strong>的元组，记为$\sigma_F(R)=\{t|t\in R,F(t)=True\}$.</p></li><li><p>投影：从关系中取若干属性列，并删去重复行，组成新的关系，记为$\Pi_A(R)=\{t[A]|t \in R, A \subseteq U\}$.</p></li><li><p>连接：在两个关系的<strong>广义笛卡尔积</strong>中，指定属性<strong>组</strong>$X,Y$，并且选择其中满足条件$\theta$的<strong>元组</strong>并返回<strong>整条组合记录</strong>构成的集合。</p><ul><li><p>$\theta$</p><ul><li><code>=</code>：等值连接</li><li><code>&lt;</code>：小于连接</li><li><code>&gt;</code>：大于连接</li></ul></li><li><strong>一个元组</strong>可能和<strong>多个元组</strong>进行连接</li></ul></li></ul></li><li><p>自然连接（更常用）：在笛卡尔积中选取在<strong>相同属性组列</strong>上<strong>取值相等</strong>的记录，并<strong>去掉重复</strong>的列。</p><ul><li>不能自定义$X,Y$</li><li>不能更换连接条件$\theta$</li></ul></li><li><p>除法：对关系$R(X,Y),S(Z)$，它们的除法记为：</p><p>$R \div S=\{t|t \in \Pi_X(R) \and \forall s\in S \and <t,s> \in R\}$.</p><ul><li>要求$Y,Z$域等价<ul><li>属性数相同</li><li>对应属性出自同样的域</li></ul></li><li>除法$A \div B$的意义就是<strong>A包含了多少个B</strong></li><li>通俗地说，把B认为是组别，除法的意义就是得到A中指定属性满足<strong>同时在B中所有组</strong>的<strong>投影</strong>。</li></ul></li><li><p>运算组合</p><ul><li>从内套外嵌套</li><li>（自然）连接的语义：指定域后跨表查找，同时<strong>保留其他域</strong>。</li><li>除法：解决<strong>“任意”</strong>问题</li><li>先投影再运算效率更高</li></ul></li><li><p>基本运算（可以推出其他运算）</p><ul><li>并</li><li>差</li><li>笛卡尔积</li><li>选择</li><li>投影</li></ul></li></ul><h2 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h2><ul><li>将<strong>谓词演算</strong>应用到关系运算中就是关系演算</li></ul><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul><li>以元组为变量</li><li>基本结构：元组演算表达式$\{t|\Phi(t)\}$表示所有使$\Phi$为真的<strong>元组</strong>集合</li><li>优先级<ul><li>算术比较</li><li>量词($\exists &gt; \forall$)</li><li>逻辑运算符</li></ul></li><li>例子<ul><li>$R1=\{t|R(t) \and t[3] \geq 4\}$：关系R中第三个域大于等于4的元组集合<ul><li>$R(t)$：$t$是关系$R$中的元组</li></ul></li><li>$R2=\{(\exists u)(R(t) \and W(u) \and t[3] &lt; u[3])\}$</li></ul></li></ul><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><ul><li>变量对应元组各个分量的域变量<ul><li>$R(t) \Rightarrow R(x_1,x_2,…x_n)$</li></ul></li><li>例子<ul><li>$R1=\{xyz|R(xyz) \and Z&lt;8 \and x=d\}$</li></ul></li></ul><h2 id="安全约束"><a href="#安全约束" class="headerlink" title="安全约束"></a>安全约束</h2><ul><li>关系代数是安全的，但是关系演算<strong>不一定</strong>安全。</li><li>无限关系：$\{t|\neg R(t)\}$集合有无穷多个元素</li><li>无穷运算：$\forall t(R(t))$，当$t$域无穷时，即为无穷验证运算。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对$\Phi$定义一个有限符号集$DOM(\Phi)$，使$\Phi$中的运算结果和中间过程中产生的元组及其分量均属于$DOM(\Phi)$</li><li>在实现安全约束后，三种运算方式<strong>才是</strong>等价并且可以相互转换的。</li></ul><h2 id="关系数据语言"><a href="#关系数据语言" class="headerlink" title="关系数据语言"></a>关系数据语言</h2><ul><li>核心是查询，所以也称为查询语言。</li></ul><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>数据定义（描述）语言(DDL)：包括模式DDL、外模式DDL、内模式DDL.</li><li>数据模拟语言(DML)：CRUD<ul><li>联机交互：独立于系统存在</li><li>宿主语言：嵌入在高级语言中</li></ul></li><li>数据控制语言(DCL)：安全性和完整性控制</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>一体化：例如SQL将DDL、DML、DCL的功能集成在一起</li><li>非过程化：用户不需要关注底层的实现细节</li><li>面向集合的存取方式<ul><li>操作对象是一个或多个关系</li><li>操作结果是新的关系</li></ul></li><li>可独立也可嵌套</li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter3-SQL"><a href="#Chapter3-SQL" class="headerlink" title="Chapter3 SQL"></a>Chapter3 SQL</h1><p>全文共<code>3006</code>字，推荐阅读时间<code>25~30</code>分钟</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>综合统一</li><li>高度<strong>非过程化</strong>（只注重交互结果，而不是具体的实现）</li><li>面向集合操作</li><li>同一个语法结构可以实现关系代数和关系演算两种使用方式</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>基本表：独立、实际存在的，有对应的实体文件。</p><blockquote><p>在SQL中，一个关系对应一个表。</p></blockquote></li><li><p>导出表：从<strong>一个或多个</strong>基本表导出的表，分为视图(View)和快照(Snapshot).</p><ul><li><p>视图</p><ul><li>虚表，只在数据字典中存储视图的定义。</li><li>视图可以进行CRUD基本操作，也可以用来定义新的视图。</li></ul><blockquote><p>SQL可以直接操作基本表（模式）和导出表（外模式）</p></blockquote></li></ul></li></ul><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q;</span><br></pre></td></tr></table></figure><ul><li><p>从目标表<code>T</code>中选择符合条件<code>Q</code>的目标列<code>C</code></p><blockquote><p><code>WHERE</code>相当于是<code>filter()</code></p></blockquote></li><li><p>表的水平方向：根据检索条件选择<strong>元组</strong>（记录）</p></li><li><p>表的垂直方向：对<strong>目标列</strong>进行投影</p></li></ul><h3 id="投影检索"><a href="#投影检索" class="headerlink" title="投影检索"></a>投影检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT C</span><br><span class="line">FROM T;</span><br></pre></td></tr></table></figure><ul><li><code>DISTINCT</code>删去结果中的重复行</li></ul><h3 id="选取检索"><a href="#选取检索" class="headerlink" title="选取检索"></a>选取检索</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><code>=</code>/<code>&lt;</code>等</li><li><code>AND</code>/<code>OR</code>/<code>NOT</code></li><li><code>()</code></li><li><code>BETWEEN ... AND ...</code></li></ul><blockquote><p><code>WHERE</code>子句<code>Q</code>中出现的列通常会在<code>SELECT C</code>中出现</p></blockquote><h3 id="排序检索"><a href="#排序检索" class="headerlink" title="排序检索"></a>排序检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q</span><br><span class="line">ORDER BY A ASC&#x2F;DESC;</span><br></pre></td></tr></table></figure><ul><li><p><code>ASC</code>：根据<code>A</code>升序（<strong>缺省</strong>）</p></li><li><p><code>DESC</code>：根据<code>A</code>降序</p></li><li><p>多列排序，按照<strong>语句顺序</strong>进行多要素排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S</span><br><span class="line">ORDER BY SD ASC, SA DESC;</span><br></pre></td></tr></table></figure></li><li><p>排序语句通常放在<code>SELECT</code>语句的<strong>最后</strong></p></li></ul><h3 id="连接（连表）检索"><a href="#连接（连表）检索" class="headerlink" title="连接（连表）检索"></a>连接（连表）检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T1, T2</span><br><span class="line">WHERE T1.c1 &#x3D; T2.c2;</span><br></pre></td></tr></table></figure><ul><li><code>c1</code>/<code>c2</code>被称为<strong>连接字段</strong></li><li>本质就是将<code>T1</code>，<code>T2</code>进行<strong>笛卡尔积</strong>操作，然后对新的表的符合条件的元组进行筛选。</li></ul><h4 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT X.SN, X.SA</span><br><span class="line">FROM S X, S Y</span><br><span class="line">WHERE X.SA&gt;Y.SA AND Y.SN&#x3D;&#39;xxx&#39;;</span><br></pre></td></tr></table></figure><ul><li>连接后选取的属性（<code>SELECT</code>选择的属性）中如果有重名属性，<strong>也要加上表名</strong>用以区分。同时，在查询的时候不会被起别名，即返回结果中依然是<code>SN</code>/<code>SA</code>.</li><li>起别名后，原有的<code>S</code><strong>不能够</strong>再使用。</li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S, SC</span><br><span class="line">WHERE S.S &#x3D; SC.S(*);</span><br></pre></td></tr></table></figure><ul><li>单纯使用连接语句可能造成信息丢失，例如没有选课的学生在连接学生表和选课表时会被忽略。</li><li>增加<code>*/+</code>的表中会<strong>增加</strong>万能空行与<strong>另一个表</strong>进行连接</li></ul><h3 id="嵌套检索"><a href="#嵌套检索" class="headerlink" title="嵌套检索"></a>嵌套检索</h3><ul><li>子查询（嵌套查询）：<code>WHERE</code>中包含的另一个查询块<ul><li>普通：与外部查询无关，<strong>可以单独执行</strong>获得一组值。</li><li>相关：把<strong>外查询的值</strong>作为检索的条件值，<strong>不可以</strong>单独执行。</li></ul></li><li>外部查询：包含子查询的语句</li></ul><h4 id="自身嵌套"><a href="#自身嵌套" class="headerlink" title="自身嵌套"></a>自身嵌套</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM s</span><br><span class="line">WHERE S.SA &#x3D; (SELECT SA FROM S WHERE S.SN &#x3D; &#39;xxx&#39;);</span><br></pre></td></tr></table></figure><blockquote><p>嵌套运算的效率<strong>高于</strong>连表运算，空间开销也更低。</p></blockquote><ul><li><p>子查询返回<strong>单值</strong>时可以直接使用<strong>运算符</strong>进行连接</p></li><li><p>子查询返回<strong>一组值</strong>，则需要在子查询结果前加上<code>ANY</code>/<code>ALL</code>.</p><ul><li><p><code>IN</code>可以替代<code>=ANY</code></p></li><li><p><code>NOT IN</code>可以替代<code>!=ALL</code>，<strong>不是</strong><code>!=ANY</code>.</p><blockquote><p><code>!=ALL</code>和<code>!=ANY</code>的区别</p><ul><li><code>!=ALL</code>：当左值和<strong>任意</strong>右值<strong>都不相等</strong>的时候为真</li><li><code>!=ANY</code>：当左值和<strong>某个</strong>右值<strong>不相等</strong>的时候为真</li></ul></blockquote></li><li><p><code>EXISTS</code>：当仅当<strong>子查询</strong>结果为<strong>非空</strong>时为真，即<code>filter()</code>的拓展，可以在<code>filter()</code>中放更加复杂的筛选条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE EXISTS</span><br><span class="line">(SELECT * FROM SC WHERE SC.S&#x3D;S.S AND C&#x3D;&#39;xxx&#39;);</span><br></pre></td></tr></table></figure><blockquote><ul><li>相当于遍历S表中的每一个学生，然后利用学号在SC中进行检索。</li><li><strong>相关</strong>子查询，因为子查询的<code>S</code>不独立。</li><li><code>EXISTS</code>判定的方式决定了<code>SELECT</code><strong>不需要</strong>明确某一列</li></ul></blockquote></li><li><p><code>NOT EXISTS</code>：在子查询结果为<strong>空</strong>时返回真，可以使用<code>NOT EXISTS</code>表示谓词逻辑。</p><ul><li><p>单层<code>NOT EXISTS</code>：即<code>exclude()</code>，排除掉所有满足嵌套条件的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM C</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM SC WHERE SC.C &#x3D; C.S);</span><br></pre></td></tr></table></figure></li><li><p>全称量词$\forall$：$(\forall x)P=\neg(\exist x(\neg P))$</p><ul><li><p>对命题和子命题都取反，把任意变成存在，然后根据等价命题进行SQL语句构造。</p></li><li><p><strong>检索选修所有课程的学生的姓名</strong></p><ul><li><p>$Given\ s,\forall cP(s,c).$</p><p>其中$P(s,c)$表示学生选上了这门课，为了能够返回布尔值，我们使用$EXISTS$语句进行包装。</p><p>将其转换为$Given\ s, \neg\exist c(\neg P(s,c))$（其中$\neg$就是<code>NOT</code>）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM C</span><br><span class="line">     WHERE NOT EXISTS</span><br><span class="line">      (SELECT * FROM SC WHERE SC.S&#x3D;S.S AND SC.C&#x3D;C.C))</span><br></pre></td></tr></table></figure><blockquote><p>命题等价于：不存在没有选修的课程的学生的姓名，即排除没有全部选修的学生。</p></blockquote></li></ul></li><li><p>蕴涵：$p \rightarrow q = \neg p \or q$</p><ul><li><p><strong>检索至少选修了学生S2选修的全部课程的学生学号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT S</span><br><span class="line">FROM SC SCX</span><br><span class="line">WHERE NOT EXISTS # 不存在S2选了但是该学生没选的课程，所以下面是S2选了但是他没选的。</span><br><span class="line">(SELECT * FROM SC SCY</span><br><span class="line">     WHERE SCY.S&#x3D;S2 AND NOT EXISTS ( # 他没有选择这门课</span><br><span class="line">     SELECT * FROM SC SCZ WHERE SCZ.S&#x3D;SCX.S AND SCZ.C&#x3D;SCY.C))</span><br></pre></td></tr></table></figure><ul><li><code>p</code>：S2选修了某门课</li><li><code>q</code>：该学生也要选修这门课</li></ul><blockquote><p>命题等价于：不存在S2选修但是他没有选修的课程</p></blockquote></li></ul></li></ul><blockquote><p>用<code>NOT EXISTS</code>表示谓词逻辑：</p><ul><li>使用纯数理逻辑进行推导，但是对于谓词过多的情况可能出现问题。</li><li><strong>把命题改写成“不存在…”的形式，然后逐层使用<code>NOT EXISTS</code>.</strong></li></ul></blockquote></li></ul></li></ul><h3 id="并、差、交检索"><a href="#并、差、交检索" class="headerlink" title="并、差、交检索"></a>并、差、交检索</h3><p>操作对象必须是<strong>相容</strong>的：有相同的属性列。</p><ul><li><p>UNION</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c1&#39;</span><br><span class="line">UNION</span><br><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c2&#39;;</span><br></pre></td></tr></table></figure></li><li><p>MINUS</p></li><li><p>INTERSECT</p></li></ul><h3 id="库函数检索"><a href="#库函数检索" class="headerlink" title="库函数检索"></a>库函数检索</h3><ul><li><p><code>COUNT()</code>：按<strong>列值</strong>计数，统计<strong>属性数</strong>。</p><blockquote><p><code>COUNT(*)</code>：对<strong>行</strong>计数，统计<strong>记录数</strong>。</p></blockquote></li><li><p><code>SUM()</code>：对数值列求总和</p></li><li><p><code>AVG()</code>：对数值列求平均</p></li><li><p><code>MAX()</code>：在列中找出最大值</p></li><li><p><code>MIN()</code>：在列中找出最小值</p></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>只能在<code>SELECT</code>和<code>HAVING</code>子句中出现</p></li><li><p>检索学生总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM S;</span><br></pre></td></tr></table></figure></li><li><p>检索选择了课程的学生总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT S)</span><br><span class="line">FROM SC;</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>DISTINCT</code>的位置</p></blockquote></li><li><p>求S4的总分和平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(G), AVG(G)</span><br><span class="line">FROM SC</span><br><span class="line">WHERE SC.S&#x3D;&#39;S4&#39;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组检索"><a href="#分组检索" class="headerlink" title="分组检索"></a>分组检索</h3><p>按<strong>属性列</strong>将记录分组，每组具有某个共同特征，然后对每一组进行<code>SELECT</code>操作。（相当于对记录进行了<strong>打包</strong>）</p><ul><li><p>分组子句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GROUP BY C</span><br><span class="line">[HAVING conditionExpression]</span><br></pre></td></tr></table></figure><ul><li><p><code>WHERE</code>是对<strong>行</strong>进行过滤，去掉不符合条件的行。</p></li><li><p><code>HAVING</code>只能对<strong>分组</strong>进行过滤，必须建立在<code>GROUP BY</code>之上.</p><blockquote><p><code>WHERE-&gt;GROUP BY-&gt;HAVING</code></p></blockquote></li></ul></li><li><p>检索至少选修了三门课的学生学号和选课门数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, COUNT(*)</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY S</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 3;</span><br></pre></td></tr></table></figure><blockquote><p><code>GROUP BY</code>同时影响了<code>SELECT</code>的范围，相当于是<code>FROM SC GROUP BY S</code>.</p></blockquote></li></ul><h3 id="算术表达式值检索"><a href="#算术表达式值检索" class="headerlink" title="算术表达式值检索"></a>算术表达式值检索</h3><ul><li><p>为算术表达式起别名提高可读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT EMPN, BONUS&#x2F;SALARY BS</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><ul><li><p><code>LIKE/NOT LIKE</code>：对字符型列适用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># &lt;列名&gt; LIKE&#x2F;NOT LIKE &lt;字符串常量&gt;</span><br><span class="line">SELECT S, SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE SN LIKE &#39;刘%&#39;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;字符串常量&gt;</code>可包含特殊符号<ul><li><code>%</code>：通配<strong>0或多个</strong>字符</li><li><code>_</code>：通配<strong>单个</strong>字符</li></ul></li></ul></li></ul><h3 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h3><ul><li><p>MySQL目前不支持</p></li><li><p>出现在<code>FROM</code>中的子查询生成的表叫做派生表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, C</span><br><span class="line">FROM SC, (SELECT S, AVG(G) FROM SC GROUP BY S) AS AVG_SC(AVG_S,AVG_G)</span><br><span class="line"># WHERE ...</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><ul><li>基本表：定义、删除、<strong>修改</strong></li><li>视图：定义、删除</li><li>索引：定义、删除</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><code>char(n)</code>：固定长度的字符串</li><li><code>varchar(n)</code>：可变长字符串</li><li><code>numeric(p, q)</code>：定点数共<code>p</code>位，小数点右边<code>q</code>位。</li><li><code>interval</code>：两个<code>date</code>或<code>time</code>类型数据之间的差</li></ul><h3 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;tablename&gt; (&lt;columnname&gt;&lt;datatype&gt;[&lt;columnintegrity&gt;],...);</span><br><span class="line">ALTER TABLE &lt;tablename&gt; (ADD&#x2F;DROP&#x2F;MODIFY);</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li><p>创建学生表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(S CHAR(5) NOT NULL UNIQUE,</span><br><span class="line"> SN CHAR(50) NOT NULL,</span><br><span class="line"> SA INT NOT NULL,</span><br><span class="line"> PRIMARY KEY(S),</span><br><span class="line"> CHECK (SA&gt;&#x3D;18 AND SA&lt;&#x3D;45));</span><br></pre></td></tr></table></figure></li><li><p>修改属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE S ADD SCOME DATE;</span><br><span class="line">ALTER TABLE S MODIFY SA SMALLINT; # modify the data type</span><br></pre></td></tr></table></figure></li><li><p>删除基本表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE S;</span><br></pre></td></tr></table></figure></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>为了对<strong>经常查询的属性</strong>的存取进行<strong>加速</strong>而提出的策略</p><ul><li>索引项：属性组取值</li><li>位置指针：索引对应的记录存储的位置</li><li>索引文件是<strong>排序文件</strong>，进而加快了查找速度。</li></ul><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE][CLUSTER] INDEX &lt;indexname&gt; ON &lt;tablename&gt; (&lt;columnname&gt;[sequence]);</span><br><span class="line">DROP UNIQUE INDEX &lt;indexname&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>CLUSTER</code>：索引项的指针所指的<strong>内存顺序</strong>和<strong>实际数据库</strong>中的顺序是相同的（不常使用）</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX Scno ON SC (S ASC, C DESC);</span><br><span class="line">DROP INDEX Scno ON S;</span><br></pre></td></tr></table></figure><ul><li><p><code>DROP INDEX</code>可以作为<code>ALTER TABLE</code>的子句使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON tablename;</span><br><span class="line">ALTER TABLE tablename DROP INDEX index_name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>视图是一个虚表，属于外模式。</li><li>视图消解(View Resolution)：对视图的操作会被等价的转化为对<strong>基本表</strong>的操作，然后再执行。</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>简化用户操作</li><li>为同样的原始数据提供不同的角度（为一间房子在不同的方向开了窗）</li><li>逻辑独立性（数据的逻辑结构改变时，应用程序对数据的操作不需要改变）</li><li>安全保护（权限管理）</li></ul><h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW &lt;viewname&gt; [&lt;columnname&gt;] AS &lt;subquery&gt; [WITH CHECK OPTION];</span><br><span class="line">DROP VIEW &lt;viewname&gt; [IF EXISTS &lt;viewname&gt;];</span><br></pre></td></tr></table></figure><ul><li><code>WITH CHECK OPTION</code>：让用户只能对视图中的数据进行CRUD，从而保护了数据库中的其他数据。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW CS_Student</span><br><span class="line">AS</span><br><span class="line">SELECT S, SN, SA FROM S</span><br><span class="line">WHERE SD&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure><ul><li><p>在视图上查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S,SA</span><br><span class="line">FROM CS_Student</span><br><span class="line">WHERE SA&lt;20;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><p>单个元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;tablename&gt; (&lt;columnname1&gt;,...) VALUES (&lt;value1&gt;,...);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO S VALUES (&#39;xxx&#39;, &#39;yyy&#39;, &#39;zzz&#39;);</span><br><span class="line">INSERT INTO SC (S, C) VALUES (&#39;xxx&#39;, &#39;yyy&#39;);</span><br></pre></td></tr></table></figure></li><li><p>子查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO DA(SD, Aveage)</span><br><span class="line">SELECT SD, AVG(SA) FROM S GROUP BY SD;</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;tablename&gt; SET &lt;columnname&gt;&#x3D;&lt;expression&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE SC</span><br><span class="line">SET G&#x3D;666</span><br><span class="line">WHERE &#39;CS&#39;&#x3D;(SELECT SD FROM S</span><br><span class="line">           WHERE S.S&#x3D;SC.S);</span><br></pre></td></tr></table></figure><blockquote><p><code>WHERE</code>中可以把常量放在等号<strong>左边</strong></p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;tablename&gt; [WHERE &lt;conditions&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>注意<strong>不是</strong><code>DROP</code></p></blockquote><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><ul><li><p>空值用<code>NULL</code>表示</p><ul><li>不能确定的值</li><li>属性不应该被赋值</li><li>属性值不方便填写</li></ul></li><li><p>属性有<code>NOT NULL</code>或者<code>UNIQUE</code>约束的，以及主属性不能够为<code>NULL</code>.</p><blockquote><p>部分系统允许<code>UNIQUE</code>为空</p></blockquote></li></ul><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li>算数运算：<code>NULL</code></li><li>比较运算：<code>UNKNOWN</code></li><li>逻辑运算：除了<code>False AND NULL</code>和<code>True OR NULL</code>可以确定之外，其余都为<code>UNKNOWN</code>.</li></ul><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><ul><li>使用<code>IS NULL</code>或<code>IS NOT NULL</code>判断</li></ul><h2 id="数据控制"><a href="#数据控制" class="headerlink" title="数据控制"></a>数据控制</h2><ul><li><p>完整性约束</p></li><li><p>事务操作</p></li><li><p>安全控制</p><ul><li><p>授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; TO &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure></li><li><p>收回权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; FROM &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h2><ul><li><p>将SQL的特性和程序设计语言的<strong>过程处理能力</strong>结合起来</p></li><li><p>预编译</p><ul><li>把嵌入在程序中的SQL语句翻译为高级语言源码，然后再编译、链接、执行。</li></ul></li><li><p>实现</p><ul><li><p>区分SQL和高级语言：在SQL语句前加<code>EXEC SQL</code></p></li><li><p>数据库工作单元和程序工作单元之间的通信：通过主变量（主程序语言变量）的值来传递</p></li><li><p>SQL和主语言之间操作方式的协调：通过游标(<code>Cursor</code>)解决，由游标进行记录的操作，然后将结果传递给主变量。</p><blockquote><p>游标时系统开辟的存放SQL执行结果的缓冲区</p></blockquote></li></ul></li><li><p>动态SQL：允许嵌入式语句的某些参数不确定，在运行时动态生成<code>SQL</code>语句。</p></li><li><p>ODBC/JDBC</p><ul><li><p>执行效率相比嵌入式SQL低，但是开发效率高。</p></li><li><p>组件</p><ul><li>应用程序</li><li>驱动程序管理器</li><li>驱动程序</li><li>数据源</li></ul><blockquote><p>不同的数据库提供相同的API接口，通过驱动管理程序即可以实现程序的移植性。</p></blockquote></li></ul></li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter4-数据库设计"><a href="#Chapter4-数据库设计" class="headerlink" title="Chapter4 数据库设计"></a>Chapter4 数据库设计</h1><p>全文共<code>2640</code>字，推荐阅读时间<code>20~25</code>分钟。</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><ul><li>直接设计法（手工试凑）<ul><li>高度依赖开发人员经验</li><li>后期维护困难</li><li>移植困难</li><li>难以合作设计</li></ul></li><li>规范设计法<ul><li>将设计过程分为若干个阶段，每个阶段只解决整个设计中的部分问题。<ul><li>需求分析：调查应用环境</li><li>概念结构设计（在三级模式两级映象中<strong>没有</strong>对应的部分）：形成可以<strong>用E-R图</strong>表示的模型</li><li>逻辑结构设计（<strong>概念模型</strong>，即模式、信息世界）：将E-R图转换成DBMS的模式和子模式</li><li>物理结构设计（<strong>数据模型</strong>，即内模式、机器世界）：存储结构（内模式）和存取方法（例如索引）</li><li>数据库实施：建立数据库</li><li>数据库运行和维护</li></ul></li></ul></li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>处理要求</li><li>信息要求</li><li>安全性和完整性要求</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>和用户交流</p></li><li><p>分析、表达用户需求</p><ul><li><p>用<strong>数据流图</strong>表达数据和处理之间的关系</p><ul><li>数据流图(Data Flow Diagram, DFD)：表达系统逻辑功能和数据逻辑流向和逻辑变换<ul><li><strong>自顶向下</strong></li></ul></li></ul></li><li><p>用<strong>数据字典</strong>描述系统中各类数据</p><ul><li><p>数据字典：对数据进行集中的说明，包含数据元素的名字、含义等。</p><ul><li>从数据流图中提取原子数据项</li><li>把有联系的数据项组合为数据组</li></ul><blockquote><p>上述数据字典和在数据库实施阶段的数据字典<strong>不同</strong>，前者可以看作是现实世界的<strong>数据元素表</strong>，后者是数据库系统的组成部分。</p></blockquote></li></ul></li></ul></li></ul><h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><ul><li>概念结构是信息世界的结构，即概念模型。</li></ul><h3 id="E-R法"><a href="#E-R法" class="headerlink" title="E-R法"></a>E-R法</h3><ul><li>描述概念模型</li><li>组成部分<ul><li>E-R图</li><li>转换E-R图为对应的数据模型</li></ul></li></ul><h4 id="E-R图概述"><a href="#E-R图概述" class="headerlink" title="E-R图概述"></a>E-R图概述</h4><ul><li>组成<ul><li>实体（方框）</li><li>属性（椭圆框）</li><li>联系（菱形框）<ul><li>联系也可以有属性，例如学生和课程的选修联系可以拥有成绩属性。</li><li>两个实体型之间可以具有多种联系，例如机器和工人可以有使用、维修两种联系。</li><li>语义扩充<ul><li>存在依赖(<code>E</code>)</li><li>标识依赖(<code>E&amp;I</code>)</li><li>实体的子类（连线上有一个圈）</li></ul></li></ul></li></ul></li></ul><h3 id="E-R图设计"><a href="#E-R图设计" class="headerlink" title="E-R图设计"></a>E-R图设计</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li><p>自顶向下</p></li><li><p>自底向上<strong>（最常用）</strong></p><blockquote><p>自顶向下需求分析，自底向上概念设计。</p></blockquote></li><li><p>逐步扩张：先定义核心概念结构</p></li><li><p>混合策略</p></li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>以自底向上为例</p><h5 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h5><ul><li>分类</li><li>聚集：定义某个实体型的组成成分</li><li>概括：定义类型之间的子集联系</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li><p>设计<strong>局部</strong>E-R图</p><ul><li><p>选择局部应用</p></li><li><p>利用数据抽象建立实体模型</p></li><li><p>确定实体之间的联系</p></li><li><p>必要调整（属性上升为实体）</p><ul><li><p>属性规范化（不可分割）：E-R图中属性不能和其他属性有<strong>关系</strong>（包括联系）</p></li><li><p>一个属性不能和多个实体之间有联系</p></li><li><p>属性和实体之间应该是“一对一”或者“多对一”的关系，不能“多对多”或者“一对多”。（即实体的某个属性取值是否确定）</p><blockquote><p>例如学生和课程号可能是“多对多”的关系，因此需要将课程号上升为实体。</p><ul><li>这里的多对多和<strong>实体</strong>之间的多对多不同，后者是靠<strong>联系</strong>体现的。但前者指<strong>取值的个数</strong>，例如存在一个学生有多门课，那么课程号的取值有多个，即一对多。</li></ul></blockquote></li></ul></li></ul></li><li><p>综合<strong>局部</strong>E-R图</p><ul><li><p>集成</p><ul><li>一次集成</li><li>逐步集成：累加</li></ul></li><li><p>消除冲突</p><ul><li><p>属性：类型、取值范围、取值单位</p><blockquote><p>协商讨论</p></blockquote></li><li><p>命名</p><blockquote><p>建立命名表</p></blockquote></li><li><p>结构</p><ul><li><p>同一个对象在不同应用中抽象层次不同，例如一个为实体，在另一个中为属性。</p><blockquote><p>实体上升或属性下降，通常为前者。</p></blockquote></li><li><p>同一个实体在不同应用中描述不同，例如属性个数、次序不同。</p><blockquote><p>取并集</p></blockquote></li><li><p>联系类型不同</p><blockquote><p>根据语义综合</p></blockquote></li></ul></li></ul></li><li><p>消除冗余：集成得到的初步E-R图可能存在<strong>数据冗余</strong>和<strong>联系冗余</strong>，调整过后得到<strong>基本E-R图</strong>。</p><ul><li>分析法<ul><li>重点考察<strong>联系的属性</strong>（可能由其他的属性表示，<strong>不一定成环</strong>）</li></ul></li><li>规范化方法</li></ul><blockquote><p>冗余危害：数据不一致。当某个属性变化时，需要更改所有相关的冗余属性，少改任何一个就会出问题。</p></blockquote></li></ul></li></ul><h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><ul><li><p>把概念模型（E-R图）转换为DBMS支持的数据模型（模式）的过程</p></li><li><p>任务</p><ul><li><p>形成初始关系数据库模式：关系</p><blockquote><p>其他的数据库可能是网状、层次等结构。</p></blockquote></li><li><p>关系模式规范化：特定DBMS支持下的数据模型</p></li><li><p>关系模式优化</p></li><li><p>子模式定义（定义外模式）</p><blockquote><p>模式是很多张表的<strong>规范</strong>（设计表），关系是具体的<strong>数据内容</strong>。</p></blockquote></li></ul></li></ul><h3 id="E-R图与关系模型"><a href="#E-R图与关系模型" class="headerlink" title="E-R图与关系模型"></a>E-R图与关系模型</h3><h4 id="普适转换规则"><a href="#普适转换规则" class="headerlink" title="普适转换规则"></a>普适转换规则</h4><blockquote><p>一个关系模式就是一种<strong>数据模型</strong></p></blockquote><ul><li><p>前提：确定每个关系模式的<strong>码</strong></p></li><li><p>一个实体型转换为一个关系模式</p></li><li><p>一个联系转换为一个关系模式</p><ul><li><p><code>1:1</code>：每个实体的码均是该联系的候选码，任意选择一个作为联系模型的主码即可。</p><blockquote><p><strong>不可以</strong>同时选，因为不满足码的<strong>最小性</strong>。</p></blockquote></li><li><p><code>1:n</code>：关系的码是<strong><code>n</code>端实体</strong>的码</p><blockquote><ul><li><code>n</code>端实体码才有唯一标识作用</li><li><strong>不是<code>n</code>端所有实体码的组合</strong></li></ul></blockquote></li><li><p><code>m:n</code>：关系的码是<strong>两端所有</strong>实体码的组合</p></li></ul><blockquote><ul><li>一般只有<code>n:m</code>关系才有属性，其他的联系都可以整合进属性，例如<code>1:n</code>可以在<code>n</code>端实体增加存放<code>1</code>端的码。</li><li>只选择一端实体的码<strong>不代表</strong>只存储一端实体的属性</li></ul></blockquote></li><li><p>多元联系转换为一个关系模式</p></li><li><p>具有相同的码的关系可以<strong>合并</strong>。例如消耗关系和零件的码都是零件号，就可以合并为一个关系。</p><blockquote><p>合并后可能和概念模型E-R图规范不符，但是在逻辑结构设计环节是合法的。</p></blockquote></li></ul><h4 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h4><p>存在依赖中依赖别的实体的实体</p><ul><li>为每个弱实体创建新的关系</li><li>将<strong>被依赖关系的码</strong>作为新关系的<strong>外码</strong></li><li>新关系的主码是<strong>被依赖实体的码</strong>和<strong>自身部分标识属性</strong>的组合</li></ul><h4 id="超类-子类联系"><a href="#超类-子类联系" class="headerlink" title="超类/子类联系"></a>超类/子类联系</h4><ul><li><p>为超类和每个子类创建单独的关系</p></li><li><p>超类关系中，<strong>包含所有子类共有的属性</strong>，包括<strong>主码</strong>。</p></li><li><p>在超类中选定属性组作为子类的判定符</p></li><li><p>子类关系中，包含超类主码以及子类特有的属性。（<strong>没有</strong>共有属性）</p><blockquote><p>子类使用超类的主码作为自己的主码</p></blockquote></li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul><li>确定范式等级（通常需要达到3NF）</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>模式的合并和分解</li><li>关系模式的分解可以提高存取效率和存储空间的利用率</li></ul><h4 id="水平分解"><a href="#水平分解" class="headerlink" title="水平分解"></a>水平分解</h4><ul><li><p>选取操作</p></li><li><p><code>2-8</code>原则：常使用的部分提取出来作为一个关系</p></li><li><p>数据分片：根据不相交的事务将关系分解为多个子关系</p><blockquote><p>事务：一组相对独立的操作</p></blockquote></li><li><p>恢复：并运算</p></li></ul><h4 id="垂直分解"><a href="#垂直分解" class="headerlink" title="垂直分解"></a>垂直分解</h4><ul><li><p>投影操作</p></li><li><p>将经常使用的属性提取出来作为一个子关系模式</p></li><li><p>垂直分解需要保证<strong>无损连接性</strong>和<strong>保持函数依赖</strong>（能够完全复原关系）</p><blockquote><p>完全复原的必要条件：垂直分解得到的子关系模式保留了主码</p></blockquote></li><li><p>恢复：连表运算</p></li></ul><h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><ul><li>用户需求</li><li>具体DBMS的特点，例如MySQL是<code>CREATE VIEW</code>.<ul><li>根据不同的用户设置不同的列名</li><li>权限管理保证系统的安全性</li><li>降低复杂查询的难度</li></ul></li></ul><h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><ul><li>确定数据库的存储结构（内模式）</li><li>存取方法</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>存放位置<ul><li>冷热数据分开存放</li><li>数据和日志备份放在<strong>不同的磁盘</strong>上</li></ul></li><li>系统配置<ul><li>存储分配参数</li><li>物理优化</li></ul></li></ul><h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><ul><li><p>索引记录/索引项：索引文件的记录</p><ul><li>索引域：数据文件中属性组的<strong>一个取值</strong></li><li>指针：指向索引域对应的磁盘块地址</li></ul><blockquote><p>在MySQL的底层，在发起查询时会先查找记录索引域的数据区，然后确定是否对索引进行查找。</p></blockquote></li><li><p>分类</p><ul><li>稀疏索引：把所有数据记录按索引值分组，每组设立一个索引项。</li><li>稠密索引：为每个记录设置一个索引项，记录的存放是任意的，但是<strong>索引是有序</strong>的。</li></ul></li><li><p>多级索引</p><ul><li>（排序）二叉树索引</li><li>多叉树索引：每个结点有<code>D</code>个值作为分界点，共<code>(D+1)</code>个指针。</li><li>平衡树索引：限制每个结点放置的关键字和指针最小/最大个数，从而使所有的叶子结点都在一层。</li><li><code>B+</code>树索引（常用）：把树中所有关键字按<strong>递增次序</strong>从左到右安排在叶结点上，并<strong>链接</strong>起来。</li></ul></li><li><p>索引域选择</p><ul><li>经常被查询的属性</li><li>经常作为库函数的参数</li><li>经常作为连接属性</li></ul><blockquote><p>索引并非越多越好</p></blockquote></li></ul><h4 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h4><ul><li><p>将关系中<strong>某个属性组值相同</strong>的记录集中存放在<strong>连续的物理块</strong>中，可以提高查询速度。</p><blockquote><p>就像同学院的同学安排在一栋宿舍楼中</p></blockquote></li><li><p><strong>一个</strong>关系<strong>只能</strong>参与<strong>一个</strong>聚集（一个关系只能被存储一次）</p></li><li><p>选择原则</p><ul><li>经常进行连接操作的关系</li><li>单个关系中经常比较的属性组</li><li>关系<strong>属性组值</strong>重复率高的属性组</li><li>更新操作较多时<strong>不应该</strong>使用聚集方法</li></ul></li></ul><h4 id="HASH文件"><a href="#HASH文件" class="headerlink" title="HASH文件"></a>HASH文件</h4><ul><li><p>通过HASH函数将记录关键字转换成地址，并将这个地址作为<strong>记录</strong>的存储地址。</p></li><li><p>选择原则</p><ul><li><p>关系大小可预知，并且不变。</p><blockquote><p>如果大小会变化，DBMS需要提供对应的动态HASH存取方法。</p></blockquote></li></ul></li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter5-关系数据理论"><a href="#Chapter5-关系数据理论" class="headerlink" title="Chapter5 关系数据理论"></a>Chapter5 关系数据理论</h1><p>全文共<code>4341</code>字，推荐阅读时间<code>30~45</code>分钟。</p><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul><li>数据依赖：影响<strong>模式质量</strong>的因素<ul><li>关系内部属性之间的约束关系</li><li>分类<ul><li>函数依赖</li><li>多值依赖</li></ul></li></ul></li><li>范式理论：衡量模式质量的标准</li><li>规范化方法与算法：提升模式质量的办法</li></ul><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>给定属性集$U$，及其子集$X$，$Y$，$R(U)$是其上的<strong>关系模式</strong>（域名元组），$r$是$R$的<strong>任意一个</strong>具体关系（填入了任意的具体内容），$t$，$s$是$r$中<strong>任意</strong>两个元组。</p><ul><li>如果$t[X]=s[X]$，则$t[Y]=s[Y]$.此时称“$X$函数确定$Y$”或“$Y$函数依赖于$X$”，记作$X\rightarrow Y$.</li></ul><blockquote><p>等价定义：对于$X$的每个具体值，$Y$有唯一的值与之对应。</p></blockquote></li><li><p>函数依赖属于<strong>语义</strong>范畴</p></li><li><p>函数依赖具有时间稳定性，<strong>不随</strong>时间改变。</p><blockquote><p><code>r</code>（具体关系）可能会发生变化，但是函数依赖<strong>不会</strong>发生改变。</p></blockquote></li></ul><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>平凡依赖：若$Y\subseteq X$，则$X\rightarrow Y$是平凡依赖。</li><li>非平凡</li><li>决定因素：$X$被称为决定因素</li></ul><h4 id="属性联系"><a href="#属性联系" class="headerlink" title="属性联系"></a>属性联系</h4><ul><li><code>1:1</code>：$X\rightarrow Y,Y \rightarrow X$，即两者<strong>相互决定</strong>。</li><li><code>1:n</code>：<code>n</code>端项($X$)决定<code>1</code>端项($Y$)，即$X\rightarrow Y$.</li><li><code>m:n</code>：两者之间<strong>不存在</strong>函数依赖</li></ul><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li><p>完全：$X$的<strong>任意</strong>真子集（除空集）都<strong>不能够</strong>确定$Y$，记为$X \rightarrow Y$（箭头上有一个<code>f</code>）。</p></li><li><p>部分：$X\rightarrow Y$（箭头上有一个<code>p</code>）</p></li><li><p>传递：若$X\rightarrow Y(Y\nsubseteq X),Y\rightarrow Z(Z\nsubseteq Y)$，且$Y$<strong>不确定</strong>$X$，则称为$Z$对$X$<strong>传递</strong>函数依赖（箭头上有一个<code>t</code>）。</p><blockquote><ul><li>如果$Y$可以确定$X$，则$Z$对$X$是<strong>直接</strong>依赖（因为可以归为以上三种类型之一，因此<strong>不是</strong>独立的类型）。</li><li>注意传递依赖要求两个函数依赖都是<strong>非平凡</strong>的</li></ul></blockquote></li></ul><h3 id="关系键"><a href="#关系键" class="headerlink" title="关系键"></a>关系键</h3><ul><li>候选码：设$K$是$R<U,F>$（$F$是属性集$U$上的函数依赖<strong>集</strong>）的属性或属性组合，若$U$<strong>完全依赖</strong>于$K$，则称$K$是$R$的候选码。当候选码多于一个时，选定其中一个作为主码。</li><li>性质<ul><li>唯一性</li><li>最小性</li></ul></li><li>属性分类<ul><li>主属性：包含在<strong>任一候选码</strong>中的属性</li><li>非主属性：不包含在任何候选码中的属性</li></ul></li><li>外码：关系模式$R$中的属性或属性组$X$并非$R$的码，但$X$是另一个关系模式的码，则称$X$是$R$的外码。</li></ul><h3 id="逻辑蕴涵"><a href="#逻辑蕴涵" class="headerlink" title="逻辑蕴涵"></a>逻辑蕴涵</h3><ul><li>通过函数依赖集$F$能够推出$X\rightarrow Y$，则称$F$逻辑蕴涵$X\rightarrow Y$.</li><li>$F$的闭包：$F$蕴涵的<strong>全体函数依赖</strong>称为$F$的闭包，记为$F^+$.</li></ul><h3 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h3><ul><li><p>定律（可从蕴涵定义出发证明）</p><p>对$R<U,F>$</p><ul><li><p>自反律：属性集蕴涵其<strong>子集</strong></p></li><li><p>增广率：对属性$Z\subseteq U$，若$X\rightarrow Y$，则$XZ\rightarrow YZ$.</p><blockquote><p>$XZ$：将两个属性组<strong>直接拼接</strong></p></blockquote></li><li><p>传递率</p></li></ul></li><li><p>推论</p><ul><li>合并：若$X\rightarrow Y, X\rightarrow Z$，则$X\rightarrow YZ$.</li><li>伪传递：若$X \rightarrow Y, WY\rightarrow Z$，则$WX\rightarrow Z$.</li><li>分解：若$X\rightarrow Y$且$Z\subseteq Y$，则$X \rightarrow Z$.</li></ul></li><li><p>定理</p><p>$X\rightarrow A_1A_2…A_k \Longleftrightarrow X\rightarrow A_i(i=1,2,…,k)$</p></li><li><p>属性集闭包：$X\subseteq U$，将所有从$X$出发，通过$F$能够导出的<strong>属性的集合</strong>，记为$X_F^+$.</p><ul><li>$K_F^+=U$，即通过主码能够推出全体属性。</li><li>定理：$X\rightarrow Y \Longleftrightarrow Y\subseteq X_F^+$</li></ul></li><li><p>有效性（正确性）：从$F$出发，根据Armstrong公理导出的所有函数依赖一定在$F$蕴涵的<strong>全体函数依赖</strong>中</p></li><li><p>完备性（实用性）：$F^+$一定可以由Armstrong公理系统导出</p><blockquote><p>证明逆否命题：如果$X\rightarrow Y$不能用Armstrong公理从$F$中导出，则它一定不被$F$逻辑蕴涵。（即不属于该函数依赖集合下的关系模式）</p></blockquote></li></ul><blockquote><p>Armstrong公理系统是一种操作$F$的方式，还可以有其他公理系统，<strong>不</strong>影响$F$本身的存在。</p></blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>算法：求$X_F^+$</p><ul><li>以$X$为起始属性集，对其所有<strong>子集</strong>（不只是元素）进行迭代推导。</li><li>属性集在某一次迭代中没有更新或者等于全集$U$时终止算法</li></ul><blockquote><p>闭包表示</p><ul><li>函数依赖闭包$F^+$：<code>{}</code></li><li>属性集闭包$X_F^+$：<strong>直接列举元素</strong>，外层不需要<code>{}</code>或<code>()</code>修饰。</li></ul></blockquote><h3 id="函数依赖集"><a href="#函数依赖集" class="headerlink" title="函数依赖集"></a>函数依赖集</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>对于$F,G$，若$F^+=G^+$，即两者能推出的全体函数依赖相同，则称两者等价。<ul><li>此时称$F$和$G$相互覆盖</li><li>$F^+=G^+\Longleftrightarrow F \subseteq G^+ \Longleftrightarrow G \subseteq F^+$</li></ul></li><li>最小依赖集<ul><li>右部单属性化：$F$中任一函数依赖$X\rightarrow A$，$A$必是单属性。</li><li>函数依赖<strong>左部</strong>没有多余属性：<strong>不存在</strong>部分函数依赖</li><li>没有多余的函数依赖：$F$中<strong>不存在</strong>可以被其他函数依赖导出的函数依赖</li></ul></li></ul><h4 id="极小化"><a href="#极小化" class="headerlink" title="极小化"></a>极小化</h4><ul><li><p>定理：每个函数依赖集$F$<strong>均等价于</strong>一个极小函数依赖集$Fm$</p></li><li><p>算法</p><ul><li><p>对于<strong>右部</strong>是属性集合的函数依赖进行分解，转换为<strong>多个</strong>单属性依赖。</p></li><li><p>对于<strong>左部</strong>是属性集合的函数依赖，对左侧进行消融检查。对于消融后函数依赖不受影响属性，均从左侧属性集中删除<strong>并更新迭代集</strong>。</p><blockquote><p>也可能消融实验后，左部依然是属性组。</p></blockquote></li><li><p>对于<strong>每个函数依赖</strong>做消融检查，如果消融某个依赖后依然可以推导出该函数依赖，则可以将该函数依赖删除<strong>并更新迭代集</strong>。</p><ul><li>算法一：转化为图的连通性判定</li><li>算法二：求该函数依赖左侧属性<strong>新的属性集闭包</strong>，判断是否包含该消融函数依赖的右侧元素。</li></ul></li></ul><blockquote><p>对于算法的2，3步而言，如果消融的顺序不一样，可能会得到不一样的$Fm$，即$Fm$不唯一。</p></blockquote></li></ul><h2 id="规范化-1"><a href="#规范化-1" class="headerlink" title="规范化"></a>规范化</h2><ul><li>目的：消除冗余和异常</li><li>思想：“一事一地”，一个关系只描述一个实体或者实体间的一种联系。</li><li>消除部分函数依赖和传递函数依赖</li></ul><h3 id="范式-Normal-Form"><a href="#范式-Normal-Form" class="headerlink" title="范式(Normal Form)"></a>范式(Normal Form)</h3><ul><li>一个关系满足的某个<strong>指定的约束集</strong></li><li>各级范式联系：$5NF \sub 4NF\sub BCNF \sub 3CNF \sub 2NF \sub 1NF$（反证法）</li><li>规范化：通过<strong>模式分解</strong>将低级范式的关系模式提升到更高的范式等级</li></ul><h4 id="分级"><a href="#分级" class="headerlink" title="分级"></a>分级</h4><ul><li><p>第一范式(1NF)：最低要求，满足的关系被称为<strong>规范化关系</strong>。</p><ul><li>一个关系只包含原子值（属性<strong>不可</strong>再分）</li></ul></li><li><p>第二范式(2NF)</p><ul><li><p>$R\in 1NF$，并且每个<strong>非主属性完全依赖</strong>于码，则称$R\in2NF$.</p></li><li><p><strong>允许主属性部分依赖于码</strong></p><blockquote><ul><li>任一主属性<strong>均部分依赖</strong>于码</li><li>某些所有属性都是主属性，但是码<strong>不是</strong>全体主属性的情况，例如<code>STC(S, T, C)</code>.</li></ul></blockquote></li><li><p>如果$R$的全体属性都是主属性，则$R\in 2NF$.</p></li><li><p>从$1NF$中消除非主属性对码的部分函数依赖即可升级为2NF</p><ul><li>画函数依赖图</li><li>投影分解法（选择部分列）</li></ul></li></ul></li><li><p>第三范式(3NF)</p><ul><li><p>若$R\in2NF$，并且每个<strong>非主属性</strong>都<strong>不传递依赖</strong>于$R$的任何码，则$R\in3NF$.</p><ul><li><p>推论：若非主属性$Z$<strong>部分依赖</strong>于码$X$，则$R\notin 3NF$.</p><blockquote><p>此时$R\notin 2NF$</p></blockquote></li></ul></li><li><p>投影分解法</p></li></ul></li><li><p>BCNF</p><ul><li><p>3NF<strong>没有限制主属性</strong>对码的<strong>部分及传递函数依赖</strong>，依然会在某些情况下带来异常。</p></li><li><p>若$R\in 1NF$，对任意函数依赖$X\to Y$，且$Y\nsubseteq X$时，$X$必含有码，则$R\in BCNF$.</p><blockquote><p>等价定义：BCNF中任意<strong>非平凡</strong>函数依赖的<strong>左部</strong>含有码</p></blockquote></li><li><p>性质（反证法）</p><ul><li><p><strong>所有</strong>非主属性<strong>完全函数依赖</strong>于任一候选码(2NF)</p></li><li><p><strong>所有</strong>主属性<strong>完全函数依赖</strong>于每个<strong>不包含它</strong>的候选码(BCNF)</p></li><li><p><strong>没有</strong>属性<strong>完全函数依赖</strong>于非码的任意属性组(3NF, BCNF)</p><blockquote><p>如果没有完全函数依赖，则不可能有部分函数依赖。</p></blockquote></li><li><p>全码（所有属性一起作为码的关系模式）关系就是BCNF</p></li></ul></li><li><p>BCNF是只考虑函数依赖的<strong>最高标准</strong></p><blockquote><p>和多值依赖对应，不是指保持函数依赖。</p></blockquote></li></ul></li></ul><h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li><p>给定属性组$X$，$Y$，$Z$，满足$Z=U-X-Y$.当给定一组$(x,z)$可以得到一个$Y$的取值集合，若该集合与$X$有关而与$Z$无关，则称$Y$多值依赖于$X$，记为$X\to \to Y$.</p><blockquote><ul><li>即$(x,z)$中$z$任意变化对$Y$的取值集合<strong>没有</strong>影响，由$X$确定了$Y$的一组取值。</li><li>因为一个自变量对应了多个因变量，因此叫做多值依赖而不是函数依赖。</li><li>函数依赖是多值依赖的特殊情况。</li></ul></blockquote></li><li><p>有效性范围</p></li><li><p>现实场景：各个域之间均为多对多关系，即<strong>不能够</strong>提取出函数依赖关系的模式。</p></li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>给定$Z=U-X-Y$</p><ul><li><p>对称性：若$X\to \to Y$，则$X\to\to Z$.</p></li><li><p>若$X\to Y$，则$X\to\to Y$，即函数依赖可以看作多值依赖的特例。</p></li><li><p>平凡：若$X\to\to Y$，且$Z= \phi$.</p><blockquote><p>即$U$只被划分为了$X$和$Y$</p></blockquote></li><li><p>非平凡：若$X\to\to Y$，且$Z\neq \phi$.</p></li></ul><h3 id="第四范式-4NF"><a href="#第四范式-4NF" class="headerlink" title="第四范式(4NF)"></a>第四范式(4NF)</h3><ul><li><p>对任意<strong>非平凡</strong>多值依赖$X\to\to Y(Y\nsubseteq X)$，$X$都含有码，则称$R\in 4NF$.</p><blockquote><p>若关系已经满足BCNF，且所有的多值依赖都是平凡的，则关系也满足4NF.</p></blockquote></li><li><p>意义：降低数据冗余程度，减少修改异常。</p></li></ul><h2 id="模式分解理论"><a href="#模式分解理论" class="headerlink" title="模式分解理论"></a>模式分解理论</h2><ul><li><p>目的：通过模式分解，将关系模式的范式等级提高，同时保有原关系模式的一定信息。</p><blockquote><p>如果不保有信息，分解是没有意义的。因此，所有的分解算法都和性质的保持有关。</p></blockquote></li></ul><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>分解$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>,…,R_n<U_n,F_n>\}$，满足：</p><ul><li><p>$U=\bigcup_{i=1}^n U_i$，且$\forall 1\leq i,j \leq n,U_i\nsubseteq U_j$.</p><blockquote><p>可以相交但<strong>不能</strong>包含</p></blockquote></li><li><p>$F_i$是$F$在$U_i$上的一个投影，即选择了$F^+$中相关属性<strong>都在</strong>$U_i$中($XY\subseteq U_i)$的函数依赖作为$F_i$.（可以只选择一部分，不一定全选）</p></li><li><p>表示</p><p>$\rho=\{R_1&lt;\{Sno,Sdept\},\{Sno \to Sdept\}&gt;,R_2&lt;\{Sno,Mname\},\{Sno \to Mname\}&gt; \}$</p></li></ul><h3 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性"></a>无损连接性</h3><ul><li><p>将分解后的关系模式做<strong>自然连接</strong>得到合成的新关系模式，如果新关系模式中的关系和分解前的原关系模式中的关系逐一相等，则称该分解$\rho$具有无损连接性，记为<strong>无损分解</strong>。</p></li><li><p>判定</p><ul><li><p>算法</p></li><li><p>定理（无损连接性的充要条件）：以分解为两个子模式为例，若$R_1$和$R_2$的共同属性<strong>至少构成二者之一</strong>的候选码，则为无损分解。</p><blockquote><p>扩展为<code>n</code>个子关系模式：将子模式间<strong>两两进行比较</strong>，若<strong>所有</strong>的比较都满足以上条件，则该分解无损连接性。（每一次都是无损连接，则合成后的连接也是无损连接）</p></blockquote></li></ul></li></ul><h3 id="保持函数依赖性"><a href="#保持函数依赖性" class="headerlink" title="保持函数依赖性"></a>保持函数依赖性</h3><ul><li>若$F^+=(\bigcup_{i=1}^nF_i)^+$，即两个函数依赖集等价，则称$\rho$是保持函数依赖性的分解。</li><li>判定：设$G=(\bigcup_{i=1}^nF_i)$，$G\subseteq F^+$一定成立，则只需要判断$F^+\subseteq G$是否成立。<ul><li>$\forall (X\to Y) \in F$，判断$Y$是否属于$X_G^+$.</li><li>对于$F$中的每个函数依赖，判断是否可以从$G$中的函数依赖导出。</li></ul></li></ul><blockquote><p>分解$\rho$可以无损连接性和保持函数依赖性，也可以只满足其中一个，也可以同时都不满足。</p></blockquote><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>规范化过程中采用的投影分解可能不唯一，但是好的无损分解应该无损连接并且保持函数依赖。</li><li>若要保持函数依赖，则最高可能只能到3NF.（BCNF的粒度过小，可能<strong>不保持</strong>函数依赖）</li><li>若要进行无损分解，则可以到达4NF或更高。</li></ul><blockquote><ul><li>模式分解是在求当前模式的“数据等价子集”，在保证<strong>数据完整性（无损连接）</strong>的条件下尽可能地减小单个模式的复杂度，因此某些不影响数据完整性的函数依赖可能被舍弃。</li><li>大多数情况下，3NF是最为合适的规范化等级，因为它是能够无损连接并且保持函数依赖的最高等级。</li></ul></blockquote><h3 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h3><ul><li><p>3NF+函数依赖</p><ul><li><p>对$F$进行<strong>极小化</strong>处理，记为$F$.</p></li><li><p>将<strong>不在</strong>$F$中出现的属性从$U$中删除，记为$U$.</p><blockquote><p>删除了部分元素，所以<strong>不具有</strong>无损连接性。</p></blockquote></li><li><p>若$F$只有一个函数依赖，则$\rho=\{R\}$.</p></li><li><p>对$F$按照<strong>“具有相同左部”</strong>的原则进行分组，由$F_i$求出$U_i$，则$\rho=\{R_1<U_1,F_1>,…R_k<U_k,F_k>\}$为所求。</p></li></ul></li><li><p>3NF+无损连接性+函数依赖</p><p>从<strong>满足保持函数依赖</strong>的分解$\rho$出发，设$X$是$R<U,F>$的码。</p><ul><li><p>若$\exist U_i, X\subseteq U_i$，则$\rho$为所求。</p></li><li><p>否则，令$\tau=\rho \cup\{R^*<X,F_X>\}$，则$\tau$为所求。</p><blockquote><ul><li>$F_X$是以$X$为属性集的函数依赖的投影</li><li>$X_F$是属性$X$蕴涵的属性集</li><li>在满足函数依赖的算法中，删去了<strong>不出现</strong>在$F$中的属性，但是它们是<strong>主属性</strong>，因此通过$X$对无损连接性进行了恢复。</li><li>注意，$\tau$求解时是直接把$R^<em>$并入，而<em>*不是</em></em>把$X$添加进$U_i$.</li></ul></blockquote></li></ul></li><li><p>BCNF+无损连接性</p><p>设$\rho$中$R_i<U_i,F_i>\notin BCNF$</p><ul><li>则$R_i$中存在$X\to A\in F_i^+(A\notin X)$，且$X$不是$R_i$的码（也不含有），则$XA$是$U_i$的真子集，将$R_i$分解为$\sigma=\{S_1,S_2\}$，其中$U_{S_1}=XA$，$U_{S_2}=U_i-\{A\}$.</li></ul><blockquote><p>$A$是<strong>单属性</strong>，而<strong>不是</strong>属性组。</p></blockquote><ul><li><p>使用$\sigma$进行迭代，直到$\sigma \in BCNF$.</p><blockquote><p>相当于逐步分离不符合BCNF的函数依赖</p></blockquote></li></ul></li></ul><h2 id="候选码求解"><a href="#候选码求解" class="headerlink" title="候选码求解"></a>候选码求解</h2><h3 id="单属性"><a href="#单属性" class="headerlink" title="单属性"></a>单属性</h3><h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><ul><li>$L$：<strong>仅</strong>出现在左部</li><li>$R$：<strong>仅</strong>出现在右部</li><li>$N$：两边均未出现</li><li>$LR$：两边均出现</li></ul><blockquote><p>以上是<strong>属性</strong>分类，而不是<strong>属性组</strong>分类。</p><p>例如，$BC\to A$和$C\to B$均成立时，$BC\notin L$.</p></blockquote><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><ul><li>L类属性一定是<strong>所有候选码</strong>中的成员（<strong>强于</strong>主属性）<ul><li>若L类属性能够推出全体属性，则该属性单独作为候选码，且由码的极小性，该候选码唯一，即<strong>主码</strong>为该属性。</li></ul></li><li>R类属性一定<strong>不是</strong>任意候选码成员</li><li>N类属性一定是<strong>所有候选码</strong>中的成员<ul><li>若L和N类属性组成的集合能够推出全体属性，则该属性集是<strong>主码</strong>。</li></ul></li></ul><h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><p>将<strong>单属性依赖</strong>关系模式转换为图$G(U,F)$，其中$F$为有向边集合，表示<strong>单属性</strong>函数依赖。</p><ul><li>关键点（原始点+孤立点）对应的属性必在$R$的任何候选码中</li><li>属性集$X$是$R$的唯一候选码$\Leftrightarrow$X能到达$G$中的任一结点<ul><li>在单属性条件下，即不存在独立回路。</li></ul></li><li>对途中点而言，成为候选码成员$\Leftrightarrow$途中点是独立回路中的结点。</li><li>对于存在独立回路的关系模式而言，候选码=关键属性集+独立回路笛卡尔积中的任意元素。</li></ul><h3 id="多属性"><a href="#多属性" class="headerlink" title="多属性"></a>多属性</h3><ul><li><p>$X=L\cup N，Y=LR$.</p></li><li><p>判断$X$是否可以推出全体属性集，如果不可以的话就从$Y$中取一个并进$X$，然后再次判断。</p></li><li><p>依次迭代取的个数，直到能够推出全体属性。</p><blockquote><ul><li>这是一个穷举算法，取两个不只是在取的第一个的基础上再取，而是遍历所有取两个的情况。</li><li>证明了独立回路存在时，主码$K\neq L\cup N$.</li></ul></blockquote></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>通过最小函数依赖集消除<strong>冗余</strong>联系</li><li>$D=F-F_m$中的函数依赖<strong>不一定</strong>是冗余的，因此除了$F_m$中的函数依赖外，可能$D$中也有需要保留的函数依赖。</li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter6-关系查询处理与查询优化"><a href="#Chapter6-关系查询处理与查询优化" class="headerlink" title="Chapter6 关系查询处理与查询优化"></a>Chapter6 关系查询处理与查询优化</h1><p>全文共<code>448</code>字，推荐阅读时间<code>3~5</code>分钟。</p><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul><li>分析</li><li>检查<ul><li>将查询转换为<strong>查询树</strong>（语法分析树）</li></ul></li><li>优化<ul><li>代数：恒等变换</li><li>物理：根据数据规模、分布等确定对应的底层存储策略。</li></ul></li><li>执行</li></ul><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><ul><li>查询代价=I/O代价<strong>（主要）</strong>+CPU代价+内存代价</li></ul><h3 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h3><ul><li>变换规则：主要是优化<strong>连接</strong>（笛卡尔积为主）运算。<ul><li>交换律</li><li>结合律</li></ul></li><li>特殊优化：先缩小范围再运算一般效率更高<ul><li>投影、选择的串接：合并操作减小遍历次数</li><li>投影、选择的交换律：先投影再选择</li><li>选择、笛卡尔积的交换律：能先投影时，先投影再作笛卡尔积。</li></ul></li><li>查询树的启发式优化<ul><li>减少<strong>中间</strong>（临时）关系：选择、投影尽可能先做。</li><li>减少扫描次数：投影、选择并行等操作。</li><li>减少操作总数：连接=笛卡尔积+选择</li><li>中间结果复用：使用中间文件存储公共表达式的结果</li></ul></li></ul><h3 id="物理优化"><a href="#物理优化" class="headerlink" title="物理优化"></a>物理优化</h3><ul><li><p>存取路径选择</p><ul><li><p>选择操作</p><ul><li>小关系：全表扫描</li><li>大关系：索引扫描</li></ul></li><li><p>连接操作</p><ul><li><p>排序-合并</p></li><li><p>索引连接：为连接属性建立索引</p></li><li><p>Hash Join：为小表建Hash文件</p></li><li><p>嵌套循环：小表在外层</p><blockquote><p>原因：分配时通常给外表的内存更大</p><ul><li><p>设外表分配$(K-1)$块，内表$1$块。</p><p>$Cost=Cost_{out}+Cost_{in}*\frac{B_{out}}{K-1}$</p></li></ul></blockquote></li></ul></li></ul></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul><li>将查询转换成语法树</li><li>代数优化</li><li>物理优化，确定底层的存储路径</li><li>生成查询计划</li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter7-事务处理技术"><a href="#Chapter7-事务处理技术" class="headerlink" title="Chapter7 事务处理技术"></a>Chapter7 事务处理技术</h1><p>全文共<code>2870</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ul><li>事务(Transaction)：用户定义的数据库操作序列，这些操作要么一起做，要么都不做，是一个不可分割的<strong>工作单位</strong>。<ul><li>应用程序可以包含<strong>多个</strong>事务</li><li>事务的开始和结束可以由用户显式控制（DBMS也会缺省定义一部分事务划分），从而保证数据的<strong>完整性</strong>。</li></ul></li><li>事务是<strong>数据库恢复</strong>及<strong>并发控制</strong>的基本单位</li></ul><h3 id="特性-ACID"><a href="#特性-ACID" class="headerlink" title="特性(ACID)"></a>特性(ACID)</h3><ul><li><p>原子性</p><ul><li>基础：恢复机制<ul><li>回退，将已经执行的部分进行撤销。</li></ul></li></ul></li><li><p>一致性：事务执行前后数据库均为一致性状态</p><ul><li>基础：原子性</li></ul><blockquote><p>Q：什么是一致性状态</p><p>A：满足数据库约束的状态</p></blockquote></li><li><p>隔离性：并发事务之间不能相互影响</p><ul><li>基础：并发控制机制</li></ul></li><li><p>持久性：事务<strong>提交后</strong>对数据库的改变应该是永久的，故障等情况不应该有影响。</p><ul><li>基础：恢复机制</li></ul></li></ul><blockquote><p><code>ACID</code>里的<code>AID</code>都是数据库的特征,也就是<strong>依赖数据库的具体实现</strong>。而唯独这个C，实际上它依赖于<strong>应用层</strong>，也就是依赖于开发者。做个比喻事务就好比一个保镖，我们提到事务就会说ACID，而我们提到保镖会说强壮、保护安全、好功夫、踏实。这里强壮、好功夫和踏实都是保镖自己的特征，而安全是属于你的，即你通过保镖的特征来保护你的安全。</p></blockquote><h4 id="破坏"><a href="#破坏" class="headerlink" title="破坏"></a>破坏</h4><ul><li><p>事务并行时，不同事务的操作交叉进行。（隔离性）</p><blockquote><p>交叉是指<strong>完整</strong>事务间，而<strong>不是</strong>在某个事务中进行切换。</p></blockquote></li><li><p>事务运行时被强行停止（持久性）</p></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li><p>开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br></pre></td></tr></table></figure></li><li><p>结束</p><ul><li><p>正常结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT</span><br></pre></td></tr></table></figure></li><li><p>非正常结束：撤销全部更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h2><ul><li>从<strong>错误</strong>状态恢复到某一已知<strong>正确</strong>状态</li><li>通过DBMS的<strong>恢复子系统</strong>完成</li></ul><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><ul><li>事务<ul><li>可预期：事务根据<strong>内部</strong>测试条件而触发的回滚</li><li>不可预期：不能由应用程序处理</li></ul></li><li><p>系统</p><ul><li><p>事务异常中断：数据库本身不会受到破坏。</p><blockquote><p>指数据不会丢失，而<strong>不是数据的正确性</strong>。</p></blockquote></li></ul></li><li><p>介质</p><ul><li>数据库本身受到破坏及正在使用这部分数据的相关事务</li></ul></li><li><p>病毒</p><ul><li>对数据进行非法修改</li></ul></li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><ul><li><p>基本原理：冗余</p></li><li><p>建立冗余</p><ul><li><p>数据转储（备份）</p><ul><li>静态：保证一致性，但是可用性低。</li><li>动态：不影响可用性，不能保证一致性。<ul><li>建立日志文件，在使用副本进行数据库恢复时，需要经过一遍日志处理。</li></ul></li><li>海量：每次转储全部数据库</li><li>增量：每次只转储上一次转储后更新的部分</li></ul></li><li><p>登录日志文件：记录事务对数据库的更新操作</p><ul><li>记录单位：事务驱动</li><li>数据块单位：数据驱动</li></ul><blockquote><ul><li>事务、系统故障必须使用日志文件</li><li>写入规则<ul><li>按照并发事务的时间顺序</li><li><strong>先写</strong>日志文件，<strong>再写</strong>数据库。</li></ul></li></ul></blockquote></li></ul></li></ul><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>事务：UNDO<ul><li><strong>反向</strong>扫描日志，对更新执行逆操作，直到事务开始标志。</li></ul></li><li>系统：UNDO+REDO<ul><li>未完成的事务已经修改了数据库，此时采取<strong>撤销</strong>操作。</li><li>已经提交的事务还留在缓冲区中，没有写入数据库，此时采取<strong>重做</strong>操作。<ul><li><strong>正向</strong>扫描日志，获得撤销队列和重做队列。</li><li>对队列中的事务分别执行<strong>撤销</strong>和<strong>重做</strong>操作</li></ul></li></ul></li><li>介质：REDO<ul><li>装入最新数据库的后备副本</li><li>装入日志文件副本，重做已完成的事务。</li></ul></li></ul><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><ul><li><p>缩小日志文件的检查范围</p></li><li><p>新增“重新开始”文件记录检查点在日志的位置</p></li><li><p>在日志文件增加检查点记录</p><ul><li><p>存储检查点时正在运行的事务清单</p></li><li><p>维护</p><ul><li><p>将<strong>日志缓存</strong>写入磁盘，同时增加一个检查点记录。</p></li><li><p>将<strong>数据缓存</strong>写入磁盘</p><blockquote><p>由此，检查点<strong>之前</strong>的提交的缓存事务<strong>不需要</strong>被加入正在执行的事务清单。</p></blockquote></li><li><p>将检查点记录的地址写入“重新开始”文件</p></li></ul></li><li><p>恢复</p><ul><li><p>从检查点开始进行日志扫描，从而对事务清单进行分类，得到撤销列表和重做列表。</p><blockquote><p>在正向扫描的过程中，可能会存在检查点之后才开始的事务。对于这些事务，一样需要把它们加入<strong>正在执行</strong>的事务清单。</p></blockquote></li><li><p>对两个列表中的事务采取不同操作</p></li></ul></li></ul></li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul><li>利用镜像来维护原始数据库</li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul><li>并发(Concurrency)：<strong>单</strong>处理器，<strong>逻辑</strong>并列。</li><li>并行(Parallel)：<strong>多</strong>处理器，<strong>物理</strong>并列。</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>主要：数据不一致</p><ul><li>丢失更新(Lost Update)：并发事务的结果出现了“不正常”覆盖</li><li>脏数据读出(Dirty Read)：数据处理未完成时被读出</li><li>不能重复读(Non-Repeatable Read)：数据在相邻读之间被更新，导致读操作无法复现。</li></ul><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li>合理调度并发事务，避免事务之间的互相干扰造成数据的不一致。</li></ul><h3 id="基本手段"><a href="#基本手段" class="headerlink" title="基本手段"></a>基本手段</h3><ul><li><p>封锁（上锁）</p></li><li><p>分类</p><ul><li><p>排它锁（<code>X</code>锁、独占锁）：<strong>只允许</strong>上锁事务<strong>读取和修改</strong>数据对象</p></li><li><p>共享锁（<code>S</code>锁）：上锁事务<strong>只能读</strong>数据对象，其他事务能够继续上<code>S</code>锁，但是不能上<code>X</code>锁。</p><blockquote><p>同一个数据对象可以有多个<code>S</code>锁，但是只能有一个<code>X</code>锁，并且两个锁不能同时出现。</p></blockquote></li></ul></li><li><p>相容矩阵</p><p><img src="https://i.loli.net/2020/11/20/VgGK16P2QrdtBqf.png" alt="image-20201120114606476" style="zoom:50%;" /></p></li><li><p>封锁协议：各级协议间是<strong>包含关系</strong>，<strong>不是并列</strong>。</p><ul><li><p>一级：事务在修改数据对象之前必须上<code>X</code>锁，等到<strong>事务结束</strong>后再释放锁。</p><blockquote><ul><li><p>事务结束$\neq$修改完成，因为可能是<strong>非正常结束(ROLLBACK)</strong>。</p></li><li><p>限制写，解决<strong>写间冲突</strong><code>Lost Update</code>；因为没有限制读操作，所以没有解决<strong>读写冲突</strong><code>Dirty Read</code>和<code>Non-Repeatable Read</code>.</p></li><li><p>Q：上了<code>X</code>锁不也限制了其他事务的读吗？</p><p>A：上<code>X</code>锁<strong>并不是不允许</strong>其他事务读，而是限制了其他事务上<code>S</code>锁。因此如果读之前不进行上锁操作，则不会受到<code>X</code>锁的限制，一样能够读到脏数据。</p></li></ul></blockquote></li><li><p>二级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>读完之后</strong>释放。</p><blockquote><p>解决了<code>Dirty Read</code>，但是由于<strong>上锁时间较短</strong>，所以依然可能出现<code>Non-Repeatable Read</code>.</p></blockquote></li><li><p>三级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>事务结束之后</strong>释放。</p><blockquote><p>解决了三种数据不一致问题</p></blockquote></li></ul></li><li><p>粒度：封锁对象的大小（被上锁的对象的大小）</p><ul><li><p>常见封锁对象：属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库、物理页、块等。</p></li><li><p>多粒度封锁：一个系统的封锁机制可以提供多种粒度</p><ul><li><p>多粒度树：根据数据对象及其之间的关系构造的树</p><ul><li><p>显式：锁<strong>直接</strong>加在事务需要的数据对象上 </p></li><li><p>隐式：锁加在事务需要的<strong>数据对象的上级结点</strong>上</p></li><li><p>上锁检查：显式锁和隐式锁都需要检查</p><ul><li>隐式锁需要检查<strong>所有</strong>的上级节点</li></ul><blockquote><p>包括<strong>下级结点的显式锁</strong>（下级结点的隐式锁在对当前结点的检查中就已经被判断了）</p></blockquote></li></ul></li></ul></li></ul></li><li><p>意向锁：表示<strong>下级节点</strong>被上了相应类型的锁（优化多粒度树上锁检查）</p><ul><li><p>在为对象上锁时，需要先对其<strong>所有</strong>上级节点添加意向锁。</p></li><li><p>在为对象解锁时，需要向上逐级为上级节点释放锁。</p><blockquote><p><strong>不能</strong>优化当前结点的<strong>隐式锁</strong>检查</p></blockquote></li><li><p>分类</p><ul><li><p>意向共享锁(<code>IS</code>, Intent Share Lock)</p></li><li><p>意向排它锁(<code>IX</code>, Intent Exclusive Lock)</p></li><li><p>意向共享排它锁(<code>SIX</code>, Share Intent Exclusive Lock)：对该对象加<code>S</code>锁后，再加<code>IX</code>锁。</p><blockquote><p><strong>不是</strong>下级对象的<code>IS</code>和<code>IX</code>的叠加</p></blockquote></li></ul></li><li><p>相容矩阵</p><p><img src="https://i.loli.net/2020/11/20/8KL7aMQVrhPAmRF.png" alt="image-20201120115143845" style="zoom:50%;" /></p><ul><li><p>上了<code>IS</code>后，可以上<code>IX</code>，反之亦然。</p><blockquote><p>意向锁来自不同的结点，所以<code>S</code>和<code>X</code>能够“同时出现”。</p></blockquote></li><li><p>可以多次上<code>IS</code>和<code>IX</code>锁</p></li><li><p>上了<code>IS</code>后，还可以上<code>S</code>和<code>IX</code>变成<code>SIX</code>；但是上了<code>IX</code>之后，<strong>不能</strong>再上<code>S</code>和<code>IX</code>变成<code>SIX</code>了。</p><blockquote><p>上了<code>IX</code>后<strong>不能</strong>再为下级结点隐式上<code>S</code>锁了</p></blockquote></li><li><p>上了<code>SIX</code>之后，还可以上<code>IS</code>，但是不能再上<code>IX</code>了。</p><blockquote><p>因为下级结点已经隐式上了<code>S</code>，不能再上<code>X</code>了。</p></blockquote></li></ul></li></ul></li></ul><h3 id="活锁和死锁"><a href="#活锁和死锁" class="headerlink" title="活锁和死锁"></a>活锁和死锁</h3><ul><li><p>活锁：系统正常运行，但是有些事务可能永远不能得到上锁机会。</p><ul><li>采用<code>FCFS</code>解决</li></ul></li><li><p>死锁</p><ul><li><p>预防</p><ul><li><p>一次封锁法：事务执行前为<strong>所有</strong>需要的资源上锁</p><ul><li>降低系统并发度</li></ul></li><li><p>顺序封锁法：为资源编号，事务执行时必须按照顺序对所需的资源上锁。</p><ul><li>实现难度大</li></ul><blockquote><p>不是按照顺序获取<strong>所有</strong>资源，而是在获取所需对象时按照顺序进行。</p></blockquote></li></ul></li><li><p>检测</p><ul><li>超时法：事务等待时间过长时认为发生死锁</li><li>等待图法：结点表示事务，边指向等待的事务，出现回路则发生死锁。</li></ul></li><li><p>恢复（解除）</p><ul><li><p>选择代价小的事务撤销</p><blockquote><p>撤销后，需要回滚该事务的所有操作</p></blockquote></li></ul></li></ul></li></ul><h3 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h3><ul><li><p>调度的单位是事务的<strong>操作</strong>，而<strong>不是</strong>事务本身。</p></li><li><p>事务执行正确性：保证数据库<strong>一致性</strong>的都是正确的执行结果</p><blockquote><p>不同执行顺序可能有不一样的执行结果（随机性），但可能都是正确的。</p></blockquote></li><li><p>可串行化：事务的并发执行正确$\Leftrightarrow$按照某一次序<strong>串行执行</strong>的结果和<strong>并发执行</strong>结果相同</p><ul><li>可串行化的并发调度是正确调度</li></ul></li><li><p>判定</p><ul><li><p><strong>冲突可串行化</strong>调度：调度$Sc$交换<strong>事务间不冲突</strong>操作的次序后，得到<strong>串行调度</strong>$Sc’$.</p><ul><li>不能交换<strong>事务间</strong>的冲突操作</li><li>不能交换<strong>一个事务内</strong>的操作</li></ul></li><li><p>冲突操作：读-写、写-写</p></li><li><p>充分条件：冲突可串行化调度$\Rightarrow$可串行化调度</p><blockquote><p>冲突可串行化调度$\Rightarrow$可串行化调度$\Rightarrow$正确调度</p></blockquote></li></ul></li><li><p>两段锁协议：保证并发调度可串行</p><ul><li>扩展阶段：读写操作执行前需要上锁</li><li>收缩阶段：开始释放锁之后，事务不再获取其他任何锁。</li></ul><blockquote><p>依然可能发生死锁</p></blockquote></li></ul><h2 id="Reference-7"><a href="#Reference-7" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li><a href="https://www.zhihu.com/question/31346392" target="_blank" rel="noopener">https://www.zhihu.com/question/31346392</a></li></ul><h1 id="Chapter8-数据库保护"><a href="#Chapter8-数据库保护" class="headerlink" title="Chapter8 数据库保护"></a>Chapter8 数据库保护</h1><p>全文共<code>732</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul><li>安全性(<code>security</code>)：防止不合法的使用造成的<strong>数据泄露</strong>、<strong>更改</strong>、<strong>破坏</strong>。</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul><li><p>用户标识和认证（最外层）</p><ul><li>常用：用户名和密码（口令）</li></ul></li><li><p>存取控制</p><ul><li><p>权限定义</p></li><li><p>权限检查</p></li><li><p>方法</p><ul><li><p>自主(<code>DAC</code>)：用户可以将权限转授</p><ul><li><p>权限=数据对象+操作类型</p></li><li><p>SQL</p><ul><li>用户级：操作数据库，例如创建外模式、创建会话、创建表等。</li><li>关系级：操作某个关系和视图，针对具体的对象，例如在某个表中进行CRUD操作。</li></ul></li><li><p>角色：一组权限的集合，可以授给<strong>用户或其他角色</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT CREATE SESSION to xxx; # 用户级</span><br><span class="line">GRANT CREATE TABLE to xxx; # 用户级</span><br><span class="line">REVOKE CREATE TABLE FROM xxx; # 用户级</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>强制(<code>MAC</code>)：不同数据对象有不同的加密等价，每个用户的许可证级别决定了能够访问哪些数据，由系统<strong>直接指定</strong>级别。</p><ul><li>实体=主体+客体</li><li>主体：实际用户</li><li>客体：系统中的被动实体，包括文件、基本表、索引、视图等。</li><li>许可证级别(<code>Label</code>，敏感度标记)<ul><li>主体<strong>大于等于</strong>客体：读</li><li>主体<strong>等于</strong>客体：写</li></ul></li></ul></li></ul></li><li><p>操作系统/网络安全保护</p></li><li><p>数据加密</p></li><li><p>其他</p><ul><li>视图：不同用户有不同的视图</li><li>审计：将用户对数据库的操作记录在审计日志中，出现安全问题时进行审查。</li></ul></li></ul><h3 id="可信系统评测"><a href="#可信系统评测" class="headerlink" title="可信系统评测"></a>可信系统评测</h3><ul><li>TCSEC</li><li>TDI</li></ul><h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul><li>完整性=正确性+相容性<ul><li>正确性：类型、取值范围</li><li>相容性：同一个事实的值应该相同</li></ul></li><li>确保数据库语义正确</li></ul><h3 id="约束条件-1"><a href="#约束条件-1" class="headerlink" title="约束条件"></a>约束条件</h3><ul><li>作用对象<ul><li>列：对属性进行约束</li><li>元组：元组间的<strong>字段</strong>约束（属性间约束）</li><li>关系：元组之间、关系之间的约束，例如实体完整性、参照完整性。</li></ul></li><li>时机<ul><li>静态：数据库在每一确定状态应该满足的约束</li><li>动态：新、旧值之间的约束，例如年龄只能上升不能下降。</li></ul></li></ul><blockquote><p>总共可以组合出3*2=6种约束条件</p></blockquote><h3 id="控制-1"><a href="#控制-1" class="headerlink" title="控制"></a>控制</h3><ul><li><p>定义</p></li><li><p>检查</p><ul><li>立即执行：<strong>语句</strong>执行完后立即检查</li><li>延迟执行：<strong>事务</strong>执行完毕后再进行检查</li></ul></li><li><p>违约相应</p></li><li><p>规则：$(D,O,A,C,P)$</p><ul><li><code>D</code>：数据本身</li><li><code>O</code>：操作</li><li><code>A</code>：断言</li><li><p><code>C</code>：<code>A</code>指定的谓词（自然语言约束的主语）</p></li><li><p><code>P</code>：违反规则时触发的过程</p></li></ul></li><li><p>SQL</p><ul><li><p><code>CREATE TABLE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NULL</span><br><span class="line">NOT NULL</span><br><span class="line">UNIQUE</span><br><span class="line">PRIMARY KEY</span><br><span class="line">FOREIGN KEY</span><br><span class="line">CHECK</span><br></pre></td></tr></table></figure></li><li><p><code>CREATE ASSERTION</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSERTION ASSE_NAME</span><br><span class="line">CHECK (60 &gt;&#x3D; ALL(SELECT COUNT(*) FROM SD GROUP BY C));</span><br></pre></td></tr></table></figure></li><li><p><code>CREATE TRIGGER</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Reference-8"><a href="#Reference-8" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li></ul><h1 id="Chapter9-数据库新技术"><a href="#Chapter9-数据库新技术" class="headerlink" title="Chapter9-数据库新技术"></a>Chapter9-数据库新技术</h1><p>全文共<code>2031</code>字，推荐阅读时间<code>10~15</code>分钟。</p><h2 id="数据仓库-Data-Warehouse"><a href="#数据仓库-Data-Warehouse" class="headerlink" title="数据仓库(Data Warehouse)"></a>数据仓库(<code>Data Warehouse</code>)</h2><ul><li><p>支持管理决策过程</p><blockquote><p>不同于数据库提供的<strong>日常业务查询</strong>服务</p></blockquote></li><li><p>面向主题</p><ul><li>从大量的历史数据中提取</li></ul></li><li><p>持久数据集合</p></li><li><p>业务</p><ul><li>OLAP：数据<strong>仓库</strong>联机<strong>分析</strong>处理</li><li>OLTP：数据<strong>库</strong>联机<strong>事务</strong>处理</li></ul></li><li><p>数据仓库系统</p><ul><li><p>数据源</p><ul><li>数据库</li><li>数据文件</li></ul></li><li><p>数据仓库管理工具</p><ul><li><p>数据建模工具：根据主题确定，例如学生就业情况。</p></li><li><p>抽取、转换、装载(<code>ETL</code>)</p></li><li><p>元数据库：描述数据的数据</p><blockquote><p>类似数据库中的数据字典</p></blockquote></li></ul></li><li><p>数据仓库</p><ul><li>高度综合数据：准决策数据</li><li>轻度综合数据：来自近期基本数据</li><li>当前数据：最近时期业务数据</li><li>历史数据：早期基本数据</li></ul></li><li><p>分析工具</p><ul><li>用户查询工具</li><li>OLAP工具</li><li>DM工具</li></ul></li><li><p>比较</p><ul><li><p>数据库</p><p><img src="https://pic4.zhimg.com/80/v2-bdc235fbdd1825c1b67ef7d609f81adb_1440w.jpg?source=1940ef5c" alt="img" style="zoom: 33%;" /></p><ul><li>一种事务处理技术</li><li>表格结构复杂，存储结构紧致，冗余数据少。</li><li>读写均进行优化</li><li>查询要求较简单，单次作用的数据量小。</li><li>常见：MySQL, Oracle, SqlServer.</li></ul></li><li><p>数据仓库</p><p><img src="https://pic4.zhimg.com/80/v2-ccefb7a678de237560cc4df80c11cca3_1440w.jpg?source=1940ef5c" alt="img" style="zoom:33%;" /></p><ul><li>一种体系结构</li><li>表格结构简单，存储结构松散，冗余数据多。</li><li>通常只优化读</li><li>查询要求较复杂，单次作用的数据量大。</li><li>常见：AWS Redshift, Hive.</li></ul><blockquote><ul><li>数据仓库是为某种特定的查询而设置的，是对数据库中多张表的整合，因此可以承担相应的分析工作。</li><li>数据仓库来自于“分析型数据库”，但也因此不满足数据库的一些规范，所以被改叫“数据仓库”。</li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="分布式数据库系统"><a href="#分布式数据库系统" class="headerlink" title="分布式数据库系统"></a>分布式数据库系统</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><p>基础：网络+数据库</p></li><li><p>结构</p><ul><li>全局应用=局部应用+网络，操作<strong>两个及以上</strong>节点中的数据库。</li><li>局部应用=数据库+服务器，操作<strong>一个</strong>节点中的数据库。</li></ul><blockquote><p>结构必须完整，缺一不可。</p></blockquote></li><li><p>前提：数据分布存储</p><ul><li>场地自治性</li><li>场地协作性</li></ul></li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>数据独立性<ul><li>逻辑</li><li>物理</li><li><strong>分布</strong>（分布透明性）：数据的存储特征（分片、位置等）和用户/应用程序无关</li></ul></li><li>控制结构：集中和自治相结合<ul><li>共享<ul><li>局部</li><li>全局</li></ul></li></ul></li><li>适当增加数据冗余：在不同节点存储同一数据的多个副本<ul><li>提高系统可靠性、可用性</li><li>提高系统性能</li><li>不利于更新，增大了系统维护代价。</li></ul></li><li>全局一致性、可串行性、可恢复性</li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">全局外模式--&gt;|映象1|全局概念模式</span><br><span class="line">全局概念模式--&gt;|映象2|分片模式</span><br><span class="line">分片模式--&gt;|映象3|分布模式</span><br><span class="line">分布模式--&gt;|映象4|局部概念模式</span><br></pre></td></tr></table></figure><ul><li>全局概念模式定义了数据库的整体逻辑结构</li><li>分片模式定义了数据库关系的全局关系的分片方式</li><li>分布模式定义了各片段的存储位置，进而决定了数据库是否冗余。</li><li>各级映像中存储了上级模式到下级模式的映射关系</li></ul><blockquote><p>映象的作用类似虚拟地址和物理地址的转换。例如，映象1为外模式在概念模式中选取合适的部分进行构造；映象2的作用就是为每个关系指定合适的分片方式；映象3则是为每个分片方式确定合适的存储位置（虚拟，类似数据库1、2、3…）；映象4将分布模式中的虚拟存储位置映射到现实中的物理存储位置。</p><p>综上，模式是<strong>“原则/方法/定义”</strong>的集合，映象是集合间的映射关系，通常是在下级映象中进行选择，然后返回结果由上级映象使用。</p></blockquote><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul><li><p>水平：关系模式不变，将元组进行分割。</p></li><li><p>垂直：对属性集合进行划分</p><blockquote><p>为了具有可复原性，<strong>通常</strong>让各个片段都具有原关系的码。（不是必要条件）</p></blockquote></li><li><p>导出：利用其他关系模式的属性对某一关系进行水平分片。</p><blockquote><p>连表后选择，然后再去掉多余属性。</p></blockquote></li><li><p>混合</p></li></ul><h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5><ul><li>完全性：各个片段的并需要涵盖全局关系的所有信息</li><li>不相交性</li><li>可重构性：片段可以重构全局关系<ul><li>水平：并</li><li>垂直：自然连接</li></ul></li></ul><h4 id="分布透明性"><a href="#分布透明性" class="headerlink" title="分布透明性"></a>分布透明性</h4><ul><li><strong>分片</strong>透明性（分片模式）</li><li><strong>位置</strong>透明性（分布模式）</li><li>局部数据模型透明性（局部概念模式）：用户/应用程序不关心节点的DBMS类型（使用统一的查询语言）</li></ul><h4 id="DDBMS"><a href="#DDBMS" class="headerlink" title="DDBMS"></a>DDBMS</h4><ul><li>LDBMS：场地自治，执行局部应用及全局查询的<strong>子查询</strong></li><li>GDBMS：提供分布透明性，保证数据库的全局一致性。<ul><li>协调全局事务的执行</li><li>协调局部DBMS</li><li>并发控制</li><li>更新同步</li><li>全局恢复</li></ul></li><li>GDD<ul><li>全局概念模式、分片模式、分布模式、各级映象</li><li>用户权限定义</li><li>完整性约束条件</li></ul></li><li>CM：通信管理</li></ul><h5 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5><ul><li>全局控制<strong>集中</strong>：GDD和GDBMS集成在一起<ul><li>控制简单</li><li>易形成<strong>性能</strong>瓶颈</li><li>可靠性低</li></ul></li><li>全局控制<strong>分散</strong><ul><li>完全：GDBMS和GDD分布在<strong>每个</strong>节点上<ul><li>节点独立</li><li>自治性强</li><li>控制复杂</li></ul></li><li>部分：GDBMS和GDD分布在<strong>某些</strong>节点上</li></ul></li><li>同构型：各个节点的DBMS相同</li><li>异构型：各个节点的DBMS不同</li></ul><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><h5 id="分类-5"><a href="#分类-5" class="headerlink" title="分类"></a>分类</h5><ul><li>局部</li><li>远程</li><li>全局</li></ul><blockquote><p>局部和远程查询<strong>只</strong>涉及<strong>单个</strong>节点，全局查询涉及<strong>多个</strong>节点。</p></blockquote><h5 id="处理-1"><a href="#处理-1" class="headerlink" title="处理"></a>处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">查询分解--&gt;确定操作次序</span><br><span class="line">确定操作次序--&gt;选择操作执行方法</span><br></pre></td></tr></table></figure><h5 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h5><p>查询开销=I/O代价+CPU代价+通信代价（主要）</p><ul><li><p>分类</p><ul><li><p>分布优化（<strong>更重要</strong>）</p><ul><li><p>传送时间T=总传输延迟（由网络本身决定）+总数据量/传输速度</p><blockquote><p>问答方式中通常会<strong>忽略</strong>传送时间而<strong>只考虑</strong>传输延迟</p></blockquote></li></ul></li><li><p>局部优化</p></li></ul></li><li><p>目标：减小通信代价</p><blockquote><p>通信代价通常来自于不同节点间的<strong>连接和并</strong>操作</p></blockquote></li><li><p>技术</p><ul><li><p>半连接：在连接之前，先对其中某个关系进行所需属性的投影，然后再进行连接。</p><p>$R_3=R_1{\ltimes}_{A=B} R_2=R_1{\bowtie}_{A=B}(\Pi_B(R_2))$</p><ul><li><p>得到的结果是<strong>没有投影</strong>的关系$R_1$的子集</p><blockquote><p>从$R_1$中提取出了<strong>有用</strong>的元组</p></blockquote></li><li><p>$R_1\bowtie R_2=(R_1\ltimes R_2)\bowtie R_2$</p><blockquote><p>连接=半连接+连接=投影+连接+连接</p></blockquote></li><li><p>在使用优化技术之前，需要进行估算。</p></li></ul></li></ul></li><li><p>分布事务处理</p><ul><li><p><code>NewSQL</code></p></li><li><p>原子性：全局事务的子事务要么一起提交，要么全部回滚。</p></li><li><p>可串行性：多用户系统</p></li><li><p>恢复：两段提交协议</p><ul><li>局部事务管理<ul><li>协调者（一个）</li><li>参与者（多个）</li></ul></li><li>第一阶段：协调者征求意见做决定</li><li>第二阶段：参与者执行决定</li></ul></li><li><p>并发控制：封锁技术</p><ul><li><p>写操作需要申请<strong>所有</strong>副本的<code>X</code>锁，读操作<strong>只要</strong>申请一个副本的<code>S</code>锁。</p></li><li><p>读/写操作均对<strong>大多数</strong>副本申请<code>X</code>和<code>S</code>锁</p><blockquote><p>大多数指“<strong>大于</strong>一半”，所以上锁时一定会出现相交情况。</p></blockquote></li><li><p>设置主副本，所有读/写都需要对主副本上锁。</p></li><li><p>全局死锁解决（<strong>两个及以上</strong>场地发生死锁）</p><ul><li>检测及解除</li><li>预防</li></ul></li></ul></li></ul></li></ul><h2 id="Reference-9"><a href="#Reference-9" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2020 BUAA Database Course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/C++%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/C++%20Learning%20Note/</id>
    <published>2021-06-23T12:34:24.552Z</published>
    <updated>2021-06-23T12:37:05.831Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全文共<code>2981</code>字，为暑期C++学习记录，推荐按照顺序阅读。</strong></p><a id="more"></a><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li><p>每个<code>.h</code>文件智能定义一个<code>class</code></p></li><li><p>函数主体放在<code>.cpp</code>中</p></li><li><p><code>.h</code>文件需要使用标准头文件格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NAME_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NAME_H_</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul><li>变量是对象自己的</li><li>函数是类的<ul><li>隐藏了<code>this</code>参数将对象传进类的函数</li></ul></li><li>私有变量通过<code>::</code>也<strong>不能</strong>访问</li></ul><h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><p>创建对象时使用</p></li><li><p>和类同名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    A(); <span class="comment">// no return type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A()</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>没有参数</strong>的构造函数<strong>都叫</strong><code>default constructor</code>，不一定是编译器默认创造的。</p></blockquote></li><li><p>参数化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree::Tree(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">t</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass c1;<span class="comment">//表示使用不带参数的构造函数，或者有默认参数值的构造函数。</span></span><br><span class="line"><span class="function">MyClass <span class="title">c2</span><span class="params">()</span></span>;<span class="comment">//不会调用无参构造函数,各种情况下该处是声明一个返回值为MyClass类型的函数而已</span></span><br><span class="line"><span class="function">MyClass <span class="title">c3</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//调用参数为int的构造函数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li><p>销毁对象时使用</p><blockquote><p>对象的生存周期是<strong>大括号</strong></p></blockquote></li><li><p>无参数，在构造函数前加一个<code>~</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> height; <span class="comment">// default to be private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> initialHeight);</span><br><span class="line">    ~Tree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> years)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new&amp;delete"></a>new&amp;delete</h2><ul><li><p>delete不能操作没有new的空间</p></li><li><p>delete对同一个对象不能连续使用两次</p></li><li><p>delete[]和new[]需要<strong>成对</strong>使用</p></li><li><p>在delete之前最好判断一下是否是空指针（是空指针<strong>大多数情况</strong>也安全）</p></li><li><p>new创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------对于new关键字加括号和不加括号的区别---</span></span><br><span class="line"><span class="comment">1.对于自定义类型来说没有区别，都是使用默认构造函数</span></span><br><span class="line"><span class="comment">2.对于内置类型来说加括号会初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">MyClass *c4 = <span class="keyword">new</span> MyClass();</span><br><span class="line">c4-&gt;MyMethod();</span><br><span class="line">MyClass *c5 = <span class="keyword">new</span> MyClass(<span class="number">1</span>);</span><br><span class="line">c5-&gt;MyMethod();</span><br><span class="line">MyClass *c6 = <span class="keyword">new</span> MyClass;</span><br><span class="line">c6-&gt;MyMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *pint1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> *pint2 = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// *pint2 is 0</span></span><br><span class="line"><span class="keyword">int</span> *pint3 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// *pint3 is a random number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*pint1&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint2&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint3&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><code>new</code>创建对象需要<strong>指针</strong>接收</li><li><code>new</code>创建对象需要<code>delete</code>销毁</li><li><code>new</code>创建的对象在<strong>堆</strong>上，不使用<code>new</code>创建的对象在<strong>栈</strong>上。</li></ul></li></ul><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul><li><p><code>private</code>的变量在类的函数中可以被<strong>其他的对象</strong>访问，即同类对象可以相互访问私有变量。</p><blockquote><p><code>private</code>只在编译时有限制</p></blockquote></li><li><p>使用<code>friend</code>授权某些函数访问<strong>私有变量</strong></p></li><li><p>class的访问属性默认为<code>private</code>，struct默认为<code>public</code>.</p></li></ul><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> x, y;</span><br><span class="line">    Point(<span class="keyword">float</span> xa = <span class="number">0.0</span>, <span class="keyword">float</span> ya = <span class="number">0.0</span>): x(xa), y(ya)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>初始化列表在构造函数<strong>之前</strong>执行</p></li><li><p>和构造器赋值的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(String s): name(s)&#123;&#125;</span><br><span class="line">Student::Student(String s) &#123;name = s;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>推荐使用初始化列表进行对象的初始化。</p><p>在构造器赋值时，如果有一个成员变量是自定义类的对象，并且该类没有无参数构造函数，那么在构造函数中对该对象赋值时就会报错。（因为在<strong>构造函数</strong>中，会默认调用无参数构造函数）</p></blockquote></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>名称隐藏：当子类覆写父类函数时，所有的父类函数都会被子类屏蔽。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> ii) : i(ii) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : A(<span class="number">15</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.print(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>b</code><strong>没有</strong>无参数的<code>print</code>方法</p></blockquote></li></ul><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><ul><li><p>只能在<code>.h</code>（函数声明）时设置默认值，<strong>不可以</strong>在函数定义处使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j=<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>和Python不同的是，修改<code>j</code>时直接传数据即可，<strong>不需要</strong>写参数名称。</p></li><li><p>尽量<strong>不使用</strong>默认参数值</p></li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li><p>在调用的地方直接展开，减少调用函数时的栈操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b = f(a); <span class="comment">// int b = a * 2;</span></span><br><span class="line">    <span class="keyword">int</span> c = f(<span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内联函数的定义<strong>不在</strong><code>.cpp</code>文件中，而应该和声明<strong>都放在</strong><code>.h</code>中</p><blockquote><p>因为<code>inline</code>告诉编译器这是个<strong>函数声明</strong>而不是定义，在<strong>使用函数</strong>的地方再进行展开。</p></blockquote></li><li><p>当<code>inline</code>函数太大时（例如递归），编译器可能会拒绝展开。</p></li><li><p>类的<code>.h</code>文件中直接写出函数体的函数<strong>都是</strong>内联函数，在<code>.h</code>中也可以单独声明内联函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is a inline function defined in header file."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环体中的<strong>小函数</strong>推荐使用内联函数</p></li><li><p>和宏相比，内联函数可以做类型检查，更加安全。</p></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li><p><strong>不可修改</strong>机制是在编译时确定的，因此是编译器进行检查。</p><ul><li><p>编译时确定的值可以用来声明数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_size = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> finalGrade[class_size];</span><br></pre></td></tr></table></figure></li><li><p><code>const</code>在<code>*</code>前后对指针的影响</p><ul><li><p>在<code>*</code>前：<strong>对象</strong>是<code>const</code>（<strong>不能</strong>通过该指针改变对象，但是<strong>可以</strong>通过其他指针）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;a;</span><br><span class="line">*p2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person *p = &amp;p1;</span><br><span class="line">Person <span class="keyword">const</span> *p = &amp;p1;</span><br></pre></td></tr></table></figure></li><li><p>在<code>*</code>后：<strong>指针</strong>是<code>const</code>（<strong>不能</strong>改变该指针的指向）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *<span class="keyword">const</span> p = &amp;p1;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>普通指针<strong>不能</strong>指向<code>const</code>变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">3</span>;</span><br><span class="line">ip = &amp;ci; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>不可</strong>修改对象的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::get_day</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    day++; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在声明和定义处要重复<code>const</code></p></li><li><p>便于编译器对<code>const</code>对象调用方法时进行安全检查</p></li><li><p>本质是将<code>this</code>设置为<code>const</code></p></li><li><p><code>const</code>可以实现重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : i(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    ~A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f() with const"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> A a;</span><br><span class="line">    a.f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>const</code>对象<strong>只能</strong>调用<code>const</code>函数</li></ul></li></ul></li><li><p><code>const</code>成员变量必须在<strong>初始化列表</strong>中初始化（<strong>不可以</strong>在构造函数中进行）</p></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p>一种访问对象的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;p = c;</span><br></pre></td></tr></table></figure><ul><li>引用<strong>必须</strong>初始化（成员变量、函数参数除外）</li><li>引用相当于是<strong>别名</strong></li><li>引用的目的就是为了减少代码中的<code>*</code></li></ul></li><li><p>引用和指针的比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">(<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>不同于</strong>指针，引用在执行过程中<strong>不能</strong>改变对象。</p></li><li><p>引用<strong>不能</strong>是<code>NULL</code></p></li><li><p>传入的<code>x</code>在两种情况中<strong>都会</strong>被修改</p></li><li><p>传入函数的参数<strong>不是指针</strong>时，也<strong>可能</strong>被修改。</p></li><li><p>引用是由<code>const</code>指针实现的</p></li><li><p>引用的引用实际上<strong>不存在</strong>，只是改变了引用的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> &amp;a = x;</span><br><span class="line"><span class="keyword">int</span> &amp;b = y; </span><br><span class="line"></span><br><span class="line">b = a; <span class="comment">// y = x, but not b refer to a.</span></span><br></pre></td></tr></table></figure><blockquote><p>Java的引用实际上对应C++的指针</p></blockquote></li><li><p>引用的指针可以存在，但是指针的引用不存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;*p1; <span class="comment">// illegal</span></span><br><span class="line"><span class="keyword">int</span> *&amp;p2; <span class="comment">// reference to pointer</span></span><br></pre></td></tr></table></figure><blockquote><p>引用<strong>没有</strong>地址</p></blockquote></li><li><p><strong>没有</strong>引用数组（因为引用并不是实体，<strong>没有</strong>地址）</p></li></ul></li><li><p>引用作为成员变量时，需要在初始化列表中写上这个引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> &amp;b): a(b) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为返回值时，最好<strong>不是</strong>局部变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> &amp;<span class="title">subscript</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为函数参数传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">int</span>&amp;z)</span></span>&#123;</span><br><span class="line">    z *= <span class="number">5</span>; <span class="comment">// OK</span></span><br><span class="line">    y += <span class="number">8</span>; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>传<strong>非</strong><code>const</code>引用时<strong>不可以</strong>是算式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li><p>动态调用的方法需要使用<code>virtual</code>关键字声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在父类中声明一次<code>virtual</code>后，所有子类中的函数都是虚函数，可以省略<code>virtual</code>，但是推荐加上。</li><li>所有含虚函数的类的对象都会增加一个<code>vptr</code>指针，指向类自己的<code>vtable</code>，存储了<strong>该类</strong>所有的虚函数。</li></ul></li><li><p>继承关系对象的赋值<strong>不改变</strong><code>vtable</code>（与指针赋值不同）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a = b;</span><br><span class="line">a.f(); <span class="comment">// A's f() instead of B's</span></span><br></pre></td></tr></table></figure></li><li><p>析构函数需要是<code>virtual</code>的</p></li><li>多态需要使用指针实现，<strong>不能</strong>通过<code>.</code>实现。</li></ul><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><ul><li><p>编译器默认的拷贝构造是浅拷贝</p><ul><li><p>当字符串是<code>char *</code>时，内存会被<code>delete</code>两次，这样会发生错误。因此Cpp通常使用<code>string</code>类来定义字符串。</p><blockquote><p>尽管是浅拷贝，标准库中的类<strong>也不会</strong>出现内存问题。</p></blockquote></li></ul></li><li><p>拷贝构造和<strong>初始化</strong>的形式相同，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = p;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>一个类必须声明的三个函数</p><ul><li><p>默认构造函数（参数列表为空）</p></li><li><p><code>virtual</code>的析构函数</p></li><li><p>自定义的拷贝构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(<span class="keyword">const</span> ClassName &amp;p) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>Cpp保证对象只被构造一次</li><li><code>static</code>让对象变成全局的</li></ul><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><ul><li><p>通过<code>static</code>成为和对象<strong>无关</strong>的变量</p></li><li><p>类中只是<strong>声明</strong>，需要单独定义后才能使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;i = <span class="number">0</span>;&#125; <span class="comment">// A():i(0) &#123;&#125; is illegal</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::i; <span class="comment">// not static int A::i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a, b;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">    b.print();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化列表只能对<strong>非静态</strong>成员变量使用</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>调用<ul><li>对象：<code>a.f()</code></li><li>类：<code>A::f()</code></li></ul></li><li>在静态函数中<strong>没有</strong><code>this</code>参数</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>在Cpp中，几乎所有的运算符都可以被重载，除了<code>./.*/::/?:</code>.</li><li>重载只能在类/枚举类发生</li><li>优先级、运算格式<strong>不能</strong>改变。</li><li><p>关键字<code>operator</code>+运算符表示重载函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> *(...);</span><br><span class="line"><span class="keyword">const</span> String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String &amp;that);</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp;n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(i + n.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z = x + y; <span class="comment">// OK</span></span><br><span class="line">z = x + <span class="number">3</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + <span class="number">7</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + y; <span class="comment">// Error!</span></span><br><span class="line">z = x + <span class="number">3.5</span> <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li><p>设置全局函数解决<code>z=3+y</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(l.i + r.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一元运算符<strong>不需要</strong>设置参数，应该是成员的。</li><li><code>=/()/[]/-&gt;/-&gt;*</code><strong>必须是</strong>成员的</li><li>其他二元运算符<strong>最好是</strong>全局的</li></ul></li></ul></li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><p><code>+-*/%^&amp;|~</code>:<code>const T operatorX(const T &amp;l, const T&amp;r) const;</code></p></li><li><p><code>!/&amp;&amp;/||/&lt;/&lt;=/==/&gt;=/&gt;</code>:<code>bool operatorX(const T &amp;l, const T &amp;r) const;</code></p></li><li><p><code>[]</code>:<code>T &amp;T::operator[](int index);</code></p></li><li><p><code>++/--</code>：参数填一个占位<code>int</code>表示<strong>后置</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Integer &amp;<span class="keyword">operator</span>++() <span class="comment">// ++a</span></span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>++(<span class="keyword">int</span>) <span class="comment">// a++</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName a = b; <span class="comment">// copy construct</span></span><br><span class="line">a = b; <span class="comment">// assign</span></span><br></pre></td></tr></table></figure><ul><li><p>标准写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T &amp;T::<span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;r) &#123;</span><br><span class="line">        <span class="comment">// assign</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自己和自己相等进行赋值时，若成员中有指针，可能出现指针被改变后导致原来的内容无法访问，从而赋值失败的问题。</li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>禁止<strong>隐式</strong>类型转换：<code>explicit</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Two</span><span class="params">(class One &amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">one = two <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li>定义在<code>Two</code>中</li></ul></li><li><p>强制类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassName::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>定义在<code>One</code>中（不是<code>double</code>）</li><li><strong>没有</strong>返回类型</li></ul><blockquote><ul><li>两者地位相同，有哪种用哪种。</li><li>两种类型转换<strong>只能</strong>存在一种，除非第一种加了<code>explicit</code>.</li></ul></blockquote></li><li><p>不推荐使用默认转换，应该写成显式的转换方法<code>toXXX()</code>.</p></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>重用代码的一种方式，类似于Java中的泛型编程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // &lt;class Key, class Value&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">foo</span>(<span class="title">void</span>) &#123;</span><span class="comment">/* ... */</span>&#125;</span><br><span class="line">foo&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// type for T is int</span></span><br><span class="line">foo&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure></li><li><p>指定其他参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">bounds</span> = 100&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>继承</p><ul><li><p>模板之间不能继承，只能用来指定父类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> List&lt;A&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125; <span class="keyword">catch</span> (VectorIndexError &amp;e) &#123;</span><br><span class="line">    <span class="comment">// throw;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>不带对象的<code>throw</code>就是抛出<strong>原异常</strong></p></li><li><p><code>catch(...)</code>捕捉<strong>所有的</strong>异常，但是没有办法确定具体是哪一种。</p></li><li><p>函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a)</span> : <span class="title">throw</span><span class="params">(MathErr)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数抛异常之前，使用<code>delete this;</code>防止出现内存垃圾。</p></li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li><p>自定义类的输入流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>&gt;&gt;(istream &amp;is, T &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// construct obj</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul><li>包含常见的数据结构和算法<ul><li><code>Vector</code></li><li><code>List</code></li><li><code>Deque</code></li><li><code>Sets &amp; Maps</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;全文共&lt;code&gt;2981&lt;/code&gt;字，为暑期C++学习记录，推荐按照顺序阅读。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm Course Note</title>
    <link href="http://yoursite.com/2021/06/23/Algorithm%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/Algorithm%20Course%20Note/</id>
    <published>2021-06-23T12:31:27.612Z</published>
    <updated>2021-06-23T12:39:00.682Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2020 BUAA Algorithm Course.</strong></p><a id="more"></a><h1 id="Chapter0-Introduction"><a href="#Chapter0-Introduction" class="headerlink" title="Chapter0 Introduction"></a>Chapter0 Introduction</h1><p>Total Count: <code>161</code> words</p><p>Preferred Reading Time: <code>3~5</code> minutes</p><h2 id="Syllabus"><a href="#Syllabus" class="headerlink" title="Syllabus"></a>Syllabus</h2><ul><li>Basics</li><li>Divide and Conquer</li><li>DP</li><li>Greedy</li><li>Graph</li><li>Hard Problems</li></ul><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ul><li>Design</li><li>Analyze</li></ul><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><ul><li>Computational Problem</li><li>Instance</li><li>Algorithm</li></ul><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><ul><li>Memory</li><li>Running time(focus of course)<ul><li>computer</li><li>implementation details</li><li>input(size etc.)</li></ul></li></ul><h3 id="Machine-independent-running-time"><a href="#Machine-independent-running-time" class="headerlink" title="Machine-independent running time"></a>Machine-independent running time</h3><ul><li>depend on quantity of <strong>primitive operations</strong><ul><li>addition</li><li>multiplication</li><li>comparison</li></ul></li><li>$T(n)$:denote the running time of n-size input<ul><li>n<ul><li>sorting: items to be sorted</li><li>graph: vertices and edges</li></ul></li></ul></li><li>Best Case: an instance for given size <code>n</code> results in the most efficient situation<ul><li>eg. A sorted list for insertion sort</li></ul></li><li>Worst Case<strong>(Mostly Used)</strong>: opposite to Best Case<ul><li>eg. A rev-sorted list for insertion sort</li></ul></li><li>Average Case: based on probability of all situations </li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li><p>$Θ(n)$ notation</p><ul><li><p>a supplement of <code>T(n)</code> notation</p><blockquote><p>$T(n)$ is exact while $Θ(n)$ is approximate</p></blockquote></li><li><p>eg. Mergesort</p><p>$T(n) = 2T(n/2) + Θ(n)\ (n&gt;1)$</p><p>$T(n)=Θ(1)\ (n=1)$</p><blockquote><p>Recursive notation</p></blockquote></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter1-Asymptotic-Notations-And-Recurrence"><a href="#Chapter1-Asymptotic-Notations-And-Recurrence" class="headerlink" title="Chapter1 Asymptotic Notations And Recurrence"></a>Chapter1 Asymptotic Notations And Recurrence</h1><p>Total Count: <code>291</code> words</p><p>Preferred Reading Time: <code>5~10</code> minutes</p><h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><h3 id="Big-Oh"><a href="#Big-Oh" class="headerlink" title="Big-Oh"></a>Big-Oh</h3><ul><li><p><strong>Upper</strong> bounds</p></li><li><p>$f(n)=O(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\leq{c*g(n)}\ (c&gt;0, n&gt;n0)$</p></li><li><p>Example</p><ul><li>$sin(n)=O(1)$</li><li>$log(n!)=O(nlog(n))$</li><li>$\sum{1/n}=O(log(n))$</li></ul></li><li><p>$log_{b_1}(n)=O(log_{b_2}(n))$</p><blockquote><p>Bases in <code>O</code> notation are usually omitted.</p></blockquote></li></ul><h3 id="Big-Omega"><a href="#Big-Omega" class="headerlink" title="Big-Omega"></a>Big-Omega</h3><ul><li><p><strong>Lower</strong> bounds</p></li><li><p>$f(n)=Ω(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\geq{c*g(n)}\ (c&gt;0,n&gt;n0)$</p></li><li><p>Example</p><ul><li><p>$\sum{1/n}=Ω(log(n))$</p><blockquote><p><code>log(n)</code> is both bounds above and below, the difference is coefficient.</p></blockquote></li></ul></li></ul><h3 id="Big-Theta"><a href="#Big-Theta" class="headerlink" title="Big-Theta"></a>Big-Theta</h3><ul><li><strong>Tight</strong> bounds</li><li>$f(n)=Θ(g(n))$ when $f(n)=O(g(n))$ and $f(n)=Ω(g(n))$</li></ul><h2 id="Recurrence"><a href="#Recurrence" class="headerlink" title="Recurrence"></a>Recurrence</h2><script type="math/tex; mode=display">\begin{cases} T(n)=3T(n/4)+n^2&(n>1) \\ 1&(n=1) \tag{1} \end{cases}</script><ul><li>$n^2$ is workload of first level</li></ul><h3 id="Recursion-tree-Method"><a href="#Recursion-tree-Method" class="headerlink" title="Recursion-tree Method"></a>Recursion-tree Method</h3><p>$T(n) \leq n^2+3/16n^2+(3/16)^2n^2 + … =O(n^2)$</p><h3 id="Substitution-Method"><a href="#Substitution-Method" class="headerlink" title="Substitution Method"></a>Substitution Method</h3><p>Prove $T(n) \leq cn^2$.</p><p>$T(n)=3T(n/4)+n^2 \le3c(n/4)^2 =cn^2-(13c/16-1)n^2 \leq cn^2 (c\geq16/13)$</p><p>So when $c\geq16/13$, we can prove $T(n)\leq cn^2$.</p><blockquote><p>Since $T(n) \geq n^2$, then $Θ(n)=Ω(n)=O(n)$.</p></blockquote><h3 id="Master-Method-and-Master-Theorem"><a href="#Master-Method-and-Master-Theorem" class="headerlink" title="Master Method and Master Theorem"></a>Master Method and Master Theorem</h3><p>If $T(n)=aT(upper(\frac{n}{b}))+O(n^d)(a&gt;0,b&gt;1,d\geq0)$, then</p><script type="math/tex; mode=display">T(n)=\begin{cases} O(n^d)&d>lob_ba,b^d>a \\ O(n^dlogn)&d=lob_ba,b^d=a \\ O(n^{log_b{a}})&d<lob_ba,b^d<a \end{cases}</script><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter2-Divide-and-Conquer"><a href="#Chapter2-Divide-and-Conquer" class="headerlink" title="Chapter2 Divide and Conquer"></a>Chapter2 Divide and Conquer</h1><p>Total Count: <code>559</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><h2 id="MCS"><a href="#MCS" class="headerlink" title="MCS"></a>MCS</h2><ul><li>Maximum Contiguous Subarray<ul><li>Find the span of years in which the company earned most</li></ul></li></ul><h3 id="Exhaustive-Search"><a href="#Exhaustive-Search" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_Val</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^3)$</li></ul><h3 id="Data-Reuse"><a href="#Data-Reuse" class="headerlink" title="Data-Reuse"></a>Data-Reuse</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_val</span></span><br></pre></td></tr></table></figure><ul><li>$V(i,j)=V(i,j-1)+A[j]$</li><li>$O(n^2)$</li></ul><h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input A[s...t]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s == t:</span><br><span class="line">    retun A[s] <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    MCS(A, s, mid) <span class="comment"># T(n/2)</span></span><br><span class="line">    MCS(A, mid, t) <span class="comment"># T(n/2)</span></span><br><span class="line">    <span class="comment"># find the max_val of cut position containing A[mid] and A[mid+1]</span></span><br></pre></td></tr></table></figure><ul><li>Be cautious the array may be at the cut position.</li><li>When finding the <code>max_val</code> containing <code>A[mid]</code> and <code>A[mid+1]</code>, we can do it from <code>mid</code> to <code>0</code>.</li><li>$T(n)=2T([n/2])+n$</li><li>$O(nlogn)$</li></ul><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, temp, ans, temp_sum;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">    temp_sum = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// When temp_sum &lt; 0, it means last temp &lt; 0, and last temp has already been compared with ans to decide whether to update the start point of the sub-array.</span></span><br><span class="line">        temp_sum = max(<span class="number">0</span>, temp_sum); </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        temp_sum += temp;</span><br><span class="line">        ans = max(temp_sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Counting-inversions"><a href="#Counting-inversions" class="headerlink" title="Counting inversions"></a>Counting inversions</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># count inversion</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^2)$</li></ul><h3 id="Merge-Sort-Idea"><a href="#Merge-Sort-Idea" class="headerlink" title="Merge Sort Idea"></a>Merge Sort Idea</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(L) == <span class="number">0</span>:</span><br><span class="line">    reutrn <span class="number">0</span>, L</span><br><span class="line">cnt_a, A = sort_and_count(L[l, mid])</span><br><span class="line">cnt_b, B = sort_and_count(L[mid+<span class="number">1</span>, r])</span><br><span class="line">cnt_c, L = merge_and_count(L[l, mid], L[mid+<span class="number">1</span>, r])</span><br><span class="line"><span class="keyword">return</span> cnt_a + cnt_b + cnt_c, L</span><br></pre></td></tr></table></figure><ul><li>Increase inversion count when merging sorted two list.</li><li>$O(nlogn)$</li></ul><h2 id="Polynomial-Multiplication"><a href="#Polynomial-Multiplication" class="headerlink" title="Polynomial Multiplication"></a>Polynomial Multiplication</h2><h3 id="Brute-Force-1"><a href="#Brute-Force-1" class="headerlink" title="Brute Force"></a>Brute Force</h3><ul><li>compute all coefficients and merge them at last<ul><li>multiplications:$O(n^2)$</li><li>addition:$O(n^2)$</li><li>complexity:$O(n^2)$</li></ul></li></ul><h3 id="Divide-and-Conquer-1"><a href="#Divide-and-Conquer-1" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><ul><li>extract $x^{\frac{n}{2}}$ to make size <code>n</code> problem into $2*2$ problem</li><li>$O(n^2)$</li></ul><h4 id="Improve"><a href="#Improve" class="headerlink" title="Improve"></a>Improve</h4><ul><li>We need $A_0B_1+A_1B_0$ instead of $A_0B_1$and$A_1B_0$.<ul><li>$\begin{cases} U=A_0B_0 \\ V=A_0B_1 \\ W=A_1B_0 \\ Z=A_1B_1\end{cases}$</li><li>Take $Y=(A_0+A_1)(B_0+B_1)$, then we can get $A_0B_1+A_1B_0=Y-U-Z$.</li><li>$T(n)=\begin{cases} 3T(n/2) + n&amp;(n&gt;1) \\ 1&amp;(n=1) \end{cases}$</li></ul></li></ul><h2 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h2><ul><li>partition with pivot as a benchmark</li><li>place pivot into right place</li><li>above can be a recursive process</li><li>$O(nlogn)$: the average complexity</li></ul><h3 id="Improve-1"><a href="#Improve-1" class="headerlink" title="Improve"></a>Improve</h3><ul><li><p>The normal complexity of quicksort is $O(n^2)$ because the array may be partially sorted.</p><p>$T(n)=T(0)+T(n-1)+O(n)$</p><blockquote><ul><li>The complexity of quick sort is $O(n^2)$ instead of $O(nlogn)$.</li><li>$O(n)$ comes from the count of key comparisons.</li></ul></blockquote></li><li><p>Adopt random pivot to get randomized partition</p><ul><li>Swap random position with the last position for reuse the partition function</li><li>This action can validly lower the probability to encounter unlucky array partition</li></ul></li></ul><h4 id="Expected-Case"><a href="#Expected-Case" class="headerlink" title="Expected Case"></a>Expected Case</h4><ul><li>Analysis for randomization algorithm</li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter3-Dynamic-Programming"><a href="#Chapter3-Dynamic-Programming" class="headerlink" title="Chapter3 Dynamic Programming"></a>Chapter3 Dynamic Programming</h1><p>Total Count: <code>906</code> words</p><p>Preferred Reading Time: <code>20~25</code> minutes</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><p>Similar to Divide and Conquer, but when subproblems overlap, DP is preferred.</p><blockquote><ul><li>Recurrence is from top to bottom, while DP is from bottom to top.</li><li>Recurrence is efficient when subproblems are independent, while DP requires overlapped subproblems.</li><li>DP trades space for time.</li></ul></blockquote></li><li><p>DP is used for <strong>optimization</strong> problems</p></li><li><p><strong>Core: As long as all subproblems are optimized, the merged problem can be optimized.</strong></p><blockquote><p>Prerequisite: All subproblems cannot be completely individual, and in other words,  they have to affect each other’s solution.</p></blockquote></li></ul><h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ul><li>model subproblems</li><li>establish value connections between subproblems</li><li>bottom-up computation to get result</li><li>trace to get format answer</li></ul><h2 id="0-1-knapsack"><a href="#0-1-knapsack" class="headerlink" title="0-1 knapsack"></a>0-1 knapsack</h2><h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h3><ul><li>try all $2^n$ methods and compare them.</li></ul><h4 id="Simple-Recursion"><a href="#Simple-Recursion" class="headerlink" title="Simple Recursion"></a>Simple Recursion</h4><ul><li><p>$V[i,w]=max(V[i-1,w], v_i+V[i-1,w-w_i])$</p><ul><li><p>$V[i,w]$ denote any subset of items $\{1, 2, 3, …i\}$ value sum with <strong>at most</strong> weight $w$.</p><blockquote><p>Real weight may be smaller than $w$.</p></blockquote></li></ul></li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li>State of subproblems<ul><li>establish formal description for problem requirements</li></ul></li><li><p>Relate a problem to its subproblems</p><ul><li>establish recurrence equation</li><li>set boundary cases</li></ul></li><li><strong>Bottom-up</strong> computation of $V[i,w]$</li><li>initialize boundary cases<ul><li>Save trace when calculating $V[i,j]$, and till the end we can use recorded result to get $V[i,w]$.</li></ul></li><li>Add <code>keep[i,w]</code> to record for a specific w, whether an item is taken.</li></ul><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>DP save duplicate computation.</li><li>DP trades space for time.</li><li>Strategy<ul><li>Structure</li><li>Recursion</li><li>Bottom-up computation</li><li>Construct optimal solution: trace the table</li></ul></li></ul><h2 id="Rod-Cutting"><a href="#Rod-Cutting" class="headerlink" title="Rod Cutting"></a>Rod Cutting</h2><h3 id="brute-force-1"><a href="#brute-force-1" class="headerlink" title="brute force"></a>brute force</h3><ul><li>$r_n=max(p_n,r_1+r_{n-1},…,r_{n-1}+r_1)$<ul><li>$r_n$ is the optimal revenue of length <code>n</code> rod.</li><li>$p_n$ is the price of length <code>n</code> rod.</li><li>simpler definition:  $r_n=max_{1\leq i \leq n}(p_i+r_{n-i})$</li></ul></li><li>Even recurrence equation is established, the recursive method still contains duplicate computation.</li></ul><h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><ul><li>one-dimension array <code>r[]</code> to store max revenue of length from 0 to n.</li><li><code>r[i] = max(r[i], p[j] + r[i - j])</code></li></ul><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>$O(n^2)$</li></ul><h2 id="Chain-Matrix-Multiplication"><a href="#Chain-Matrix-Multiplication" class="headerlink" title="Chain Matrix Multiplication"></a>Chain Matrix Multiplication</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>C(<code>p*q</code> and <code>q*r</code> matrix to multiply, each entry takes $O(q)$ to calculate): $O(pqr)$</p></li><li><p>$A_1A_2A_3=(A_1A_2)A_3=A_1(A_2A_3)$</p><blockquote><p>cause of different complexity</p></blockquote></li></ul><h3 id="Exhaustive-Search-1"><a href="#Exhaustive-Search-1" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><ul><li>$\Omega(\frac{4^n}{n^{\frac{3}{2}}})$</li></ul><h3 id="DP-2"><a href="#DP-2" class="headerlink" title="DP"></a>DP</h3><p>for matrix $A_i$, it has dimension of $p_{i-1}*p_i$.</p><ul><li><p>model subproblems</p></li><li><p>establish <strong>value</strong> connection between subproblems</p><p>$m[i,j]=\begin{cases}0, &amp; i=j\\min_{i\leq k&lt;j}(m[i,k]+m[k+1,j])+p_{i-1}p_kp_j, &amp; i&lt;j\end{cases}$</p></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$<ul><li>Outlying loop layer is for traverse multiply-array’s length from 2 to n.</li></ul></li><li>space: $O(n^2)$</li></ul><h2 id="Longest-Common-Subsequence-Problem"><a href="#Longest-Common-Subsequence-Problem" class="headerlink" title="Longest Common Subsequence Problem"></a>Longest Common Subsequence Problem</h2><h3 id="Basic-Concepts-1"><a href="#Basic-Concepts-1" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>subsequence: not necessarily continuous</li><li>substring: <strong>must</strong> be continuous</li></ul><h3 id="DP-3"><a href="#DP-3" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ the length of LCS in $A[1..i]$ of $A[1..m]$ and $B[1..j]$ of $B[1..n]$</p><ul><li>$d_{i,j}=\begin{cases} 0, &amp; i,j=0 \\ d_{i-1,j-1}+1, &amp; x_i=y_j \\ max(d_{i-1.j},d_{i,j-1}), &amp; x_i\neq y_j\end{cases}$</li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(mn)$</p></li><li><p>space: $O(n^2)$</p><ul><li><p>optimization for solution matrix: only save two rows</p><blockquote><p>The trace matrix needs totally preserving.</p></blockquote></li></ul></li><li><p>Different trace may lead to different subsequence.</p></li></ul><h2 id="Longest-Common-Substring-Problem"><a href="#Longest-Common-Substring-Problem" class="headerlink" title="Longest Common Substring Problem"></a>Longest Common Substring Problem</h2><h3 id="Basic-Concepts-2"><a href="#Basic-Concepts-2" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>Different from subsequence, substring must be contiguous.</li></ul><h3 id="DP-4"><a href="#DP-4" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ to be the length of the longest common substring of $X[1..i]$ and $Y[1..j]$</p><ul><li>$d_{i,j}=\begin{cases} d_{i-1,j-1}+1, &amp;x_i=y_j\\ 0, &amp;x_i\neq y_j\end{cases}$</li><li>$maxSubstring(X,Y)=max(d_{i,j})$</li></ul><h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Without saving DP direction, we can still trace the whole substring by knowing the <strong>end index</strong> of substring $(X_i|Y_j)$ and its length $d_{i,j}$.</li><li>time: $O(mn)$</li><li>Subsequence algorithm can be used to solve this problem by only outputting diagonal $LU$ elements.</li></ul><h2 id="Minimum-Edit-Distance"><a href="#Minimum-Edit-Distance" class="headerlink" title="Minimum Edit Distance"></a>Minimum Edit Distance</h2><h3 id="Basic-Concepts-3"><a href="#Basic-Concepts-3" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><ul><li>“Spell Correction” in search engine</li><li>Computational Biology such as comparing DNA</li><li>Machine Translation, Information Extraction, Speech Recognition etc.</li></ul><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>calculate the smallest number of edit operations</p><ul><li><p>edit operations</p><ul><li>insertion: add a letter</li><li>deletion: delete a letter</li><li>substitution: replace a character</li></ul><blockquote><p>All operations’ cost is usually (throughout the course) counted as <code>1</code>, but the cost can be adjusted.</p></blockquote></li></ul><h3 id="DP-5"><a href="#DP-5" class="headerlink" title="DP"></a>DP</h3><p>define $D[i,j]$ the edit distance of $X[1..i]$ and $Y[1..j]$</p><ul><li>$D[i,j]=min\begin{cases} D[i-1,j]+1, &amp;delete\ X[i] \\ D[i,j-1]+1, &amp;insert\ Y[j] \\ D[i-1,j-1] +0, &amp;X[i]=Y[j] \\ D[i-1,j-1]+1, &amp;X[i] \neq Y[j] \end{cases}$</li></ul><blockquote><ul><li>All edit operations take place on $X[1..i]$.</li><li>When operation cost changes, the constant in equation will be changed as well.</li><li>When the problem can be depicted as a state graph, <strong>shortest path algorithm</strong> can be used to solve the problem. In other words, the problems degrades to shortest path problem.</li></ul></blockquote><h3 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>When tracing the edit process, <code>L</code>/<code>U</code>/<code>LR</code> stand for four different operations(<strong>including doing nothing</strong>).</li><li>time: $O(mn)$</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>multi-stage strategy problem</li><li>DP is not a specific method but a way of thinking.</li><li>Key to DP: basic equations and boundary conditions</li><li>DP’s effect is also called Markova effect for there’s no effect on future events. </li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter4-Mid-term-Review"><a href="#Chapter4-Mid-term-Review" class="headerlink" title="Chapter4 Mid-term Review"></a>Chapter4 Mid-term Review</h1><p>Total Count: <code>413</code> words</p><p>Preferred Reading Time: <code>15~20</code> minutes</p><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2><h3 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h3><ul><li><p>Any comparison-based sorting algorithm requires $\Omega(nlogn)$ comparisons.</p><blockquote><p>proved by binary decision tree</p></blockquote></li><li><p>Thus, in order to break the lower bound, we should take other methods except comparison.</p></li><li><p>counting sort isn’t based on comparison.</p></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>When inputting numbers, count occurrences of all numbers.</p><blockquote><p>counting array’s length is based on boundary value of inputting array.</p></blockquote></li><li><p>Fill sorted array with the counting array.</p></li></ul><h3 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n)$</li><li>counting sort is a <strong>stable</strong> sort as long as the final filling loop is from raw array’s <strong>end</strong> to its <strong>head</strong>.</li></ul><h2 id="Randomized-Selection-Problem"><a href="#Randomized-Selection-Problem" class="headerlink" title="Randomized Selection Problem"></a>Randomized Selection Problem</h2><h3 id="Basic-Concepts-4"><a href="#Basic-Concepts-4" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>find the <code>i-th</code> smallest element in a given array</li></ul><h3 id="brute-force-2"><a href="#brute-force-2" class="headerlink" title="brute force"></a>brute force</h3><ul><li>sort the array and index specific element</li></ul><h3 id="Partition-and-Selection"><a href="#Partition-and-Selection" class="headerlink" title="Partition and Selection"></a>Partition and Selection</h3><ul><li>The same as quick sort, part the array into two subarrays, and then make sure the index of selected separator number.</li><li>When the index is greater than <code>i</code>, handle another branch and abandon this one, vice versa.</li></ul><h3 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(n)$</p><blockquote><p>Different from quick sort’s $O(nlogn)$, this algorithm only deals with one branch of subproblems, while quick sort handles both branches.</p></blockquote></li></ul><h2 id="Optimal-Binary-Search-Tree"><a href="#Optimal-Binary-Search-Tree" class="headerlink" title="Optimal Binary Search Tree"></a>Optimal Binary Search Tree</h2><h3 id="Basic-Concepts-5"><a href="#Basic-Concepts-5" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>construct a BST with smallest search cost</p></li><li><p>height</p><ul><li>$node_height=max(children_height + 1)$</li><li>$leave_ height=0$</li><li>$tree_height=root_height$</li><li>$empty_tree_height = -1$</li></ul><blockquote><p><code>root_height</code> is the <strong>biggest</strong> one.</p></blockquote></li><li><p>$depth=H(root)-H(n)+1$</p><ul><li>$root_depth=1$</li></ul></li><li><p>balanced binary tree: the height difference of two subtrees cannot go beyond 1.</p><ul><li>$balance_factor = H(right)-H(left)$</li></ul></li><li><p>AVL tree: besides balanced binary tree, every node will store the height of two subtrees.</p></li></ul><h3 id="DP-6"><a href="#DP-6" class="headerlink" title="DP"></a>DP</h3><ul><li><p>subproblem: find an optimal BST containing $keys<a href="1 \leq i \leq j \leq n">i..j</a>$</p></li><li><p>$e[i,j]$: the expected search cost of a subtree with $k[i..j]$.</p><ul><li>$e[i, j] =\begin{cases} q_{i-1}, &amp;j=i-1 \\ min_{i\leq r\leq j}(e[i, r-1]+e[r+1, j]+w[i, j]), &amp;i\leq j\end{cases}$</li><li>$w[i,j]=E_r=w[i,r-1]+p_r+w[r+1,j]=w[i,j-1]+p_j+q_j$</li></ul></li><li><p>diagonal traverse template</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>): <span class="comment"># length of fixed diagnals</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n-l+<span class="number">1</span>):</span><br><span class="line">        j = i + l - <span class="number">1</span> <span class="comment"># (n-l+1, n) is always on f(i, j)</span></span><br></pre></td></tr></table></figure><blockquote><p>Due to $i\leq j$, then the traverse should be diagonal.</p></blockquote></li></ul><h3 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$</li><li>space: $O(n^2)$</li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter5-Greedy-Algorithms"><a href="#Chapter5-Greedy-Algorithms" class="headerlink" title="Chapter5 Greedy Algorithms"></a>Chapter5 Greedy Algorithms</h1><p>Total Count: <code>522</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li><p>Greedy algorithms don’t always produce the optimal solution.</p></li><li><p>As a result, if the result is optimal, we need to prove its correctness.</p><blockquote><p>The usual way is to prove that any other optimal solution can be converted into the greedy one.</p></blockquote></li></ul><h2 id="Fraction-Knapsack-Problem"><a href="#Fraction-Knapsack-Problem" class="headerlink" title="Fraction Knapsack Problem"></a>Fraction Knapsack Problem</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Different from 0-1 problem, knapsack can take only a fraction of an item.</li></ul><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><ul><li>calculate value-per-pound of every item</li><li>sort items by <strong>decreasing</strong> value-per-pound</li><li>put as much as possible weight of an item into knapsack from the starting point to the end of the sorted array</li></ul><h3 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$, the time complexity of sort process.</li><li>Different from DP, all subproblems of greedy algorithms are optimal no matter whether they are connected with each other.</li></ul><h2 id="Huffman-Coding-Problem"><a href="#Huffman-Coding-Problem" class="headerlink" title="Huffman Coding Problem"></a>Huffman Coding Problem</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>Encode characters according to its frequency so that the variable length can save the memory space compared with fixed length.</p><blockquote><p>especially useful when storing images</p></blockquote></li><li><p>Uniquely Decodable: In order to decode correctly, the encoding method should avoid one character’s code being the prefix of another character, and then the code can be named after <strong>prefix (free) code</strong>.</p></li><li><p>Huffman coding targets at the <strong>minimized binary prefix code</strong>.</p></li></ul><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><ul><li>pick two least-occur characters from alphabet and build a subtree</li><li>the subtree’s frequency is the sum of its sub-subtrees</li><li><strong>note that the Huffman tree can be a complete binary tree as well</strong></li></ul><h3 id="Analysis-10"><a href="#Analysis-10" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$<ul><li>Every update of the priority queue is $O(logn)$ and the total operation count is $n$.</li></ul></li></ul><h2 id="Activity-Selection-Problem"><a href="#Activity-Selection-Problem" class="headerlink" title="Activity Selection Problem"></a>Activity Selection Problem</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Given activities that may overlap with each other, take part in as many activities as possible.</li><li>core: find a maximized compatible activity set</li></ul><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>sort activities list in ascending order of finishing time</p></li><li><p>select the first activity: the one <strong>finishes at the earliest time</strong></p><blockquote><p>not the one starting earliest or the shortest one</p></blockquote></li><li><p>advance the time and update sort activities until the head activity’s starting time is still valid</p></li><li><p>select next activity</p></li></ul><h3 id="Analysis-11"><a href="#Analysis-11" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>Time: $O(nlogn)$ to sort activity list.</p></li><li><p>The correctness can be proved that greedy algorithms produce the optimal solution of this problem.</p><blockquote><p>Proof: we can convert any other optimal solution($P’$) to the greedy algorithm solution($P$) by replacing different elements in $P’$ with corresponding elements in $P$.</p></blockquote></li></ul><h2 id="Weighted-Activity-Selection-Problem"><a href="#Weighted-Activity-Selection-Problem" class="headerlink" title="Weighted Activity Selection Problem"></a>Weighted Activity Selection Problem</h2><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Every activity is given a weight, and the goal is to construct the set with maximized weight sum.</li></ul><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>Greedy algorithm is correct when weight are all equal.</p></li><li><p>DP can still work in this weight-varied scenario.</p><ul><li><p><strong>First of all, sort activity with its finishing time.</strong></p></li><li><p>$p(j)$ : the largest index $i&lt;j$ guaranteeing $a_i$ compatible with $a_j$.</p><blockquote><p><strong>index</strong> is the one of <strong>sorted</strong> activity array.</p></blockquote></li><li><p>$OPT(j)$: the max weight sum of any subset in $a[1..j]$</p><script type="math/tex; mode=display">OPT(j)=\begin{cases} 0,& j=0 \\ max(OPT(i-1), w_j+OPT(p(j)), & j>0\end{cases}</script></li></ul></li></ul><h3 id="Analysis-12"><a href="#Analysis-12" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$ to sort the activity list</li><li>Greedy algorithms never reconsider its previous choices, while DP construct its solution by comparing all possible previous choices.</li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter6-Graph-Algorithms"><a href="#Chapter6-Graph-Algorithms" class="headerlink" title="Chapter6 Graph Algorithms"></a>Chapter6 Graph Algorithms</h1><p>Total Count: <code>1887</code> words</p><p>Preferred Reading Time: <code>30~45</code> minutes</p><h2 id="Basic-Concepts-6"><a href="#Basic-Concepts-6" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><ul><li><p>complete graph</p><ul><li>undirected: $|E|=n(n-1)/2$</li><li>directed: $|E|=n(n-1)$</li></ul></li><li><p>dense &amp; sparse graph: not quantitative defined</p></li><li><p>degree: number of edges incident on a vertex</p><ul><li>degree of a graph is the sum of degrees of all vertices</li></ul></li><li><p>leave node</p><ul><li>directed graph: no out degree</li><li>undirected graph: degree is <code>1</code></li></ul></li><li><p>path length: <strong>edges’</strong> count(not vertex)</p></li><li><p>simple path: all <strong>vertices</strong> are distinct on the path(no cycle, acyclic)</p></li><li><p>cycle: requires all <strong>edges</strong> are distinct with multi-exist vertices</p><blockquote><ul><li><p>an edge cannot be used twice in a cycle</p></li><li><p>Q: self-to-self edge can produce cycle?</p><p>A: Yes, that’s why a legal tree <strong>cannot</strong> have self-to-self edge.</p></li></ul></blockquote></li><li><p>connected component</p><ul><li><p><strong>disconnected</strong> graph’s biggest connected subgraph</p><blockquote><p>a disconnected graph can have <strong>more than one</strong> connected components</p></blockquote></li><li><p>connected graph itself</p></li></ul></li><li><p>included subgraph: As long as <strong>both</strong> endpoints are preserved, the edges should be preserved.</p></li><li><p>leaf</p><ul><li>directed graph: out-degree is zero</li><li>undirected graph: degree is one</li></ul></li></ul><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><ul><li>Adjacency List<ul><li>space complexity: $O(V+E)$</li><li>$adj[u]$: hold all vertices adjacent to $u$, usually a linked list.</li><li>mostly for sparse graph</li></ul></li><li>Adjacency Matrix<ul><li>space complexity: $O(V^2)$</li><li>undirected graphs always have <strong>symmetric</strong> adjacency matrix</li><li>mostly for dense graph</li></ul></li></ul><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul><li><p>data structure</p><ul><li><code>color[u]</code>: state of vertex <code>u</code><ul><li><code>undiscovered</code></li><li><code>discovered but not finishing processing</code></li><li><code>finished processing</code></li></ul></li><li><code>pred[u]</code>: the predecessor of vertex <code>u</code></li><li><code>d[u]</code>: distance from starting point to <code>u</code></li></ul></li><li><p>end-loop condition: the vertex queue is empty</p></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><blockquote><p>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</p></blockquote></li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li><p>tree-like traverse process</p></li><li><p>data structure</p><ul><li><code>color[u]</code></li><li><code>pred[u]</code></li><li><code>d[u]</code>: discovery time of vertex <code>u</code></li><li><code>f[u]</code>: finishing time of vertex <code>u</code></li></ul></li><li><p><code>u</code> is a descendant of <code>v</code> if and only if $[d[u],f[u]]\subset[d[v],f[v]]$</p><ul><li><p>tree edge$(u,v)$: $u$ is the predecessor in a DFS path</p></li><li><p>back edge$(u,v)$: $v$ is the predecessor in a DFS path</p><blockquote><p>As long as the graph is acyclic, there is no back edge.</p></blockquote></li><li><p>cross edge$(u,v)$: both vertices are endpoints of a DFS path</p></li></ul></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><ul><li>Different from normal complexity calculation, we can think it in this way: as for each vertex, $O(1)$ is needed to update the timestamp, and $O(degree(u))$ is required to run the for loop. Therefore, the total time complexity is the sum of every single time complexity.</li></ul><blockquote><ul><li>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</li><li>The time complexity is the same as the one of BFS under adjacency list.</li></ul></blockquote></li><li><p>White-path theorem: As long as $v$ is a descendant(direct or indirect) of $u$, then there is a white path between them in DFS algorithm.</p></li></ul><h2 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h2><h3 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Topological sort is adopted for <strong>directed acyclic graph(DAG)</strong>.<ul><li>$G$ doesn’t need to be connected, for the order of disconnected parts won’t break the rule.</li></ul></li><li>find a sequence based on edge $(u,v)$ that $u$ must be ahead of $v$</li><li>If no “zero in-degree” vertex is found, the graph must contain cycle.</li></ul><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><ul><li>BFS<ul><li>find all vertices with in-degree as 0</li><li>delete them and their outgoing edges(decrease in-degree of its direct descendants)</li><li>repeat above steps</li></ul></li><li>DFS<ul><li>traverse all vertices and build a DFS tree</li><li>Once a vertex cannot span the tree anymore, add it into $L$.<ul><li>all direct descendants are added into $L$</li><li>no direct descendant exists</li></ul></li><li>next DFS tree traverse won’t reach vertices in $L$</li><li>Tasks with <strong>later</strong> finishing time should be down <strong>earlier</strong>, so $L$ needs reversing to be correct order.</li></ul></li></ul><h3 id="Analysis-13"><a href="#Analysis-13" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>BFS<ul><li>time: $O(|V|+|E|)$</li></ul></li><li>DFS<ul><li>time: $O(|V|+|E|)$</li></ul></li></ul><h2 id="Strongly-Connected-Components"><a href="#Strongly-Connected-Components" class="headerlink" title="Strongly Connected Components"></a>Strongly Connected Components</h2><h3 id="Definition-6"><a href="#Definition-6" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>SCC is a subset of a <strong>directed</strong> graph, in which all vertices can reach each other, <strong>and</strong> the subset should be <strong>maximal</strong>(no more vertex can be added).</p><ul><li>SCC can contain <strong>only one</strong> vertex.</li></ul></li><li><p>Theorem: Suppose $S_1$ and $S_2$ are both SCCs of $G$, then the intersection must be $\Phi$.</p><blockquote><p>Proof: Any vertex in intersection can make $S_1\cup S_2$ a bigger SCC.</p><ul><li>After finding a SCC, all vertices within can be taken as a single vertex.</li></ul></blockquote></li><li><p>Finding all SCC of $G$ is to find a partition with all subset are SCC.</p></li><li><p>Sink SCC: SCC with no outgoing edge</p><ul><li><p>$G^{SCC}$ is a graph taking all SCC as a single vertex.</p></li><li><p>$G^{SCC}$ is a DAG</p><blockquote><p>Proof: As long as there is a cycle, the element of $SCC$ can be merged.</p></blockquote></li><li><p>$G^{SCC}$ must contain at least one <strong>SSCC</strong>.</p><blockquote><p>Proof: The DAG graph can be topological sorted, so the last vertex in the topological order has no outgoing edge, which means the vertex is a SSCC.</p></blockquote></li></ul></li></ul><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><ul><li>generate reverse graph $G^R$</li><li>Operate topological sort on $G^R$, and the result is $L^R$.</li><li>reverse $L^R$ to get $L$</li><li>execute DFS on $G$ with starting point as white ones in $L$</li><li>Every DFS on $G$ can produce a SCC, and corresponding vertices should be marked black.<ul><li>Starting from a SSCC, then the component won’t contain vertices of other SCC.</li></ul></li></ul><h3 id="Analysis-14"><a href="#Analysis-14" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(V+E)$</li></ul><h2 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a>Spanning Tree</h2><h3 id="Definition-7"><a href="#Definition-7" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>An <strong>undirected</strong> graph’s subgraph containing all vertices.</p><blockquote><p>Q: Can spanning tree has cycle?</p><p>A: No,  tree is an <strong>acyclic</strong> graph.</p></blockquote></li><li><p>Every connected graph has at least one spanning tree.</p></li><li><p>Minimum Spanning Tree: the subgraph with smallest weight sum in a weighted undirected graph</p><ul><li><p>minimum spanning tree may <strong>not</strong> be unique</p><blockquote><p>Only when weight varies from one to another, the minimum spanning tree is unique.</p></blockquote></li></ul></li><li><p>safe edge: After adding safe edge to a subset of MST, the new set is still a subset of MST.</p><ul><li><p>Find the light edge of a cut respecting subset A, and then the light edge is the sage edge.</p><blockquote><p>Subset contains only edges, which means <strong>not all</strong> edges needs selecting even though their endpoints are with in the subset.</p></blockquote></li></ul></li><li><p>min heap</p><ul><li>root has min value</li><li>any vertex’s sons have <strong>greater</strong> value than its own value.</li></ul></li></ul><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><ul><li><p><strong>focus on vertex</strong></p></li><li><p>start with a randomly picked up <strong>vertex</strong></p></li><li><p>iterate to find the <strong>lightest</strong> edge outside the tree and add it (and its <strong>endpoint</strong>) into tree</p><ul><li><p>priority queue</p><ul><li><p>insert: insert at tail and <strong>reverse up</strong></p></li><li><p>extract min</p><ul><li><p>After extracting the first element, the last element needs swapping to the first.</p><blockquote><p>Only the last element won’t influence the tree structure.</p></blockquote></li><li><p><strong>roll down</strong> new first element to construct a new heap</p></li><li><p>time complexity is $O(logn)$</p></li></ul></li><li><p>update value: <strong>reverse up</strong> to respect the heap</p></li></ul></li></ul></li><li><p>When adding an new edge and its vertex into SMT, loop over its adjacent vertices to update key values.</p></li></ul><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><ul><li><strong>focus on edges</strong></li><li>Construct many forests, and finally they will be merged.<ul><li>When selecting edges, be cautious there cannot be cycles.<ul><li>disjoint set</li></ul></li></ul></li></ul><h3 id="Analysis-15"><a href="#Analysis-15" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time</p><ul><li><p>Prim: $O(VlogV+ElogV)=O(ElogV)$</p><ul><li>Usually, $E$ is greater than $V$ and sometimes may be $V^2$, which means $E=O(V^2)$.</li></ul><blockquote><p>As for loops like <code>while Q.size() &gt; 0</code>, and <code>Q</code> is changed within, we can consider it based on every single operation instead of every loop.</p></blockquote></li><li><p>Kruskal: $O(ElogE)=O(ElogV)$</p><blockquote><p>$logE\leq logV^2 \leq 2logV \leq O(logV)$</p><ul><li>Usually place $E$ outside $log$, and $V$ is placed inside.</li></ul></blockquote></li></ul></li></ul><h2 id="Shortest-Path"><a href="#Shortest-Path" class="headerlink" title="Shortest Path"></a>Shortest Path</h2><h3 id="Definition-8"><a href="#Definition-8" class="headerlink" title="Definition"></a>Definition</h3><ul><li>distance is the <strong>minimal</strong> length between two vertices</li><li>lemma: Any sub-path of a shortest path must also be a shortest path.</li></ul><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><ul><li><p>single source problem</p></li><li><p>can only handle <strong>no-negative-edge</strong> graph</p></li><li><p>greedy algorithm</p></li><li><p>maintain <code>d[v]</code> and <code>S</code></p><ul><li><p><code>d[v]</code>: upper bound of length <code>l(source, v)</code></p><ul><li><p>can be optimized by priority queue</p></li><li><p>relax</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[v] &lt;- min(d[v], d[u] + w(u, v));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>S</code>: set of distance-settled vertices</p></li></ul></li></ul><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><ul><li><p>single source problem</p></li><li><p>relax according to <strong>edges</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to <span class="params">|V|</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> E <span class="keyword">do</span></span><br><span class="line">        relax(e.p1, e.p2, e.w);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>Every iteration will settle an edge in the shortest paths.</p></li><li><p>The shortest path can at <strong>most</strong> contain <code>(|V|-1)</code> edges.</p></li><li><p>Iteration at most runs for <code>(|V|-1)</code> times.</p><blockquote><p><code>ith</code> iteration settle the paths containing <code>i</code> edges</p></blockquote></li></ul></li><li><p>If relaxation still happens after <code>(|V|-1)</code> iterations, there must be negative cycles in graph.</p></li></ul><h4 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h4><ul><li><p>all-pairs problem</p></li><li><p>dynamic programming algorithm</p><ul><li><p>$f[k][i][j]=min\{f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j]\}$</p><ul><li><p>using rolling array to optimize</p><p>$f[i][j]=min\{f[i][j],f[i][k]+f[k][j]\}$</p></li></ul></li></ul></li><li><p>The sequence to traverse <code>k</code>(intermediate vertex) isn’t important.</p><blockquote><p>Proof: Mathematics Induction(<a href="https://blog.csdn.net/dypdypdyp123/article/details/50492894" target="_blank" rel="noopener">https://blog.csdn.net/dypdypdyp123/article/details/50492894</a>)</p></blockquote></li></ul><h3 id="Analysis-16"><a href="#Analysis-16" class="headerlink" title="Analysis"></a>Analysis</h3><p>time</p><ul><li><p>Dijkstra: $O(VlogV+ElogV)=O(ElogV)$</p></li><li><p>Bellman-Ford: $O(EV)$</p></li><li><p>Floyd-Warshall: $O(V^3)$</p><blockquote><p>Apart from data structure, Floyd’s traversal decides the $n^3$ complexity.</p></blockquote></li></ul><h2 id="Maximum-Flow-amp-Minimum-Cut"><a href="#Maximum-Flow-amp-Minimum-Cut" class="headerlink" title="Maximum Flow &amp; Minimum Cut"></a>Maximum Flow &amp; Minimum Cut</h2><h3 id="Definition-9"><a href="#Definition-9" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>a flow network <code>G</code> with source <code>s</code>, sink <code>t</code> and no parallel edges.</p></li><li><p>capacity is nonnegative: $c(e) \geq 0$</p></li><li><p>cut’s capacity: $cap(A, B)=\sum_{e\ out\ of\ A}c(e)$</p><ul><li>a cut requires $s \in A$ and $t \in B$</li></ul></li><li><p>minimum cut: output a cut of minimum capacity</p></li><li><p>maximum flow: output a flow of maximum value</p></li><li><p>Except <code>s</code> and <code>t</code>, every vertex’s <code>out</code> equals <code>in</code>, which means it cannot store any water.</p></li><li><p>flow value: $val(f)=\sum_{e\ out\ of\ s}f(e)$, and <code>s</code> is the source.</p><blockquote><p><code>value</code> may not be the sum of capacity</p></blockquote></li></ul><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Heuristic-Algorithm"><a href="#Heuristic-Algorithm" class="headerlink" title="Heuristic Algorithm"></a>Heuristic Algorithm</h4><ul><li>initialize all <code>f(e)</code> to zero</li><li>find a <code>s-t</code> path where each edge meets $f(e)&lt;c(e)$</li><li>augment flow along <code>s-t</code> path</li><li>iterate above steps until no <code>s-t</code> path can be found</li></ul><blockquote><p><code>Heuristic Algorithm</code> <strong>cannot</strong> guarantee the optimal answer</p></blockquote><h4 id="Ford-Fulkerson-Method"><a href="#Ford-Fulkerson-Method" class="headerlink" title="Ford-Fulkerson Method"></a>Ford-Fulkerson Method</h4><ul><li><p>residual network: add reverse edges to dynamically adjust the flow of an edge</p><ul><li>residual capacity: $c_f(e)=\begin{cases} c(e)-f(e), &amp; c(e)&gt;f(e) \\ f(e), &amp;f(e)&gt;0 \end{cases}$</li></ul><blockquote><p>Once and residual capacity is zero, there is <strong>only one</strong> edge between two vertices.(even no edge at all)</p></blockquote></li><li><p>augment(ing) path: a simple <code>s-t</code> path in $G_f$</p><ul><li><p>bottleneck capacity: minimum residual capacity of any edge in augment path</p></li><li><p>key property: $val(f’)=val(f)+bottoleneck(G_f, P)$</p><ul><li>As for specific edge, the flow may decrease. However, the overall flow will increase.</li></ul></li><li><p>$val(f’)&gt;val(f)$</p><blockquote><p>the out edges of <code>s</code> must have the <strong>same</strong> direction as that in augment path</p></blockquote></li></ul></li><li><p>Process</p><ul><li>start with all <code>f(u, v) = 0</code></li><li>randomly choose an augment path to update <code>f</code> and $G_f$.</li><li>iterate until there is <strong>no</strong> augment path $\Leftrightarrow$ no <code>s-t</code> path in $G_f$</li></ul></li></ul><h3 id="Analysis-17"><a href="#Analysis-17" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(|E||f^<em>|)$, $f^</em>$ is the max flow of graph $G$.</p><ul><li><p>BFS/DFS: $O(|V| + 2|E|)=O(|E|)$</p><blockquote><p>the worst case: one edge in $G$ has two corresponding edges in $G_f$</p></blockquote></li><li><p>The time complexity is determined by $|f^*|$, so the method to pick up an augment path is important.</p><ul><li>EK Algorithm: ignore all edges’ weight and find a shortest path</li><li>In a flow network, EK’s time complexity is $O(|V||E|)$.<ul><li>an edge <strong>at most</strong> can be critical for $|V|/2$ times</li></ul></li><li>new time complexity of Ford-Fulkerson Algorithm: $O(|V||E|^2)$</li></ul></li></ul></li><li><p>Augmenting Path Theorem: A flow of $f$ is a max-flow $\Leftrightarrow$ <strong>no</strong> augment path in $G_f$</p></li><li><p>Max Flow &amp; Min Cut Theorem</p><ul><li>$val(f)=cap(min_cut)$</li><li>$f$ is the max flow</li><li>$f$ has no augmenting path</li></ul></li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li><li>BUAA Algorithm MOOC, Autumn of 2020.</li><li>OI Wiki</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2020 BUAA Algorithm Course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
  </entry>
  
</feed>

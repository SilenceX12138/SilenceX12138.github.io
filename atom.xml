<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-23T13:09:51.105Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Silence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Airbnb Data Analysis</title>
    <link href="http://yoursite.com/2021/06/23/Airbnb-Data-Analysis/"/>
    <id>http://yoursite.com/2021/06/23/Airbnb-Data-Analysis/</id>
    <published>2021-06-23T13:08:53.000Z</published>
    <updated>2021-06-23T13:09:51.105Z</updated>
    
    <content type="html"><![CDATA[<object data="./Airbnb-Data-Analysis/analysis report.pdf" type="application/pdf" width="100%" height="100%">]]></content>
    
    <summary type="html">
    
      
      
        &lt;object data=&quot;./Airbnb-Data-Analysis/analysis report.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;

      
    
    </summary>
    
    
      <category term="Data Mining" scheme="http://yoursite.com/categories/Data-Mining/"/>
    
    
  </entry>
  
  <entry>
    <title>Machine Learning Course Note</title>
    <link href="http://yoursite.com/2021/06/23/Machine%20Learning%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/Machine%20Learning%20Course%20Note/</id>
    <published>2021-06-23T12:49:05.050Z</published>
    <updated>2021-06-23T12:58:05.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2021 NTU Machine Learning Course.</strong></p><a id="more"></a><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><ul><li><p>当训练集loss小而测试集loss大时，<strong>不一定是</strong>过拟合，也有可能是因为训练集和测试集数据<strong>分布不同</strong>而造成的mismatch.</p></li><li><p>神经网络在训练时会有随机因素影响参数的更新，但是在训练结束后应当具有稳定的输出。</p></li><li><p>数据增强需要根据数据本身的特性进行，例如图像通常会进行左右翻转而<strong>不是</strong>上下翻转。</p></li><li><p>模型训练时遇到的梯度为0的点成为critical point，分为局部最小值、局部最大值和鞍点，其中<strong>鞍点最为常见</strong>。</p><blockquote><p>出现鞍点时，理论上可以通过计算Hessian矩阵的特征值，根据特征值为负的向量来更新参数，但实际操作时由于计算量较大而<strong>不采用</strong>。</p></blockquote></li><li><p><strong>最小化</strong>交叉熵等价于<strong>最大化</strong>似然函数</p><ul><li>交叉熵：衡量两个分布之间的差异</li><li>似然：模型对样本分布的解释力度</li></ul></li></ul><h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><ul><li><p>Naïve Bayes</p><ul><li><p>判别模型&amp;生成模型：<a href="https://www.zhihu.com/question/20446337/answer/256466823" target="_blank" rel="noopener">https://www.zhihu.com/question/20446337/answer/256466823</a></p><blockquote><ul><li>判别模型学习区别，生成模型学习本质。</li><li>判别模型直接对$P(C|x)$进行建模，而生成模型先求$P(C,x)$.</li><li>判别模型力求<strong>经验误差最小化</strong>，生成模型强调<strong>出现概率最大化</strong>。</li></ul></blockquote></li><li><p>“拉普拉斯修正”平滑操作可以避免信息被训练集中未出现的属性值“抹去”</p><blockquote><p>假设属性值与类别均匀分布</p></blockquote></li><li><p>联合概率：包含多个条件且<strong>所有条件同时成立</strong>的概率，记作$P(X=a,Y=b)$或$P(a,b)$.</p></li></ul></li><li><p>参数估计：设$p(x)=f(\theta)$即$x$的概率分布与$\theta$相关</p><ul><li><p>极大似然：$argmax\{P(x|\theta)\}$，取能够使概率值最大的参数$\theta$.</p><blockquote><p>$P(x|\theta)$实际上就是将$\theta$代入假设的分布后得到的函数</p></blockquote></li><li><p>贝叶斯：在$p(x)$分布的基础上，设出第二个参数的分布$g(\theta)$.通过贝叶斯公式估计$g(\theta)$，然后求出期望平均作为$\theta$的估计值，然后再求出$p(x)$</p></li><li><p>最大后验概率：$argmax\{P(x|\theta)P(\theta)\}$，即在极大似然的基础上增加对参数本身概率的考量。（$P(\theta)$是对数据的<strong>主观认识</strong>，即人为设置其概率分布）</p></li></ul></li><li><p>$\hat{y}$在李宏毅老师MOOC中表示<strong>真实值</strong>，而西瓜书中是<strong>预测值</strong>。</p></li></ul><h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><ul><li><p>Logistic Regression是在线性回归的基础上增加了<code>sigmoid</code>函数，解决的是<strong>分类问题</strong>。</p></li><li><p>偏置项用于增强模型的拟合能力：<a href="https://www.zhihu.com/question/305340182/answer/721739423" target="_blank" rel="noopener">https://www.zhihu.com/question/305340182/answer/721739423</a></p><blockquote><p>偏置也可以理解成<strong>阈值</strong>，只有当计算出的值足够大时（大过阈值），才表示决策更加笃定。</p></blockquote></li><li><p>Logistic Regression使用的误差表示方法是<strong>交叉熵</strong>，因为MSE会出现label处梯度为0的情况，不能保证优化参数。</p></li><li><p>$y=w^Tx+b$越大越好的原因：损失函数中想要使$f(y)$在正样本时尽量向<code>1</code>靠近，也就是要求$y$的值尽量大，所以$y$越大则表示样本分类为正的可能性越大。</p><blockquote><p>如果正样本时要求$f(y)$向<code>-1</code>靠近，则$y$的值就应该越小越好。</p></blockquote></li><li><p>通过多个Logistic Regressor的拼接，可以构成神经网络。</p><blockquote><ul><li>本质上是用Logistic Regression来寻找<strong>最好</strong>的特征</li><li>最后的输出层实际上是<code>OvR</code>模型</li></ul></blockquote></li><li><p>softmax的作用：将不同类别的预测值归一化，同时将差异<strong>放大</strong>。</p><p><img src="https://i.loli.net/2021/06/23/5vVFz2KRG7rIny3.png" alt="img" style="zoom: 50%;" /></p><blockquote><p>同时将<strong>负</strong>预测值转换为<strong>正值</strong></p></blockquote></li><li><p>梯度下降方法是<strong>提前</strong>将偏微分公式求出，然后带入实际的参数（权值、偏置）进行计算得到梯度值，然后更新参数，例子如下：$\left(x_{2}\right)=\left(x_{1}\right)-\eta \nabla f\left(x_{1}\right)=(6)-0.2 \times(12)=(3.6)$.</p></li></ul><h2 id="Backpropagation"><a href="#Backpropagation" class="headerlink" title="Backpropagation"></a>Backpropagation</h2><ul><li><p>反向传播是一种高效的计算<strong>损失函数</strong>相对于参数<strong>梯度</strong>的办法</p></li><li><p>参数更新方程：<script type="math/tex">\cases {w_i^2=w_i^1-\Delta w_i \\ \Delta w_i=\eta*\frac{\partial L}{\partial w_i}}</script></p><blockquote><ul><li>更新方向和梯度方向<strong>相反</strong></li><li>存在多种不同的更新方式（优化器）</li></ul></blockquote></li><li><p>$\frac{\partial C}{\partial w_n}=\frac{\partial C}{\partial z}*\frac{\partial z}{\partial w_n}$</p><ul><li>$C$(cost)是某一个样本的预测值和真实值的<strong>距离</strong></li><li>$z$是$w_n$对应神经元的输入值线性回归（<strong>没有</strong>经过激活函数）</li><li>损失函数是多个$C$的累加</li></ul></li><li><p>$\frac{\partial z}{\partial w_n}=x_n$：<code>Forward Pass</code>中，单层神经元的输出对<strong>权重</strong>求导是对应的<strong>输入特征</strong>的值。</p></li><li><p>$\frac{\partial C}{\partial z}$：<code>Backward Pass</code>本质上和正向的<code>Forward Pass</code>相同，即建立一个反向的神经网络进行正常的<strong>预测</strong>计算。</p><ul><li>反向网络中神经元的激活函数是原激活函数的<strong>导函数</strong></li><li>反向网络的激活函数直接和线性回归方程<strong>相乘</strong>，而<strong>不是复合</strong>。</li></ul></li><li><p><code>Sigmoid</code>函数可能导致梯度消失：<strong>输出端</strong>参数收敛，<strong>输入端</strong>参数依然处在随机态。</p></li></ul><h2 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h2><ul><li><p>SVM对噪声敏感</p></li><li><p>硬间隔：$\hat{y}^if(x_i)\geq 1$</p></li><li><p>软间隔：</p><ul><li><p>目标函数：$min\ \frac{||w||_2}{2}+C\Sigma l(\hat{y}^if(x^i)-1)$</p><ul><li><p>$C$：常数，无穷大时<strong>不允许</strong>错误出现，软间隔变为硬间隔。</p></li><li><p>$l(x)$：<code>0/1</code>损失函数，当$x&lt;0$时，取值为1.通常使用<code>hinge loss</code>函数($l(z)=max\{0,1-z\}$)代替</p><blockquote><p><code>hinge loss</code>是$l(x)$的<strong>紧凑上界</strong></p></blockquote></li></ul></li><li><p>约束：$\hat{y}^if(x^i)\geq 1-\epsilon^i(\epsilon^i \geq 0)$</p></li><li>求解<ul><li>拉格朗日乘子法+SMO</li><li>线性SVM：<strong>梯度下降</strong>（间断函数如<code>hinge loss</code>也是可以使用梯度下降进行优化的）</li></ul></li></ul><blockquote><p>在使用<code>hinge loss</code>函数时，$\epsilon ^i=max\{0,1-\hat{y}^if(y^i)\}$，即满足非负约束和大于$1-\hat{y}^if(x^i)$的条件下，令$\Sigma \epsilon^i$尽量小，从而使目标函数最小。</p></blockquote></li><li><p>核函数</p><ul><li>让特征在高维空间<strong>线性可分</strong>，从而得到一个非线性SVM.（普通支持向量机<strong>只能解决线性可分</strong>问题，此时SVM可以处理低维空间线性不可分的数据）</li><li>降低运算量，在计算高维空间的目标函数时不需要真正做变换，只需要计算核函数即可。</li></ul></li><li><p>SVM/SVR学习出的模型都可以表示成<strong>核函数的线性组合</strong>：$h^*(x)=\Sigma\alpha_i K(x,x_i)$</p><ul><li>模型仅与支持向量有关，<strong>不用记录</strong>其他样本。</li><li>偏置项被合并进了支持向量</li></ul></li></ul><h2 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h2><ul><li><p>同样的参数量，深层神经网络比只有一层的感知机性能更好。</p><ul><li>深层神经网络蕴含了“模块化”的思想，例如各层网络进行不同维度的分类。</li><li>因为每个模块的分类功能并不复杂，神经网络需要的训练数据实际上是<strong>更少</strong>的。</li></ul></li><li><p>End-to-end Learning：让流水线上每一个函数自己学习相应的特征</p></li><li><p>训练指南</p><ul><li><p>过拟合的<strong>前提</strong>是训练集的表现很好，如果训练集就没有高性能，那么不叫过拟合。</p></li><li><p>训练集</p><ul><li>更换激活函数<ul><li>ReLU函数可以<strong>防止</strong>梯度消失：有效的神经元是线性的，不会出现极小的梯度。</li></ul></li><li>调整学习率</li></ul></li><li><p>测试集</p><ul><li><p>及时停止训练：根据<strong>验证集</strong>确定时机</p><ul><li><p>验证集(fold 5)&amp;测试集</p><p><img src="https://i.loli.net/2021/06/23/o3AQOKPEci6wWHC.png" alt="img"></p><ul><li>验证集用于模型筛选、调优和消融实验</li></ul></li></ul></li><li><p>测试集<strong>仅</strong>用于评估模型性能</p></li><li><p>正则化：正则项有多种形式，例如L1/L2.</p><blockquote><ul><li>正则项中通常<strong>不含</strong>偏置项</li><li>正则化目的是让参数尽量靠近零，某些情况下效果<strong>不如</strong>停止训练显著。</li></ul></blockquote></li><li><p>Dropout：在<strong>训练</strong>过程中<strong>每次</strong>更新参数时，以概率值$p$随机<strong>舍弃</strong>一些神经元。（激活函数以概率$p$输出0）</p><ul><li>rescale：预测时<strong>所有神经元</strong>都会参与，输出是朴素情况$\frac{1}{1-p}$倍，因此需要乘$(1-p)$保证规模正常。</li></ul></li><li><p>inverted dropout：在训练时将<strong>输出缩小</strong>为$(1-p)$，测试时就<strong>不需要</strong>rescale了。</p></li><li><p>Batch Normalization：在激励函数前对数据特征值进行标准化，可以提高模型和性能和学习速度。</p><p><img src="https://pic2.zhimg.com/80/v2-d3ccd01453f215cf3357192debd14489_1440w.png" alt="img" style="zoom:33%;" /></p><ul><li><p>在BN操作外还需要添加<strong>反标准化</strong>，从而使神经网络自行对BN有效性进行判断，即学习参数$\gamma$和$\beta$.</p><p><img src="https://pic3.zhimg.com/80/v2-083ca0bcd0749fd0f236a690b50442e6_1440w.png" alt="img" style="zoom:33%;" /></p></li><li><p>BN操作本质上是使<strong>error surface平滑</strong>，避免模型困在critical point.</p></li></ul></li></ul></li></ul></li><li><p>SGD&amp;标准GD$\Leftrightarrow$标准BP&amp;累计BP，即单个样本&amp;batch中的样本。</p></li></ul><h2 id="Convolutional-Neural-Network"><a href="#Convolutional-Neural-Network" class="headerlink" title="Convolutional Neural Network"></a>Convolutional Neural Network</h2><ul><li>卷积的作用<ul><li>特征的位置对特征的识别没有影响</li><li>特征可能只在原图中的很小一部分</li></ul></li><li>池化的作用<ul><li>缩放原图不影响特征的信息</li></ul></li><li>卷积的本质<ul><li>权重是卷积的<strong>参数</strong></li><li>全连接网络<strong>舍弃</strong>一部分权重</li><li>卷积层之后的神经元<strong>共享</strong>权重</li></ul></li><li>卷积核的叠加：10个$1<em>3</em>3$的卷积核将图像升维到后，下一个卷积核实际上是<strong>三维</strong>的，即$10<em>3</em>3$.此时如果再将图像升维，则需要<strong>多个</strong>三维卷积核。</li><li>特征图中的<strong>一个像素</strong>实际上就是<strong>一个神经元</strong>（<strong>不包括</strong>激活函数）</li><li>二维卷积&amp;三维卷积<ul><li><code>conv2D</code>：可以具有多个通道，但是每个通道是<strong>二维</strong>的，例如图像处理。</li><li><code>conv3D</code>：每个通道是<strong>三维</strong>的，例如CT影像和视频处理。</li></ul></li><li>感受野(receptive field)可以是<strong>长方形</strong>的</li></ul><h2 id="Self-attention"><a href="#Self-attention" class="headerlink" title="Self-attention"></a>Self-attention</h2><ul><li><p>作用：在输入为<strong>序列</strong>时对其进行预处理，即通过考虑整个输入的上下文信息对输入进行处理。</p><blockquote><ul><li>将图片某个像素的多个通道抽象为一个vector，也可以把整张图当作m*n个向量的序列。</li><li>可以在神经网络<strong>隐层</strong>中使用</li><li>现在通常使用self-attention替代RNN</li></ul></blockquote></li><li><p>卷积实际上就是简化的self-attention</p></li><li><p>positional encoding：弥补self-attention没有考虑位置信息的问题</p></li></ul><h2 id="Recurrent-Neural-Network"><a href="#Recurrent-Neural-Network" class="headerlink" title="Recurrent Neural Network"></a>Recurrent Neural Network</h2><ul><li><p>LSTM是采用RNN思想的另一种<strong>网络架构</strong>（并不是神经元）</p></li><li><p>RNN通常<strong>不使用</strong><code>ReLu</code>作为激活函数</p></li><li><p>LSTM中记忆单元存储的值在遗忘门没有打开时，更新操作适合输入流相加，而不是RNN的直接替换，所以能够保证：所有对记忆单元造成了影响的值不会被完全遗忘，从而解决了RNN的梯度消失问题。</p><blockquote><ul><li>梯度消失的本质：距离较远的时间序列的信息难以在参数更新拥有话语权</li><li>LSTM仍然可能出现梯度爆炸，因此学习率通常设置的很小。</li></ul></blockquote></li><li><p>GRU将输入门和遗忘门联系起来（只剩下两个门），降低了参数量。</p></li><li><p>RNN下一状态隐层输出：$h_t = \tanh(W_{ih} x_t + b_{ih} + W_{hh} h_{(t-1)} + b_{hh}) $</p><ul><li><p>需要学习的参数：输入和记忆单元传递使用的权值$W$，两个偏置。</p><p><img src="https://i.loli.net/2021/05/18/1VFZxoh5P6EGjBN.png" alt="image-20210518110154693" style="zoom: 50%;" /></p></li></ul></li></ul><h2 id="Semi-supervised-Learning"><a href="#Semi-supervised-Learning" class="headerlink" title="Semi-supervised Learning"></a>Semi-supervised Learning</h2><ul><li><p>纯半监督学习的测试数据<strong>不是</strong>未标注数据，直推学习(transductive)的<strong>测试数据</strong>就是<strong>未标注数据</strong>。</p></li><li><p>主动学习：逐步扩展有标注数据集（专家协助），力求使用最小的数据量进行训练。</p><blockquote><p>增加了标注数据量，<strong>不属于</strong>半监督学习。</p></blockquote></li><li><p>生成式模型：基于极大似然思想，代表方法为$EM$法.</p><ul><li><p><strong>似然</strong>是用样本推测分布（参数），<strong>概率</strong>是用分布（参数）对样本进行预测。</p></li><li><p><strong>需要先对样本的分布做出假设</strong></p></li><li><p>每个样本既可以是正类，也可以是负类。</p></li><li><p>优化函数：$argmax\ \Sigma (P(x|C1)P(C1)+P(x|C2)P(C2))$</p><blockquote><p>概率值与参数$\theta$有关</p></blockquote></li></ul></li><li><p><code>Low Density</code>假设：在不同类别的分界处出现样本的概率是很小的（非黑即白）</p><ul><li>self-learning：不同于主动学习，模型使用<code>pseudo label</code>进行更新。</li><li>S3VM</li><li>正则化：无标注数据交叉熵（使预测是一个偏态分布）</li></ul><blockquote><p><strong>不</strong>适用于<strong>回归</strong>问题：回归问题的输出是确定值而不是概率，即重新输入模型的值和模型的原输出值相同，因此生成的pseudo value被加入标注数据集<strong>并不能</strong>优化原有参数。</p></blockquote></li><li><p><code>Smoothness</code>假设：相同类别的样本的模型输出应该是相近的</p><ul><li>Cluster</li><li>Graph based</li><li>正则化：无标注数据平滑度（保证联系够紧密的才能分为一类）</li></ul></li></ul><h2 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h2><p>无监督学习通常应用在数据挖掘领域，在没有标签的数据中找寻内在规律并解决问题。</p><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><ul><li><p>聚类可以单独解决一个问题，也可以作为其他方法的<strong>预处理</strong>手段。</p></li><li><p>聚类最常使用的方法：k-means</p><blockquote><p><code>kNN</code>（k近邻）算法：懒惰监督学习，根据输入计算出距离最近的<code>k</code>个训练样本，然后取最多的标签作为预测结果。</p></blockquote></li></ul><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><ul><li><p>通过提取主成分，在丢失<strong>少量信息</strong>的情况下，<strong>大幅度降低</strong>运算复杂度。</p></li><li><p>线性降维方法：通过<strong>线性变换</strong>（矩阵运算）减少特征维数</p></li><li><p>主成分本质上就是原成分构成的一组新基</p><ul><li><p>范数（模长）为1</p></li><li><p>相互正交（协方差为零/不相关）</p></li><li><p>新基是原特征间协方差矩阵的特征向量和原特征的内积，按照特征值大小<strong>降序排列</strong>。</p><blockquote><p>特征值越大，说明该成分对样本特征影响越大（越重要）。</p></blockquote></li></ul></li><li><p>PCA运算在以构造误差$L=||(x-\bar{x})-\hat{x}||_2$<strong>最小化</strong>为目标时，是<strong>线性单隐层</strong>神经网络的<strong>最优解</strong>。(Autoencoder)</p><blockquote><p>PCA的最优解对应<strong>最大特征值</strong>，因此可以使用<strong>梯度下降</strong>求解。（但神经网络中通常无法求得最优解）</p></blockquote></li></ul><h3 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h3><ul><li>也是一种降维压缩的办法，使用不同秩的奇异值矩阵保留不同密度的信息。（秩越大保存的信息越多）</li></ul><p><img src="https://pic2.zhimg.com/80/v2-74f7d2430ace69c9cd6b963eb58a5079_1440w.jpg" alt="img" style="zoom: 25%;" /></p><h3 id="Word-Enbedding"><a href="#Word-Enbedding" class="headerlink" title="Word Enbedding"></a>Word Enbedding</h3><ul><li><p>词向量</p><ul><li><p>基于统计：阅读大量文章，经常一起出现的词所对应的词向量应该有<strong>较高相似度</strong>。</p></li><li><p>基于预测：使用词的上下文信息建立神经网络，例如前一个单词的<strong>独热编码</strong>作为输入来预测下一个单词。此时神经网络的输出是下一个单词各个类别的概率，通过训练使某个词对应的概率最大化，然后将改神经网络的第一个隐层的<strong>输入</strong>作为词向量。</p><blockquote><p>因为相似的词需要得到相似的输出，所以第一个隐层的输入作为词向量可以保证它们的相似度。</p></blockquote></li></ul></li><li><p>涉及到共享权值时，梯度下降更新时需要<strong>减去所有</strong>共享的权值的偏微分与学习率的乘积。</p><blockquote><ul><li>卷积反向传播更新参数<strong>同理</strong></li><li>不可导/多微分反向传播：<a href="https://blog.csdn.net/qq_21190081/article/details/72871704" target="_blank" rel="noopener">https://blog.csdn.net/qq_21190081/article/details/72871704</a></li></ul></blockquote></li><li><p>共享权值的作用</p><ul><li><strong>上下文相同</strong>的单词具有<strong>同样的编码</strong>（即相同的权重）</li><li>减小模型参数量</li></ul></li></ul><h2 id="Explainable-Machine-Learning"><a href="#Explainable-Machine-Learning" class="headerlink" title="Explainable Machine Learning"></a>Explainable Machine Learning</h2><ul><li>Local Explanation：找出数据中对预测起到关键作用的部分<ul><li>设置一个自定义大小、颜色的蒙版，根据不同的摆放位置判断某区域是否关键。</li><li>随机扰动某个pixel，根据结果改变的梯度判断其重要性高低，最终得到salience map.</li></ul></li></ul><h2 id="Attack-ML-Model"><a href="#Attack-ML-Model" class="headerlink" title="Attack ML Model"></a>Attack ML Model</h2><ul><li><p>损失函数&amp;目标函数&amp;性能表现</p><ul><li>Loss Function：目标函数在有约束的条件下<strong>需要最小化</strong>的函数</li><li>Object Function：需要被优化的函数（最大/最小化均可）</li><li>Accuracy/IoU/F1 etc.：供比较的模型的性能指标</li></ul><blockquote><p><strong>Q：为什么不用性能表现作为目标函数？</strong></p><p>A：性能表现是<strong>以数据项为单位</strong>的，粒度过粗。例如100张图片分类任务，模型多次迭代后正确率均在90%左右，实际上这90个正确标签<strong>不一定</strong>是相同的，但是准确率不变，<strong>无法通过</strong>梯度下降对模型进行优化。</p></blockquote></li><li><p>攻击时模型的参数固定，改变的是<strong>输入的样本</strong>。</p><ul><li>通常由梯度下降进行优化<ul><li>损失函数：$L\left(x^{\prime}\right)=-C\left(y^{\prime}, y^{\text {true }}\right)+C\left(y^{\prime}, y^{\text {false }}\right)$<ul><li>$x’$：输入样本</li><li>$y’$：输出结果</li><li>$C$：交叉熵损失函数</li></ul></li><li>目标函数：$x^{*}=\arg \min _{d\left(x^{0}, x^{\prime}\right) \leq \varepsilon} L\left(x^{\prime}\right)$</li></ul></li></ul></li><li>白盒攻击：已知模型结构和参数<ul><li>FGSM(Fast Gradient Sign Method)<ul><li>$x^{*} \leftarrow x^{0}-\varepsilon \Delta x$</li><li>$\Delta x=\left[\begin{array}{c}\operatorname{sign}\left(\partial L / \partial x_{1}\right) \\ \operatorname{sign}\left(\partial L / \partial x_{2}\right) \\ \operatorname{sign}\left(\partial L / \partial x_{3}\right) \\ \vdots\end{array}\right]$only have $+1$ or $-1$</li></ul></li></ul></li><li>黑盒攻击：训练proxy model进行攻击（白盒攻击），然后使用得到的样本攻击黑盒模型。</li><li>被动防御：不修改原始模型，通常在输入模型前增加filter(eg. smoothing/padding/reshape)</li><li>主动防御：类似数据增强，在训练时对模型进行攻击，把有害样本加入训练集对模型进行再次训练。</li></ul><h2 id="Network-Compression"><a href="#Network-Compression" class="headerlink" title="Network Compression"></a>Network Compression</h2><ul><li><p>网络剪枝：在给定数据集上将模型计算过程中多次为0的权值和神经元进行删除，然后将小网络再次训练。（以上过程可迭代）</p><ul><li>实践中，“删除”操作通过将其置为恒0实现。</li></ul><blockquote><p><strong>Q：为什么不直接训练较小的网络？</strong></p><p>A：</p><ul><li>剪枝后的网络结构通常不规则，很难直接构造。</li><li>工程经验表明：小网络很难通过优化取得和大网络剪枝相同的效果。</li></ul></blockquote></li><li><p>知识蒸馏：用小网络去学习大网络的<strong>完整输出</strong>（eg. 各个label的概率分布），和直接用数据训练小网络不同。</p><ul><li>使用<strong>集成学习模型</strong>作为大网络可以有效提高小网络的性能</li><li>在输入softmax层前将概率值除以$T(Temperature)$，避免大网络的输出变为one-hot，即需要和正确标签保持一定的差异。</li></ul></li><li><p>参数量化</p><ul><li>改变数据类型，eg. float32 to float16.</li><li>权值聚类，最终所有的同类权值均取平均值。（类似colormap）<ul><li>可以使用Huffman Coding进一步优化</li></ul></li></ul></li><li><p>调整网络结构（最有效）</p><ul><li><p>在隐层间插入含$K$个神经元的全连接层，通过控制$K$来减少参数量。</p><p><img src="https://i.loli.net/2021/05/18/cq1yjMaveILkTzd.png" alt="image-20210518105034732" style="zoom:50%;" /></p></li><li><p>卷积分解：depthwise+pointerwise</p><p><img src="https://i.loli.net/2021/05/18/WXJ4PCbVIctwEsS.png" alt="image-20210518105117502" style="zoom:50%;" /></p></li><li><p>动态计算</p><ul><li><p>根据环境限制从存储的多个model中选择（内存开销大）</p></li><li><p>在中间层增加分类器直接进行预测（也可以是其他操作）</p><blockquote><p>要求<strong>浅层</strong>网络也要提取<strong>深层</strong>信息，可能对<strong>模型整体性能</strong>造成影响。</p></blockquote></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2021 NTU Machine Learning Course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>OS Course Note</title>
    <link href="http://yoursite.com/2021/06/23/OS%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/OS%20Course%20Note/</id>
    <published>2021-06-23T12:49:05.048Z</published>
    <updated>2021-06-23T12:49:32.910Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2020 BUAA OS course.</strong></p><a id="more"></a><h1 id="Chapter0-操作系统引论"><a href="#Chapter0-操作系统引论" class="headerlink" title="Chapter0 操作系统引论"></a>Chapter0 操作系统引论</h1><p><strong>全文共<code>2443</code>字，推荐阅读时间<code>10~15</code>分钟。</strong></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>操作系统是一组管理计算机硬件资源的<strong>软件集合</strong></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>用户和计算机硬件间的接口</li><li>系统资源的管理者</li><li>实现计算机资源的抽象</li></ul><h3 id="矛盾解决"><a href="#矛盾解决" class="headerlink" title="矛盾解决"></a>矛盾解决</h3><h4 id="人机"><a href="#人机" class="headerlink" title="人机"></a>人机</h4><p>批处理</p><ul><li>联机批处理<ul><li>在输入机和主机之间增加<strong>磁带</strong></li><li>输入输出时CPU仍处于空闲状态</li></ul></li><li>脱机批处理<ul><li>增加不和主机直接连接的<strong>卫星机</strong>（让主机和IO设备隔离）</li><li>卫星机处理输入机和输出机的结果</li><li>当发出I/O请求（磁盘访问等）仍会出现CPU空闲</li></ul></li></ul><h4 id="CPU和外设"><a href="#CPU和外设" class="headerlink" title="CPU和外设"></a>CPU和外设</h4><p>多道程序设计：允许<strong>多个程序</strong>同时在内存中运行</p><ul><li>当程序因为I/O请求暂停运行时，CPU立即执行另外一个程序。</li></ul><h2 id="多道程序系统"><a href="#多道程序系统" class="headerlink" title="多道程序系统"></a>多道程序系统</h2><h3 id="单处理机"><a href="#单处理机" class="headerlink" title="单处理机"></a>单处理机</h3><ul><li>多道：内存中可存放不止一道相互独立的程序</li><li><strong>宏观</strong>并行</li><li><strong>微观</strong>串行</li></ul><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ul><li>成批：运行过程中不允许用户与其作业发生交互作用</li></ul><blockquote><p>优点：</p><ul><li>系统吞吐量大</li><li>资源利用率高</li></ul><p>缺点：</p><ul><li>平均周转时间长</li><li>不能交互</li></ul></blockquote><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>将CPU处理时间分割成多个<strong>时间片</strong>，将时间片分配给不同程序达到<strong>宏观</strong>并行的效果。</p><ul><li>支持多用户、多进程</li><li>分时：多个用户分享同一台计算机</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>多路性</li><li>交互性</li><li>独立性：系统保证用户程序的完整性</li><li>及时性：系统及时响应用户的输入</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>使用可重入代码</li><li>引入虚存减少对换</li></ul><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>有网络作为底层支撑</li><li>模块性：各个分支机器具有自己的功能</li><li>并行性：相对独立，重在合作。<ul><li>物理上：松散耦合</li><li>逻辑上：紧密耦合</li></ul></li><li>自治性</li><li>通信性</li></ul><blockquote><p>和计算机网络的区别：分布式系统具有多机合作和健壮性</p></blockquote><h2 id="实时系统（嵌入式系统）"><a href="#实时系统（嵌入式系统）" class="headerlink" title="实时系统（嵌入式系统）"></a>实时系统（嵌入式系统）</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>及时响应</li><li>安全和可靠性</li><li>整体性</li><li>交互性较弱，通常是周期性任务。</li><li>专用系统：有特别需求</li></ul><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>异常(exception) = 陷阱(trap) + 中断(interrupt)<ul><li>中断是<strong>异步</strong>异常</li><li>陷阱是<strong>同步</strong>异常</li><li><strong>系统调用</strong>看作<strong>同步</strong>异常</li></ul></li><li>软件和硬件都可产生中断</li><li>陷阱帧：线程描述表的子集，用于现场保护。</li><li>陷阱处理程序：处理少量事件后移交给其他<strong>内核</strong>或<strong>执行体</strong>模块 </li></ul><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li><p>批处理系统</p></li><li><p>分时系统（现代OS的源头）</p></li><li><p>实时系统</p></li><li><p>混合系统（现代OS）</p><blockquote><p>现代OS是软实时，不是强实时。</p></blockquote></li></ul><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>两个进程在一个<strong>时间段</strong>内同时完成，微观上依然是有顺序的。</p><blockquote><p>并行：两个进程同时运行，多核，微观上也是并列的。</p></blockquote><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ul><li>互斥共享（打印机、变量）</li><li>同时访问（宏观）</li></ul><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><ul><li>多道程序中的CPU</li><li>SPOOLING（虚拟外围设备同时联机操作）</li><li>虚拟存储</li></ul><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><ul><li>程序以“走走停停”的方式执行</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h3><ul><li>进程/线程控制：创建和撤销</li><li>进程/线程同步：保证进程的次序正确</li><li>进程通信：进程间的数据交换</li><li>进程/线程调度：控制次序</li></ul><h3 id="存储机管理"><a href="#存储机管理" class="headerlink" title="存储机管理"></a>存储机管理</h3><ul><li>内存分配：静态和动态分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充：虚拟存储连接内外存</li></ul><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><ul><li>缓冲管理：匹配CPU和IO的速度</li><li>设备分配</li><li>设备处理：中断处理等</li><li>虚拟设备功能：防止设备产生死锁</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li>存储空间</li><li>目录管理</li><li>文件读、写管理</li><li>文件保护</li><li>为用户提供接口</li></ul><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><ul><li><p>作业调度：从磁盘到内存，再从内存写回磁盘的整个过程。</p><blockquote><p>进程调度：只指从内存进行调度的过程</p></blockquote></li><li><p>作业控制</p><ul><li>批处理</li><li>终端型</li></ul></li></ul><h2 id="OS需要解决的问题"><a href="#OS需要解决的问题" class="headerlink" title="OS需要解决的问题"></a>OS需要解决的问题</h2><ul><li>解决各种冲突<ul><li>资源的竞争引起</li></ul></li><li>协调并发的关系</li><li>保证数据的一致性<ul><li>一台机器</li><li>分布式系统</li></ul></li><li>数据存取控制</li></ul><h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><h3 id="模块接口（单体系统）"><a href="#模块接口（单体系统）" class="headerlink" title="模块接口（单体系统）"></a>模块接口（单体系统）</h3><ul><li>内聚性</li><li>耦合性</li></ul><blockquote><p>优点：开发效率高</p><p>缺点：接口定义困难</p></blockquote><h3 id="有序分层法"><a href="#有序分层法" class="headerlink" title="有序分层法"></a>有序分层法</h3><ul><li>自底向上、自顶向下</li><li>设置原则</li><li>调用方式</li></ul><blockquote><p>在<code>MULTICS</code>系统中，有许多的同心环，内环比外环有更高的级别，当<strong>外环</strong>想要调用<strong>内环</strong>的过程时，需要使用<code>TRAP</code>/<code>syscall</code>等指令。</p></blockquote><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h3 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h3><ul><li>内核中只有中断处理、进程通信(IPC)、基本调度等</li><li>其他的文件系统、网络、内存管理、设备管理都在<strong>微内核</strong>上运行</li></ul><blockquote><p>优点：内核易于实现、可移植性好、适应分布式环境</p><p>缺点：速度慢</p></blockquote><h3 id="机制与策略分离"><a href="#机制与策略分离" class="headerlink" title="机制与策略分离"></a>机制与策略分离</h3><ul><li>策略：用户自定义调度算法</li><li>机制：内核对资源的分配办法</li></ul><blockquote><ul><li>机制就是寻找最高优先级的进程并运行它，策略就是为每个进程赋予不同的优先级。</li><li>机制是框架，策略是调用组合。</li></ul></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Q：多道程序设计和分时系统的区别</p><p>A：多道设计是指，将内存分配给多个<strong>进程</strong>，<strong>轮流</strong>占用CPU。（没有进行整个内存的刷新）</p><p>​      而分时系统根据时间片刷新内存，为不同<strong>用户</strong>提供服务，依然是轮流占用CPU。</p><p>​      多道系统强调效率，一个进程分配的时间会比分时系统的时间片长，但是两者并不矛盾。</p><blockquote><p>发展过程：批处理-&gt;多道程序-&gt;分时系统</p></blockquote><h2 id="Modern-OS-Extract"><a href="#Modern-OS-Extract" class="headerlink" title="Modern OS Extract"></a>Modern OS Extract</h2><ul><li><p>用户接口程序(shell&amp;GUI)<strong>并不是</strong>操作系统的一部分</p></li><li><p>嵌入式系统<strong>没有</strong>内核态</p></li><li><p>资源时间复用就是不同的程序或用户轮流使用它</p></li><li><p>SPOOLing(Simultaneous Peripheral Operation On Line),同时的外部设备联机操作——运算完成后能立即读入下一个程序进行运算，不用等待当前程序输出完成。（多道程序设计）</p><blockquote><p>多道程序设计的本质依旧是批处理系统</p></blockquote></li><li><p>POSIX是IEEE提出的一个UNIX标准</p></li><li><p><strong>单核</strong>多线程并不提供真正的<strong>并行</strong>处理，在一个时刻只有<strong>一个进程</strong>在运行，但是线程的切换时间则减少到<strong>纳秒</strong>数量级。</p></li><li><p>GPU指的是由成千上万个<strong>微核</strong>组成的处理器</p></li><li><p>主存被分割成<strong>高速缓存行(cache line)</strong>,其典型大小为64字节。</p></li><li><p>EEPROM和闪存可以进行擦除和重写，但是ROM不可以。</p><blockquote><p>CMOS是<strong>易失性</strong>的，常被用来保持当前的时间和日期。</p></blockquote></li><li><p>为了能够使用设备驱动程序，必须把设备驱动程序装入OS中。（可能在内核态也可能在用户态运行）</p></li><li><p>即插即用：系统自动地收集有关I/O设备的信息，集中赋予终端级别和I/O地址，然后通知每块I/O卡具体的数值。</p></li><li><p><strong>批处理系统</strong>处理不需要交互式用户干预的<strong>周期性作业</strong>，例如保险公司的索赔处理和商店的销售报告；<strong>事务处理系统</strong>负责大量小的请求，例如银行的支票处理和航班预定；<strong>分时系统</strong>允许多个远程用户同时在一台计算机上运行作业。</p></li><li><p>数字音频、多媒体系统和智能手机是<strong>软实时</strong>系统。</p></li><li><p>每个<strong>进程</strong>都有一个<strong>工作目录</strong>，对于没有以斜线开头给出绝对地址的路径将在这个<strong>工作目录</strong>下进行寻找。</p><blockquote><p><code>/mnt/hgfs</code>和<code>mnt/hgfs</code>可能指不同的文件</p></blockquote></li><li><p>在读写文件之前，需要<strong>打开文件</strong>，检查访问权限。若权限许可，系统将返回一个小整数，称作文件描述符；若禁止访问，系统则返回一个错误码。</p></li><li><p><strong>块特殊文件</strong>指那些由可随机存取的块组成的设备，如磁盘等；<strong>字节特殊文件</strong>用于打印机、调制解调器和其他接受或输入字符流的设备。</p><blockquote><p>特殊文件保存在<code>\dev</code>目录中，例如<code>\dev\lp</code>是打印机。</p></blockquote></li><li><p>管道是一种虚文件，它可以连接两个进程。</p></li><li><p>对目录来说，文件保护码<code>rwx</code>中的<code>x</code>指<strong>是否可查询</strong>。</p></li><li><p>虚拟内存使得程序可以在运行时动态地链接库，而不是必须在编译时链接。</p></li><li><p>第一类虚拟机管理程序没有底层支持，所以必须自行实现所有功能（在自己的分区上进行存储管理）。</p></li><li><p>第二类虚拟机将操作系统安装在一个<strong>虚拟盘</strong>上，这个盘实际上是宿主操作系统的一个大文件，因此可以利用宿主操作系统的相关接口。</p></li><li><p>在所有情形下，操作系统的代码都是<strong>直接</strong>在硬件上执行的，不用解释器，也不是即时编译。</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul><h1 id="Chapter0-1-系统引导"><a href="#Chapter0-1-系统引导" class="headerlink" title="Chapter0-1 系统引导"></a>Chapter0-1 系统引导</h1><p>全文共<code>752</code>字，推荐阅读时间<code>5~10</code>分钟。</p><h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul><li><p>系统加电后运行的第一个程序，在内核之<strong>前</strong></p></li><li><p><code>Bootloader = Booter + Loader</code></p><ul><li>Booter负责初始化系统硬件，使其<strong>部分</strong>运行。</li><li>Loader将OS镜像加载到内存中，并跳转到OS的代码开始运行。</li></ul></li><li>可以帮助OS和硬件分离</li></ul><blockquote><p>MIPS:U-Boot</p><p>X86:LILO/GRUB</p></blockquote><h2 id="启动及引导"><a href="#启动及引导" class="headerlink" title="启动及引导"></a>启动及引导</h2><h3 id="MIPS-U-Boot"><a href="#MIPS-U-Boot" class="headerlink" title="MIPS(U-Boot)"></a>MIPS(U-Boot)</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ul><li><p>Stage1:和体系结构相关，常为<strong>汇编</strong>语言。</p></li><li><p>Stage2:为了可移植性，常为<strong>C</strong>语言。</p></li></ul><h4 id="MIPS基本地址空间"><a href="#MIPS基本地址空间" class="headerlink" title="MIPS基本地址空间"></a>MIPS基本地址空间</h4><ul><li><p><code>0x0000_0000-0x7FFF_FFFF(2GB)</code>:kuseg，需要<strong>MMU</strong>才可使用。</p></li><li><p><code>0x8000_0000-0x9FFF_FFFF(512MB)</code>:Unmapped cached(kseg0)，最高位清零则是物理地址，没有MMU也可以使用。</p><ul><li>无MMU:放置程序和数据</li><li>有MMU:操作系统<code>kernel</code>(0x80010000)</li></ul><blockquote><p>这段地址的存取几乎一定会经过cache,所以在cache设置好之前，不能随意访问。</p></blockquote></li><li><p><code>0xA000_0000-0xBFFF_FFFF(512MB)</code>:Unmapped uncached(kseg1)，<strong>高三位</strong>清零是物理地址。</p><ul><li>不用通过cache存取，通常用于访问外部设备。</li></ul></li><li><p><code>0xC000_0000-0xFFFF_FFFF(1GB)</code>:Mapped(kseg2),MMU支持。</p></li></ul><h4 id="MIPS-ROM-Flash启动地址"><a href="#MIPS-ROM-Flash启动地址" class="headerlink" title="MIPS ROM/Flash启动地址"></a>MIPS ROM/Flash启动地址</h4><ul><li>在kseg0中选择</li><li>0xBFC0_0000</li></ul><h4 id="OS引导过程"><a href="#OS引导过程" class="headerlink" title="OS引导过程"></a>OS引导过程</h4><ul><li>Head.s<ul><li>完成内核堆栈初始化</li><li>将未初始化段清零(bss)</li><li><code>start_kernel()</code></li></ul></li></ul><h3 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h3><h4 id="启动过程（与OS无关）"><a href="#启动过程（与OS无关）" class="headerlink" title="启动过程（与OS无关）"></a>启动过程（与OS无关）</h4><h5 id="第一步-启动BIOS"><a href="#第一步-启动BIOS" class="headerlink" title="第一步 启动BIOS"></a>第一步 启动BIOS</h5><ul><li>turn on</li><li>BIOS（固化在ROM中的程序）<ul><li>放在<code>0xF_FFF0</code></li></ul></li><li>加电自检(POST)</li></ul><blockquote><p> UEFI</p><ul><li>支持大硬盘引导</li><li>可移植性好</li></ul></blockquote><h5 id="第二步-读取MBR"><a href="#第二步-读取MBR" class="headerlink" title="第二步 读取MBR"></a>第二步 读取MBR</h5><p>MBR(Master Boot Record)：主引导记录，位于<strong>第0磁头的第0磁道的第1个扇区</strong>，大小是512字节。存放了启动信息、分区表信息。</p><blockquote><p>扇区(sector)</p><ul><li>磁道上的弧段</li></ul><p>磁道(track)</p><ul><li>盘片上的同心圆</li></ul><p>柱面(cylinder)</p><ul><li>不同盘片同半径的磁道构成的柱面</li></ul><p>磁头(head)</p><ul><li>每个磁盘有两个面，每个面都有一个磁头。</li></ul></blockquote><ul><li>寻找可启动的设备（硬盘扇区）</li><li>把MBR加载进内存</li></ul><blockquote><p>MBR = 启动代码 + 数据 + 分区表(DPT,Disk Partition Table) + 幻数(Magic Number)</p><p>启动代码 + 数据：0-446字节，存放<em>bootloader</em>.</p><p>分区表：447-510字节，四个分区项，各分区有16字节。</p><ul><li>第1字节：引导标志，80H表示活动分区，00H表示非活动。（装系统时用于激活）</li></ul><p>幻数：511-512字节，固定装入<code>AA</code>和<code>55</code>,如果MBR没有这两个幻数，则是没有被分区（安装了OS）的硬盘。</p></blockquote><h5 id="第三步-BIOS将控制权交给OS-BootLoader"><a href="#第三步-BIOS将控制权交给OS-BootLoader" class="headerlink" title="第三步 BIOS将控制权交给OS BootLoader"></a>第三步 BIOS将控制权交给<code>OS BootLoader</code></h5><ul><li>初始化硬件，所以Bootloder十分依赖硬件。</li><li>建立内存映射</li><li>准备调用系统内核<ul><li>GRUB和LILO是<code>Linux</code>加载器，也可以加载<code>Windows</code>.</li><li>GRUB和LILO可以放在MBR中，也可以放在活动分区的第一个扇区内（推荐）。</li></ul></li></ul><blockquote><p>内核镜像(Kernel Image) = 引导代码 + 启动代码 + 压缩的OS代码</p></blockquote><h4 id="OS引导过程-1"><a href="#OS引导过程-1" class="headerlink" title="OS引导过程"></a>OS引导过程</h4><p>bootloader-&gt;kernel-&gt;init</p><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul><h1 id="Chapter1-程序、进程和线程"><a href="#Chapter1-程序、进程和线程" class="headerlink" title="Chapter1 程序、进程和线程"></a>Chapter1 程序、进程和线程</h1><p><strong>全文共<code>1327</code>字，推荐阅读时间<code>7~10</code>分钟。</strong></p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><ul><li>编译：得到目标文件（二进制）</li><li>链接(linkage editor)：得到可执行（加载）文件</li><li>装入(loader)</li></ul><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><ul><li><p>本质是一个工具集\脚本集</p><ul><li><p>cc1:预处理器和编译器</p><blockquote><p>预处理将库、宏展开，编译器将<code>.c</code>变成<code>.s</code>,常存放在<code>\tmp</code>作为临时文件。</p></blockquote></li><li><p>as:汇编器</p><blockquote><p><code>.s</code>-&gt;<code>.o</code></p></blockquote></li><li><p>collect2:链接器</p></li></ul></li></ul><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>将<code>.o</code>文件符号化</p><h3 id="ELF-Executable-and-Linkable-Format"><a href="#ELF-Executable-and-Linkable-Format" class="headerlink" title="ELF(Executable and Linkable Format)"></a>ELF(Executable and Linkable Format)</h3><ul><li><code>.out</code>+<code>.o</code></li><li><code>.out</code>-&gt;程序头表</li><li><p><code>.o</code>-&gt;节头表</p></li><li><p><code>.bss</code>:<strong>不占</strong>文件空间的<strong>未</strong>初始化数据</p></li></ul><h4 id="文件头的定义"><a href="#文件头的定义" class="headerlink" title="文件头的定义"></a>文件头的定义</h4><ul><li>e_indent:头文件标志，前4字节是magic number.</li><li>e_type:标明文件类型，例如可执行文件、动态链接库、可重定位文件。</li><li>e_machine:体系结构，如x86、MIPS、PowerPC.</li><li>e_version:文件版本</li><li>e_entry:程序入口的<strong>虚拟</strong>地址</li><li>e_phoff:程序头表在ELF文件中的偏移</li><li>e_shoff:节头表在ELF文件中的偏移</li><li>e_eflags:处理器的标志</li></ul><h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>使用<code>readelf</code>/<code>objdump</code>反汇编实现</p><ul><li>在<code>.o</code>文件中是逻辑地址</li><li>在<code>.out</code>文件中是物理地址</li></ul><h3 id="Relocation-Entry"><a href="#Relocation-Entry" class="headerlink" title="Relocation Entry"></a>Relocation Entry</h3><ul><li><p>函数重定位地址的计算</p></li><li><p>全局变量重定位地址的计算</p></li></ul><h2 id="装载和运行"><a href="#装载和运行" class="headerlink" title="装载和运行"></a>装载和运行</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ul><li>shell调用<code>fork()</code></li><li>创建一个子进程</li><li>子进程调用<code>execve()</code>加载程序</li></ul><h3 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>一个segment在<strong>文件</strong>中的大小<strong>小于等于</strong>在<strong>内存</strong>中的大小</li><li>如果文件中大小<strong>小于</strong>在内存中的大小，则应该<strong>补零</strong>使其达到对应内存大小。</li></ul><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>读取ELF文件头的magic number: 0x7f/E/L/F</li><li>找到段表项</li><li>解析段表项需要加载到的虚地址</li></ul><h3 id="execve"><a href="#execve" class="headerlink" title="execve()"></a>execve()</h3><ul><li><code>sys_execve()</code>只是一个界面，实际在<code>do_execve()</code>中执行。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>根据文件名查找可执行文件结点</li><li>检查文件权限</li><li>设置程序参数结构</li><li>调用<code>prepare_binprm()</code>检查前128字节</li><li>调用<code>do_mmap()</code>把程序加载进内存</li><li><code>set_brk()</code>加载BSS段和初始化寄存器（包括指令寄存器）</li><li><code>start_thread()</code>进入就绪状态，等待OS调度后执行。</li></ul><blockquote><p>栈中原本存储着环境变量、命令行参数等，在下方才存访程序的函数帧。</p></blockquote><h2 id="Modern-OS-Extract-1"><a href="#Modern-OS-Extract-1" class="headerlink" title="Modern OS Extract"></a>Modern OS Extract</h2><ul><li><p>由于CPU在各个进程之间来回快速切换，因此每个进程执行的运算速度是不确定的。</p></li><li><p>通常大多数进程并不受CPU多道程序设计或者其他进程相对速度的影响</p></li><li><p>如果<strong>一个</strong>程序运行了两遍，则算作<strong>两个</strong>进程。</p></li><li><p>停留在后台处理诸如电子邮件、Web页面、新打印之类活动的进程称为<strong>守护进程(Daemon)</strong></p></li><li><p>在UNIX系统中，只有<code>fork</code>可以用来创建新进程。通常，子进程接着执行<code>execve</code>或者一个类似的系统调用，以修改其<strong>内存映像</strong>并运行一个新的程序。</p></li><li><p>在<strong>Windows</strong>中，从一开始父进程和子进程的地址空间就是<strong>不同</strong>的。</p></li><li><p>在有些系统中（<strong>不包括</strong>UNIX和Windows），当一个进程终止时，无论是自愿还是其他原因，由该进程创建的<strong>所有</strong>进程也一律被终止。</p></li><li><p>在Windows中，创建进程时父进程得到一个特别的令牌（<strong>句柄</strong>），该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他进程，因此<strong>不存在</strong>进程层次。</p></li><li><p>当正在运行的进程被调度时，不是加入<strong>阻塞</strong>队列，而是加入<strong>就绪</strong>队列。</p></li><li><p>所有的中断都从保存寄存器开始，通常是保存在进程表项中。随后，会从堆栈中删除由<strong>中断硬件机制</strong>存入堆栈的那部分信息，并将堆栈指针指向一个由<strong>进程处理程序</strong>所使用的<strong>临时堆栈</strong>。</p><blockquote><ul><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装入新的程序计数器</li><li><strong>汇编语言</strong>过程保存<strong>寄存器值</strong></li><li><strong>汇编语言</strong>过程设置<strong>新的堆栈</strong></li><li>C中断服务例程<strong>运行</strong></li><li>调度程序决定下一个运行的进程</li><li>C过程返回至汇编代码</li><li>汇编语言过程开始运行新的当前进程</li></ul></blockquote></li><li><p>每个线程有自己的程序计数器、寄存器、堆栈、状态。但是进程之间<strong>可以</strong>互相修改对方的堆栈。</p></li><li><p>如果在用户空间实现线程，则每个进程都要有其专用的<strong>线程表</strong>，用来跟踪该进程中的线程。</p></li><li><p>用户级线程的切换不需要陷入内核，也不需要上下文切换、对高速缓存进行刷新，相比于进程切换十分快捷。</p></li><li><p>用户级线程允许每个进程有<strong>自己定制</strong>的调度算法</p></li><li><p>在混合型实现方式中，每个内核线程有一个可以轮流使用的<strong>用户级线程集合</strong>。</p><blockquote><p><strong>多个</strong>用户级线程对应一个内核级线程</p></blockquote></li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul><h1 id="Chapter1-1-进程、线程与并发"><a href="#Chapter1-1-进程、线程与并发" class="headerlink" title="Chapter1-1 进程、线程与并发"></a>Chapter1-1 进程、线程与并发</h1><p>全文共<code>3661</code>字，推荐阅读时间<code>15~30</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>并发：两个活动可以在<strong>同一个</strong>处理机，也可以在<strong>不同</strong>的处理机上执行，只要满足都在正常执行即可。</p></li><li><p>并行：两个程序运行在<strong>不同</strong>的处理机上</p><blockquote><p>并发可能是<strong>伪并行</strong>，也可能是<strong>真并行</strong>。</p></blockquote></li><li><p>前趋图：<strong>有向无环</strong>图，指向下一个执行的语句、程序段或进程。</p><blockquote><p><strong>单个</strong>节点引出的多个结点是<strong>可并发</strong>的</p></blockquote></li><li><p>顺序执行</p><ul><li>顺序性</li><li>封闭性：一个时间只有一个进程<strong>独占</strong>全部资源</li><li>可再现性</li></ul></li><li><p>并发执行</p><ul><li>间断性</li><li><strong>非</strong>封闭性</li><li>不可再现性</li></ul></li><li><p>竞争：多个进程在读写共享数据时的<strong>结果</strong>依赖于它们执行的<strong>相对顺序</strong></p></li><li><p>并发进程的无关性：并发进程执行结果和顺序无关的<strong>充分条件</strong>（Bernstein条件）</p><p>若两个进程P1，P2满足</p><ul><li>P1的<strong>读区域</strong>和P2的<strong>写区域</strong>没有交集</li><li>P1的<strong>写区域</strong>和P2的<strong>读区域</strong>没有交集</li><li>P1的<strong>写区域</strong>和P2的<strong>写区域</strong>没有交集</li></ul><p>则两个进程的并发执行结果与<strong>顺序无关</strong></p></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul><li><p>进程时系统进行<strong>资源分配和调度</strong>的一个<strong>独立单位</strong>（这里的调度指<strong>资源调度</strong>，不是线程中提到的<strong>运行调度</strong>。）</p></li><li><p>$进程 = 程序 + 数据 + 进程控制块$</p><blockquote><ul><li>多次执行：一个程序对应多个进程</li><li><strong>调用</strong>：<strong>一个进程</strong>含有<strong>多个程序</strong></li></ul></blockquote></li></ul><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>程序段</li><li>数据段</li><li>进程控制块PCB</li></ul><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ul><li>代码</li><li>数据</li><li>PC值</li><li>通用寄存器的值、堆、栈</li><li>系统资源（如打开的文件）</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul><li>主要任务是<strong>创建和撤销</strong>进程和进程的<strong>状态转换</strong></li><li><strong>内核</strong>实现</li></ul><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul><li>就绪</li><li>执行</li><li>阻塞</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">执行--&gt;就绪</span><br><span class="line">就绪--&gt;执行</span><br><span class="line"></span><br><span class="line">执行--&gt;阻塞</span><br><span class="line"></span><br><span class="line">阻塞--&gt;就绪</span><br></pre></td></tr></table></figure><blockquote><p>注意<strong>就绪</strong>不能够变为<strong>阻塞</strong></p></blockquote><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ul><li>管理进程的创建和撤销</li><li>进程的<strong>唯一标志</strong></li><li>限制系统进程的<strong>总数</strong></li></ul><h5 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h5><ul><li>进程标识符</li><li>程序和数据地址</li><li>当前状态</li><li>现场保护区</li><li>互斥和同步机制：存储<strong>信号量</strong></li><li>进程通信机制</li><li>优先级</li><li>资源清单：IO设备，打开的文件等。</li><li>链接字：下一个进程的PCB</li><li>家族关系</li></ul><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><ul><li><strong>调度器</strong>执行</li><li>保存断点及相关寄存器</li><li>切换内存映射（页表基址、TLB重填）</li></ul><h4 id="陷入内核"><a href="#陷入内核" class="headerlink" title="陷入内核"></a>陷入内核</h4><ul><li>CPU状态改变</li><li>中断、异常、Trap指令（系统调用）</li><li>需要保存现场（寄存器、堆栈）</li></ul><blockquote><ul><li>进程上下文切换是指进程调度层面的<strong>大切换</strong>，因此开销很大。</li><li>进程上下文切换时<strong>一定会</strong>陷入内核</li><li>陷入内核<strong>不一定</strong>需要切换进程，有可能只是<strong>内核态和用户态</strong>的切换，因此开销较小。</li></ul></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul><li>为了弥补进程不能够灵活切换导致的功能单一、效率低的问题。</li><li>一种可以并发、<strong>可以共享地址</strong>空间的实体（第二点发挥主要作用：将<strong>资源和计算分离</strong>）</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>MS DOS：<strong>单进程、单线程</strong></li><li>早期UNIX：<strong>多进程、单线程</strong></li><li>Java：<strong>单进程、多线程</strong></li><li>NT、OS/2、SALORIS、MACH：<strong>多进程、多线程</strong></li></ul><blockquote><p>Linux并不确切区分进程和线程，而将线程定义为“执行上下文”，所以切换线程就是切换“执行上下文”。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>用户级线程：POSIX、MACH、Java</p><p>内核中只有<strong>进程表</strong>，没有<strong>线程表</strong>。</p><ul><li>优点<ul><li>移植性好</li></ul></li><li>缺点<ul><li>系统调用可能会阻塞<strong>所有的线程</strong>（线程在一个处理机上）</li><li>内核分配处理器时是以<strong>进程</strong>为单位，因此<strong>线程</strong>无法<strong>真并行</strong>。</li></ul></li></ul></li><li><p>内核级线程：Windows 2000/XP、OS/2、Linux、Solaris、UNIX、Mac OS</p><p>内核中既有<strong>进程表</strong>，又有<strong>线程表</strong>。</p><ul><li>优点<ul><li>真并行</li><li>阻塞时一般只阻塞一个线程</li></ul></li><li>缺点<ul><li>线程切换需要陷入内核，效率降低。</li></ul></li></ul></li><li><p>混合线程</p><p>用户线程和内核线程实现多路复用（映射关系可以发生变化）</p><ul><li><p>Many-to-One</p><p>多个<strong>用户级线程</strong>对应一个<strong>内核线程</strong>，线程只需要在用户空间进行统一管理，效率较高。</p></li><li><p>One-to-one</p><p>阻塞只会影响一个线程</p></li><li><p>Many-to-Many（要求<strong>内核线程数量&lt;=用户线程数量</strong>）</p></li></ul></li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li>线程安全：多个线程之间</li><li><p>可重入：在<strong>一个线程</strong>中，函数在执行的任何阶段都有可能被<strong>中断</strong>，中断处理函数中可能<strong>在该线程中</strong>再次调用这个函数，如果多次执行的结果都是正确的，那么这个函数就是可重入的。</p></li><li><p>可重入&amp;线程安全</p><ul><li>可重入<strong>不一定</strong>线程安全</li><li>线程安全<strong>不一定</strong>可重入</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reentrant</span></span><br><span class="line"><span class="comment">// NOT Thread safe</span></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add10</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmp = a;<span class="comment">// tmp may be overwritten by other threads</span></span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">10</span>;  <span class="comment">// return value will always be correct</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// non-reentrant</span></span><br><span class="line"><span class="comment">// Thread safe</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add10</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmp = a;<span class="comment">// tmp is different in every thread</span></span><br><span class="line">    <span class="keyword">return</span> tmp + <span class="number">10</span>;<span class="comment">// return value may not equal a + 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>在第一个函数中，<code>tmp</code>是全局变量，因此不同的线程可能会互相覆盖<code>tmp</code>，但是返回值永远之和参数有关，也就是说，函数的功能永远是正确的，因此线程不安全，但是可重入。</li><li>在第二个函数中，<code>tmp</code>是线程全局变量，不同的线程<strong>不能够</strong>相互修改<code>tmp</code>，但是在一个线程中多次的反复调用是可以修改<code>tmp</code>的，因此返回值不一定是<code>a+10</code>，所以线程安全，但是不可重入。</li></ul></blockquote></li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>高级调度：从用户工作流程的角度，一次提交若干个作业，对<strong>每个作业进行调度</strong>，时间单位通常是分钟、小时或天。</li><li>中级调度：<strong>内外存</strong>交换</li><li>低级调度：<strong>进程（线程）调度</strong>，时间单位通常是毫秒。<ul><li>抢占式<ul><li>时间片</li><li>优先级</li><li>短作业优先</li></ul></li><li>非抢占式</li></ul></li></ul><h3 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h3><ul><li>周转时间：作业从提交到完成所经历的<strong>总时间</strong>，通常<strong>大于等于运行时间</strong>。<ul><li>平均周转时间</li><li>带权平均周转时间</li></ul></li><li>响应时间：用户输入一个请求到系统首次相应的时间</li><li>截止时间：开始截止时间和完成截止时间</li><li>优先级：关键性任务的区分度<ul><li>不同于<strong>优先数</strong>，优先级是一个<strong>相对</strong>概念，优先数是一个<strong>绝对</strong>概念。</li></ul></li><li>公平性</li><li>吞吐量：单位时间内完成的<strong>作业数</strong></li><li>处理机利用率</li><li>资源的均衡利用</li></ul><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><h4 id="公式集锦"><a href="#公式集锦" class="headerlink" title="公式集锦"></a>公式集锦</h4><ul><li><p><strong>运行时间 = 没有进程竞争时需要的完成时间 = 只有这一个作业时需要的周转时间</strong></p></li><li><p>吞吐量 = 作业数 / 总运行时间</p></li><li><p>周转时间 = 完成时刻 - 提交时刻</p></li><li><p>带权周转时间 = 周转时间 / 运行时间</p><blockquote><p>周转时间相同时，运行时间越短，说明该作业等待的时间较长，因此需要在求周转时间是进行一定的<strong>放大</strong>。</p></blockquote></li><li><p>平均周转时间 = 周转时间之和 / 作业数</p></li><li><p>平均带权周转时间 = 带权周转时间之和 / 作业数</p></li></ul><blockquote><p>吞吐量<strong>不是</strong>平均周转时间的倒数，因为总周转时间<strong>不一定</strong>等于总运行时间。</p><p>例如在并发系统中，两个作业的周转时间分别是1.5h和2h，则总周转时间为3.5h，但是总运行时间是2h.此时，</p><ul><li>平均周转时间 = 3.5 / 2 = 1.75h</li><li>吞吐量 = 2 / 2 = 1个/h</li></ul></blockquote><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><ul><li><strong>非抢占方式</strong></li><li>当前进程如果遇到IO阻塞一样<strong>会让出</strong>CPU，但是阻塞结束后，由于非抢占，并不会立即恢复执行，而是等到当前进程让出CPU.</li><li>利于CPU繁忙的作业，不利于IO繁忙的作业。</li><li>利于长作业，不利于短作业。</li></ul><h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><ul><li><strong>非抢占方式</strong></li><li>对就绪队列中的进程按照执行时间<strong>升序</strong>排列，依次执行。</li></ul><h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><ul><li><strong>抢占式调度</strong></li></ul><h4 id="最高响应比优先"><a href="#最高响应比优先" class="headerlink" title="最高响应比优先"></a>最高响应比优先</h4><ul><li><p>每次调度时先计算作业队列中各个作业的响应比，然后选择值<strong>最大</strong>的作业运行。</p><p>响应比 = 1 + 已经等待时间 / 要求运行时间</p></li><li><p>不会出现饥饿现象</p></li><li><p>计算响应比带来时间开销，性能比SJF略低。</p></li></ul><h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><ul><li>时间片轮转</li><li>多级队列</li><li>多级反馈队列</li></ul><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul><li>排队：FCFS</li><li>轮转</li><li>中断</li><li><strong>抢占</strong>：将队首进程调到队尾，然后执行队首进程。</li><li>出让：进程未执行完一个时间片时就让出CPU（例如阻塞）</li></ul><h5 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h5><ul><li><strong>系统</strong>响应时间 = 进程数目 * 时间片长度</li><li>时间片过短时，用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间<strong>也会增加</strong>。</li></ul><h4 id="优先级算法"><a href="#优先级算法" class="headerlink" title="优先级算法"></a>优先级算法</h4><ul><li>静态优先级</li><li>动态优先级<ul><li>等待时间长则优先级升高</li><li>用完时间片都没有执行完则优先级降低</li></ul></li></ul><h5 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h5><p>高优先级进程被低优先级进程延迟或阻塞</p><ul><li>通常发生在资源竞争中，低优先级进程抢先对共享资源上锁，但是被高优先级进程抢占了CPU，而高优先级进程却因为锁只能被阻塞。</li></ul><p><strong>解决办法</strong></p><ul><li><p>优先级置顶</p><p>当任意进程进入临界区后，将其优先级设置为最高。</p></li><li><p>优先级继承</p><p>当高优先级进程发现资源被低优先级进程上锁之后，将低优先级进程的优先级临时升高和高优先级进程相等。</p></li></ul><h4 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h4><ul><li>不同队列有不同的优先级、时间片长度、调度策略。</li></ul><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><ul><li>设置多个就绪队列，分别赋予不同的优先级，队列1的优先级最高。</li><li>优先级<strong>越低</strong>的队列时间片长度也<strong>越长</strong></li><li>新进程先加入优先级最高的队列，如果时间片用完都没有执行完，则调入低一级队列，以此类推。</li><li>最后一级队列按照<strong>FCFS</strong>的策略进行调度，其他都是“时间片轮转法”。</li><li><strong>高优先级</strong>队列<strong>空</strong>时才会执行<strong>低优先级</strong>队列</li><li><strong>抢占式</strong>调度，当低优先级进程被抢占后，加入原队列的末尾。<strong>（不用改变优先级）</strong></li></ul><blockquote><ul><li>IO型进程放在<strong>高优先级</strong>队列，因为阻塞会自动让出CPU，并且计算任务通常在<strong>较短时间</strong>内即可完成。</li><li>计算型进程放在<strong>低优先级</strong>队列，最终使用<strong>大时间片</strong>执行，减少调度次数。</li></ul></blockquote><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><ul><li>时间主导</li><li>硬实时：作业<strong>绝对满足</strong>截止时间要求（汽车、飞机的控制系统）</li><li>软实时：偶尔不满足（视频播放软件）</li><li>要求每个进程的行为<strong>可预测</strong></li></ul><h4 id="调度要求"><a href="#调度要求" class="headerlink" title="调度要求"></a>调度要求</h4><ul><li><strong>抢占式</strong>调度</li><li>调度信息更多</li><li>中断快速响应</li><li>任务快速分派：采用线程调度</li></ul><h4 id="静态表调度"><a href="#静态表调度" class="headerlink" title="静态表调度"></a>静态表调度</h4><ul><li>固定的调度方案</li><li>无灵活性，任务完全固定。</li></ul><h4 id="单调速率调度-RMS"><a href="#单调速率调度-RMS" class="headerlink" title="单调速率调度(RMS)"></a>单调速率调度(RMS)</h4><ul><li><p>RMS时单处理器下<strong>最优静态调度</strong>算法</p></li><li><p>任务集可调度的<strong>充分条件</strong>是：$CPU利用率&lt;=ln2\approx0.693147$</p></li><li><p>任务周期<strong>越小</strong>优先级<strong>越高</strong>，优先级高的抢占式调度。</p><blockquote><p>优先级相等时会随机选择</p></blockquote></li></ul><h4 id="最早截止时间优先算法-EDF"><a href="#最早截止时间优先算法-EDF" class="headerlink" title="最早截止时间优先算法(EDF)"></a>最早截止时间优先算法(EDF)</h4><ul><li><p>截止时间<strong>越早</strong>，优先级<strong>越高</strong>。（<strong>动态</strong>优先级）</p><blockquote><p>优先级相等时会随机选择，有时候如果当前有没有执行完成的任务，则保持其运行可以减少一次切换。</p></blockquote></li><li><p>任务集可调度的<strong>充要条件</strong>是：$CPU利用率&lt;=1$</p></li></ul><h4 id="最低松弛度优先算法-LLF"><a href="#最低松弛度优先算法-LLF" class="headerlink" title="最低松弛度优先算法(LLF)"></a>最低松弛度优先算法(LLF)</h4><ul><li><p>任务紧急程度越高（<strong>松弛度越低</strong>），则其优先级<strong>越高</strong>。</p></li><li><p>$松弛度 = 进程截止时间 - 当前时间 - 剩余运行时间$</p></li><li><p>调度时机：进程完成/某个进程松弛度为0</p><blockquote><p>发生调度时计算被调出的进程的<strong>最晚重启时间</strong></p></blockquote></li><li><p>任务集可调度的<strong>充要条件</strong>是：$CPU利用率&lt;=1$</p></li></ul><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><ul><li>周转时间<ul><li><strong>长</strong>作业：先来先服务 <strong>优于</strong> 最高响应比优先 <strong>优于</strong> 时间片轮转</li><li><strong>短</strong>作业：时间片轮转 <strong>优于</strong> 最高响应比优先 <strong>优于</strong> 先来先服务</li></ul></li></ul><h3 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h3><ul><li>调度单位通常采用<strong>线程</strong></li></ul><h4 id="非对称式多处理系统"><a href="#非对称式多处理系统" class="headerlink" title="非对称式多处理系统"></a>非对称式多处理系统</h4><ul><li>每个处理机的分工、地位不同</li><li>一个主机负责分派任务给每个处理机</li><li>由潜在的不可靠性（主机）</li></ul><h4 id="对称式多处理系统"><a href="#对称式多处理系统" class="headerlink" title="对称式多处理系统"></a>对称式多处理系统</h4><ul><li>各个处理机的分工、地位相同</li><li>集中控制（专门的处理机负责分配）：静态/动态调度</li><li>分散控制：自调度</li></ul><h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><ul><li>每个CPU有自己的就绪队列，进程一直在同一个CPU上执行。</li><li>容易出现忙闲不均</li></ul><h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><ul><li>各个CPU共享一个就绪队列，进程可能<strong>跨CPU</strong>执行。</li><li>避免忙闲不均</li></ul><h5 id="自调度"><a href="#自调度" class="headerlink" title="自调度"></a>自调度</h5><ul><li>在动态分配的基础上，取消分配处理机，让各个CPU自由竞争。</li></ul><h5 id="成组调度"><a href="#成组调度" class="headerlink" title="成组调度"></a>成组调度</h5><ul><li>将<strong>一个进程</strong>的<strong>一组线程</strong>同时分派到<strong>不同</strong>的处理机上工作</li></ul><h5 id="专用处理机调度"><a href="#专用处理机调度" class="headerlink" title="专用处理机调度"></a>专用处理机调度</h5><ul><li>为进程每个线程都设置一个专用CPU，直到线程执行完成。</li></ul><h3 id="Linux处理机调度"><a href="#Linux处理机调度" class="headerlink" title="Linux处理机调度"></a>Linux处理机调度</h3><ul><li>2.4：O(n)</li><li>2.6.0：O(1)</li><li>2.6.23：CFS（<strong>完全公平调度器</strong>）<ul><li>使用红黑树维护就绪的进程（按照虚拟运行时间vt排序）</li><li>每次选择<strong>vt最小</strong>的进程执行（树最<strong>左侧</strong>）</li></ul></li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul><h1 id="Chapter1-2-进程同步"><a href="#Chapter1-2-进程同步" class="headerlink" title="Chapter1-2 进程同步"></a>Chapter1-2 进程同步</h1><p>全文共<code>6329</code>字，推荐阅读时间<code>30~45</code>分钟。</p><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><ul><li><p>制约</p><ul><li>直接：进程合作</li><li>间接：资源共享</li></ul></li><li><p>进程同步：多个相关进程在<strong>次序</strong>上的协调</p></li><li><p>原语：由若干条指令组成的序列，并实现某个特定的操作功能。</p><ul><li><p>指令序列的执行是连续的，不可<strong>分割</strong>。</p><blockquote><p>即指原语的执行是原子的，不能够被打断。</p></blockquote></li><li><p>OS的核心组成部分</p></li><li><p>必须在管态（内核态）下执行，且常驻内存。</p></li><li><p>根据用途进行命名，例如用于进程同步则叫做“同步原语”。</p></li></ul></li></ul><h2 id="并发错误"><a href="#并发错误" class="headerlink" title="并发错误"></a>并发错误</h2><h3 id="数据竞争-data-race"><a href="#数据竞争-data-race" class="headerlink" title="数据竞争(data race)"></a>数据竞争(data race)</h3><ul><li><p>多个进程/线程对共享变量<strong>无保护同时</strong>访问，且<strong>至少有一个</strong>是<strong>写</strong>。</p></li><li><p>互斥：一个时刻只能由一个进程访问共享数据。</p><blockquote><p>避免数据竞争</p></blockquote></li><li><p>临界区：对临界资源进行访问的<strong>程序片段</strong></p><ul><li>一个时间，临界区内只能有<strong>一个</strong>进程。</li><li>临界区外的进程不能妨碍其他的进程进入临界区</li><li>一个进程不能在临界区外<strong>无限等待</strong></li></ul></li><li><p>临界资源：一次只允许<strong>一个</strong>进程使用的资源，如打印机、共享变量。</p><blockquote><p>假脱机打印(spooling)：进程打印文件是把文件放在缓冲区，使临界资源（打印机）可以被共享访问。</p></blockquote></li></ul><h3 id="原子性违反-Atomicity-Violation"><a href="#原子性违反-Atomicity-Violation" class="headerlink" title="原子性违反(Atomicity Violation)"></a>原子性违反(Atomicity Violation)</h3><ul><li><code>HeisenBug</code></li><li>多线程结果不可再现的原因<ul><li>不同的环境输入</li><li>不同的API返回</li><li>不同的调度时间</li><li>中断时间</li><li>共享内存访问的顺序（取决于各个核执行的快慢）</li></ul></li><li>执行<strong>重放技术</strong>：在执行时记录所有的相关信息，重放时再写回。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>进程集合中都在<strong>互相等待</strong></li></ul><h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待：当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</li></ul><h2 id="互斥方法"><a href="#互斥方法" class="headerlink" title="互斥方法"></a>互斥方法</h2><h3 id="基于忙等待的互斥方法"><a href="#基于忙等待的互斥方法" class="headerlink" title="基于忙等待的互斥方法"></a>基于忙等待的互斥方法</h3><ul><li><p>忙等：不能满足进入临界区条件就一直等</p><blockquote><p>可能导致优先级反转：进入临界区后的进程被调度后依然在临界区中</p><p>Q：用户级线程实现会不会发生优先级反转</p><p>A： 不会。</p><p>在<strong>用户级</strong>线程之间，因为抢占发生在<strong>进程</strong>级别，所以低优先级不会被高优先级抢占。但是<strong>内核级</strong>线程可能会发生优先级反转。</p></blockquote></li><li><p>屏蔽中断</p><ul><li>用户程序不可取（安全问题）</li><li>关闭中断<strong>只能关闭</strong>一个CPU</li><li>内核常使用</li></ul></li><li><p>共享锁变量</p><ul><li>初值设置为0</li><li>发现未上锁，并且在上锁（置1）<strong>前</strong>被调度的话会导致多个进程进入临界区</li></ul><blockquote><p>读取和设置锁<strong>必须</strong>是一个原子操作</p></blockquote></li><li><p>严格轮换法</p><ul><li><p>要求<strong>两个</strong>进程交替执行（使用<code>turn</code>实现）</p></li><li><p>由于IO可能会导致进程被<strong>未处在</strong>临界区的进程阻塞，违反了同步机制和临界区的规则。</p></li></ul></li><li><p>Peterson算法</p><ul><li><p>在严格轮换法基础上增加<code>interested[]</code>表示进程是否会马上使用CPU</p><blockquote><ul><li>当两个进程同时调度<code>enter_region</code>时，先被写入的<code>turn</code>会被覆盖，因此调度执行的可能会是后写<code>turn</code>的进程。</li><li>并发执行也能正常执行，但是<strong>非抢占式</strong>调度可能导致不公平。</li></ul></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line"><span class="keyword">int</span> interested[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> procnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> othernum;</span><br><span class="line">    </span><br><span class="line">    othernum = <span class="number">1</span> - procnum;</span><br><span class="line">    interested[procnum] = TRUE;</span><br><span class="line"><span class="built_in">turn</span> = procnum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">turn</span> == procnum &amp;&amp; interested[other] == TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> procnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    interested[procnum] = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>硬件指令机制</p><ul><li><p><code>TSL</code>：CPU会锁住<strong>内存总线</strong></p></li><li><p><code>XCHG</code>：<strong>原子性</strong>的值交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVE REG,#1</span><br><span class="line">XCHG REG,LOCK</span><br></pre></td></tr></table></figure></li></ul></li><li><p>信号量机制(Semaphore)</p><ul><li><p>原子操作：一组相关联的操作要么<strong>不间断</strong>地执行，要么<strong>都不</strong>执行。</p></li><li><p>S有且只有一次置初值的机会</p><ul><li><p>$S&gt;0$：表示可以同时获取的资源数目</p><blockquote><p>不同的OS中可能出现$S&lt;0$的情况</p></blockquote></li><li><p>只能由P/V操作改变</p></li></ul></li><li><p>$P(S)$：<code>down</code>操作分配资源</p></li><li><p>$S&gt;0$：信号量减1后继续执行</p><ul><li>$S=0$：进程被直接阻塞，减1操作等到阻塞完成后再执行。 </li></ul><blockquote><p>原子操作，只有一个进程能完成$P(S)$.</p></blockquote></li><li><p>$V(S)$：<code>up</code>操作释放资源</p><ul><li><p>首先将S加1</p></li><li><p>如果加1后发现有进程在信号量队列中<code>sleep</code>,则随机唤醒一个进程然后进行<code>P(S)</code></p><blockquote><p>S：0-&gt;1-&gt;0</p></blockquote></li></ul></li><li><p>实现</p><ul><li>DS：一个整数+一个队列（类似哈希链表）</li><li>操作前关闭中断，操作后打开中断。</li><li>单CPU：关闭中断后测试并更新信号量</li><li>多CPU：使用<strong>锁变量</strong>保护信号量，使用<code>TSL</code>/<code>XCHG</code>保证每次只能由一个CPU检查<strong>信号量</strong>。</li></ul></li></ul><blockquote><p>类似于分配一个数组中的元素，s是数组的元素个数，当s设置为1时，就是<code>mutex</code>（互斥）的。</p></blockquote></li></ul><h3 id="基于信号量的方法"><a href="#基于信号量的方法" class="headerlink" title="基于信号量的方法"></a>基于信号量的方法</h3><p>信号量将<code>sleep</code>和<code>wakup</code>信息存储了起来，避免了相关信息丢失造成的死锁。</p><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><ul><li>信号量初值设置为1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line">P(mutex)</span><br><span class="line">a();</span><br><span class="line">V(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line">P(mutex);</span><br><span class="line">b();</span><br><span class="line">V(mutex);</span><br></pre></td></tr></table></figure><h4 id="汇合-Rendezvous"><a href="#汇合-Rendezvous" class="headerlink" title="汇合(Rendezvous)"></a>汇合(Rendezvous)</h4><ul><li><p>两个进程的同步，使得a1永远在b2之前，b1永远在a2之前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore aArrived = <span class="number">0</span>; <span class="comment">// not 1</span></span><br><span class="line">semaphore bArrived = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1</span></span><br><span class="line">a1();</span><br><span class="line">V(aArrived);</span><br><span class="line">P(bArrived);</span><br><span class="line">a2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// P2</span></span><br><span class="line">b1();</span><br><span class="line">V(bArrived);</span><br><span class="line">P(aArrived);</span><br><span class="line">b2();</span><br></pre></td></tr></table></figure></li></ul><h4 id="多路复用-Multiplex"><a href="#多路复用-Multiplex" class="headerlink" title="多路复用(Multiplex)"></a>多路复用(Multiplex)</h4><ul><li><code>mutex</code>泛化，使n个线程能够<strong>同时在临界区</strong>运行，也称为限流阀。</li></ul><h4 id="屏障-Barriers"><a href="#屏障-Barriers" class="headerlink" title="屏障(Barriers)"></a>屏障(Barriers)</h4><ul><li><p>低级通信原语</p></li><li><p>对Rendezvous进行<strong>泛化</strong>，能够同步<strong>多个</strong>线程。 </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = the number of threads</span><br><span class="line">count = <span class="number">0</span> <span class="comment"># threads arrive at barrier</span></span><br><span class="line">semaphore mutex = <span class="number">1</span> <span class="comment"># protect count</span></span><br><span class="line">semaphore barrier = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">count = count + <span class="number">1</span></span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count == n:</span><br><span class="line">    V(barrier)</span><br><span class="line">P(barrier)</span><br><span class="line">V(barrier)</span><br></pre></td></tr></table></figure><blockquote><p>注意在<code>count==n</code>时地进程也需要执行尾部的一对PV操作</p></blockquote><h4 id="“信号量集”机制"><a href="#“信号量集”机制" class="headerlink" title="“信号量集”机制"></a>“信号量集”机制</h4><ul><li>当出现多个临界资源时（多个对不同信号量的P操作），不正确的PV顺序可能会导致死锁。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1</span></span><br><span class="line">P(mutex1); <span class="comment">// step 1</span></span><br><span class="line">P(mutex2); <span class="comment">// wait</span></span><br><span class="line">V(mutex2); <span class="comment">// cannot execute</span></span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line">P(mutex2); <span class="comment">// step 2</span></span><br><span class="line">P(mutex1); <span class="comment">// wait</span></span><br><span class="line">V(mutex1); <span class="comment">// cannot execute</span></span><br><span class="line">V(mutex2);</span><br></pre></td></tr></table></figure><h4 id="AND型信号量集"><a href="#AND型信号量集" class="headerlink" title="AND型信号量集"></a>AND型信号量集</h4><ul><li>同时需要<strong>多个</strong>资源且每种占用<strong>一个</strong>资源</li><li>基本思想：将几个进程需要的所有资源一次性分配给其中一个进程，等它使用完它需要的资源后再释放。</li><li>$SP(S_1,S_2,…,S_n)$</li><li>$SV(S_1,S_2,…,S_n)$</li><li>可能影响SP操作进程化归到不同的阻塞队列，但是资源的<strong>原子性</strong>获取不受影响，所以不会死锁。</li></ul><blockquote><p>当某个资源数量不够时，其他资源也<strong>不会被</strong>分配，因此<strong>原子性</strong>分配保证了安全性。</p></blockquote><h4 id="一般“信号量集”机制"><a href="#一般“信号量集”机制" class="headerlink" title="一般“信号量集”机制"></a>一般“信号量集”机制</h4><ul><li><p>同时需要多种资源，每种占用数目<strong>不同</strong>，并且被分配的资源还存在一个<strong>临界值</strong>（大于该临界值才能够分配资源）。</p></li><li><p>$SP(S_1,t_1,d_1;…;S_n,t_n,d_n)$</p><p><code>ti</code>是检测值，当所有<code>Si&gt;=ti</code>时才分配<code>di</code>个<code>i</code>类资源，其余情况则阻塞。</p></li><li><p>$SV(S_1,d_1;…;S_n,d_n)$</p></li></ul><blockquote><p>特殊情况：</p><ul><li>$SP(S,d,d)$：每次分配d个资源，少于d时不分配。</li><li>$SP(S,1,1)$：当S初值为1时，等价于<code>mutex</code>.</li><li>$SP(S,1,0)$：开关机制，S为0时可以禁止所有的进程进入临界区。</li></ul></blockquote><h4 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量(Mutex)"></a>互斥量(Mutex)</h4><ul><li>信号量设置为1就是互斥量</li><li><strong>0表示解锁，1表示加锁。</strong>（和PV操作中0阻塞不同）</li><li>如果<code>mutex</code>已经加锁，调用<code>mutex_lock</code>会阻塞。</li><li>主要在<strong>用户线程库</strong>实现</li><li><code>mutex_trylock</code>使得进程不会因为无法获得锁而阻塞，而是返回错误码。</li></ul><h3 id="基于管程的同步和互斥"><a href="#基于管程的同步和互斥" class="headerlink" title="基于管程的同步和互斥"></a>基于管程的同步和互斥</h3><h4 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h4><ul><li>一种<strong>高级</strong>的同步原语，基于条件变量实现。</li><li>定义了一个数据结构和并发进程能执行的一组操作</li><li>为每个临界资源设立一个管程</li><li>任意时刻，管程中只能有一个活跃进程。</li></ul><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul><li>增加<code>wait/signal</code>操作</li><li>条件变量不像信号量可以存储信号，因此<code>wait</code>必须在<code>signal</code>之前执行。</li></ul><blockquote><ul><li>依赖于编译器支持</li><li>不适用于分布式系统</li></ul></blockquote><h3 id="进程通信-IPC-方法"><a href="#进程通信-IPC-方法" class="headerlink" title="进程通信(IPC)方法"></a>进程通信(IPC)方法</h3><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li>低级通信：只能传递<strong>状态和整数值</strong>（控制信息）<ul><li>进程互斥/同步采用的信号量和管程机制</li></ul></li><li><p>高级通信：可以传递任意数量的数据</p><ul><li>管道(Pipe)</li><li>共享内存(Shared Memory)：最快的IPC形式</li><li>消息系统</li></ul><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4></li><li><p>无名管道：使用<code>|</code>连接</p><ul><li>半双工：<strong>单方向</strong>流动</li><li>只能用于<strong>父子</strong>进程/<strong>兄弟</strong>进程</li></ul></li><li>有名管道：使用<code>mkfifo()</code>创建</li></ul><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><ul><li><p>通信原语</p><ul><li><code>send(dest, &amp;message)</code></li><li><code>receive(src, &amp;message)</code></li></ul></li><li><p>过程：</p><ul><li>发起<code>send</code>请求并<strong>陷入内核</strong></li><li>将消息复制进入OS空间的消息缓冲区</li><li>将消息加入<strong>接收进程</strong>PCB的消息队列</li><li>将消息复制到<strong>接收进程</strong>中</li></ul></li><li><p>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore buf_empty = N;</span><br><span class="line">semaphore buf_full = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1 = <span class="number">1</span>; <span class="comment">// mem</span></span><br><span class="line">semaphore mutex2 = <span class="number">1</span>; <span class="comment">// PCB queue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// send</span></span><br><span class="line">P(buf_empty);</span><br><span class="line">P(mutex1);</span><br><span class="line">dup_to_mem();</span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line">P(mutex2);</span><br><span class="line">add_to_queue();</span><br><span class="line">V(mutex2);</span><br><span class="line">V(buf_full);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reveive</span></span><br><span class="line">P(buf_full);</span><br><span class="line">P(mutex1);</span><br><span class="line">dup_to_proc();</span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line">P(mutex2);</span><br><span class="line">del_from_queue();</span><br><span class="line">V(mutex2);</span><br><span class="line">V(buf_empty);</span><br></pre></td></tr></table></figure><blockquote><p>本质上也是一个生产者-消费者模型</p><ul><li>消费者<strong>一开始</strong>就申请满缓冲区，<strong>最后</strong>释放空缓冲区。</li><li>生产者<strong>一开始</strong>就申请空缓冲区，<strong>最后</strong>释放满缓冲区。</li></ul></blockquote></li></ul><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul><li>需要同步机制的约束</li></ul><h2 id="经典的进程同步问题"><a href="#经典的进程同步问题" class="headerlink" title="经典的进程同步问题"></a>经典的进程同步问题</h2><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><ul><li>网络应用响应</li></ul><h3 id="读写者问题"><a href="#读写者问题" class="headerlink" title="读写者问题"></a>读写者问题</h3><ul><li><p>共享资源<strong>并发</strong>访问</p></li><li><p>分类互斥问题</p><ul><li><p>写进程在临界区：其他进程不可以进入临界区</p></li><li><p>读进程在临界区：写进程不可以进入临界区</p><blockquote><p>第一个读线程加锁，最后一个读线程解锁。（灯开关模式）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readers = <span class="number">0</span>;</span><br><span class="line">  semaphore mutex = <span class="number">1</span>;</span><br><span class="line">  semaphore roomEmpty = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  cobegin&#123;</span><br><span class="line">    <span class="built_in">Process</span> Writer</span><br><span class="line">      P(roomEmpty);</span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">      V(roomEmpty);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Process</span> Reader</span><br><span class="line">      P(mutex);</span><br><span class="line">      <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">          P(roomEmpty);</span><br><span class="line">      readers += <span class="number">1</span>;</span><br><span class="line">      V(mutex);</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">read</span>();</span><br><span class="line">  </span><br><span class="line">      P(mutex);</span><br><span class="line">      readers -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">          V(roomEmpty);</span><br><span class="line">      V(mutex);</span><br><span class="line">  &#125;coend</span><br></pre></td></tr></table></figure></li><li><p>实现方式</p><ul><li><p>一般信号量集机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore readers = N;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin&#123;</span><br><span class="line">    <span class="built_in">Process</span> Writer</span><br><span class="line">    SP(mutex,<span class="number">1</span>,<span class="number">1</span>;readers,N,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    SV(mutex,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Process</span> Reader</span><br><span class="line">    SP(mutex,<span class="number">1</span>,<span class="number">0</span>;readers,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    SV(readers,<span class="number">1</span>);</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure><blockquote><p>在写者中维护<code>mutex</code>，在读者中维护<code>readers</code>.</p></blockquote></li><li><p><code>wait-signal</code></p></li><li><p>PV</p></li></ul><blockquote><p>灯开关模式对<strong>读</strong>有利，对<strong>写</strong>不利。</p></blockquote></li><li><p>公平读写（非饥饿版本）</p><ul><li>使用<code>barrier</code>实现<code>Turnstile</code></li><li>闸机可以阻塞所有的进程，也可以让进程轮流通过。<ul><li>当信号量为0，闸机关闭，任何进程都<strong>不能够</strong>进入。（在写者<strong>进入</strong>后设置）</li><li>当信号量为1，闸机打开，允许多个进程<strong>排队</strong>进入。（在写者<strong>完成</strong>后设置）</li></ul></li></ul><blockquote><p>是否完全公平还取决于<strong>调度器</strong>选择哪一个在<code>turnstile</code>中排队的进程</p></blockquote></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int readers = <span class="number">0</span></span><br><span class="line">Semaphore mutex = <span class="number">1</span><span class="comment"># mutually exclusively access readers</span></span><br><span class="line">Semaphore roomEmpty = <span class="number">1</span></span><br><span class="line">Semaphore turnstile = <span class="number">1</span> <span class="comment"># use turnstile as a barrier to make it fair</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader</span></span><br><span class="line">P(turnstile)</span><br><span class="line">V(turnstile)</span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">readers += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (readers == <span class="number">1</span>):</span><br><span class="line">    P(roomEmpty) <span class="comment"># the first reader will lock the room</span></span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line">read_in_critical_region()</span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">reader -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(readers == <span class="number">0</span>):</span><br><span class="line">    V(roomEmpty) <span class="comment"># the last reader will unlock the room</span></span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Writer</span></span><br><span class="line">P(turnstile) <span class="comment"># wait in line of turnstile</span></span><br><span class="line">P(roomEmpty) <span class="comment"># wait in line of roomEmpty</span></span><br><span class="line"></span><br><span class="line">write_in_critical_region()</span><br><span class="line"></span><br><span class="line">V(roomEmpty) <span class="comment"># after writing, unlock the room.</span></span><br><span class="line">V(turnstile) <span class="comment"># after writing, reopen the turnstile.</span></span><br></pre></td></tr></table></figure><blockquote><p>在两个进程最开始都是获得<code>turnsile</code>，不会出现写者获得<code>turnsile</code>并且<code>roomEmpty</code>被锁定时的同时没有任何<strong>读进程</strong>在执行的死锁情况。（一定先有读进程获得了<code>turnsile</code>才会获得<code>roomEmpty</code>.</p></blockquote><h3 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h3><ul><li><p>理发店中有一位理发师、一把理发椅和<code>n</code>把等候椅。</p></li><li><p>没有顾客时，理发师在理发椅上休息，顾客到来时叫醒理发师。</p></li><li><p>顾客到来时，如果有空椅子则等待，否则离开。</p></li><li><p>分析：</p><ul><li><p><strong>互斥</strong>：两个进程对等待人数的改变</p><blockquote><p>本质是两个进程都会改变的<strong>非信号量</strong></p></blockquote></li><li><p><strong>同步</strong>：第一个顾客唤醒理发师，理发师唤醒下一个顾客。</p><blockquote><p>本质是使用<strong>信号量</strong>进行进程间同步</p></blockquote></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAIRS 10</span></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore clients = <span class="number">0</span>;</span><br><span class="line">semaphore barber = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin&#123;</span><br><span class="line">    Barber</span><br><span class="line">    P(clients);</span><br><span class="line">    </span><br><span class="line">    P(mutex);</span><br><span class="line">    waiting -= <span class="number">1</span>;</span><br><span class="line">    V(mutex);</span><br><span class="line">    </span><br><span class="line">    cut();</span><br><span class="line">    V(barber);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Client</span></span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting == CHAIRS)</span><br><span class="line">    &#123;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    waiting += <span class="number">1</span>;</span><br><span class="line">    V(mutex)</span><br><span class="line">    </span><br><span class="line">    V(clients);</span><br><span class="line">    P(barber);</span><br><span class="line">    get_cut();</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>P</code>操作就是在排队，相当于是一个<code>while(conditionNotSatisfied);</code>阻塞。</li><li><code>waiting</code>计数在限制等待容量时才有意义</li><li>在某某些条件不满足直接返回时（如没有椅子直接离开和没有顾客直接睡觉），要<strong>释放</strong>当前进程已经占有的资源，不能够直接<code>continue</code>或者<code>return</code>.</li><li><code>waiting</code>和<code>clients</code>虽然意义相似，但是信号量不能直接取值进行比较，所以需要增加<code>waiting</code>.</li><li>在<code>Barber</code>线程中，将<code>P(clients)</code>放在最前面可以简化将<code>waiting</code>放在前面时对0的判断。</li></ul></blockquote><h3 id="有序唤醒问题"><a href="#有序唤醒问题" class="headerlink" title="有序唤醒问题"></a>有序唤醒问题</h3><ul><li>顾客接受服务的顺序应该和进入顺序保持一致</li><li>分析：<ul><li>互斥：当前已经进入银行的人员总数</li><li>同步：注意<strong>同一个柜台连续两次</strong>服务的人员<code>id</code>可能是<strong>跳跃</strong>的</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> clients = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next_id = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore next_mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin&#123;</span><br><span class="line">    Stuff</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(next_mutex);</span><br><span class="line">        <span class="keyword">if</span>(next_id == clients)</span><br><span class="line">        &#123;</span><br><span class="line">            V(next_mutex);</span><br><span class="line">            V(mutex);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_id += <span class="number">1</span>;</span><br><span class="line">        V(next_mutex);</span><br><span class="line">        V(mutex);</span><br><span class="line"></span><br><span class="line">        serve(next_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Client</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    P(mutex);</span><br><span class="line">    clients += <span class="number">1</span>;</span><br><span class="line">    id = clients;</span><br><span class="line">V(mutex);</span><br><span class="line">    </span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure><blockquote><ul><li>此时人员不用<strong>唤醒柜台</strong>（柜台没有睡觉），柜台会自动进行服务，所以能够简化<code>stuff</code>信号量。</li></ul></blockquote><h3 id="固定差值问题"><a href="#固定差值问题" class="headerlink" title="固定差值问题"></a>固定差值问题</h3><ul><li>无限大的仓库装A和B，要求两者始终满足库存$-M&lt;=A-B&lt;=N$</li><li>分析：<ul><li>互斥：A和B的差值，只取正数的话需要分为两个。</li><li>同步：满足条件时才能够继续入库</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">semaphore sa = N; <span class="comment">// A - B</span></span><br><span class="line">semaphore sb = M; <span class="comment">// B - A</span></span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">&#123;</span><br><span class="line">A</span><br><span class="line">    P(sa);</span><br><span class="line">   a += <span class="number">1</span>;</span><br><span class="line">    V(sb);</span><br><span class="line">    </span><br><span class="line">    B</span><br><span class="line">    P(sb);</span><br><span class="line">    b += <span class="number">1</span>;</span><br><span class="line">    V(sa);</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果仓库容量有限，可以在两个进程的最前面加一个判断。</li><li>增加<strong>一个</strong>消费者：需要先对库存进行<strong>非零</strong>判断，同时，P操作其实隐含了一个条件判断，所以在消费是，需要把P操作放在V操作之前，如果P不能通过，那么V就不应该出现。<ul><li>消费A：<code>P(sb)&amp;V(sa)&amp;mutex</code></li><li>消费B：<code>P(sa)&amp;V(sb)&amp;mutex</code></li></ul></li></ul></blockquote><h3 id="构建水分子-H2O"><a href="#构建水分子-H2O" class="headerlink" title="构建水分子(H2O)"></a>构建水分子(H<sub>2</sub>O)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">oxygen = <span class="number">0</span></span><br><span class="line">hydrogen = <span class="number">0</span></span><br><span class="line">Semaphore mutex = <span class="number">1</span> <span class="comment"># only oxygen or hydrogen can be modified at a time</span></span><br><span class="line">Barrier barrier(<span class="number">3</span>)  <span class="comment"># after wait for three times, process can go on.</span></span><br><span class="line">Semaphore oxyQueue = <span class="number">0</span></span><br><span class="line">Semaphore hydroQueue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># oxygen atom</span></span><br><span class="line">P(mutex)</span><br><span class="line">oxygen += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (hydrogen &gt;= <span class="number">2</span>):</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    hydrogen -= <span class="number">2</span></span><br><span class="line">    V(oxygenQueue)</span><br><span class="line">    oxygen -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    V(mutex)</span><br><span class="line">P(oxygenQueue)</span><br><span class="line">bond()</span><br><span class="line">barrier.wait()</span><br><span class="line">V(mutex) <span class="comment"># only oxygen thread has this V operation</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hydrogen atom</span></span><br><span class="line">P(mutex)</span><br><span class="line">hydrogen += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (hydrogen &gt;= <span class="number">2</span> <span class="keyword">and</span> oxygen &gt;= <span class="number">1</span>):</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    hydrogen -= <span class="number">2</span></span><br><span class="line">    V(oxygenQueue)</span><br><span class="line">    oxygen -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    V(mutex)</span><br><span class="line">P(hydrogenQueue)</span><br><span class="line">bond()</span><br><span class="line">barrier.wait()</span><br></pre></td></tr></table></figure><blockquote><ul><li>分子中有<strong>几个原子</strong>就开<strong>几个线程</strong></li><li>同时开启三个线程/进程，由于氧原子<strong>进程</strong>只有一个，因此最后释放<code>mutex</code>的操作在氧原子操作中。</li><li><code>bond()</code>操作会在三个原子凑齐后在三个线程中<strong>各</strong>被调用一次。</li><li><code>mutex</code>同时对<code>hydrogen</code>和<code>oxygen</code>进行了上锁操作。</li></ul></blockquote><h2 id="死锁-deadlock"><a href="#死锁-deadlock" class="headerlink" title="死锁(deadlock)"></a>死锁(deadlock)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>并发死锁</p><p>并发程序执行的<strong>顺序不当</strong>造成的死锁</p></li><li><p>资源死锁</p><ul><li>$饥饿\neq死锁$</li></ul><blockquote><p>资源</p><ul><li>可剥夺资源：CPU、内存。</li><li>非可剥夺资源：CD刻录机、打印机、<strong>临时性资源（消息、中断）</strong></li></ul></blockquote></li></ul><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li>互斥：一段时间内某个资源只能够由<strong>一个</strong>进程占用</li><li>保持和请求：已经得到资源的线程<strong>可以</strong>请求新的资源（多个锁的请求顺序）</li><li>不剥夺：已经获得资源的进程不能被强制剥夺该资源，只能自行释放。</li><li>环路（循环）等待条件：发生死锁时必然存在多个进程组成的环形链。</li></ul><h3 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h3><ul><li><p>鸵鸟算法</p><p>死锁概率小、影响低时可以考虑。</p></li><li><p>死锁检测&amp;死锁恢复(detection and recovery)</p><ul><li>允许死锁发生，发生后采取措施恢复。</li><li>检测方法<ul><li>资源分配图<ul><li>使用场景：每类资源只有<strong>一个</strong></li></ul></li><li>资源向量计算<ul><li>使用场景：每类资源有<strong>多个</strong></li></ul></li></ul></li></ul></li><li><p>死锁预防(avoidance)</p><ul><li><p><strong>静态</strong>行为</p></li><li><p>破坏四个<strong>必要条件</strong>之一（或更多）</p></li></ul></li><li><p>死锁避免(prevention)</p><ul><li><strong>动态</strong>行为</li><li>分配资源前进行<strong>安全检查</strong><ul><li>银行家算法：运行前知道所有进程所需资源的最大值</li></ul></li></ul></li></ul><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>检测算法核心：是否存在进程之间的<strong>循环等待</strong></p><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>适合每类资源只有一个的死锁检测，主要是检查图中是否存在<strong>有向环</strong>。</p><ul><li>圆形：进程(<code>P</code>)</li><li>方形：资源(<code>R</code>)</li><li>资源-&gt;进程：资源被占用</li><li>进程-&gt;资源：进程正在请求资源</li></ul><blockquote><p>作图：<strong>先画资源然后画进程</strong></p></blockquote><h4 id="资源向量（矩阵）法"><a href="#资源向量（矩阵）法" class="headerlink" title="资源向量（矩阵）法"></a>资源向量（矩阵）法</h4><p><strong>概念</strong></p><p>适用于每类资源有多个的死锁检测</p><p>$\sum_{i=1}^{n}C_{ij}+A_j=E_j$</p><p>当前分配矩阵中选定一列和A中对应列一起求和的值等于资源总量中对应的列的值。</p><ul><li>E(existing resource vector)：存在资源<strong>行向量</strong>，表示各类资源存在的<strong>总量</strong>。</li><li>A(available resource vector)：可用资源<strong>行向量</strong>，当前未被分配的可用资源数.</li><li>C(current allocation matrix)：当前分配<strong>矩阵</strong>，第<code>i</code>个行向量对应第<code>i</code>个进程<strong>已经分配</strong>到的各类资源数量。</li><li>R(request matrix)：第<code>i</code>个行向量表示第<code>i</code>个进程<strong>还需要的</strong>资源数量</li></ul><p><strong>实现步骤</strong></p><ul><li>寻找进程$P_i$,要求其在R矩阵中对应的第<code>i</code>行<strong>小于等于</strong>A，如果找不到，则跳过下一步。</li><li>使$P_i$运行完成，将$P_i$的当前分配向量<code>flush</code>到A中，并<strong>标记该进程执行完毕</strong>，然后<strong>跳转回第一步</strong>。</li><li>算法结束，如果存在没有标记的进程，则发生死锁。</li></ul><blockquote><p>Q：选择$P_i$的顺序是否有影响</p><p>A：没有，这是一个饱和式算法，会有多次遍历。</p></blockquote><h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><ul><li><p>资源抢占法</p><p>挂起一些占有资源的进程，解除死锁，等待死锁结束后，<strong>再次激活</strong>这些被挂起的进程。</p></li><li><p>杀死进程法</p><p>杀死一个或若干进程，直到打破死循环。</p><blockquote><p><strong>编译进程</strong>可以，但是<strong>数据库进程、打印进程</strong>等不可以。</p></blockquote></li><li><p>回滚法</p><p>设置检查点（记录上下文），当出现死锁时选择一个拥有资源的进程回滚到<strong>未占用资源</strong>的检查点状态。</p><ul><li>定期创建检查点</li><li>回滚常用来<strong>容错</strong><ul><li>数据库事务</li><li>高可用服务系统：脱敏疗法（脱离过敏原）</li></ul></li></ul></li></ul><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul><li><p>打破互斥条件</p><p>使用假脱机技术让独占资源共享（缓冲区）</p></li><li><p>打破保持和请求条件</p><ol><li>当进程需要的<strong>所有</strong>资源都满足后一次性分配，进程结束后再<strong>统一释放</strong>。<strong>（SP&amp;SV操作）</strong></li><li>每次请求资源之前<strong>先释放</strong>已有资源，然后再尝试<strong>获取所有的资源</strong>。</li></ol><blockquote><p>局限：</p><ul><li>不可预测</li><li>资源利用率低</li><li>降低进程的并发性</li></ul></blockquote></li><li><p>打破不可抢占条件</p><p>允许进程强行抢占某些资源</p></li><li><p>打破循环等待条件</p><p>提前为资源编号，分配资源时必须按照顺序进行。</p><blockquote><p>局限：</p><ul><li>增加系统开销</li><li>因为必须按照顺序申请，则“挡”在<strong>现在</strong>需要的资源之前的进程也要被<strong>一并申请</strong>，因此会增加进程对资源的占用时间。(不产生竞争条件的资源<strong>不用</strong>进行编号)</li></ul></blockquote></li></ul><h3 id="哲学家进餐问题-the-dining-philosophers-problem"><a href="#哲学家进餐问题-the-dining-philosophers-problem" class="headerlink" title="哲学家进餐问题(the dining philosophers problem)"></a>哲学家进餐问题(the dining philosophers problem)</h3><p>解决思路</p><ul><li>每次只允许4个哲学家竞争餐具，则总有一个哲学家可以进餐完毕。（破除<strong>循环等待</strong>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Semaphore dinners = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_forks</span><span class="params">(i)</span>:</span></span><br><span class="line">    dinners.wait()</span><br><span class="line">    </span><br><span class="line">    forks[right[i]].wait()</span><br><span class="line">    forks[left[i]].wait()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_forks</span><span class="params">()</span>:</span></span><br><span class="line">    forks[right[i]].signal()</span><br><span class="line">    forks[left[i]].signal()</span><br><span class="line">    </span><br><span class="line">    dinners.signal()</span><br></pre></td></tr></table></figure><ul><li><p>假如至少一个左撇子和一个右撇子，则不会发生死锁。（反证法）（破除<strong>循环等待</strong>）</p></li><li><p>对餐具进行编号，哲学家按照<strong>升序</strong>拿餐具。（破除<strong>循环等待</strong>）</p><p>本质上，1号哲学家是<strong>右撇子</strong>，5号哲学家是<strong>左撇子</strong>。</p><blockquote><p>Q：当被1和5号筷子夹着的1号哲学家哲学家用餐时，是否会同时占用2、3、4？</p><p>A：不会。假设大家都拿起了筷子，那么1、5或者1、2之间的哲学家一定有一个没有拿起，不如假设是前者。那么4、5之间的哲学家可以正常用餐，放下筷子后又可以正常进行竞争，因此1、5之间的哲学家不需要去竞争2、3、4，所以便不会出现问题中描述的情况。</p></blockquote></li><li><p>对哲学家编号，奇数号先拿左再拿右，偶数号相反。（破除<strong>循环等待</strong>）</p><blockquote><p>相当于加入了左撇子和右撇子</p></blockquote></li><li><p><strong>同时拿起</strong>两边的餐具，要不都不拿。（破除<strong>保持等待</strong>）</p></li><li><p><code>Tanebum</code>算法：加入对哲学家状态<code>eating</code>/<code>bungry</code>的判断</p><blockquote><p>破除<strong>死锁</strong>，但是依然有<strong>饥饿</strong>现象。</p></blockquote></li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p><strong>动态策略</strong>，对每个资源请求进行检查，避免<strong>资源死锁</strong>。</p><blockquote><p>这里的动态和死锁恢复不一样，死锁恢复的动态体现在死锁<strong>发生后</strong>，而这里是死锁<strong>发生前</strong>。</p></blockquote><ul><li><p>安全序列：不产生死锁的资源分配顺序</p></li><li><p>安全状态：没有死锁时，所有进程突然请求<strong>最大</strong>需要的资源量<strong>（同时请求并不是同时分配）</strong>，也<strong>不发生</strong>死锁。</p></li><li><p>不安全状态：<strong>不存在</strong>安全序列使进程可以运行完毕</p><blockquote><p>系统进入不安全状态也<strong>不一定</strong>会产生死锁；但是产生死锁后，<strong>一定处于</strong>不安全状态。</p><p>Q：为什么不安全状态不一定产生死锁</p><p>A：不安全状态是由<strong>最大需求</strong>推导出的，但是实际上，可能在进程下一次真正申请资源时，资源条件已经得到满足，从而<strong>不产生</strong>死锁。</p></blockquote></li></ul><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul><li><p>可用资源向量(Available)</p></li><li><p>最大需求矩阵(Max)</p></li><li><p>分配矩阵(Allocation)</p></li><li><p>需求矩阵(Need)</p><p>$Need_{ij}=Max_{ij}-Allocation_{ij}$</p></li></ul><p><strong>实现步骤：</strong></p><p>设request是P的请求向量，且需要k个R类资源</p><ul><li>${request}\leq{need}$则进入下一步，否则认为出错。（请求资源超过了<strong>事先约定的</strong>限额）</li><li>${request}\leq{available}$则进入下一步，否则进入等待状态。</li><li>系统模拟把资源分配给P,并执行<strong>安全性算法检查</strong>。</li><li>如果检查通过，则正式分配资源，否则恢复到模拟前的状态，让P等待。</li></ul><p><strong>安全性算法：</strong></p><ul><li><p>设置两个向量</p><ul><li><p>工作向量(Work)：表示系统<strong>可提供的各类资源的数目</strong></p><p>初始时<code>Work:=Available</code></p></li><li><p>完成向量(Finish)：表示系统是否有足够的资源分配给进程</p><p>初始时<code>Finish[i]:=false</code>，如果资源足够（<strong>不是检查通过</strong>）则置为<code>true</code>.</p></li></ul></li><li><p>寻找满足以下条件的进程</p><ul><li>$Finish[i]=false$</li><li>${Need_i}\leq{Work}$</li></ul><p>如果找到则进入下一步，否则跳过。</p></li><li><p>将Allocation<code>flush</code>到Available并返回上一步</p></li><li><p>如果<code>Finish[i]=true</code><strong>都成立</strong>则检查通过</p></li></ul><blockquote><p>特点：</p><ul><li>算法考虑到了<strong>互斥、部分分配、不可抢占</strong>，因而可提高资源利用率</li><li>要求实现说明最大资源要求，在现实中无法使用。</li></ul></blockquote><h4 id="资源分配图-1"><a href="#资源分配图-1" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>原理和银行家算法相同</p><ul><li>封锁进程：对应银行家算法中Need无法被满足的线程</li><li>非封锁进程：没有被封锁的进程</li><li>化简：一个进程运行完成则使其成为孤立节点</li></ul><p>死锁定理：</p><ul><li>死锁等价于资源分配图<strong>不能</strong>完全化简（不能全部成为孤立节点）</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Q：一个进程的死锁是否存在？</p><p>A：否，死锁发生时必须存在环路（必要条件）</p><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul><h1 id="Chapter2-内存管理"><a href="#Chapter2-内存管理" class="headerlink" title="Chapter2 内存管理"></a>Chapter2 内存管理</h1><p>全文共<code>1684</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="存储器硬件"><a href="#存储器硬件" class="headerlink" title="存储器硬件"></a>存储器硬件</h2><ul><li>RAM<ul><li>SRAM：常用于制作高速缓存</li><li>DRAM：常用于制作主存</li><li>SDRAM、DDR SDRAM：常用于制作主存</li></ul></li><li>ROM<ul><li>PROM、EPROM、EEPROM</li></ul></li><li>FLASH<ul><li>NOR</li><li>NAND</li></ul></li><li>DISK</li><li>Tape</li></ul><blockquote><ul><li>RAM是易失性存储，ROM是非易失性存储。</li><li>RAM和ROM是内存（reg+cache+主存）</li><li>ROM只读，FLASH可写容量小，RAM可读写容量大。</li></ul></blockquote><h2 id="基本需求"><a href="#基本需求" class="headerlink" title="基本需求"></a>基本需求</h2><ul><li>独立性：程序发出的地址和物理地址不相关</li><li>保护性：一个程序不能访问另一个程序的地址空间</li></ul><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><ul><li>主要内容：存储分配和回收</li><li>地址变换<ul><li>可执行文件<strong>生成</strong>时的<strong>链接</strong>技术</li><li>程序<strong>加载</strong>时的<strong>重定位</strong>技术</li><li>进程<strong>运行</strong>时硬件和软件地址<strong>变换</strong>技术</li></ul></li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><ul><li>分配原则：多退少补，但是退的太少时就不退了。</li><li><p>空闲分区合并：注意取哪个分区的首地址</p></li><li><p>分配算法</p><ul><li>下次适应算法：尽管一个分区没有分配完，但是再次寻找时还是会跳转到下一个分区。</li></ul></li></ul><h2 id="碎片处理"><a href="#碎片处理" class="headerlink" title="碎片处理"></a>碎片处理</h2><h3 id="内碎片"><a href="#内碎片" class="headerlink" title="内碎片"></a>内碎片</h3><ul><li><strong>只能</strong>等待释放</li></ul><h3 id="外碎片"><a href="#外碎片" class="headerlink" title="外碎片"></a>外碎片</h3><ul><li><p>紧凑技术(Compaction)：将多个空闲分区拼接</p><p>技术支撑：动态重定位（<strong>不同于</strong>装载）-&gt;移动作业时，内存位置会发生变化。</p></li></ul><h2 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h2><h3 id="覆盖-Overlay"><a href="#覆盖-Overlay" class="headerlink" title="覆盖(Overlay)"></a>覆盖(Overlay)</h3><ul><li>将程序分成多个<strong>独立</strong>的程序段，利用时间差共享同一块<strong>小内存</strong>区域。</li></ul><blockquote><p>分段需要程序员进行，增加了负担。</p></blockquote><h3 id="交换-Swapping"><a href="#交换-Swapping" class="headerlink" title="交换(Swapping)"></a>交换(Swapping)</h3><ul><li>以程序为单位进行主存与辅存间的交换</li></ul><h2 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li>x86保护模式下段式访存不能禁止，但是页式访存可以启用和禁止。</li><li>多级页表页目录所在地址的计算（按照抽象层级的方法计算）</li></ul><h2 id="Modern-OS-Extract-2"><a href="#Modern-OS-Extract-2" class="headerlink" title="Modern OS Extract"></a>Modern OS Extract</h2><ul><li><p>当一个进程运行时，程序的<strong>起始物理地址</strong>装载到<strong>基址寄存器</strong>中，<strong>程序的长度</strong>装载到<strong>界限寄存器</strong>中。</p></li><li><p>对每个进程都使用基址寄存器和界限寄存器的缺点就是每次访问内存都需要进行加法和比较运算</p></li><li><p>在决定把一个占<code>k</code>个分配单元的进程调入内存时，存储管理器必须搜索位图，在位图中找到有<code>k</code>个<strong>连续0</strong>的串。查找位图中指定长度的<code>0</code>串时耗时的操作，因为串可能跨越了<strong>最小分配单元</strong>。</p></li><li><p><strong>下次适配算法</strong>每次在<strong>上一次</strong>结束的地方开始搜索，而不是像首次适配算法、最佳适配算法那样<strong>从头开始</strong>搜索。</p><blockquote><p>下次适配的性能略<strong>低于</strong>首次适配算法</p></blockquote></li><li><p>为进程和空闲区设置独立的链表，即<strong>进程链表</strong>和<strong>空闲区链表</strong>分离，可以提高算法的速度。</p></li><li><p>空闲区链表可以合并进空闲区本身——例如空闲区第一个字是空闲区大小，第二个字指向下一个空闲区。</p></li><li><p>覆盖技术是指一个程序的若干程序段，或者<strong>几个程序</strong>的某些部分共享某一个存储空间。</p><blockquote><p>由程序员将程序分割成多个片段</p></blockquote></li><li><p>页表的目的式把虚拟页面映射为页框。从数学角度说，页表是一个函数，它的参数是<strong>虚拟页号</strong>，结果是<strong>物理页框号</strong>。</p></li><li><p>对于IO映射到内存中的设备而言，需要在页表中设置<strong>高速缓存禁止位</strong>，但是对于独立的IO空间和不使用内存映射IO的设备则不需要。</p></li><li><p>发生缺页中断时，操作系统需要调入的页面的磁盘地址等信息保存在操作系统内部的<strong>软件表格</strong>中，硬件(MMU)<strong>不需要它</strong>。</p></li><li><p>地址放入MMU进行转换时，硬件首先通过将虚拟页号和TLB中<strong>所有表项并行</strong>进行匹配，判断虚拟页面是否在其中。</p></li><li><p>当一个页面访问在内存中而不再TLB中时，产生<strong>软失效</strong>；当页面本身不在内存中时（当然也不在TLB中），将产生<strong>硬失效</strong>。</p></li><li><p>在反置页表中，实际内存中的每个<strong>物理页框</strong>对应一个表项。</p></li><li><p>在反置页表中，当进程访问虚拟页面时，必须搜索<strong>整个</strong>反置页表来查找某个页表项。</p><blockquote><p>可以使用Hash加速</p></blockquote></li><li><p>引入多级页表的原因是避免把全部页表一直保存在内存中，特别是某些从来都不会用到的页表。</p><blockquote><p>当只有单级页表时，因为需要直接使用虚拟地址访问到对应的页表项，所以需要用<strong>页表始址寄存器</strong>保存页表的起始物理地址。由于这个寄存器的个数限制（只有一个），所有的页表只能被放在固定的地址上，因此单级页表需要一块<strong>连续</strong>的<strong>物理</strong>内存空间用来存放页表。</p><p>但是对于多级页表，只需要用这个寄存器存储一级页表的物理始址，之后查找的高级页表就可以是不连续的了。</p></blockquote></li><li><p>当调度一个进程执行时，<strong>必须</strong>为新进程<strong>重置</strong>MMU，<strong>刷新</strong>TLB，以清楚以前的进程遗留的痕迹。</p></li><li><p>如果分页算法是全局算法，包含IO缓冲区的页面也<strong>有很小的可能</strong>会被换出内存。此时如果一个IO设备正处在对该页面的DMA传输过程中，则传输的数据一部分在换出前的缓冲区页面中，一部分在新装入的页面中。</p><blockquote><p>解决方法一般有两种：</p><ul><li>将此类页面设置为<strong>不可换出</strong>的</li><li>在<strong>内核缓冲区</strong>中完成IO操作后再将数据复制到<strong>用户页面</strong></li></ul></blockquote></li><li><p>由于程序正文通常是只读的，当内存资源紧张、程序页不得移出内存时，尽管丢弃它们，再需要的时候再从可执行文件读入即可。</p><blockquote><p><strong>共享库</strong>正是使用这个方式工作</p></blockquote></li><li><p><strong>每个</strong>段由一个从<strong>0到最大的线性地址序列</strong>构成，不同的段的长度可以不同，并且在运行期间可以动态改变。</p><blockquote><p>堆栈段的长度再数据被压入时会增长，在数据弹出时又会减小。</p></blockquote></li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul><h1 id="Chapter2-1-分页系统管理及设计"><a href="#Chapter2-1-分页系统管理及设计" class="headerlink" title="Chapter2-1 分页系统管理及设计"></a>Chapter2-1 分页系统管理及设计</h1><p>全文共<code>3463</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><ul><li>发生缺页中断时，OS必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。</li><li>置换算法存在于许多领域<ul><li>高速缓存的置换问题</li><li>Web服务器的网页置换问题</li></ul></li></ul><h2 id="最优置换算法-OPT"><a href="#最优置换算法-OPT" class="headerlink" title="最优置换算法(OPT)"></a>最优置换算法(OPT)</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>换出<strong>未来</strong>最长时间内<strong>不会</strong>被访问的页面</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul><li>对所有<strong>逻辑</strong>页面的<strong>下一次</strong>访问时间进行排序</li><li>换出最大时间对应的的<strong>物理</strong>页面</li></ul><h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><ul><li>无法实现</li><li>意义是作为评价标准的<strong>上限</strong></li></ul><blockquote><p>可以首先在仿真程序上运行程序，跟踪所有页面的访问情况，然后正式执行时利用仿真信息其实可以实现最有置换算法。</p></blockquote><h2 id="最近未使用页面置换算法-NRU"><a href="#最近未使用页面置换算法-NRU" class="headerlink" title="最近未使用页面置换算法(NRU)"></a>最近未使用页面置换算法(NRU)</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在最近的一个时钟周期内，淘汰一个<strong>没有被访问</strong>的<strong>已修改</strong>页面要比淘汰一个被<strong>频繁使用</strong>的<strong>干净</strong>页面更好。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><ul><li>为每个页面设置R位和M位<ul><li>R表示页面是否被访问</li><li>M表示页面是否被修改</li></ul></li><li><strong>R位</strong>（不是M位）定期地被清零</li><li>所有页面可以被分为以下四类<ul><li>0：没有被访问，没有被修改。</li><li>1：没有被访问，已经被修改。</li><li>2：已经被访问，没有被修改。</li><li>3：已经被访问，已经被修改。</li></ul></li><li>淘汰时<strong>随机</strong>选择编号小的类进行修改</li></ul><h3 id="特征-3"><a href="#特征-3" class="headerlink" title="特征"></a>特征</h3><ul><li>易于理解并且可以被有效实现</li><li>性能并不是最好的</li></ul><h2 id="先进先出-First-In-First-Out-FIFO"><a href="#先进先出-First-In-First-Out-FIFO" class="headerlink" title="先进先出(First-In First-Out,FIFO)"></a>先进先出(First-In First-Out,FIFO)</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ul><li>选择进入内存时间<strong>最长</strong>的页面进行置换</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><ul><li>构造按时间<strong>降序</strong>排列的链表</li><li>调出<strong>头部</strong>页面，调入页面接在<strong>尾部</strong>。</li></ul><h3 id="特征-4"><a href="#特征-4" class="headerlink" title="特征"></a>特征</h3><ul><li>实现简单</li><li>性能低</li><li>Belady现象：因为头部页面也可能被访问，增加物理页框后缺页<strong>不一定</strong>减少。</li><li>很少<strong>单独</strong>使用</li></ul><h2 id="第二次机会页面置换算法"><a href="#第二次机会页面置换算法" class="headerlink" title="第二次机会页面置换算法"></a>第二次机会页面置换算法</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><ul><li>在FIFO基础上增加对链表头页面的访问位判断</li></ul><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><ul><li>检查链表头页面的R位<ul><li>如果R位是0，则<strong>头部</strong>页面可以直接被淘汰。</li><li>如果R位是1，则将R位清零，然后把链表头页面插在<strong>尾部</strong>，从<strong>头</strong>开始继续搜索。</li></ul></li><li>淘汰页面后进行新页面的插入。</li></ul><h3 id="特征-5"><a href="#特征-5" class="headerlink" title="特征"></a>特征</h3><ul><li>发生缺页时，如果链表中所有页面的R位都是1，则二次机会算法退化为FIFO.</li></ul><h2 id="时钟置换算法-Clock"><a href="#时钟置换算法-Clock" class="headerlink" title="时钟置换算法(Clock)"></a>时钟置换算法(Clock)</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><ul><li>在二次机会算法的机会上使用<strong>环形</strong>链表简化<strong>线形</strong>链表的“<strong>掐头去尾</strong>”操作</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><ul><li><p>环形链表的指针指向<strong>最老的页面</strong></p><blockquote><p>在页面链表中，最先被调入的页面就是最老的页面。</p></blockquote></li><li><p>发生缺页中断时，检查页面的R位</p><ul><li><p>如果R位为0，则被指向的页面可以直接被淘汰。</p></li><li><p>如果R位为1，则将R位清零，然后将表指针顺时针/逆时针转动。</p><blockquote><p>旋转方向和插入页面的方向<strong>相同</strong></p></blockquote></li></ul></li><li><p>当装入页面后，指针需要移动到新页面的<strong>下一个</strong>相邻的<strong>旧页面</strong>处。</p><blockquote><p>此时被指向的<strong>旧页面</strong>就是当前环形链表中<strong>最老</strong>的页面</p></blockquote></li></ul><h3 id="特征-6"><a href="#特征-6" class="headerlink" title="特征"></a>特征</h3><ul><li>相比于二次机会算法，减少了链表操作。</li></ul><h2 id="最近最少使用页面置换算法-LRU"><a href="#最近最少使用页面置换算法-LRU" class="headerlink" title="最近最少使用页面置换算法(LRU)"></a>最近最少使用页面置换算法(LRU)</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><ul><li>局部性原理</li><li>选择<strong>最长</strong>时间没有被访问的页面置换</li></ul><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><ul><li>维护一个所有页面的链表，按照上次使用到现在的时间<strong>升序</strong>排序，则最近最多使用的页面在链表头，最近最少使用的页面在链表尾。</li></ul><blockquote><ul><li>这种方法在每次<strong>正常</strong>访存（没有缺页）时都要更新链表——访问一个页面就在链表中找到它，删除后移动到链表头。</li></ul></blockquote><ul><li>发生缺页中断则删除<strong>尾部</strong>页面，将新页面插在链表头。</li></ul><h4 id="计数器实现"><a href="#计数器实现" class="headerlink" title="计数器实现"></a>计数器实现</h4><ul><li>在每个页表项处维护一个”上次使用时间“寄存器</li><li>发生缺页中断时，选择寄存器值<strong>最小</strong>的页面进行置换。</li></ul><h3 id="特征-7"><a href="#特征-7" class="headerlink" title="特征"></a>特征</h3><ul><li>代价高</li><li>可能需要特殊硬件实现</li><li><strong>没有</strong>Belady现象</li></ul><h2 id="最不常用算法-LFU"><a href="#最不常用算法-LFU" class="headerlink" title="最不常用算法(LFU)"></a>最不常用算法(LFU)</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><ul><li>置换从<strong>上电</strong>开始访问次数最少的页面</li></ul><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><ul><li>发生<strong>时钟中断</strong>时，OS扫描所有的页面，将R位为1的页面的计数器加1.<strong>（同时把R位清零）</strong></li><li>发生<strong>缺页中断</strong>时，置换计数器值最小的页面。<strong>（但是不对其他页面计数器进行清零操作）</strong></li></ul><h3 id="特征-8"><a href="#特征-8" class="headerlink" title="特征"></a>特征</h3><ul><li>LRU的简化版本，开销依然较大。</li><li>”不忘记任何事情“，在整个系统的运行过程中<strong>所有的</strong>访问都会被记录在案，在中途不会被清除。</li></ul><h2 id="老化算法-Aging"><a href="#老化算法-Aging" class="headerlink" title="老化算法(Aging)"></a>老化算法(Aging)</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><ul><li>在LFU的基础上，增加移位操作，规避”钉子户“现象。</li></ul><h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><ul><li>每次<strong>时钟中断</strong>时，OS扫描所有的页面，将R位为1的页面的计数器<strong>右移一位</strong>，然后将<strong>最高位</strong>置为1.</li><li><strong>缺页中断</strong>时，置换计数器值最小的页面。<strong>（但是不对其他页面计数器进行清零操作）</strong></li></ul><h3 id="特征-9"><a href="#特征-9" class="headerlink" title="特征"></a>特征</h3><ul><li>相比于LRU，老化算法记录了更长时间段内页面的访问情况，而不只是<strong>上一次</strong>。</li><li>计数器的位数是有限的，因此相比于LFU，老化算法能够记录的绝对访问次数是<strong>有限的</strong>。</li></ul><h2 id="工作集页面置换算法"><a href="#工作集页面置换算法" class="headerlink" title="工作集页面置换算法"></a>工作集页面置换算法</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><ul><li><p>当发生缺页中断时，淘汰一个不在工作集中的页面。</p></li><li><p>一个进程当前正在使用的页面的集合称为它的<strong>工作集</strong>。</p><ul><li>工作集是随着<strong>时间</strong>变化的</li><li>工作集就是<code>W(t,Δ)</code><ul><li>t：时刻</li><li>Δ：工作集窗口(working-set window)，一个<strong>定长</strong>的页面访问时间段（窗口）。</li><li><code>W(t,Δ)</code>是当前时刻t<strong>前</strong>Δ时间窗口内<strong>所有</strong>访问页面组成的集合</li><li><code>|W(t,Δ)|</code>是工作集中页面数目</li><li><code>W</code>是一个<strong>单调不减函数</strong></li></ul></li><li>当工作集基本稳定之后，当程序<strong>重新开始</strong>时，就有可能根据上次<strong>结束</strong>时的工作集进行一个推测，从而在本次程序开始运行前进行<strong>预调页</strong>操作。</li></ul></li><li>若每执行几条指令就发生一次缺页中断，则称这个程序发生了<strong>颠簸</strong>。</li></ul><h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><ul><li>设置一个时间窗口<code>t</code>，每个<strong>页框</strong>在原有基础上增加对<strong>上次使用时间</strong>的记录。</li><li>发生<strong>时钟中断</strong>时，需要清空页面的R位。</li><li>发生<strong>缺页中断</strong>时，扫面检查所有页面的R位。<ul><li>如果R位为1，则设置页面的<strong>上次使用时间</strong>为<strong>当前时间</strong>。</li><li>如果R位为0<ul><li>若页面生存时间<strong>大于</strong>时间窗口<code>t</code>，则淘汰该页面。</li><li>若页面生存时间<strong>小于等于</strong>时间窗口<code>t</code>，则将其加入淘汰页面候选列表。</li></ul></li></ul></li><li>在淘汰页面候选列表中选择<strong>上次使用时间最小</strong>的页面进行淘汰</li><li>无法选出时，则随机选择一个页面进行淘汰，不过最好是<strong>干净的</strong>（未被修改）页面。</li></ul><h3 id="特征-10"><a href="#特征-10" class="headerlink" title="特征"></a>特征</h3><ul><li>开销大</li><li>对局部性明显的程序效果好</li></ul><h2 id="工作集时钟页面置换算法-WSClock"><a href="#工作集时钟页面置换算法-WSClock" class="headerlink" title="工作集时钟页面置换算法(WSClock)"></a>工作集时钟页面置换算法(WSClock)</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><ul><li>在工作集算法的基础上，简化每个时钟周期遍历所有页面的操作。</li></ul><h3 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h3><ul><li><p>构建以<strong>页框</strong>为元素的循环链表</p></li><li><p>发生<strong>时钟中断</strong>时，需要清空页面的R位。</p></li><li><p>发生<strong>缺页中断</strong>时</p><ul><li><p>对R位的处理和时钟置换算法相同</p></li><li><p>当碰到R=0的页面时</p><ul><li><p>如果生存时间大于时间窗口</p><ul><li><p>如果页面是干净的，则淘汰该页面。</p></li><li><p>如果该页面被修改过，则发起磁盘回写（异步），指针继续旋转处理下一个页面。</p><blockquote><p>为了降低磁盘阻塞，需要设置一个限制，在一个循环中，<strong>最大</strong>只允许写回<code>n</code>个页面。</p></blockquote></li></ul></li><li><p>如果生存时间小于等于时间窗口，则更新上次使用时间。</p></li></ul></li></ul></li><li><p>在指针循环一整周后，可能是以下两种情况。</p><ul><li><p>至少发起过一次回写操作</p><p>说明发现了工作集<strong>外</strong>的脏页面，但是<strong>没有</strong>工作集外的干净页面。此时指针<strong>继续旋转</strong>，淘汰遇到的第一个干净页面（回写操作已经完成的工作集外页面）</p><blockquote><p>此时遇到的第一个干净页面<strong>不一定</strong>是第一个发起回写的页面，因为磁盘驱动程序可能将回写任务进行了<strong>重排序</strong>。</p></blockquote></li><li><p><strong>没有</strong>发起过回写操作</p><p>此时指针一圈都没有发现工作集外的页面，则随便置换一个干净的页面来使用。</p><blockquote><p>旋转时可以记录下干净页面的位置</p></blockquote><p>如果此时循环表中没有干净的页面，则<strong>相当于</strong>再进行一次<strong>所有页面都在工作集外的依次回写</strong>循环，再下一圈一定能够化归到<strong>至少发起过一次回写操作</strong>的情况中。</p></li></ul></li></ul><h3 id="特征-11"><a href="#特征-11" class="headerlink" title="特征"></a>特征</h3><ul><li>开销较大</li><li>实现简单</li><li>性能较好</li><li>应用广泛</li></ul><blockquote><p>最好的算法通常是老化算法和工作集时钟算法，在实际应用中通常是最重要的。</p></blockquote><h2 id="分页系统设计"><a href="#分页系统设计" class="headerlink" title="分页系统设计"></a>分页系统设计</h2><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><ul><li><p>局部：在进程内部进行页面置换</p></li><li><p>全局</p></li></ul><div class="table-container"><table><thead><tr><th>局部</th><th>全局</th></tr></thead><tbody><tr><td>每个进程有固定的内存片段</td><td>各个进程的页框数随时间变化</td></tr><tr><td>/</td><td>通常效果<strong>优于</strong>局部算法</td></tr><tr><td>基于工作集的算法<strong>只有</strong>在局部策略下才有意义</td><td>/</td></tr></tbody></table></div><h3 id="缺页中断率算法-PFF"><a href="#缺页中断率算法-PFF" class="headerlink" title="缺页中断率算法(PFF)"></a>缺页中断率算法(PFF)</h3><h4 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h4><ul><li>缺页中断率 = <strong>每秒</strong>的缺页中断数</li></ul><h4 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h4><ul><li>PFF将每个进程的缺页中断率控制在一个可以接受的范围内</li></ul><h3 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h3><p>调节<strong>并发</strong>进程数(MPL,multiprogramming level)，增大某个进程拥有的内存，从而降低该进程的缺页率。</p><ul><li>进程页面大小和 = 内存大小</li><li>平均缺页时间间隔(MTBF) = 缺页异常处理时间(PFST)</li></ul><h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><p>通常小页面更优</p><ul><li><p>小尺寸页面可以减小内碎片</p></li><li><p>传输一个大页面和一个小页面所花费的时间通常差别不大</p><blockquote><ul><li>装入64个512字节的页面可能需要64*10ms</li><li>装入4个8KB页面可能需要4*12ms</li></ul></blockquote></li><li><p><strong>但是</strong>，<strong>大</strong>页面能更充分地利用TLB空间。（占用的页表项更少）</p></li><li><p><strong>内核</strong>使用大页面，<strong>用户进程</strong>使用小页面。</p></li></ul><h3 id="指令和数据空间分离"><a href="#指令和数据空间分离" class="headerlink" title="指令和数据空间分离"></a>指令和数据空间分离</h3><p>将指令和数据地地址空间分离，每个地址空间<strong>都从0开始</strong>到某个最大值。</p><h3 id="共享-1"><a href="#共享-1" class="headerlink" title="共享"></a>共享</h3><ul><li>共享页面<ul><li>写时保护机制</li></ul></li><li>共享库</li></ul><h4 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h4><ul><li><p>任何在目标文件中被调用了但是没有被定义的函数，都被称作<strong>未定义外部函数</strong>(undefined externals)</p></li><li><p>当一个共享库被装载和使用时，整个库<strong>并不是一次性</strong>地读入内存。而是根据需要，以<strong>页面</strong>为单位进行装载的，因此没有被调用到的函数<strong>不会</strong>被装载进内存中。</p></li><li><p>当多个程序引用同一个库时，装载时的重定位就会<strong>失效</strong>。</p><blockquote><p>重定位是指在链接时根据函数的<strong>最终</strong>位置对指令进行修正的过程，这个<strong>最终</strong>位置通常是指<strong>程序绝对起始位置+函数相对位置</strong>。</p><p>由于不同的程序链接后产生的可执行文件不同，因此程序绝对起始地址会有不同，此时在指令中同一个函数的最终位置就会不同，因此调用就会发生错误。</p></blockquote></li><li><p>在编译时使用特殊选项告知编译器，仅仅使用与<strong>相对地址</strong>有关的指令，避免<strong>绝对地址</strong>的出现，就可以实现正确的库共享。（这种只使用<strong>相对偏移量</strong>的代码叫做<strong>位置无关代码</strong>）</p></li></ul><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><ul><li>比共享库更为<strong>通用</strong>的一种机制</li><li>进程可以发起一个系统调用，将一个文件映射为虚拟地址空间的<strong>一部分</strong>。</li><li>可以实现<strong>高速</strong>进程间通信</li></ul><h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><ul><li><p>发生缺页中断时，如果内存中有大量空闲页框，说明分页系统工作状态好。</p></li><li><p>增加<strong>分页守护进程</strong>，该进程大多数时候睡眠，但是定期唤醒检查内存状态。如果内存中空闲页框过少（<strong>不一定没有空闲页框</strong>），则该进程同过一定的分页置换算法将一部分页面换出，同时<strong>可能会</strong>发起磁盘写回请求。</p><blockquote><p>分页守护进程就可以保证真正发生缺页中断时，被替换的页框大都是干净的。</p></blockquote></li></ul><h3 id="虚拟内存接口"><a href="#虚拟内存接口" class="headerlink" title="虚拟内存接口"></a>虚拟内存接口</h3><ul><li>允许程序员控制虚拟内存的映射关系，增强某些进程的行为。</li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li><li>TSU OS Lecture, Spring Of 2019.</li></ul><h1 id="Chapter3-设备管理"><a href="#Chapter3-设备管理" class="headerlink" title="Chapter3 设备管理"></a>Chapter3 设备管理</h1><ul><li>全文共<code>4275</code>字，推荐阅读时间<code>15~20</code>分钟</li><li>若没有特殊说明，本文中I/O与IO等价。</li><li>有输入输出功能的设备都叫做I/O设备，没有特殊说明时，设备等价于I/O设备。</li></ul><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>提高效率</li><li>方便使用：对不同类型的设备统一使用方法</li><li>方便控制：OS<strong>增加和删除</strong>设备</li></ul><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><ul><li>提供用户接口：<strong>命令</strong>接口和<strong>编程</strong>接口</li><li>设备分配和释放</li><li>设备的访问和控制：<strong>并发</strong>访问和<strong>差错处理</strong></li><li>I/O缓冲和调度：提高效率</li></ul><h3 id="总线-Bus"><a href="#总线-Bus" class="headerlink" title="总线(Bus)"></a>总线(Bus)</h3><p>接入I/O设备的<strong>主要</strong>方式</p><ul><li>PCI：卡类接口为主</li><li>PCIe</li><li>SCSI：快于PCI，接硬盘、打印机等智能设备。</li><li>expansion：扩展总线，不与上面三种标准并列。</li></ul><p>$总线带宽=频率*宽度(Bytes/sec)$</p><h2 id="管理概述"><a href="#管理概述" class="headerlink" title="管理概述"></a>管理概述</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>把<strong>硬件设备</strong>抽象为<strong>控制器</strong>，用<strong>应用程序和文件系统</strong>统一管理所有I/O.（IO设备可以直接从<strong>应用程序或者文件系统</strong>得到请求，并负责完成这个请求。）</p><ul><li>逻辑I/O：与设备<strong>无关</strong>的操作，例如设备分配和释放。</li><li>设备驱动程序：通过读写设备寄存器来<strong>真正控制</strong>设备</li><li>中断服务程序：<strong>设备</strong>工作结束<strong>后</strong>向<strong>CPU</strong>发<strong>中断</strong>信号</li></ul><h3 id="I-O分类"><a href="#I-O分类" class="headerlink" title="I/O分类"></a>I/O分类</h3><h4 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h4><ul><li><p>块设备：以数据<strong>块</strong>为单位进行读写，速率高，<strong>可寻址</strong>（随机读写）。（磁盘、光盘、USB）</p><p>块大小通常在512B到65536B<strong>(64KB)</strong>之间(2<sup>9</sup>~2<sup>16</sup>)</p></li><li><p>字符设备：字符为单位进行读写，速率低，<strong>不可寻址</strong>。（打印机网络接口、鼠标）</p></li></ul><blockquote><ul><li>这种分类方式并<strong>没有</strong>囊括所有的设备，例如时钟和内存映射的显示器。</li><li>文件系统只处理<strong>抽象</strong>的块设备，把与设备相关的部分留给更底层的软件实现。</li></ul></blockquote><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>存储设备</li><li>传输设备</li><li>人机交互设备</li></ul><h4 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h4><ul><li><p>独占分配：<strong>一段时间</strong>只能由<strong>一个进程</strong>使用，如打印机、磁带机等。</p></li><li><p>共享设备：硬盘</p></li><li><p>虚设备：用<strong>共享</strong>设备模拟<strong>独占</strong>设备，用<strong>高速</strong>设备模拟<strong>低速</strong>设备。（例如Spooling技术下的打印机是共享设备）</p><blockquote><p>因为可以<strong>共享</strong>，所以才能够利用假脱机技术来<strong>模拟</strong>独占。</p></blockquote></li></ul><h3 id="目标和任务"><a href="#目标和任务" class="headerlink" title="目标和任务"></a>目标和任务</h3><ul><li>完成I/O请求<ul><li>设备分配和回收</li><li>设备驱动程序：真正的操作</li><li>设备中断管理</li><li>缓冲区</li></ul></li><li>建立<strong>统一</strong>接口<ul><li>屏蔽物理硬件的细节</li></ul></li><li>提高CPU与设备、设备与设备之间的<strong>并行</strong>工作能力，提高资源利用率。</li><li>保护数据安全</li></ul><h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><ul><li><p>功能</p><ul><li>接收、识别CPU命令</li><li>数据交换</li><li>报告设备状态</li><li><strong>地址处理</strong></li><li><strong>作为缓冲区</strong></li><li>差错检查</li></ul></li><li><p>组成</p><ul><li><p>控制器和<strong>CPU</strong>接口（向<strong>上</strong>）：寄存器</p><ul><li><p>控制寄存器</p></li><li><p>状态寄存器</p></li><li><p>数据寄存器</p></li></ul></li><li><p>控制器与<strong>设备</strong>接口（向<strong>下</strong>）：信号</p><ul><li>控制信号</li><li>状态信号</li><li>数据信号</li></ul></li><li><p>I/O逻辑：解释I/O控制指令（处理来自上下接口的信息，然后<strong>继续传递</strong>）</p></li></ul></li></ul><h3 id="I-O端口地址"><a href="#I-O端口地址" class="headerlink" title="I/O端口地址"></a>I/O端口地址</h3><h4 id="内存映像编址"><a href="#内存映像编址" class="headerlink" title="内存映像编址"></a>内存映像编址</h4><p>将<strong>设备控制器</strong>的<strong>内存/寄存器地址空间</strong>映射为内存地址的一部分</p><ul><li>通常映射到地址空间的顶端</li></ul><blockquote><p><strong>不能够</strong>对控制寄存器的信息进行缓存（一旦缓存则<strong>不会</strong>再去检测外设来确定信号）</p></blockquote><h4 id="独立编址"><a href="#独立编址" class="headerlink" title="独立编址"></a>独立编址</h4><p>I/O设备和内存地址空间分离，有IO专用的指令。</p><ul><li>接口电路中每个<strong>寄存器</strong>具有的<strong>唯一</strong>地址</li><li>所有的I/O<strong>端口地址</strong>形成IO端口空间（OS才能操作）</li><li>外设不占用内存的地址空间</li><li>实现I/O保护</li><li>控制指令少，不够灵活。</li></ul><blockquote><p>intel体系架构in/out指令</p></blockquote><h2 id="I-O控制技术"><a href="#I-O控制技术" class="headerlink" title="I/O控制技术"></a>I/O控制技术</h2><ul><li><p>程序控制(PIO)</p><ul><li>轮询</li></ul></li><li><p>中断驱动(Interrupt-drive I/O)</p><ul><li>设备向驱动发出请求</li></ul></li><li><p>直接存储访问(DMA, Direct Memory Access)</p><ul><li>由专门的控制器完成<strong>数据从设备到内存</strong>、<strong>内存到设备</strong>的传输工作。</li></ul></li><li><p>通道技术(<strong>Channel</strong>)</p><ul><li>通道是一个<strong>特殊</strong>处理器，替代了CPU的<strong>传输控制</strong>功能，CPU只有<strong>数据处理</strong>功能。</li></ul><blockquote><p>注意不是<strong>管道</strong></p></blockquote></li></ul><h3 id="程序控制"><a href="#程序控制" class="headerlink" title="程序控制"></a>程序控制</h3><p>设备<strong>驱动程序反复</strong>查看<strong>设备控制器</strong>的<strong>状态寄存器</strong>，当把数据都拷贝进入内存后再由<strong>设备驱动程序</strong>通知应用程序。</p><blockquote><ul><li>查询时，CPU没有工作。<strong>（驱动程序也是运行在CPU上的）</strong></li><li>多核、高速网络设备使用轮询可以提高效率（避免中断阻塞）</li></ul></blockquote><h3 id="中断驱动"><a href="#中断驱动" class="headerlink" title="中断驱动"></a>中断驱动</h3><p>驱动程序负责将设备状态记录在表中，然后CPU可以去做其他事情，直到<strong>CPU</strong>收到来自外设<strong>状态寄存器</strong>中断信号，并切换进入<strong>中断处理程序</strong>。</p><ul><li>收到中断信号<strong>不代表</strong>数据已经读入内存，而是说明数据已经<strong>就绪可读</strong>（数据会被放在<strong>缓冲寄存器</strong>）。</li><li><strong>中断处理程序</strong>通知<strong>设备管理程序</strong>（不是设备<strong>驱动</strong>程序），在<strong>查表后</strong>再把<strong>数据读入内存</strong>，再然后由CPU读取。</li></ul><h3 id="直接存储访问"><a href="#直接存储访问" class="headerlink" title="直接存储访问"></a>直接存储访问</h3><ul><li>由<strong>程序</strong>设置DMA控制器中的寄存器（实际上是设置读写参数，如内存始址，传送字节数），然后进行统一的I/O操作。</li><li>DMA将<strong>外设数据</strong>拷进<strong>内存</strong>（循环操作，不是一次完成。</li><li>操作完成后由<strong>DMA控制器</strong>向<strong>CPU</strong>发出中断</li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li>命令/状态寄存器(CR)：接受CPU发送的I/O指令、设备传来的状态等。</li><li>内存地址寄存器(MAR)：数据读写的<strong>内存地址</strong></li><li>数据寄存器(DR)：暂存发生交换的数据</li><li>数据计数器(DC)：存放需要传送的字节数，每拷贝一次减拷贝的字节数，到<code>0</code>后触发中断。</li></ul><blockquote><p>DMA&amp;中断驱动辨析</p><ul><li>DMA在传输<strong>一批数据</strong>后触发中断，中断控制则在<strong>每个数据</strong>传输后触发中断。</li><li>DMA的数据传送控制（传什么、传多少）是由DMA控制器完成的，CPU只负责在最开始向这个控制器发送一些指令即可。但是中断的数据传送过程（<strong>设备管理程序</strong>）则<strong>全都由</strong>CPU指导完成。</li></ul></blockquote><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><ul><li>增加<strong>独立控制器</strong>的功能，有自己的指令体系，进一步减少CPU的干预。</li><li>通道程序通常由操作系统构造，并放在内存中。</li></ul><h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><ul><li><p><strong>字节多路</strong>通道：多个设备<strong>交替</strong>以字节为单位传输，适用于打印机、终端等低速、中速设备。</p></li><li><p><strong>选择</strong>通道：对外设分组，每次多组通过<strong>多个通道</strong>并行传输。</p><blockquote><p>但是<strong>一个通道</strong>在一段时间内只能为<strong>一个设备</strong>服务</p></blockquote></li><li><p><strong>数组多路</strong>通道：不同组别可以同时使用<strong>非本组</strong>的<strong>空闲</strong>通道</p></li></ul><blockquote><p>通道&amp;DMA辨析</p><ul><li>通道的处理能力更强</li><li>通道可以同时控制<strong>多种</strong>设备，DMA通常只能控制少量的<strong>同类</strong>设备。</li><li>通道的费用较高</li></ul></blockquote><h2 id="I-O软件组成"><a href="#I-O软件组成" class="headerlink" title="I/O软件组成"></a>I/O软件组成</h2><p>分层设计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">用户进程--&gt;与设备无关的软件</span><br><span class="line">与设备无关的软件--&gt;设备驱动程序</span><br><span class="line">设备驱动程序--&gt;硬件</span><br><span class="line"></span><br><span class="line">硬件--&gt;中断处理程序</span><br><span class="line">中断处理程序--&gt;设备驱动程序</span><br><span class="line">设备驱动程序--&gt;与设备无关的软件</span><br><span class="line">与设备无关的软件--&gt;用户进程</span><br></pre></td></tr></table></figure><blockquote><p>中断处理程序其实应该在硬件和设备驱动程序之间</p></blockquote><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><ul><li>逻辑设备</li><li>物理设备</li></ul><p>系统将逻辑设备名称转换为物理设备名称</p><blockquote><ul><li>设备分配灵活<ul><li><strong>同类设备</strong>可以相互替代</li></ul></li><li>实现I/O重定向</li><li>实现了应用程序和物理设备之间的独立</li></ul></blockquote><h4 id="LUT（逻辑设备表）"><a href="#LUT（逻辑设备表）" class="headerlink" title="LUT（逻辑设备表）"></a>LUT（逻辑设备表）</h4><p>将逻辑设备名映射为物理设备名和驱动程序入口地址</p><ul><li>整个系统一张表：所有设备只能有<strong>一个逻辑设备名</strong></li><li>一个用户一张表</li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>接受上层软件的抽象请求，并执行这个请求。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li><p>自动配置和初始化子程序</p></li><li><p>I/O操作子程序</p><blockquote><p>系统I/O请求调用该子程序，并从用户态切换到内核态。</p></blockquote></li><li><p>中断服务子程序</p></li></ul><h4 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h4><ul><li>设备驱动是<strong>内核</strong>的一部分</li><li>设备驱动为内核提供一个标准接口</li><li>动态可加载</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p>初始化函数</p><ul><li>向操作系统登记该驱动程序的接口函数，在系统启动时安装进入内核执行。</li></ul></li><li><p>卸载驱动、申请释放设备</p></li><li><p>I/O操作</p></li><li><p>中断处理</p><blockquote><ul><li>中断处理才会使用到设备驱动的<strong>下层</strong>部分来接受<strong>外设</strong>触发的<strong>中断</strong>（I/O请求传递给设备时<strong>不会</strong>）</li><li>上层是用来处理和管理I/O请求的程序</li><li>当把中断处理程序归为设备驱动程序时，中断处理在下层，上层主要是和OS的交互部分。</li></ul></blockquote></li></ul><h4 id="驱动程序-amp-应用程序"><a href="#驱动程序-amp-应用程序" class="headerlink" title="驱动程序&amp;应用程序"></a>驱动程序&amp;应用程序</h4><ul><li>应用程序以<code>main</code>开始</li><li>驱动程序没有<code>main</code>，但以一个<strong>模块初始化函数</strong>作为入口。</li><li>应用程序从头到尾执行<strong>一个</strong>任务</li><li>驱动程序不会自主运行，而是在初始化后等待系统调用。</li><li>应用程序可以使用标准C库，但是驱动程序不行。</li></ul><h2 id="I-O缓冲管理"><a href="#I-O缓冲管理" class="headerlink" title="I/O缓冲管理"></a>I/O缓冲管理</h2><h3 id="单缓冲-single-buffer"><a href="#单缓冲-single-buffer" class="headerlink" title="单缓冲(single buffer)"></a>单缓冲(single buffer)</h3><ul><li>输出时间(T)：I/O-&gt;缓冲区</li><li>传送时间(M)：缓冲区-&gt;工作区</li><li>处理时间(C)</li><li><strong>一块数据平均</strong>处理时间：$max(T,C)+M$</li><li>总运行时间 = 块数 <em> 平均处理时间 <em>*+ C</em></em>（最后一块数据的处理没有和任何的IO设备输出并行）</li></ul><blockquote><p><strong>输出</strong>和<strong>处理</strong>可以并行</p></blockquote><h3 id="双缓冲-double-buffer"><a href="#双缓冲-double-buffer" class="headerlink" title="双缓冲(double buffer)"></a>双缓冲(double buffer)</h3><ul><li>增加缓冲区使<strong>IO输出</strong>和<strong>缓冲区传送</strong>并行</li><li>适用于CPU和外设速度相近的情况(${M+C}\approx{T}$)</li><li><strong>一块数据平均</strong>处理时间：$max(T,C)$</li></ul><h3 id="环形缓冲-circular-buffer"><a href="#环形缓冲-circular-buffer" class="headerlink" title="环形缓冲(circular buffer)"></a>环形缓冲(circular buffer)</h3><p>适用于CPU和外设速度相差较大的情况（专用缓冲）</p><p>将多个缓冲区组织成循环（圆圈），输入进程不断输入<strong>空缓冲区</strong>，计算进程不断从<strong>就绪缓冲区</strong>中提取数据。</p><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>缓冲区<ul><li>空缓冲区(R)</li><li>装满数据的缓冲区(G)</li><li>正在使用的工作缓冲区(C)</li></ul></li><li>指针<ul><li>Nextg：下一个<strong>可计算</strong>缓冲区</li><li>Nexti：下一个<strong>可输入</strong>缓冲区</li><li>Current：当前计算缓冲区</li></ul></li></ul><blockquote><p>当输入过快时可能套圈然后冲掉<code>Current</code>的内容</p></blockquote><h3 id="缓冲池-buffer-pool"><a href="#缓冲池-buffer-pool" class="headerlink" title="缓冲池(buffer pool)"></a>缓冲池(buffer pool)</h3><p>将相同类型的缓冲区链成一个队列</p><ul><li>空缓冲队列(emq)</li><li>输入队列(inq)</li><li>输出队列(outq)</li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li><p>收容输入(hin)：<strong>输入</strong>进程需要输入数据<strong>（空-&gt;输入）</strong></p><p>从空缓冲区队列中取队首，使用完后加入<strong>输入队列</strong>。</p></li><li><p>提取输入(sin)：<strong>计算</strong>进程需要输入数据<strong>（输入-&gt;空）</strong></p><p>同上取空缓冲区，使用完后调用<code>Putbuf(emq,sin)</code>将缓冲区<strong>重新加回空缓冲</strong>队列。</p></li><li><p>收容输出(hout)：<strong>计算</strong>进程需要输出数据<strong>（空-&gt;输出）</strong></p><p>取空缓冲区，然后装入输出数据，装满后放在<strong>输出队列</strong>末尾。</p></li><li><p>提取输出(sout)：<strong>输出</strong>进程需要输出数据<strong>（输出-&gt;空）</strong></p><p>在输出对首取缓冲区，提取完数据后，将缓冲区加回<strong>空缓冲队列</strong>末尾。</p></li></ul><blockquote><p>收容就是<strong>取空缓冲区</strong>，然后放进相应的队列；提取则是用完后一定<strong>放回空缓冲区</strong>。</p></blockquote><h3 id="缓冲的问题"><a href="#缓冲的问题" class="headerlink" title="缓冲的问题"></a>缓冲的问题</h3><p>多次复制一个数据包：<strong>各级缓存（缓冲区）</strong>都有相同的数据</p><h2 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I/O设备管理"></a>I/O设备管理</h2><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><ul><li>在进程间切换使用（如鼠标和键盘）</li><li>使用虚拟设备把外设和应用隔开，只由虚拟设备来使用设备。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p>设备控制表(DCT)</p><p>每个设备一张</p></li><li><p>控制器控制表(COCT)</p><p>每个控制器一张</p></li><li><p>通道控制表(CHCT)</p><p>每个通道一张</p></li><li><p>系统设备表(SDT)</p><p>一个系统一张</p></li></ul><h4 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h4><ul><li>设备固有属性</li><li>分配算法</li><li>安全性：死锁问题<ul><li><strong>安全</strong>分配：同步I/O，破坏了死锁的保持和请求条件。</li><li><strong>不安全</strong>分配：异步I/O</li></ul></li></ul><h3 id="Spooling技术"><a href="#Spooling技术" class="headerlink" title="Spooling技术"></a>Spooling技术</h3><ul><li>假脱机技术：专门利用一道程序来管理I/O</li></ul><h4 id="实际I-O"><a href="#实际I-O" class="headerlink" title="实际I/O"></a>实际I/O</h4><ul><li>来自外设</li><li>来自应用</li></ul><h4 id="虚拟I-O"><a href="#虚拟I-O" class="headerlink" title="虚拟I/O"></a>虚拟I/O</h4><ul><li>统一管理I/O</li></ul><h4 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h4><ul><li><p>输入井和输出井：<strong>磁盘上</strong>的大存储空间</p><ul><li>输入井：暂存IO设备输入的数据</li><li>输出井：暂存用户程序输出的数据</li></ul></li><li><p>输入缓冲区和输出缓冲区：<strong>内存</strong>中的缓冲区</p><ul><li>输入设备-&gt;输入缓冲区-&gt;输入井</li><li>输出井-&gt;输出缓冲区-&gt;输出设备</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">输入设备--&gt;输入缓冲区</span><br><span class="line">输入缓冲区--&gt;输入井</span><br><span class="line"></span><br><span class="line">输出井--&gt;输出缓冲区</span><br><span class="line">输出缓冲区--&gt;输出设备</span><br></pre></td></tr></table></figure></li><li><p>输入进程SPi和输出进程SPo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">输入进程--&gt;输入井</span><br><span class="line">输入井--&gt;内存</span><br><span class="line"></span><br><span class="line">输出进程--&gt;内存</span><br><span class="line">内存--&gt;输出井</span><br><span class="line">输出井--&gt;内存</span><br><span class="line">内存--&gt;输出设备</span><br></pre></td></tr></table></figure></li></ul><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul><li>虚拟I/O速度快</li><li>实现设备共享</li></ul><h2 id="I-O性能问题"><a href="#I-O性能问题" class="headerlink" title="I/O性能问题"></a>I/O性能问题</h2><h3 id="I-O操作阶段"><a href="#I-O操作阶段" class="headerlink" title="I/O操作阶段"></a>I/O操作阶段</h3><ul><li><p><strong>磁盘</strong>把数据装载进<strong>内核</strong>的内存空间</p></li><li><p>把<strong>内核</strong>的内存空间的数据复制到<strong>用户</strong>的内存空间中</p><blockquote><p>用户的IO访问其实是一个系统调用，最后由<strong>内核</strong>通知返回结果并<strong>唤醒</strong>进程。</p></blockquote></li></ul><h3 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h3><p>调用结果返回之前，当前进程会被挂起。</p><h3 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h3><p>进程发起I/O调用，内核通知进程进行别的操作。（其实<strong>别的操作</strong>就是指轮询）</p><blockquote><ul><li>进程需要不停的发出检查请求</li><li>依然是<strong>同步</strong>的</li></ul></blockquote><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>在被一个I/O阻塞时依然可以接受其他I/O的阻塞，所以可以提高效率。</p><blockquote><p>同时阻塞在多个I/O上可以改善第一阶段的效率，但是第二阶段需要进程逐一参与，因此第二阶段的效率没有改变。</p></blockquote><h3 id="事件（信号）驱动I-O"><a href="#事件（信号）驱动I-O" class="headerlink" title="事件（信号）驱动I/O"></a>事件（信号）驱动I/O</h3><p>内核记录（回调函数）发起I/O的进程，在第一阶段完成后才通知进程，则进程在第一阶段就不需要忙等了。（第二阶段依然阻塞）</p><blockquote><p>第二阶段需要进程<strong>再次</strong>发起一个系统调用</p></blockquote><h3 id="异步I-O（效率最高）"><a href="#异步I-O（效率最高）" class="headerlink" title="异步I/O（效率最高）"></a>异步I/O（效率最高）</h3><p>内核通知进程数据已经完成拷贝（两个阶段都完成）之前，进程可以做自己的事情。</p><h3 id="五种模型比较"><a href="#五种模型比较" class="headerlink" title="五种模型比较"></a>五种模型比较</h3><ul><li>同步I/O：第二段阻塞，则是同步I/O.</li><li>I/O复用和事件驱动I/O会在第一阶段结束后<strong>再次发起</strong>调用。</li></ul><h2 id="FAQ-2"><a href="#FAQ-2" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li><p>同步/异步与阻塞/非阻塞</p><ul><li><p>同步/异步是针对<strong>I/O</strong>来说的，能够自己通知调用者（触发中断）的I/O是异步的，需要调用者反复确认的I/O是同步的。</p><blockquote><p>因此异步I/O可以在<strong>两个</strong>阶段执行的过程期间做其他的事，但是同步I/O<strong>最多</strong>只能在<strong>第一阶段</strong>自由发挥。（多路复用/信号驱动）</p></blockquote></li><li><p>阻塞/非阻塞是针对<strong>进程</strong>来说的，能够在由没完成的任务时做其他事的是非阻塞的，需要一直等着某个任务完成再做下一个的是阻塞的。</p></li></ul></li><li><p>I/O的五种实现方式和之前提到的<strong>设备中断处理程序</strong>之间有关系吗</p><p>除了名字相同之外<strong>没有关系</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">process--&gt;kernel</span><br><span class="line">kernel--&gt;peripheral</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>I/O的五种实现方式是在阐述两个阶段，对于同步和异步I/O，都是由<strong>内核</strong>作为中间层进行协调的。也就是说，内核怎么通知进程，涉及到的中断和外设的中断处理程序<strong>（设备通知内核）</strong>之间没有关系。</p><p>综上，外设的中断处理程序只在第一阶段起到作用，和I/O的五种实现方式中的<strong>通知</strong>机制关系不大。</p></li></ul><h2 id="Reference-7"><a href="#Reference-7" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul><h1 id="Chapter3-1-磁盘存储管理"><a href="#Chapter3-1-磁盘存储管理" class="headerlink" title="Chapter3-1 磁盘存储管理"></a>Chapter3-1 磁盘存储管理</h1><p>全文共<code>1685</code>字，推荐阅读时间<code>10~15</code>分钟。</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>扇区(sector)：磁道中的<strong>小扇形段</strong>（<strong>一个</strong>磁道上有<strong>多个</strong>扇区，<strong>不同</strong>磁道的扇区数可以<strong>不等</strong>）</p></li><li><p>磁道(tract)：同心<strong>环</strong></p></li><li><p>柱面(cylinder)：不同盘片<strong>相同半径</strong>的磁道组成的圆柱</p></li><li><p>磁盘分为软盘和硬盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">磁盘--&gt;硬盘</span><br><span class="line">磁盘--&gt;软盘</span><br><span class="line"></span><br><span class="line">硬盘--&gt;机械硬盘</span><br><span class="line">硬盘--&gt;闪存实现的固态硬盘</span><br><span class="line">硬盘--&gt;...</span><br></pre></td></tr></table></figure></li></ul><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p>读取一个扇区需要柱面，磁头，磁道三个参数，通常以<code>(x,y,z)</code>传入。</p><ul><li>x：定位柱面</li><li>y：定位磁道</li><li>z：定位扇区</li></ul><blockquote><p>对于IBM PC而言，最大参数一般是<code>(65536,16,63)</code>，因为一个扇区512字节，因此需要使用<code>16+4+6+9=35</code>位地址来进行访问，但是因为<code>z</code>是63，因此磁盘的最大容量是<code>31.5GB</code>.</p></blockquote><h4 id="扇区"><a href="#扇区" class="headerlink" title="扇区"></a>扇区</h4><ul><li><p>将磁盘所有扇区看作一个<strong>一维的</strong>逻辑块数组（突破IBM PC遗留的内存限制）</p></li><li><p><strong>数组排序</strong>：扇区-&gt;磁道-&gt;柱面<strong>（从外到内）</strong></p><p>先按照<strong>磁道内</strong>的<strong>扇区顺序</strong>排序，然后按照<strong>柱面内</strong>的<strong>磁道顺序</strong>排序，最后按<strong>从外到内</strong>的<strong>柱面顺序</strong>来排序。</p></li></ul><h2 id="I-O性能"><a href="#I-O性能" class="headerlink" title="I/O性能"></a>I/O性能</h2><h3 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h3><ul><li><p>寻道时间：<strong>启动</strong>时间<code>s</code>与磁头<strong>移动<code>n</code>条磁道</strong>花费的时间之和</p><p>$T_s = m*n+s\ (m = const)$</p><blockquote><p><code>m</code>是移动一条磁道花费的时间</p></blockquote></li><li><p>旋转延迟时间</p><p>$T_r=\frac{1}{2*r}(r=RPS\ r/s)$</p><blockquote><ul><li><code>r</code>是转速，并且单位是秒。</li><li>公式的意思：旋转<strong>一周</strong>需要的<strong>平均</strong>时间</li></ul></blockquote><ul><li>硬盘</li><li>软盘</li></ul></li><li><p>传输时间：和每次所读写的字节数<code>b</code>,旋转速度<code>r</code>以及磁道上<strong>单位长度</strong>的字节数<code>N</code>有关</p><p>$T_t=\frac{b}{r*N}$</p><blockquote><p><code>r*N</code>是单位时间内磁盘可以读写的字节数（<strong>传输速率</strong>），所以公式就是求如果需要读写<code>b</code>字节，那么需要多少个单位时间。</p></blockquote></li></ul><p>$ResponseTime=Queue+DiskServiceTime \tag{1}$</p><blockquote><p>磁盘延迟 = 设备驱动排队时间 + 磁盘服务时间</p></blockquote><p>$DiskServiceTime=SeekTime+RotateTime+TransferTime \tag{2}$</p><blockquote><p>磁盘服务时间 = 寻道时间 + 旋转延迟时间 + 传输时间</p></blockquote><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>注意，和电梯不同的是，磁头移动到目标位置即算作服务完成。</p><ul><li><p>FCFS</p></li><li><p>SSTF</p></li><li><p>SCAN：对两侧磁道不公平</p></li><li><p>CSCAN：走到一头后直接返回（返回过程中不处理请求）</p><blockquote><p>CSCAN消除了SCAN对两端磁道的不公平现象</p></blockquote></li><li><p>LOOK/CLOOK：分别是对SCAN/CSCAN<strong>调头条件</strong>的改进</p></li></ul><h3 id="主要途径"><a href="#主要途径" class="headerlink" title="主要途径"></a>主要途径</h3><ul><li>磁盘性能</li><li>并行化</li><li>调度算法</li><li>设置缓冲区<ul><li>独立缓存：大小<strong>固定</strong></li><li>使用内存作为磁盘的缓存：大小<strong>可变</strong></li><li>周期性写回</li></ul></li><li>优化物理块分布，例如将文件和其所需数据放在一起。</li><li>优化索引节点分布，将索引节点统一管理。</li></ul><blockquote><p>其他方法：</p><ul><li>提前读</li><li>延迟写</li><li>虚拟盘</li></ul></blockquote><h2 id="Flash-Disk-闪存盘"><a href="#Flash-Disk-闪存盘" class="headerlink" title="Flash Disk 闪存盘"></a>Flash Disk 闪存盘</h2><p>闪存是固态硬盘，属于硬盘的一种，因此也算是磁盘。</p><h3 id="NAND"><a href="#NAND" class="headerlink" title="NAND"></a>NAND</h3><ul><li>地址分为块号、块内页号、页内字节号，因此访存需要寻址三次，读写速度慢。</li></ul><h3 id="NOR"><a href="#NOR" class="headerlink" title="NOR"></a>NOR</h3><ul><li>使用大量地址线实现一次性直接<strong>字节</strong>寻址</li></ul><blockquote><p>速度高于NAND,成本也高于NAND.</p></blockquote><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul><li><p>擦除影响寿命</p><p>使用磨损均衡化技术解决(Wear Leveling)</p></li><li><p>功耗低</p></li><li><p>速度快</p></li></ul><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>RAID：廉价冗余磁盘阵列</p><ul><li>利用冗余信息恢复丢失数据</li></ul><h3 id="组织-1"><a href="#组织-1" class="headerlink" title="组织"></a>组织</h3><p>把多块独立的硬盘（<strong>物理</strong>硬盘）按照不同方式组合起来形成一个硬盘组（<strong>逻辑</strong>硬盘）</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>价格低</p></li><li><p>可以让多个硬盘<strong>并行传输</strong></p><p>将数据分段，例如将一个文件数据分为多个<strong>条带</strong>，然后放在<strong>多个硬盘</strong>上。</p></li><li><p>容错带来的更高的安全性</p></li></ul><h3 id="级别"><a href="#级别" class="headerlink" title="级别"></a>级别</h3><ul><li><p>RAID0：<strong>仅提供</strong>并行交叉存取，<strong>没有冗余</strong>校验功能。（<strong>不能提高</strong>可靠性）</p><ul><li>磁盘容量<strong>线形叠加</strong></li><li>对大量数据的请求<strong>效率最高</strong></li></ul></li><li><p>RAID1：镜像磁盘冗余阵列，在<strong>两个盘</strong>上存储一样的数据，有效容量下降一半。</p><ul><li>磁盘容量只有<strong>一半</strong>，成本高，但是可靠性好。</li><li>读性能好</li><li>写性能取决于两者中较低的那一块盘</li></ul></li><li><p>RAID0+1：先<strong>分块</strong>后<strong>镜像</strong></p><p><img src="https://i.loli.net/2020/05/29/vFmTgfOlLBrwxUp.png" style="zoom:67%;" /></p><ul><li>相当于是两组完全相同的RAID0</li><li>并行体现在组内</li></ul></li><li><p>RAID1+0：先<strong>镜像</strong>后<strong>分块</strong></p><p><img src="https://i.loli.net/2020/05/29/j31kOvPZKDVX9e8.png" style="zoom:67%;" /></p><ul><li>同组的两块盘是完全相同的</li><li>并行体现在组层次上</li></ul><blockquote><p>可靠性比0+1更高</p><ul><li>RAID0+1如果坏一块盘，不会引起数据丢失，但是该盘所在的<strong>条带</strong>会失效。</li><li>坏2块盘时引起磁盘故障的概率<ul><li>RAID0+1：n/(2n-2)</li><li>RAID1+0：1/(n-1)</li></ul></li></ul></blockquote></li><li><p>RAID2：<strong>按位条带化</strong>，将奇偶校验位插入数据中（海明码：多重<strong>奇偶校验</strong>）</p><p>利用$2^P&gt;=P+D+1$确定海明码的位数</p><ul><li>P是海明码位数</li><li>D是数据位数</li></ul><blockquote><p><strong>一个</strong>海明码只能够校验或者恢复<strong>一位</strong>的数据错误</p></blockquote></li><li><p>RAID3：RAID2的简化版本，一组数据只用一个校验盘，将校验码（奇偶校验）和数据分开存储。</p><blockquote><p>不能直接定位出错的盘，可以使用“出错离线”方式进行判断。</p></blockquote></li><li><p>RAID4：<strong>数据块交叉存储</strong>，和RAID0类似，将条带分开存储，同一行使用一块校验盘。</p></li><li><p>RAID5：在RAID4基础上，将校验块和和数据位进行<strong>混合</strong>存放，没有单独的奇偶校验驱动器。</p></li><li><p>RAID6：<code>单个数据:冗余 = 1:2</code>，例如<strong>A0对应0校验码和A校验码</strong>，可以容<strong>两块</strong>盘的错。</p><blockquote><p>整体比例<strong>不是</strong><code>1:2</code></p></blockquote></li></ul><h3 id="XOR恢复数据"><a href="#XOR恢复数据" class="headerlink" title="XOR恢复数据"></a>XOR恢复数据</h3><h4 id="原理-11"><a href="#原理-11" class="headerlink" title="原理"></a>原理</h4><ul><li><p>结合律</p><p>$({a}\bigoplus{b})\bigoplus{c}={a}\bigoplus({b}\bigoplus{c})$</p></li><li><p>循环对称性</p><p>当${a}\bigoplus{b}\bigoplus{c}=d$时，</p><ul><li>$a={b}\bigoplus{c}\bigoplus{d}$</li><li>$b={a}\bigoplus{c}\bigoplus{d}$</li><li>$c={a}\bigoplus{b}\bigoplus{d}$ </li></ul></li></ul><blockquote><p>把a,b,c,d看作磁盘上的四个数据，其中三个是真正的数据，最后一个最为校验数据块，则可以进行数据恢复。</p></blockquote><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><ul><li>条带化：一个字节块可能放在多个数据盘上</li><li>镜像：数据完全拷贝</li><li>校验：冗余代价介于前两者之间</li></ul><h2 id="Reference-8"><a href="#Reference-8" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li><li>Wikipedia</li></ul><h1 id="Chpter4-文件系统"><a href="#Chpter4-文件系统" class="headerlink" title="Chpter4 文件系统"></a>Chpter4 文件系统</h1><p>全文共<code>3454</code>字，推荐阅读时间<code>15~20</code>分钟</p><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>数据可以长期保存</li><li>方便不同进程共享</li><li>容量大</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>抽象为一个<strong>单独的、连续的逻辑地址空间</strong>，其大小为文件大小，和<strong>进程</strong>的地址空间<strong>无关</strong>。</li><li>一组带标识的、在逻辑上有<strong>完整意义</strong>的<strong>信息项的序列</strong>。</li><li>本质是一组字节序列：<strong>一切皆是文件</strong><ul><li>设备文件</li></ul></li><li>文件组成<ul><li>文件体：文件本身的<strong>内容</strong></li><li>文件<strong>说明</strong>：文件名、存储地址、访问权限等。</li></ul></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>OS中统一管理信息资源的一种<strong>软件</strong></p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ul><li><p><strong>磁盘空间</strong>的分配与回收</p></li><li><p>文件按<strong>名</strong>存取</p></li><li><p>文件信息共享</p></li><li><p>向用户提供友好的接口</p></li><li><p>提高文件系统的性能</p></li><li><p>提供和I/O系统统一的接口</p><blockquote><p>文件系统在I/O系统等级之下</p></blockquote></li></ul><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><ul><li>接口（接近用户）<ul><li>命令行接口</li><li>程序接口：用户程序进行<strong>系统调用</strong></li></ul></li><li>管理软件集合（核心）</li><li><strong>被管理</strong>对象及其属性（文件的性质）<ul><li>文件，文件系统管理的<strong>直接对象</strong>。</li><li>目录</li><li>磁盘存储空间</li></ul></li></ul><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><ul><li><p>创建时指定（必须），<strong>用户</strong>通过<strong>文件名</strong>来<strong>访问文件</strong>。（<strong>不是地址</strong>）</p></li><li><p>格式：<code>文件名.扩展名</code></p><blockquote><ul><li><p>文件名一般不超过<code>8</code>个字符</p></li><li><p>Linux<strong>区分</strong>大小写</p></li><li>Windows<strong>不区分</strong>大小写</li></ul></blockquote></li></ul><h4 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h4><ul><li>性质&amp;用途：系统文件、库文件、用户文件</li><li>数据形式：源文件、目标文件、可执行文件</li><li>保护级别：只读、读写、执行、不保护</li><li><strong>逻辑结构</strong>：有结构（记录文件）、无结构（流式文件）</li><li><strong>物理结构</strong>：顺序文件、链接文件、索引文件</li></ul><h4 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h4><ul><li><p>流式结构：把文件看成字节序列，提供了最大的灵活性，用户程序可以任意更改文件。</p><p>所有的UNIX版本（含Linux和OS X）以及Windows都采用这种方式</p></li><li><p>记录式文件：文件是具有<strong>固定长度的记录</strong>的序列，每个记录内部都有结构。</p><blockquote><ul><li>之所以叫记录，就是因为读操作返回数据时是返回某次写的东西，这叫做返回记录；在写操作时，会改写一个原有的记录<strong>或者</strong>追加一个记录。</li><li>底层依然是字节序列</li></ul></blockquote></li><li><p>树形结构（也属于记录式）：文件各个记录的长度不一定相同，但是在每个记录的固定位置上，有一个<strong>Key</strong>字段用来进行迭代。</p><p>在处理商业数据的大型计算机中被广泛使用</p></li></ul><h4 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h4><ul><li>顺序</li><li>随机：直接给定<strong>读写</strong>位置</li></ul><h4 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h4><ul><li>磁盘、磁带、光盘等</li></ul><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>打开文件时，每个进程为维护<strong>文件索引表</strong>，系统有一个整合的文件开关表。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>由<strong>文件索引</strong>组成的，用于检索文件的<strong>特殊文件</strong>。</p><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><ul><li>提高效率</li><li>命名<ul><li><strong>不同</strong>文件可以有<strong>相同</strong>名字</li><li><strong>一个</strong>文件可以有<strong>多个</strong>名字</li></ul></li><li>分组<ul><li>将文件按照属性进行分组</li></ul></li></ul><h4 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h4><ul><li>基本信息：文件名、别名（名字及数目）等</li><li>文件类型</li><li>地址信息：存放位置、文件长度</li><li><strong>访问控制信息</strong>：文件的<strong>所有者</strong>和<strong>访问权限</strong></li><li>使用信息：创建信息、上次访问时间、上次修改时间。</li></ul><h4 id="单级目录"><a href="#单级目录" class="headerlink" title="单级目录"></a>单级目录</h4><p>根目录-&gt;文件</p><ul><li>常用于嵌入式系统</li><li>不方便共享</li></ul><h4 id="两级目录"><a href="#两级目录" class="headerlink" title="两级目录"></a>两级目录</h4><p>根目录-&gt;用户目录-&gt;文件</p><blockquote><p>用户目录<strong>不是指不同的用户</strong>，就是指<strong>不同的目录</strong>。</p></blockquote><h4 id="多级（层次）目录"><a href="#多级（层次）目录" class="headerlink" title="多级（层次）目录"></a>多级（层次）目录</h4><p>根目录-&gt;…-&gt;文件</p><ul><li>文件访问<ul><li>绝对路径：从<strong>根目录</strong>开始</li><li>相对路径：从当前目录开始（路径中<strong>不含</strong>当前目录名）</li></ul></li><li>解决文件重名的问题</li><li>查找速度快</li></ul><h2 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h2><h3 id="系统布局"><a href="#系统布局" class="headerlink" title="系统布局"></a>系统布局</h3><ul><li>一个磁盘通常被划分为多个<strong>分区</strong>，每个<strong>分区</strong>有一个<strong>独立的文件系统</strong>。</li><li>磁盘的0号<strong>扇区（不是分区）</strong>称为主引导记录(MBR)，在MBR的结尾是分区表，该表给出了每个分区的起始地址和结束地址。</li><li>MBR的第一个块叫做引导块，为了统一起见，每个<strong>分区</strong>的第一个块都是引导块。</li><li>引导块之后的第二个块是超级块，包含文件系统所有关键参数，在计算机<strong>启动</strong>时，超级块会被<strong>读入</strong>内存。</li></ul><h3 id="文件控制块-inode-FCB-目录项"><a href="#文件控制块-inode-FCB-目录项" class="headerlink" title="文件控制块(inode,FCB,目录项)"></a>文件控制块(inode,FCB,目录项)</h3><ul><li>基本信息<ul><li>文件名</li><li>物理位置</li><li>文件<strong>逻辑</strong>结构</li><li>文件<strong>物理</strong>结构</li></ul></li><li>访问控制信息<ul><li>所有者</li><li>访问权限</li></ul></li><li>使用信息<ul><li>创建时间</li><li>上一次修改时间</li></ul></li></ul><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>一般是一个<strong>非负整数</strong>，标识唯一一个<strong>打开</strong>的文件。</p><ul><li>不同进程可以拥有相同的文件描述符指向一个<strong>文件表项</strong></li><li><strong>文件表项</strong>又能导向文件对应的具体的inode/FCB</li></ul><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><h4 id="连续-顺序文件"><a href="#连续-顺序文件" class="headerlink" title="连续/顺序文件"></a>连续/顺序文件</h4><p>讨论<strong>文件内部、文件和文件之间</strong>如何组织</p><p>连续的分配磁盘容量</p><blockquote><p>容易出现磁盘碎片</p></blockquote><p><strong>优点</strong></p><ul><li>容易实现</li><li><strong>顺序、随机</strong>存取效率高</li></ul><p><strong>缺点</strong></p><ul><li>不利于动态修改文件</li></ul><h4 id="串联-链接文件"><a href="#串联-链接文件" class="headerlink" title="串联/链接文件"></a>串联/链接文件</h4><ul><li>讨论<strong>文件内部</strong>如何组织</li><li>链表指针结构，将<strong>文件分块</strong>。</li><li>文件所在的磁盘块号<strong>不一定连续</strong></li></ul><blockquote><p>对于记录式文件，一个块中可以包含<strong>若干个</strong>逻辑记录，也可以<strong>若干个</strong>物理块包含<strong>一个</strong>逻辑记录。</p></blockquote><p><strong>优点</strong></p><ul><li>空间利用率高</li><li><strong>顺序</strong>存取效率高</li></ul><p><strong>缺点</strong></p><ul><li>随机存取效率低</li><li>可靠性较低</li><li>当要访问文件的最后一块时，需要访问整个文件。</li></ul><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>讨论的是<strong>文件内部</strong>的组织方式</p><p>索引文件：<strong>逻辑块号</strong>和<strong>物理块号</strong>（地址）的<strong>哈希表</strong>，称为文件的索引表。</p><ul><li><p>访问过程：</p><p>文件目录-&gt;索引表-&gt;某一个物理块</p></li><li><p>存放位置</p><p>由于每个文件的索引文件的长度不一，因此<strong>PCB</strong>中只保存<strong>索引文件</strong>的<strong>存放地址</strong>，而不保存其内容。</p><blockquote><p>有时存放位置固定在<strong>文件目录</strong>中、<strong>文件的开头</strong>等。</p></blockquote></li></ul><p><strong>优点</strong></p><ul><li>顺序、随机存取效率高</li></ul><p><strong>缺点</strong></p><ul><li>空间开销大</li></ul><p><strong>索引表的组织</strong></p><ul><li><p>链接模式</p><p>为每个盘块分配一张表，然后将这些表链接起来。</p></li><li><p>多级索引</p></li><li><p>综合</p></li></ul><p><strong>inode&amp;索引表辨析</strong></p><ul><li>当使用inode管理文件时，提供inode的索引功能的表并一定是hash索引表，因为文件块号是顺序存放在inode中的。</li></ul><blockquote><p>UNIX下通常采用<strong>三级</strong>索引表</p><p>eg.当每个磁盘块可以容纳256个索引指针时，总共可以容纳$12+256+256^{2}+256^{3}$个块。（12是由直接索引的块数决定的）</p></blockquote><h3 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h3><h4 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h4><ul><li><p>直接法：目录项 = 文件名 + 文件控制块</p><blockquote><p>DOS/Windows</p></blockquote></li><li><p>间接法：目录项 = 文件名 + 文件控制块<strong>地址</strong></p><blockquote><p>Unix(inode)</p></blockquote></li></ul><blockquote><p>一个目录有多个目录项，一个目录项对应一个inode.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">目录--&gt;目录项1</span><br><span class="line">目录--&gt;目录项2</span><br><span class="line">目录--&gt;...</span><br><span class="line"></span><br><span class="line">目录项1--&gt;目录inode1</span><br><span class="line">目录项2--&gt;目录inode2</span><br><span class="line"></span><br><span class="line">目录inode1--&gt;文件inode1</span><br><span class="line">文件inode1--&gt;具体内容</span><br></pre></td></tr></table></figure><blockquote><p>目录中的inode用来存放文件inode位置，而文件的inode用来存放文件具体内容</p></blockquote><h4 id="长文件名"><a href="#长文件名" class="headerlink" title="长文件名"></a>长文件名</h4><ul><li><p>在目录项中将文件名长度固定为255个字符</p><blockquote><p>浪费空间，很少有文件使用长名字。</p></blockquote></li><li><p>目录项<strong>(entry for one file)</strong>长度可变</p><ul><li><p><strong>存放目录项长度的区域大小</strong>不变</p></li><li><p>属性信息长度不变</p></li><li><p>文件名长度可变</p><blockquote><p>通常在文件名的特殊结束字符如<code>\0</code>之后，还会填充使文件名空间<strong>字对齐</strong>。</p></blockquote></li></ul><blockquote><p>文件占用空间不好回收</p></blockquote></li><li><p>目录项长度固定，但是文件名变长并<strong>统一</strong>放在目录文件的末尾。（堆：<strong>向下扩展</strong>）</p><blockquote><p>此时<strong>不会</strong>对文件名进行<strong>字对齐</strong>处理</p></blockquote></li></ul><h4 id="查询技术"><a href="#查询技术" class="headerlink" title="查询技术"></a>查询技术</h4><ul><li>顺序查找</li><li>Hash方法</li></ul><h4 id="共享-2"><a href="#共享-2" class="headerlink" title="共享"></a>共享</h4><p>使不同目录可以用<strong>相同</strong>或者<strong>不同</strong>的文件名来访问它（<strong>有向无环图</strong>）</p><blockquote><p>环指<strong>有向环</strong></p></blockquote><p><strong>链接技术</strong></p><ul><li><p>硬链接：不同的文件索引使用同一个inode结点，并且这个结点就是文件的inode结点。</p><ul><li><p>当使用硬链接时，虽然inode1被共享，但从inode没有办法推出有哪些目录在引用这个文件，因此如果在一个目录的控制下决定删除这个文件和inode，那么只有这个目录的inode会被更新，其他的目录会指向一个无效的inode.</p></li><li><p>不能针对<strong>目录</strong>创建</p><blockquote><p>当针对目录创建时，会出现环路。</p></blockquote></li><li><p>不能针对<strong>不存在的文件</strong>创建</p></li></ul></li><li><p>软链接（符号链接）：创建一个类型为<code>LINK</code>的新文件，并把该文件放在目录A下，这个文件使得A和目录B下的某个文件存在链接，因为这个文件的内容就是所链接的文件的名字和路径。</p><ul><li>在访问文件时，会重定向到文件本身的inode进行。</li><li>因为从A和C都能够找到同一个文件，因此在A和C的再顶层目录中统计文件时，这个文件会被多次定位，造成统计冗余或者拷贝冗余。</li></ul></li></ul><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><h4 id="建立副本"><a href="#建立副本" class="headerlink" title="建立副本"></a>建立副本</h4><p>适用于<strong>短小且极为重要</strong>的文件</p><h4 id="定时转储"><a href="#定时转储" class="headerlink" title="定时转储"></a>定时转储</h4><p>Unix采用</p><h4 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h4><ul><li><p><strong>磁盘块</strong>的一致性</p><p>磁盘块有两个计数器</p><ul><li>记录磁盘块是否被使用</li><li>记录磁盘块是否在空闲块中</li></ul><p>当磁盘块在两个计数器中同时出现则不一致</p><blockquote><ul><li>当出现<strong>丢失块</strong>（两个计数器都未记录），则将块加入空闲块表。</li><li>当<strong>使用块计数</strong>中出现重复块（第一个计数器中出现<code>n</code>次），在空闲表中取<code>n-1</code>个块进行拷贝，然后标记为已使用。</li><li>当<strong>空闲块计数</strong>中出现重复块：重新建立空闲链表。</li></ul></blockquote></li><li><p><strong>文件</strong>的一致性</p><p>文件有两个计数器</p><ul><li>inode结点被引用的次数</li><li>文件目录引用的次数</li></ul><p>两个计数器不相等时出现不一致</p></li></ul><h4 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h4><ul><li>文件保护机制</li><li>存取权限验证</li></ul><h4 id="并发访问"><a href="#并发访问" class="headerlink" title="并发访问"></a>并发访问</h4><ul><li><p>访问文件之前<strong>必须</strong>打开文件</p><blockquote><p>文件目录会被读入内存中，因此多个进程共享同一个文件目录，确保了文件<strong>一致性</strong>。</p></blockquote></li></ul><h4 id="块高速缓存"><a href="#块高速缓存" class="headerlink" title="块高速缓存"></a>块高速缓存</h4><p>在<strong>内存</strong>中为<strong>磁盘</strong>设置一个缓冲区</p><ul><li>组织：双向链表<ul><li>尾部使用MRU（最常使用算法），将最近访问的块放在尾部。</li><li>头部自然就是LRU，进行淘汰。</li></ul></li><li>块大：磁盘利用率<strong>低</strong>，效率<strong>高</strong>。（块小<strong>反之</strong>）</li></ul><h2 id="基于日志结构的文件系统-LFS"><a href="#基于日志结构的文件系统-LFS" class="headerlink" title="基于日志结构的文件系统(LFS)"></a>基于日志结构的文件系统(LFS)</h2><h3 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h3><ul><li>磁盘以<strong>写</strong>操作为主，其中<strong>磁头寻道</strong>是影响写性能的主要因素之一。</li><li>写一个数据块要修改数据和<strong>元数据</strong>(inode 目录 etc.)</li></ul><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li><p>将<strong>磁盘</strong>看作是一个<strong>日志系统</strong></p><blockquote><p>文件总是<strong>顺序</strong>地追加到磁盘上</p></blockquote></li><li><p>新的数据块和元数据先以<code>segment</code>为单位放在缓存中，当<code>segment</code>填满之后写入到硬盘。</p><ul><li><code>segment &gt; block</code></li><li>若修改了数据，不对<code>segment</code>已有数据进行修改，而是继续追加。</li></ul></li><li><p>inode根据不同的追加写操作分散在整个日志中（位置<strong>不固定</strong>）</p></li><li><p>inode查找：<code>inode map</code>是从inode号到磁盘块的映射，用于查找inode.</p><ul><li>缓存在<strong>内存</strong></li><li>在磁盘上设置<code>checkpoint</code>，周期性地更新<code>inode map</code>.（追加的inode直接把之前的覆盖了）</li></ul></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>以<code>segment</code>为单位进行回收</li><li><code>segment summary</code>：记录每个数据块对应的inode号</li></ul><blockquote><ul><li>LFS的<strong>写</strong>效率比传统的UNIX更高</li><li>LFS的<strong>读</strong>和普通的文件系统性能相当</li></ul></blockquote><h2 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统(VFS)"></a>虚拟文件系统(VFS)</h2><p>初衷是为了让文件系统不需要关心数据到底存在什么样的硬件上，或者存在哪个特定的地方。只要有文件系统提供的函数，就能够满足VFS的读写要求。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>系统启动时，<strong>根文件</strong>系统在VFS中<strong>注册</strong>。</li><li>当装载其他文件系统时，它们需要向VFS提供一个<strong>包含VFS所需要的控制函数的地址列表</strong>（之后VFS就可以对该文件系统进行读写操作了）。</li><li>VFS创建v结点是为了方便<strong>上层</strong>对文件系统进行操作</li></ul><blockquote><p>VFS对用户进程提供的<strong>上层接口</strong>，就是著名的POSIX接口。</p></blockquote><h3 id="超块"><a href="#超块" class="headerlink" title="超块"></a>超块</h3><ul><li>设备：块设备标识符</li><li>索引节点指针</li><li>数据块大小</li><li>超块操作集</li><li>文件系统类型</li><li>特殊信息</li></ul><h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><ul><li>设备</li><li>编号</li><li>模式：对象类型、访问权限</li><li>用户标识符</li><li>时间</li><li>块大小</li><li>操作集</li><li>计数</li><li>锁定</li><li>脏位</li><li>特殊信息</li></ul><h2 id="Reference-9"><a href="#Reference-9" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li></ul><h1 id="Chapter4-1-inode解析"><a href="#Chapter4-1-inode解析" class="headerlink" title="Chapter4-1 inode解析"></a>Chapter4-1 inode解析</h1><p>全文共<code>964</code>字，推荐阅读时间<code>7~10</code>分钟</p><h2 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h2><ul><li>文件存储<strong>以块为单位</strong>存储在硬盘上</li><li>文件的元信息（<strong>不是</strong>文件内容）存储在inode中</li><li>inode中文译名：索引节点</li><li><strong>每个</strong>文件都对应了<strong>一个</strong>inode</li></ul><h2 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h2><ul><li>文件大小</li><li>拥有者ID</li><li>Group ID</li><li>读、写、执行权限</li><li>文件的时间戳<ul><li><code>ctime</code>:inode上一次变动的时间</li><li><code>mtime</code>:文件内容上一次变动的时间</li><li><code>atime</code>:文件上一次打开的时间</li></ul></li><li>连接数：有多少个文件名指向这个inode</li><li>文件数据的块地址</li></ul><blockquote><ul><li><code>stat</code>命令可以查看<code>inode</code>信息</li><li><strong>除了文件名</strong>以外的信息，都存储在inode之中。</li></ul></blockquote><h2 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h2><ul><li>硬盘格式化时，OS会将硬盘分成两个区域，一个是数据区，一个是<code>inode</code>区。</li><li><code>inode</code>大小一般是128或256字节，并且<strong>总数</strong>在格式化时就确定，一般是每$1KB$或每$2KB$就设置一个<code>inode</code>.</li></ul><blockquote><ul><li><code>df -i</code>：查看<code>inode</code>总数和已经使用的数量</li><li><code>sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot;</code>：查看每个<code>inode</code>结点的大小</li><li>发生<code>inode</code>用光但是硬盘未存满的情况时，<strong>无法</strong>在硬盘上继续创建新文件。</li></ul></blockquote><h2 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h2><p>系统内部不通过文件名进行文件相关操作，而是均通过<code>inode</code>号码来完成文件操作。</p><blockquote><p><code>ls -i example.txt</code>：查看文件的<code>inode</code>号码</p></blockquote><h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>目录也是一种文件，所以称为目录文件。</p><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>目录文件就是<strong>目录项的列表</strong></p><ul><li><p>目录项 = 文件名 + <code>inode</code>号码</p><blockquote><p>目录文件下的<code>inode</code>号码<strong>不止一个</strong></p></blockquote></li></ul><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><h3 id="背景-6"><a href="#背景-6" class="headerlink" title="背景"></a>背景</h3><ul><li>一般情况下，文件名和<code>inode</code>号码一一对应。</li><li>特殊情况下，可能存在<strong>多个文件名</strong>指向<strong>同一个</strong><code>inode</code>号码的情况。</li></ul><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><ul><li>可以使用不同的文件名访问同样的内容、对文件内容进行修改。（会影响到所有的文件名）</li><li>删除一个文件名，<strong>不影响</strong>其他文件名的访问。</li><li>目录项中的<code>inode</code>号就是文件数据的<code>inode</code>号</li></ul><blockquote><p><code>ln src det</code>：可以创建<strong>硬链接</strong></p></blockquote><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>对<strong>目录</strong>而言，创建目录时，默认会生成两个目录项<code>.</code>和<code>..</code>,其中<code>.</code>指向当前目录，<code>..</code>指向父目录。</p><blockquote><p>目录文件的<strong>硬链接</strong>总数 = 1 + 1 + 子目录总数（含隐藏目录）</p><ul><li>1：该文件本身的名字对应的目录项</li><li>1：<code>.</code></li></ul></blockquote><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><ul><li>文件A和文件B是不同的文件（<code>inode</code>号码不同），但是文件A的内容是文件B的<strong>路径</strong>（文件名）。因此读取文件A时，系统会自动将访问者导向B.因此，<strong>无论打开哪一个文件</strong>，最终读取的都是文件B.此时，<strong>文件A就称为文件B的软链接</strong>（又称<strong>符号</strong>链接）。</li><li>目录项中的<code>inode</code>号是软链接文件A的<code>inode</code>号，A的数据块中存放有B的路径。</li></ul><blockquote><ul><li>文件A依赖于文件B,如果B被删除或者路径发生变化，那么打开A就会报错。</li><li>文件A指向文件B的<strong>文件名</strong>，而不是<code>inode</code>号码，因此B的<code>inode</code>链接数不会发生变化。</li><li><code>ln -s src dst</code>：创建软链接</li></ul></blockquote><h2 id="特殊作用"><a href="#特殊作用" class="headerlink" title="特殊作用"></a>特殊作用</h2><ul><li>删除<code>inode</code>来删除名字<strong>包含特殊字符</strong>的文件</li><li>移动文件或重命名文件时，<strong>只改变</strong>文件名，<strong>不改变</strong><code>inode</code>号码。</li><li>系统通常无法从<code>inode</code>号码获取文件名</li><li>打开文件后，系统对该文件的操作和文件名就无关了，均以<code>inode</code>号码指代。</li></ul><h2 id="Reference-10"><a href="#Reference-10" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2011/12/inode.html</a></li></ul><h1 id="Chapter5-安全"><a href="#Chapter5-安全" class="headerlink" title="Chapter5 安全"></a>Chapter5 安全</h1><p>全文共<code>1172</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><h3 id="信息系统安全性"><a href="#信息系统安全性" class="headerlink" title="信息系统安全性"></a>信息系统安全性</h3><ul><li>机密性（暴露）：防止<strong>非授权</strong>访问，是信息安全<strong>最重要</strong>的要求。</li><li>完整性（篡改）：信息在<strong>存储</strong>和<strong>传输</strong>过程中保持不被修改、破坏或者丢失。</li><li>可用性（不能服务）</li><li>可靠性</li></ul><h3 id="OS安全目标"><a href="#OS安全目标" class="headerlink" title="OS安全目标"></a>OS安全目标</h3><ul><li>为应用程序提供安全可靠的运行环境</li></ul><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>OS是信息系统安全<strong>基础</strong>之一</li><li>OS规模庞大，安全难以保证。（理论上，OS的安全是<strong>不可判定问题</strong>）</li></ul><h3 id="OS安全需求"><a href="#OS安全需求" class="headerlink" title="OS安全需求"></a>OS安全需求</h3><ul><li>系统边界安全：禁止非法用户进入</li><li>权限管理机制：不同用户有<strong>不同</strong>的权限</li><li>应用和数据访问控制：指定安全的访问<strong>策略</strong></li><li>可信通路：保证登录和应用安全<strong>机制</strong>不被旁路</li><li>安全审计和管理：<strong>检测</strong>错误原因，或者记录攻击<strong>痕迹</strong>。</li></ul><h2 id="安全标准"><a href="#安全标准" class="headerlink" title="安全标准"></a>安全标准</h2><ul><li><p>A：<strong>验证型</strong>保护</p><p>A1：功能<strong>等同于</strong>B3,但是顶层规格设计、验证、模型都需要是<strong>形式化</strong>的。</p><p>A1以上级：比A1更加安全</p></li><li><p>B：<strong>强制型</strong>保护(B1&lt;B2&lt;B3)</p><ul><li><p>B1：满足C2，<strong>标记安全保护</strong>，并且实施强制访问控制(MAC)</p><blockquote><p>用户不能为其他用户赋予权限</p></blockquote></li><li><p>B2：可信计算基(TCB)是明确定义的<strong>形式化</strong>模型</p></li><li><p>B3：TCB可以控制所有主体对客体的访问</p></li></ul></li><li><p>C：<strong>自主型</strong>保护(C1&lt;C2)</p><ul><li>C1(Linux/Unix)：有一定<strong>自主访问控制</strong></li><li>C2(Linux/Windows NT)：相比于C1粒度更<strong>细</strong>（对<strong>每个用户</strong>分别管理），并且引入<strong>审计</strong>机制。</li></ul></li><li><p>D(MS DOS)</p></li></ul><h2 id="常见问题、方法与机制"><a href="#常见问题、方法与机制" class="headerlink" title="常见问题、方法与机制"></a>常见问题、方法与机制</h2><h3 id="加密基础"><a href="#加密基础" class="headerlink" title="加密基础"></a>加密基础</h3><ul><li><p>对称密钥（<strong>私钥</strong>算法）</p><p>加密密钥和解密密钥之间关系很明显，知道一个就能够较为容易的推出另外一个。（两者<strong>不一定相同</strong>）</p><blockquote><p>例如在单字母替换型密钥中，如果加密密钥<strong>前三位</strong>是XYZ，即<code>A-X B-Y C-Z</code>，所以明文中的A被转换为X.这也说明了密文中的Q和A对应。（替换是一个双射，因此可以推出解密密钥为ABC）</p><p>注意区分的是，<strong>密文</strong>中的A就<strong>不和明文</strong>中的X对应了，而应该和加密密钥中和A对应的明文字符（比如是Q）对应。</p><p>可以理解为：明文中的A和密文中的A没有任何关系，它们的双射之间互不干扰。</p></blockquote></li><li><p>非对称密钥（<strong>公钥</strong>算法）</p><p>原理：使用<strong>公钥</strong>进行<strong>加密</strong>，使用<strong>私钥</strong>进行<strong>解密</strong>。</p><p>​    $y=f(x)$生成一对密钥，<code>y</code>作为公钥，<code>x</code>作为私钥。</p><ul><li>解密时已经知道<code>y</code>,需要反解<code>x</code>才能够进行破解。</li></ul><blockquote><p>RSA：基于大数分解</p></blockquote></li><li><p>数字签名</p><ul><li>发送者将文档hash为小文档之后，再使用私钥对小文档进行散列值运算得到<strong>签名块</strong><code>D(hash)</code>作为签名。</li><li>接收者利用公钥对签名块进行运算，得到<code>E(D(hash))</code>.同时对文档再次进行hash变为小文档并记录hash.</li><li>加密算法要求<code>E(D(hash)) = hash</code>，如果计算得到的<code>E(D(hash))</code>和文档<code>hash</code>值不同，则说明文档被<strong>修改</strong>过。</li></ul></li></ul><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><ul><li><p>密码认证</p><ul><li>密码存储<ul><li>明文</li><li>存储hash后的值</li><li>hash+随机数(etc/shadow)</li></ul></li></ul></li><li><p>一次性口令</p><p>每一次成功登录后密钥需要被更新</p><ul><li><p>单向函数</p><p>密钥生成和<strong>上一次</strong>的密钥<strong>无关</strong>，但是和<strong>最后一次</strong>能够使用的<strong>函数</strong>有关。</p><p>$p1=f(f(f(s)))$</p><p>$p2=f(f(s))$</p><p>$p3=f(s)$</p><blockquote><ul><li>服务器存储<code>p3</code>，用户第<code>i</code>次登录需要输入正确的<code>pi</code>.</li><li>该单向函数只能使用三次</li></ul></blockquote></li></ul></li><li><p>生物特征</p></li></ul><h3 id="内部攻击"><a href="#内部攻击" class="headerlink" title="内部攻击"></a>内部攻击</h3><ul><li>逻辑炸弹：软件中的恶意陷阱、后门（旁路）</li><li>后门陷阱</li><li>登录欺骗：伪造登录页面</li></ul><h3 id="外部攻击"><a href="#外部攻击" class="headerlink" title="外部攻击"></a>外部攻击</h3><p>利用代码漏洞</p><ul><li><p>缓冲区溢出攻击(Buffer Overflow Attacks)</p><p>输入时将缓冲区填满溢出，然后改变<strong>函数</strong>返回地址。</p><ul><li>返回libc的攻击(Return to libc Attacks)<ul><li>使用<code>strcpy</code>将恶意代码拷贝到栈中继续执行</li></ul></li></ul></li><li><p>代码注入攻击(Code Injection Attacks)</p><ul><li>利用程序的命令分析漏洞</li></ul></li><li><p>恶意软件(Malware)</p></li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li><p>沙箱机制：严格限制程序的运行空间</p><blockquote><p>虚拟化，沙箱中的改动不影响OS</p></blockquote></li></ul><h2 id="Reference-11"><a href="#Reference-11" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Modern Operating System, Fourth Edition.</li><li>BUAA OS Lecture, Spring Of 2020.</li><li>Wikipedia</li></ul><h1 id="Chapter6-移动操作系统"><a href="#Chapter6-移动操作系统" class="headerlink" title="Chapter6 移动操作系统"></a>Chapter6 移动操作系统</h1><p>全文共<code>505</code>字，推荐阅读时间<code>5~7</code>分钟。</p><h2 id="智能手机系统"><a href="#智能手机系统" class="headerlink" title="智能手机系统"></a>智能手机系统</h2><h3 id="背景-7"><a href="#背景-7" class="headerlink" title="背景"></a>背景</h3><ul><li>传统功能机</li><li>智能移动终端<ul><li>智能指配备了OS,并不是人工智能。（扩展性）</li></ul></li></ul><h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><h4 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h4><h5 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h5><ul><li>硬件到服务的闭环</li><li><p><strong>不</strong>授权在非Apple硬件安装</p></li><li><p>Mac OS &amp; IOS</p></li></ul><h5 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h5><ul><li>Core OS(C)：基于微内核</li><li>Core Services(C)</li><li>Media(C&amp;Object-C)</li><li>Cocoa Touch(Objective-C)：提供应用程序框架和API</li></ul><h5 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h5><ul><li>Xcode</li><li>Objective-C&amp;Swift</li></ul><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><h5 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h5><ul><li>基于Linux</li><li>接口基于Java</li></ul><h5 id="层次-1"><a href="#层次-1" class="headerlink" title="层次"></a>层次</h5><ul><li><p>Linux Kernel：底层硬件的管理</p></li><li><p>Libraries</p><ul><li><p>大部分由C/C++编写，实现了通用功能。</p></li><li><p>Android Runtime：装入了一个虚拟机，每个应用有自己<strong>独立</strong>的虚拟机。</p><blockquote><p><code>.dex</code>：将<code>.class</code>进行字节码再次翻译达到压缩目的</p></blockquote></li></ul></li><li><p>Application Framework</p><ul><li>基本由Java编写</li><li>提供开发使用的API</li><li>应用程序可以使用<code>JNI</code>调用下层函数库（高效性）</li></ul></li><li><p>Application</p><ul><li>平台无关</li><li>Java开发</li></ul></li></ul><h5 id="Android-Market-Google-Play"><a href="#Android-Market-Google-Play" class="headerlink" title="Android Market(Google Play)"></a>Android Market(Google Play)</h5><ul><li>Market本身自己也是应用</li></ul><h5 id="开发环境-1"><a href="#开发环境-1" class="headerlink" title="开发环境"></a>开发环境</h5><ul><li>Android SDK</li><li>Java SDK</li><li>集成开发环境</li></ul><h4 id="Windows-CE-Mobile"><a href="#Windows-CE-Mobile" class="headerlink" title="Windows CE/Mobile"></a>Windows CE/Mobile</h4><ul><li>Windows CE<ul><li>嵌入式系统</li><li>支持ARM/MIPS/x86/SH4</li></ul></li><li>Windows Mobile<ul><li>基于Windows CE</li></ul></li></ul><h4 id="Symbian"><a href="#Symbian" class="headerlink" title="Symbian"></a>Symbian</h4><p>开发生态并不友好，赶走了开发者，导致了灭绝。</p><h2 id="区块链平台操作系统"><a href="#区块链平台操作系统" class="headerlink" title="区块链平台操作系统"></a>区块链平台操作系统</h2><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><ul><li>链式数据结构<ul><li>记录前一个结点的地址和哈希值</li></ul></li><li>分布式节点共识算法</li><li>智能合约</li></ul><blockquote><p>不可篡改、可追溯、构建信任、<strong>去中心</strong>、支持智能合约。</p></blockquote><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h4><h4 id="2-0（以太坊）"><a href="#2-0（以太坊）" class="headerlink" title="2.0（以太坊）"></a>2.0（以太坊）</h4><ul><li>支持图灵完备的虚拟机</li><li>使用智能合约程序管理资产</li></ul><h4 id="3-0"><a href="#3-0" class="headerlink" title="3.0"></a>3.0</h4><ul><li>在货币和金融外，在其他产业领域上提供可扩展的区块链应用。</li><li>联盟链(ToB)</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>不可篡改<ul><li>物流、法证、电子政务、发票、学位证书</li></ul></li><li>共识信任<ul><li>供应链金融</li></ul></li><li>去中心<ul><li>新型交易</li></ul></li><li>确权和可信<ul><li>医疗、物联网、大数据协调</li></ul></li></ul><h2 id="Reference-12"><a href="#Reference-12" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA OS Lecture, Spring Of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2020 BUAA OS course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>TensorFlow Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/TensorFlow%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/TensorFlow%20Learning%20Note/</id>
    <published>2021-06-23T12:46:18.752Z</published>
    <updated>2021-06-23T12:56:16.794Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全文共<code>3487</code>字，是暑期学习TensorFlow的记录，推荐按照顺序进行阅读。</strong></p><a id="more"></a><h2 id="张量、计算图、会话"><a href="#张量、计算图、会话" class="headerlink" title="张量、计算图、会话"></a>张量、计算图、会话</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>用<strong>张量</strong>表示数据，用<strong>计算图</strong>搭建神经网络，用<strong>会话</strong>执行计算图，优化线上的权重（参数），得到模型。</li></ul><h3 id="张量-tensor"><a href="#张量-tensor" class="headerlink" title="张量(tensor)"></a>张量(tensor)</h3><ul><li><p>多维数组（列表）</p></li><li><p>根据中括号数判断维数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scalar = <span class="number">1</span></span><br><span class="line">vector = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">tensor = [[[...]...]...]</span><br></pre></td></tr></table></figure></li><li><p>常量的声明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">a = tf.constant([[<span class="number">1.0</span>, <span class="number">2.0</span>]]) <span class="comment"># a matrix instead of a vector</span></span><br><span class="line">b = tf.constant([[<span class="number">3.0</span>], [<span class="number">4.0</span>]])</span><br><span class="line"></span><br><span class="line">result = tf.matmul(a, b)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></li></ul><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><ul><li>只搭建，不计算。</li></ul><h3 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话(Session)"></a>会话(Session)</h3><ul><li><p>执行运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(y)</span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li><p>在TensorFlow1中，需要先建立计算图才能够计算。但是TensowFlow2中默认将两步合并，即<code>matmul</code>操作时就直接计算结果。</p></li><li><p>在2中调用1的方法/类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.compat.v1.Session() <span class="comment"># tf.compat.v1.xxx</span></span><br></pre></td></tr></table></figure></li><li><p>运行时屏蔽TensorFlow的警告信息：在文件<strong>最前面</strong>（先于<code>import tensorflow</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>]=<span class="string">'2'</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p>神经网络线上的权重W</p></li><li><p>生成</p><ul><li><code>random_normal</code>：正态分布</li><li><code>truncated_normal</code>：去掉$2σ$以外的数据的正态分布</li><li><code>random_uniform</code>：平均分布</li><li><code>zeros</code></li><li><code>ones</code></li><li><code>fill</code>：全定值</li><li><code>constant</code>：直接给值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w = tf.Variable(tf.compat.v1.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">2</span>, mean=<span class="number">0</span>, seed=<span class="number">1</span>))</span><br><span class="line">tf.zeros([<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">tf.fill([<span class="number">3</span>, <span class="number">2</span>], <span class="number">6</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="神经网络搭建"><a href="#神经网络搭建" class="headerlink" title="神经网络搭建"></a>神经网络搭建</h3><ul><li>准备数据集</li><li>搭建NN结构，从输入到输出。<ul><li>搭建计算图</li><li>绘画执行</li></ul></li><li>迭代优化NN参数</li><li>使用训练好的模型进行预测和分类</li></ul><h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p>模型搭建，实现推理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''两层简单全连接神经网络'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入和参数</span></span><br><span class="line">x = tf.constant([[<span class="number">0.7</span>, <span class="number">0.5</span>]])</span><br><span class="line">w1 = tf.Variable(tf.compat.v1.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line">w2 = tf.Variable(tf.compat.v1.random_normal([<span class="number">3</span>, <span class="number">1</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义前向传播过程</span></span><br><span class="line">a = tf.matmul(x, w1)</span><br><span class="line">y = tf.matmul(a, w2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用会话计算结果</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op= tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    print(sess.run(y))</span><br></pre></td></tr></table></figure><ul><li><p><code>global_variables_initializer</code>返回<strong>初始化</strong>所有的<strong>全局变量</strong>(<code>Variable</code>)的操作，使用会话进行执行。</p><ul><li><p>全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.Variable(<span class="number">1</span>, name=<span class="string">'var_z'</span>)</span><br></pre></td></tr></table></figure></li><li><p>局部变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e = tf.Variable(<span class="number">6</span>, name=<span class="string">'var_e'</span>, collections=[tf.GraphKeys.LOCAL_VARIABLES])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用<code>placeholder</code>实现<strong>输入</strong>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = tf.compat.v1.placeholder(tf.float32, shape=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">print(sess.run(y, feed_dict=&#123;x: [[<span class="number">0.7</span>, <span class="number">0.5</span>]]&#125;))</span><br></pre></td></tr></table></figure><ul><li><p>输入多组数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">2</span>))</span><br><span class="line">sess.run(y, feed_dict=&#123;x: [[<span class="number">0.7</span>, <span class="number">0.5</span>], [<span class="number">0.2</span>, <span class="number">0.3</span>], [<span class="number">0.3</span>, <span class="number">0.4</span>]]&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong>多组</strong>计算值（不只一个<code>y</code>）</p></blockquote></li></ul></li></ul><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>训练模型参数，在所有参数上使用梯度下降，使NN模型在训练数据上的<strong>损失函数</strong>最小。</p><ul><li><p>损失函数：预测值(<code>y</code>)和已知答案(<code>y_</code>)之间的差距</p></li><li><p>均方差(MSE)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = tf.reduce_mean(tf.square(y_ - y))</span><br></pre></td></tr></table></figure></li><li><p>训练方法：减小loss值为优化目标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tf.compat.v1.train.GradientDescentOptimizer(learning_rate).minimize(loss)</span><br><span class="line">tf.compat.v1.train.MomentumOptimizer(learning_rate, momentum).minimize(loss)</span><br><span class="line">tf.compat.v1.train.AdamOptimizer(learning_rate).minimize(loss)</span><br></pre></td></tr></table></figure><ul><li><code>learning_rate</code>：学习率，决定参数每次更新的幅度</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''两层简单全连接神经网络'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line">BATCH_SIZE = <span class="number">8</span></span><br><span class="line">seed = <span class="number">23455</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机矩阵对象</span></span><br><span class="line">rng = np.random.RandomState(seed)</span><br><span class="line"><span class="comment"># 返回随机的 32 * 2 矩阵</span></span><br><span class="line">X = rng.rand(<span class="number">32</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 将合法数据的结果置为1 否则为0</span></span><br><span class="line">Y = [[int(x0 + x1 &lt; <span class="number">1</span>)] <span class="keyword">for</span> (x0, x1) <span class="keyword">in</span> X]</span><br><span class="line">print(<span class="string">"X:"</span> + str(X))</span><br><span class="line">print(<span class="string">"Y:"</span> + str(Y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入和参数</span></span><br><span class="line">x = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">2</span>))</span><br><span class="line">w1 = tf.Variable(tf.compat.v1.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line">w2 = tf.Variable(tf.compat.v1.random_normal([<span class="number">3</span>, <span class="number">1</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义标准输出</span></span><br><span class="line">y_ = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义前向传播过程</span></span><br><span class="line">a = tf.matmul(x, w1)</span><br><span class="line">y = tf.matmul(a, w2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数和反向传播的方法</span></span><br><span class="line">loss = tf.compat.v1.reduce_mean(tf.square(y - y_))</span><br><span class="line">train_step = tf.compat.v1.train.GradientDescentOptimizer(<span class="number">0.001</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    <span class="comment"># 未经训练的参数值</span></span><br><span class="line">    print(<span class="string">'initial w1: '</span> + str(sess.run(w1)))</span><br><span class="line">    print(<span class="string">'initial w2: '</span> + str(sess.run(w2)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    <span class="comment"># 使用同一数据集的不同数据组合训练3000轮</span></span><br><span class="line">    STEPS = <span class="number">3000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">        start = (i * BATCH_SIZE) % <span class="number">32</span></span><br><span class="line">        end = start + BATCH_SIZE</span><br><span class="line">        <span class="comment"># 传入y_指定标准输出</span></span><br><span class="line">        sess.run(train_step, feed_dict=&#123;x: X[start:end], y_: Y[start:end]&#125;)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'final w1: '</span> + str(sess.run(w1)))</span><br><span class="line">    print(<span class="string">'final w2: '</span> + str(sess.run(w2)))</span><br></pre></td></tr></table></figure><h3 id="神经网络八股"><a href="#神经网络八股" class="headerlink" title="神经网络八股"></a>神经网络八股</h3><ul><li><p>准备</p><ul><li><code>import</code></li><li>常量定义</li><li>生成数据集</li></ul></li><li><p>前传</p><ul><li>定义输入、参数、标准输出</li></ul></li><li><p>反传</p><ul><li>定义损失函数和反传优化方法</li></ul></li><li><p>迭代</p><ul><li><p>生成会话，训练<code>STEPS</code>轮。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line"></span><br><span class="line">    STEPS = <span class="number">3000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">        start = ...</span><br><span class="line">        end = ...</span><br><span class="line">        sess.run(train_step, feed_dict=&#123;...&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><ul><li><code>relu</code>:<code>tf.nn.relu()</code></li><li><code>sigmoid</code>:<code>tf.nn.sigmoid()</code></li><li><code>tanh</code>:<code>tf.nn.tanh()</code></li></ul><h3 id="NN复杂度"><a href="#NN复杂度" class="headerlink" title="NN复杂度"></a>NN复杂度</h3><ul><li>层数=隐藏层+输出层</li><li>总参数=总W+总b<ul><li><code>b</code>是偏置值，计算层一个结果神经元对应一个偏置。</li></ul></li></ul><h3 id="自定义损失函数"><a href="#自定义损失函数" class="headerlink" title="自定义损失函数"></a>自定义损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COST = <span class="number">1</span></span><br><span class="line">PROFIT = <span class="number">9</span></span><br><span class="line">loss = tf.reduce_sum(tf.where(tf.greater(y, y_), COST * (y - y_), PROFIT * (y_ - y)))</span><br></pre></td></tr></table></figure><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><ul><li><p>表征两个概率分布之间的<strong>距离</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ce = -tf.reduce_mean(y_ * tf.log(clip_by_value(y, <span class="number">1e-12</span>, <span class="number">1.0</span>)))</span><br></pre></td></tr></table></figure><ul><li><p>将<code>n</code>分类的<code>n</code>个输出通过<code>softmax()</code>函数处理使其满足概率和为1的分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ce = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y, labels=tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">cem = tf.reduce_mean(ce) <span class="comment"># loss function</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h2><ul><li>每次更新的幅度</li></ul><h3 id="指数衰减学习率"><a href="#指数衰减学习率" class="headerlink" title="指数衰减学习率"></a>指数衰减学习率</h3><ul><li><p>根据训练情况动态更新学习率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line">LEARNING_RATE_BASE = <span class="number">0.1</span>  <span class="comment"># 初始学习率</span></span><br><span class="line">LEARNING_RATE_DECAY = <span class="number">0.99</span>  <span class="comment"># 学习率衰减律</span></span><br><span class="line">LEARNING_RATE_STEP = <span class="number">1</span>  <span class="comment"># 学习率更新频度 一般为总样本数/BATCH_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 轮数计数器 初值为0 设置为不被训练</span></span><br><span class="line">global_step = tf.Variable(<span class="number">0</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 定义指数下降学习率</span></span><br><span class="line">learning_rate = tf.compat.v1.train.exponential_decay(</span><br><span class="line">    LEARNING_RATE_BASE,</span><br><span class="line">    global_step,</span><br><span class="line">    LEARNING_RATE_STEP,</span><br><span class="line">    LEARNING_RATE_DECAY,</span><br><span class="line">    staircase=<span class="literal">True</span>)  <span class="comment"># 为True表示学习率的下降是梯度曲线</span></span><br><span class="line"><span class="comment"># 定义待优化参数</span></span><br><span class="line">w = tf.Variable(tf.constant(<span class="number">5</span>, dtype=tf.float32))</span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss = tf.square(w + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 反向传播方法</span></span><br><span class="line">train_step = tf.compat.v1.train.GradientDescentOptimizer(</span><br><span class="line">    learning_rate).minimize(loss, global_step=global_step)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">40</span>):</span><br><span class="line">        sess.run(train_step)</span><br><span class="line">        learning_rate_val = sess.run(learning_rate)</span><br><span class="line">        global_step_val = sess.run(global_step)</span><br><span class="line">        w_val = sess.run(w)</span><br><span class="line">        loss_val = sess.run(loss)</span><br><span class="line">        print(w_val)</span><br></pre></td></tr></table></figure></li></ul><h2 id="滑动平均（影子值）"><a href="#滑动平均（影子值）" class="headerlink" title="滑动平均（影子值）"></a>滑动平均（影子值）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ema = tf.compat.v1.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step) <span class="comment"># 衰减率和当前轮数</span></span><br><span class="line">ema_op = ema.apply(tf.compat.v1.trainable_variables()) <span class="comment"># 对所有的待优化参数求平均值</span></span><br><span class="line"><span class="keyword">with</span> tf.control_dependencies([train_step, ema_op]):</span><br><span class="line">    train_op = tf.no_op(name=<span class="string">'train'</span>) <span class="comment"># 将训练和滑动平均操作绑定</span></span><br></pre></td></tr></table></figure><blockquote><p><code>ema.average(arg)</code>：查看参数的滑动平均值</p></blockquote><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><ul><li>缓解过拟合：通过给某些参数权值，弱化训练数据的噪声，将其正则化。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line">BATCH_SIZE = <span class="number">30</span></span><br><span class="line">seed = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于seed产生随机数</span></span><br><span class="line">rdm = np.random.RandomState(seed)</span><br><span class="line"><span class="comment"># 产生300组2维坐标</span></span><br><span class="line">X = rdm.randn(<span class="number">300</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 根据是否在园内为每个点设置颜色</span></span><br><span class="line">Y_ = [int(x0**<span class="number">2</span> + x1**<span class="number">2</span> &lt; <span class="number">2</span>) <span class="keyword">for</span> (x0, x1) <span class="keyword">in</span> X]</span><br><span class="line">Y_c = [[<span class="string">'red'</span> <span class="keyword">if</span> y <span class="keyword">else</span> <span class="string">'blue'</span>] <span class="keyword">for</span> y <span class="keyword">in</span> Y_]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据集X和标签Y进行shape整理为矩阵</span></span><br><span class="line"><span class="comment"># 第一个参数-1表示属性值由第二个参数决定</span></span><br><span class="line"><span class="comment"># 第二个参数表示有多少列 即X为n行2列 Y为n行1列</span></span><br><span class="line">X = np.vstack(X).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">Y_ = np.vstack(Y_).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取X所有坐标的第0/1列元素并指定颜色进行绘制</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=np.squeeze(Y_c))</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入 参数 输出 和前向传播过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight</span><span class="params">(shape, regularizer)</span>:</span></span><br><span class="line">    w = tf.Variable(tf.compat.v1.random_normal(shape), dtype=tf.float32)</span><br><span class="line">    tf.compat.v1.add_to_collection(</span><br><span class="line">        <span class="string">'losses'</span>,</span><br><span class="line">        tf.keras.regularizers.l2(regularizer)(w))</span><br><span class="line">        <span class="comment"># tf.contrib.layers.l2_regularizer(regularizer)(w))</span></span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bias</span><span class="params">(shape)</span>:</span></span><br><span class="line">    b = tf.Variable(tf.constant(<span class="number">0.01</span>, shape=shape))</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">2</span>))</span><br><span class="line">y_ = tf.compat.v1.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">w1 = get_weight([<span class="number">2</span>, <span class="number">11</span>], <span class="number">0.01</span>)</span><br><span class="line">b1 = get_bias([<span class="number">11</span>])</span><br><span class="line">y1 = tf.nn.relu(tf.matmul(x, w1) + b1)  <span class="comment"># 激活隐藏层</span></span><br><span class="line"></span><br><span class="line">w2 = get_weight([<span class="number">11</span>, <span class="number">1</span>], <span class="number">0.01</span>)</span><br><span class="line">b2 = get_bias([<span class="number">1</span>])</span><br><span class="line">y = tf.matmul(y1, w2) + b2  <span class="comment"># 输出层不激活</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss_mse = tf.reduce_mean(tf.square(y - y_))</span><br><span class="line">loss_total = loss_mse + tf.compat.v1.add_n(</span><br><span class="line">    tf.compat.v1.get_collection(<span class="string">'losses'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不含正则化的反向传播</span></span><br><span class="line">train_step = tf.compat.v1.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(loss_mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含正则化的反向传播</span></span><br><span class="line">train_step = tf.compat.v1.train.AdamOptimizer(<span class="number">0.0001</span>).minimize(loss_total)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    STEPS = <span class="number">40000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">        start = (i * BATCH_SIZE) % <span class="number">300</span></span><br><span class="line">        end = start + BATCH_SIZE</span><br><span class="line">        sess.run(train_step, feed_dict=&#123;x: X[start:end], y_: Y_[start:end]&#125;)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2000</span> == <span class="number">0</span>:</span><br><span class="line">            loss_mse_v = sess.run(loss_mse, feed_dict=&#123;x: X, y_: Y_&#125;)</span><br><span class="line">    <span class="comment"># 在[-3,3]上以0.01为步长生成二维网格坐标点</span></span><br><span class="line">    xx, yy = np.mgrid[<span class="number">-3</span>:<span class="number">3</span>:<span class="number">.01</span>, <span class="number">-3</span>:<span class="number">3</span>:<span class="number">.01</span>]</span><br><span class="line">    <span class="comment"># 将xx, yy拉直，合并成2列的矩阵</span></span><br><span class="line">    grid = np.c_[xx.ravel(), yy.ravel()]</span><br><span class="line">    <span class="comment"># 将点喂入神经网络</span></span><br><span class="line">    probs = sess.run(y, feed_dict=&#123;x: grid&#125;)</span><br><span class="line">    <span class="comment"># 调成probs的shape为和xx相同</span></span><br><span class="line">    probs = probs.reshape(xx.shape)</span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=np.squeeze(Y_c))</span><br><span class="line">plt.contour(xx, yy, probs, levels=[<span class="number">.5</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="搭建八股"><a href="#搭建八股" class="headerlink" title="搭建八股"></a>搭建八股</h2><ul><li><p>生成数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">()</span>:</span></span><br><span class="line">    rdm = np.random.RandomState(seed)</span><br><span class="line">    X = </span><br><span class="line">    Y_ = </span><br><span class="line">    Y_c = </span><br><span class="line">    </span><br><span class="line">    X = np.vstack(X).reshape()</span><br><span class="line">    Y = np.vstack(Y).reshape()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X, Y_, Y_c</span><br></pre></td></tr></table></figure></li><li><p>前向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''forward.py'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(x, regularizer)</span>:</span></span><br><span class="line">    w = </span><br><span class="line">    b = </span><br><span class="line">    y = </span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight</span><span class="params">(shape, regularizer)</span>:</span></span><br><span class="line">    w = tf.Variable()</span><br><span class="line">    tf.add_to_collection(<span class="string">'losses'</span>, tf,contrib.layers.l2_regularizer(regularizer)(w))</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bias</span><span class="params">(shape)</span>:</span></span><br><span class="line">    b = tf.Variable()</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure></li><li><p>反向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''backward.py'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">()</span>:</span></span><br><span class="line">    x = tf.palceholer()</span><br><span class="line">    y_ = tf.palceholer()</span><br><span class="line">    y = forward.firward(x, REGULARIZER)</span><br><span class="line">    global_step = tf.Variable(<span class="number">0</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">    loss = </span><br><span class="line"></span><br><span class="line">    train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        init_op = tf.global_variables_initializer()</span><br><span class="line">        sess.run(init_op)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">            sess.run(train_step, feed_dict=&#123;x:, y_:&#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    backward()</span><br></pre></td></tr></table></figure></li></ul><h2 id="MNIST数据集"><a href="#MNIST数据集" class="headerlink" title="MNIST数据集"></a>MNIST数据集</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><code>tf.get_collection(&#39;&#39;)</code>：取<code>collection</code>中的所有变量并生成一个列表</li><li><code>tf.add_n([])</code>：将列表中对应的元素相加</li><li><code>tf.cast(x, dtype)</code>：将<code>x</code>的类型转换为<code>dtype</code></li><li><code>tf.argmax(x, axis)</code>：返回最大值所在的索引号</li><li><code>os.path.join(&#39;home&#39;, &#39;name&#39;)</code>：返回<code>home/name</code></li><li><code>with tf.Graph().as_default() as g:</code>：语句块中的节点在计算图<code>g</code>中（多用于<strong>复现</strong>神经网络）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''mnist_forward.py'''</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">INPUT_NODE = <span class="number">784</span></span><br><span class="line">OUTPUT_NODE = <span class="number">10</span></span><br><span class="line">LAYER_NODE = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight</span><span class="params">(shape, regularizer)</span>:</span></span><br><span class="line">    <span class="comment">#beijieduande biaozhuncha buhuichaoguo liangge biaozhuncha</span></span><br><span class="line">    w = tf.Variable(tf.compat.v1.truncated_normal(shape, stddev=<span class="number">0.1</span>))</span><br><span class="line">    <span class="keyword">if</span> regularizer != <span class="literal">None</span>:</span><br><span class="line">        tf.compat.v1.add_to_collection(</span><br><span class="line">            <span class="string">"losses"</span>,</span><br><span class="line">            tf.keras.regularizers.l2(regularizer)(w))</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bias</span><span class="params">(shape)</span>:</span></span><br><span class="line">    b = tf.Variable(tf.zeros(shape))</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(x, regularizer)</span>:</span></span><br><span class="line">    w1 = get_weight((INPUT_NODE, LAYER_NODE), regularizer)</span><br><span class="line">    b1 = get_bias(LAYER_NODE)</span><br><span class="line">    y1 = tf.nn.relu(tf.matmul(x, w1) + b1)</span><br><span class="line"></span><br><span class="line">    w2 = get_weight((LAYER_NODE, OUTPUT_NODE), regularizer)</span><br><span class="line">    b2 = get_bias(OUTPUT_NODE)</span><br><span class="line">    y2 = tf.matmul(y1, w2) + b2</span><br><span class="line">    <span class="keyword">return</span> y2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.random.random((<span class="number">3</span>, <span class="number">784</span>))</span><br><span class="line">    x = x.astype(np.float32)</span><br><span class="line">    print(<span class="string">"x.shape:"</span>, x.shape)</span><br><span class="line">    regularizer = <span class="number">0.001</span></span><br><span class="line">    print(x.dtype)</span><br><span class="line"></span><br><span class="line">    pred_y = forward(x, regularizer)</span><br><span class="line">    print(<span class="string">"pred_y:"</span>, pred_y[:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''mnist_backward.py'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> mnist_forward</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">LEARNING_RATE_BASE = <span class="number">0.1</span></span><br><span class="line">LEARNING_RATE_DECAY = <span class="number">0.99</span></span><br><span class="line">REGULARIZER = <span class="number">0.0001</span></span><br><span class="line">STEPS = <span class="number">50000</span></span><br><span class="line">MOVING_AVERAGE_DECAY = <span class="number">0.99</span></span><br><span class="line">MODEL_SAVE_PATH = <span class="string">"./model/"</span></span><br><span class="line">MODEL_NAME = <span class="string">'mnist_model'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(mnist)</span>:</span></span><br><span class="line"></span><br><span class="line">    x = tf.compat.v1.placeholder(tf.float32, [<span class="literal">None</span>, mnist_forward.INPUT_NODE])</span><br><span class="line">    y_ = tf.compat.v1.placeholder(tf.float32,</span><br><span class="line">                                  [<span class="literal">None</span>, mnist_forward.OUTPUT_NODE])</span><br><span class="line">    y = mnist_forward.forward(x, REGULARIZER)</span><br><span class="line">    global_step = tf.Variable(<span class="number">0</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    ce = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y,</span><br><span class="line">                                                        labels=tf.argmax(</span><br><span class="line">                                                            y_, <span class="number">1</span>))</span><br><span class="line">    cem = tf.reduce_mean(ce)</span><br><span class="line">    loss = cem + tf.add_n(tf.compat.v1.get_collection(<span class="string">"losses"</span>))</span><br><span class="line"></span><br><span class="line">    learning_rate = tf.compat.v1.train.exponential_decay(LEARNING_RATE_BASE,</span><br><span class="line">                                               global_step,</span><br><span class="line">                                               mnist.train.num_examples /</span><br><span class="line">                                               BATCH_SIZE,</span><br><span class="line">                                               LEARNING_RATE_DECAY,</span><br><span class="line">                                               staircase=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    train_step = tf.compat.v1.train.GradientDescentOptimizer(learning_rate).minimize(</span><br><span class="line">        loss, global_step=global_step)</span><br><span class="line"></span><br><span class="line">    ema = tf.compat.v1.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step)</span><br><span class="line">    ema_op = ema.apply(tf.compat.v1.trainable_variables())</span><br><span class="line">    <span class="keyword">with</span> tf.control_dependencies([train_step, ema_op]):</span><br><span class="line">        train_op = tf.no_op(name=<span class="string">"train"</span>)</span><br><span class="line"></span><br><span class="line">    saver = tf.compat.v1.train.Saver()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        init_op = tf.compat.v1.global_variables_initializer()</span><br><span class="line">        sess.run(init_op)</span><br><span class="line">        ckpt = tf.compat.v1.train.get_checkpoint_state(MODEL_SAVE_PATH)</span><br><span class="line">        exclude = [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">            saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">            xs, ys = mnist.train.next_batch(BATCH_SIZE)</span><br><span class="line">            _, loss_value, step = sess.run([train_op, loss, global_step],</span><br><span class="line">                                           feed_dict=&#123;</span><br><span class="line">                                               x: xs,</span><br><span class="line">                                               y_: ys</span><br><span class="line">                                           &#125;)</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                print(</span><br><span class="line">                    <span class="string">"After %d training step(s), losses on trianing batch is %f. "</span></span><br><span class="line">                    % (step, loss_value))</span><br><span class="line">                saver.save(sess,</span><br><span class="line">                           os.path.join(MODEL_SAVE_PATH, MODEL_NAME),</span><br><span class="line">                           global_step=global_step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    mnist = input_data.read_data_sets(<span class="string">"./MNIST_data/"</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line">    backward(mnist)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''mnist_test.py'''</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> mnist_forward</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"><span class="keyword">import</span> mnist_forward</span><br><span class="line"><span class="keyword">import</span> mnist_backward</span><br><span class="line">TEST_INTERVAL_SECS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(mnist)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.Graph().as_default() <span class="keyword">as</span> g:</span><br><span class="line">        x = tf.compat.v1.placeholder(tf.float32, [<span class="literal">None</span>, mnist_forward.INPUT_NODE])</span><br><span class="line">        y_ = tf.compat.v1.placeholder(tf.float32, [<span class="literal">None</span>, mnist_forward.OUTPUT_NODE])</span><br><span class="line">        y = mnist_forward.forward(x, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        ema = tf.compat.v1.train.ExponentialMovingAverage(</span><br><span class="line">            mnist_backward.MOVING_AVERAGE_DECAY)</span><br><span class="line">        ema_restore = ema.variables_to_restore()</span><br><span class="line">        saver = tf.compat.v1.train.Saver(ema_restore)</span><br><span class="line"></span><br><span class="line">        correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">#qiupingjun</span></span><br><span class="line">        accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="number">20</span>:</span><br><span class="line">            <span class="comment">#gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=0.333)</span></span><br><span class="line">            <span class="comment">#with tf.Session(config=tf.ConfigProto(gpu_options=gpu_options)) as sess:</span></span><br><span class="line">            <span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">                ckpt = tf.compat.v1.train.get_checkpoint_state(</span><br><span class="line">                    mnist_backward.MODEL_SAVE_PATH)</span><br><span class="line">                <span class="comment">#                print("----")</span></span><br><span class="line">                <span class="comment">#                print(ckpt)</span></span><br><span class="line">                <span class="comment">#                print("----")</span></span><br><span class="line">                <span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">                    <span class="comment">#                    print("ok?")</span></span><br><span class="line">                    saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line">                    global_step = ckpt.model_checkpoint_path.split(</span><br><span class="line">                        <span class="string">'/'</span>)[<span class="number">-1</span>].split(<span class="string">'-'</span>)[<span class="number">-1</span>]</span><br><span class="line">                    <span class="comment">#                    print("global_step:",global_step)</span></span><br><span class="line">                    accuracy_score = sess.run(accuracy,</span><br><span class="line">                                              feed_dict=&#123;</span><br><span class="line">                                                  x: mnist.test.images[:<span class="number">256</span>],</span><br><span class="line">                                                  y_: mnist.test.labels[:<span class="number">256</span>]</span><br><span class="line">                                              &#125;)</span><br><span class="line">                    print(<span class="string">"After %s training step(s). test accuracy = %f"</span> %</span><br><span class="line">                          (global_step, accuracy_score))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"No checkpoint file found"</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                time.sleep(TEST_INTERVAL_SECS)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    mnist = input_data.read_data_sets(<span class="string">"./MNIST_data/"</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line">    test(mnist)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''mnist_app.py'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Wed Nov 28 22:37:56 2018</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: lele</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> mnist_backward</span><br><span class="line"><span class="keyword">import</span> mnist_forward</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restore_model</span><span class="params">(testPicArr)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.Graph().as_default() <span class="keyword">as</span> g:</span><br><span class="line">        x = tf.compat.v1.placeholder(tf.float32, [<span class="literal">None</span>, mnist_forward.INPUT_NODE])</span><br><span class="line">        y = mnist_forward.forward(x, <span class="literal">None</span>)</span><br><span class="line">        preValue = tf.compat.v1.arg_max(y, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        variable_averages = tf.compat.v1.train.ExponentialMovingAverage(</span><br><span class="line">            mnist_backward.MOVING_AVERAGE_DECAY)</span><br><span class="line">        variable_to_restore = variable_averages.variables_to_restore()</span><br><span class="line">        saver = tf.compat.v1.train.Saver(variable_to_restore)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">            ckpt = tf.compat.v1.train.get_checkpoint_state(</span><br><span class="line">                mnist_backward.MODEL_SAVE_PATH)</span><br><span class="line">            <span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">                saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line"></span><br><span class="line">                preValue = sess.run(preValue, feed_dict=&#123;x: testPicArr&#125;)</span><br><span class="line">                <span class="keyword">return</span> preValue</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"No checkpoint file found"</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_pic</span><span class="params">(picName)</span>:</span></span><br><span class="line">    fp = open(picName, <span class="string">'rb'</span>)</span><br><span class="line">    img = Image.open(fp)</span><br><span class="line">    reIm = img.resize((<span class="number">28</span>, <span class="number">28</span>), Image.ANTIALIAS)</span><br><span class="line">    im_arr = np.array(reIm.convert(<span class="string">'L'</span>))</span><br><span class="line">    threshold = <span class="number">50</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">28</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">28</span>):</span><br><span class="line">            im_arr[i][j] = <span class="number">255</span> - im_arr[i][j]</span><br><span class="line">            <span class="keyword">if</span> (im_arr[i][j] &lt; threshold):</span><br><span class="line">                im_arr[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                im_arr[i][j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    nm_arr = im_arr.reshape([<span class="number">1</span>, <span class="number">784</span>])</span><br><span class="line">    nm_arr = nm_arr.astype(np.float32)</span><br><span class="line">    img_ready = np.multiply(nm_arr, <span class="number">1.0</span> / <span class="number">255.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img_ready</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">()</span>:</span></span><br><span class="line">    testNum = int(input(<span class="string">"input the num of the test pictures:"</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(testNum):</span><br><span class="line">        testPic = input(<span class="string">"the path of test picture:"</span>)</span><br><span class="line">        testPicArr = pre_pic(testPic)</span><br><span class="line">        preValue = restore_model(testPicArr)</span><br><span class="line">        print(<span class="string">"the prediction num is:"</span>, preValue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    application()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><p>待优化参数过多会导致过拟合</p></li><li><p>为了避免过拟合，通常先将图片进行预处理（提取特征）。</p></li><li><p>卷积是一种有效的<strong>提取图像特征</strong>的方法</p></li><li><p>$输出图片边长=(输入图片边长-卷积核长+1)/步长(向上取整)$</p><blockquote><p>为了将输出图片和输入图片的边长保持一致，可以对输入图片进行<strong>全零填充(Padding)</strong>。</p></blockquote></li></ul><h3 id="卷积计算"><a href="#卷积计算" class="headerlink" title="卷积计算"></a>卷积计算</h3><ul><li><p><code>tf.nn.conv2d</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.nn.conv2d([batch, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">16</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>padding</code><ul><li><code>VALID</code>：不进行填充</li><li><code>SAME</code>：进行填充</li></ul></li><li>核个数指定<strong>输出</strong>的通道数</li></ul></li></ul><h3 id="池化-Pooling"><a href="#池化-Pooling" class="headerlink" title="池化(Pooling)"></a>池化(Pooling)</h3><ul><li><p>减少特征数量（模糊处理）</p></li><li><p>最大值池化：提取图片纹理</p></li><li><p>均值池化：保留背景特征</p></li><li><p>计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool = tf.nn.max_pool([batch, <span class="number">28</span>, <span class="number">28</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>) <span class="comment"># tf.nn.avg_pool</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="舍弃-Dropout"><a href="#舍弃-Dropout" class="headerlink" title="舍弃(Dropout)"></a>舍弃(Dropout)</h3><ul><li><p>训练时随机舍弃一些神经元，但是在使用时<strong>会恢复</strong>。</p></li><li><p>实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.nn.dropout(上层输出， 舍弃的概率)</span><br></pre></td></tr></table></figure><blockquote><p>一般放在<strong>全连接</strong>网络中</p></blockquote></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>卷积</li><li>激活</li><li>池化</li><li>全连接</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>TensorFlow Notebook, Peking University, 2018.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;全文共&lt;code&gt;3487&lt;/code&gt;字，是暑期学习TensorFlow的记录，推荐按照顺序进行阅读。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>Python变量详解</title>
    <link href="http://yoursite.com/2021/06/23/Python%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/06/23/Python%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-06-23T12:45:55.843Z</published>
    <updated>2021-06-23T12:50:29.659Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全文共<code>2007</code>字，推荐阅读时间<code>10~15</code>分钟。</strong></p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Python里的变量是什么？是一个代号还是具体的内存中存储的值？还是另有它意？</p><p>最近在看《Fluent Python》时受到作者启发，想要记录一些目前关于Python最基础的变量部分的理解，同时也是为了小仙女能把这里搞明白。</p><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><ul><li><p>变量名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><code>a</code>就是我们所说的变量名</li></ul></li><li><p><strong>数据</strong>类型（仅涉及常见类型）</p><ul><li>数字(int/long/float/complex)</li><li>字符串(str)</li><li>列表(list)</li><li>元组(tuple)</li><li>字典(dict)</li></ul><blockquote><p>Q：为什么不是<strong>变量</strong>类型？</p><p>A：在笔者看来，Python是一种<strong>弱类型</strong>语言，变量<strong>没有</strong>固定的类型——今天是数字，明天可能就变成了列表。因此，说<strong>数据类型</strong>分为哪些类相比于<strong>变量类型</strong>更为准确。</p></blockquote></li></ul><p>以上是最常见的关于Python变量的描述，它们具体应该怎么使用并不是本文探讨的重点。因此接下来我们从变量本身的一些性质出发，理解Python中相关的一些特殊情况。</p><h2 id="可变与不可变"><a href="#可变与不可变" class="headerlink" title="可变与不可变"></a>可变与不可变</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>可变：list/dict</li><li>不可变：tuple/str/int/long/float/complex</li></ul><h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>什么叫可变？就是单纯的可以被改变吗？</p><p>什么是不可变？不可以被改变就叫不可变吗？</p><p>显然，这可能是正确答案，但是一定不是一个准确的答案。</p><p>为了介绍清楚这两者的区别，我们首先介绍一个函数：<code>id()</code>.</p><blockquote><p><code>id()</code>这个函数的作用和它的名字一样简单粗暴：获取<strong>对象</strong>唯一的<strong>标识符</strong>。</p></blockquote><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>首先我们先讲讲什么叫做标识符：可以把它理解成身份证号，一个对象<strong>有且仅有</strong>一个的编号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">id(a) <span class="comment"># 140709554144928</span></span><br></pre></td></tr></table></figure><blockquote><p>不同的电脑和不同版本的Python解释器可能会返回不同的<code>id()</code>结果</p></blockquote><p>接下来就是本文的重点了，什么是对象？</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>这是一个现代编程领域及其复杂的概念，想要通过简单的几句话说清楚并不太现实。但是我们可以抓住主要矛盾进行剖析：<strong>对象的定义在不同的语言中是不同的</strong>。有了这个基本共识之后，我们就可以开始认识Python的对象了。</p><p><strong>Python是一门可以问心无愧地说“一切都是对象”的语言。<del>（至少相比于Java是这样）</del></strong></p><blockquote><p>在Python中，小到<code>int</code>都是一个对象。<del>（Java你倒是看看啊）</del></p></blockquote><p>因此，在Python里，我们可以把<strong>变量</strong>理解成一个我们可以随便取名字的<strong>对象索引</strong>。</p><blockquote><ul><li>刚才就提到了，对象在不同语言里的定义是不同的，因此变量的定义<strong>也是不同的</strong>。</li><li>这仅仅是一个笔者认为简单的理解，不一定严密，如果有不同意见欢迎分享。</li></ul></blockquote><p>那么，什么叫做索引呢？</p><p>我们在生活中看见过书籍索引、楼层索引等等。说白了，它们的作用就是书/房子这个大容器的<strong>路牌</strong>。</p><p>在Python中，变量就是对象的路牌，帮助我们找到对象的具体位置。因此，我们把变量作为参数传递给<code>id()</code>函数后，就可以得到这个变量所对应的对象的身份证号了呢！是不是好神奇~</p><p>说了这么久，请问我们为什么要找对象呢？</p><p><strong>因为对象里存着我们需要的信息啊！</strong></p><p>忙活半天不就是为了处理数据嘛？勿忘初心哦~</p><p>如果看到这里有一点晕，可以把对象这一小节反复读一读，相信聪明的你一定能够理解我想要表达的意思。</p><h3 id="变or不变"><a href="#变or不变" class="headerlink" title="变or不变"></a>变or不变</h3><p>有了前面的铺垫，我们终于可以开始讲什么是可变与不可变了，我们先分析下面的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">l[<span class="number">0</span>] = <span class="number">3</span> <span class="comment"># l: [3, 2, 3]</span></span><br><span class="line">t[<span class="number">0</span>] = <span class="number">3</span> <span class="comment"># Error!</span></span><br></pre></td></tr></table></figure><p>为什么不能进行<code>t[0]</code>的赋值操作呢？相信了解元组最基本特性的您一定知道：<strong>元组不可变！</strong>这是正解没错，那么我们来看看下面的例子呢：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">t[<span class="number">2</span>].append(<span class="number">4</span>) <span class="comment"># t: (1, 2, [1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure><p>咦？为啥这里元组被修改了？难道元组可变了？</p><p>其实背后的原理就在我们之前讲到的<strong>对象</strong>中：Python的可变和不可变都是针对<strong>对象</strong>而言的，而<strong>不是变量</strong>。</p><p>在第一个例子中，<code>t[0]</code>变量是一个<code>int</code>对象的索引。因为<code>int</code>是不可变的，所以我们如果要改变<code>t[0]</code>，就必须为它<strong>换一个对象</strong>。而这里的换对象，就是改变这个路牌的指向，让它指向另外一个地方。</p><p>刚才我们讲到<code>id()</code>可以获得对象的身份证号，那么我们就来做这样一个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">id(a) <span class="comment"># 140709554144928</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">id(a) <span class="comment"># 140709554144960</span></span><br></pre></td></tr></table></figure><blockquote><p>这说明，<code>a</code>这个路牌的箭头确实被改了，对<code>a</code>值得修改<strong>并没有</strong>在原来存储1的内存位置上发生。</p></blockquote><p>综上，此时我们对元组中的<code>t[0]</code>变量进行修改，就得改变<code>id(t[0])</code>，这触犯了<strong>元组不可变</strong>的特性，因此是不被允许的。</p><p>那么我们现在来看第二个例子：为啥元组又被修改了呢？</p><p>看看<code>t[2]</code>对应的是啥？是<code>[1, 2, 3]</code>这个列表(list)！</p><p>列表是什么类型？可变类型！</p><p>不可变类型<strong>不允许</strong>对象的<code>id</code>发生变化，那么可变类型自然就……<strong>允许</strong>呢！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">2</span>].append(<span class="number">4</span>) <span class="comment"># t: (1, 2, [1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure><p>这一条语句可以被拆成以下的行为：</p><ul><li>获取元组<code>t</code>中的第三个元素<code>t[2]</code>，发现是个可变的列表。</li><li>列表类型的尾部增加元素操作<code>append</code></li></ul><p>这两步中涉及到的变量和对象有：</p><ul><li>变量：指向列表的<code>t[2]</code></li><li>对象：<code>[1, 2, 3]</code>这个<strong>列表</strong>，我们给他起个名字叫<code>a</code>好了。</li></ul><p><code>a</code>列表是可变的，<code>a[0]</code>/<code>a[1]</code>这些都是<strong>变量</strong>，所以我们可以使用<code>append</code>为它增加一个<code>a[3]</code><strong>变量</strong>，并且让它指向数字<code>4</code>这个<strong>对象</strong>。</p><p>因为<code>a</code>是可变的，所以我们对它的修改不需要“另觅新欢”，<strong>只需要在原来的内存位置进行就好了</strong>。</p><p>所以，<code>t[2]</code>这个变量对应对象的<code>id</code>在过程中发生过变化吗？没有！也就是说<code>id(t[2])</code>在增加元素的前后没有变化。以下是控制台的运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">id(t[<span class="number">2</span>]) <span class="comment"># 1590806815744</span></span><br><span class="line">t[<span class="number">2</span>].append(<span class="number">4</span>) <span class="comment"># t: (1, 2, [1, 2, 3, 4])</span></span><br><span class="line">id(t[<span class="number">2</span>]) <span class="comment"># 1590806815744</span></span><br></pre></td></tr></table></figure><p>只要<code>id(t[2])</code>没有发生变化，那么元组的不可改变特性<strong>就没有</strong>被破坏，自然就可以这么操作啊！</p><p>但是这是个好现象吗，显然不是的，因此我们要避免在不可变类型中塞进可变的对象，这里使用这个例子只是为了强调Python中变量和对象的关系。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>Python中，一切都是对象。<del>（是真的一切！）</del></li><li>用对象来理解变量，才能更清楚地知道自己使用的变量究竟是什么。</li><li>可变和不可变不要记概念，判断对象的<code>id</code>是否改变最准确。</li><li>希望小仙女看懂了。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Fluent Python, Luciano Ramalho.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;全文共&lt;code&gt;2007&lt;/code&gt;字，推荐阅读时间&lt;code&gt;10~15&lt;/code&gt;分钟。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04 no wifi adapter found 解决方案</title>
    <link href="http://yoursite.com/2021/06/23/Ubuntu18.04%20no%20wifi%20adapter%20found%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2021/06/23/Ubuntu18.04%20no%20wifi%20adapter%20found%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-06-23T12:45:04.907Z</published>
    <updated>2021-06-23T12:45:34.737Z</updated>
    
    <content type="html"><![CDATA[<p><strong>重要的事说在前面</strong></p><p><strong>很重要！很重要！很重要！</strong></p><p><strong>以下教程仅适用于<u>intel</u>系列无线网卡,至于其他例如broadcom等，只能提供一个参考思路。</strong></p><a id="more"></a><hr><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>terminal中输入<code>lspci</code>,得到类似如下结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ lspci</span><br><span class="line">00:14.3<span class="built_in"> Network </span>controller: Intel Corporation Device 02f0</span><br><span class="line">00:15.0 Serial bus controller [0c80]: Intel Corporation Device 02e8</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>其中Network controller本不应该对应笔记本的无线网卡，但是ubuntu系统和intel系列网卡兼容性一言难尽，导致系统误把网卡作为了controller。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li><p><strong>升级系统内核(optional)</strong></p><p>具体可以参见这篇<a href="https://www.jianshu.com/p/0c2e7a530cfe" target="_blank" rel="noopener">博客</a>，写的很好。</p><p>虽然这一步是选择性的，但还是建议内核版本5.3以下的朋友升级到最新版本，<del>少点bug不吃亏</del>。</p><p><strong>还有，intel官网上写的驱动的kernel版本要求似乎有点问题，笔者5.0.0内核版本亲测：必须要升级到5.3+后才能识别<u>“写着4.14+以上均适用”</u>网卡驱动。</strong></p><p>总而言之，建议大家尽量还是选择升级内核版本。</p></li><li><p><strong>安装网卡驱动</strong></p><ul><li><p>首先是确认网卡型号</p><p>建议在windows下按照这篇<a href="https://blog.csdn.net/myuhua/article/details/99446855" target="_blank" rel="noopener">博客</a>进行操作</p></li><li><p>登陆intel<a href="https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi" target="_blank" rel="noopener">驱动官网</a>:<a href="https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi!" target="_blank" rel="noopener">https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi!</a></p></li><li><p>查找到对应的型号后下载.tgz文件</p></li><li><p>解压文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span>  <span class="selector-tag">-zxvf</span>  下载的驱动的名字<span class="selector-class">.tgz</span></span><br></pre></td></tr></table></figure></li><li><p>安装驱动</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp iwlwifi-*.ucode /<span class="class"><span class="keyword">lib</span>/<span class="title">firmware</span></span></span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo reboot</span></span><br></pre></td></tr></table></figure></li><li><p>和wifi愉快拥抱吧～</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;重要的事说在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很重要！很重要！很重要！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下教程仅适用于&lt;u&gt;intel&lt;/u&gt;系列无线网卡,至于其他例如broadcom等，只能提供一个参考思路。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/MySQL%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/MySQL%20Learning%20Note/</id>
    <published>2021-06-23T12:43:39.116Z</published>
    <updated>2021-06-23T12:44:21.704Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of database operation technology MySQL.</strong></p><a id="more"></a><h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><p>全文共<code>348</code>字，推荐阅读时间<code>3~5</code>分钟。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>应用程序<strong>不需要</strong>自己管理数据，而是通过数据库软件提供的<strong>接口</strong>来读写数据。</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><ul><li>树形结构</li></ul><p><img src="https://i.loli.net/2020/07/01/wScTtsDdWhjIzL4.png" alt="XR@5HT3{ZYUZH}~HSF~HTWE" style="zoom:50%;" /></p><h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><ul><li>图结构</li></ul><p><img src="https://i.loli.net/2020/07/01/lK8DtykOrIJS5eA.png" alt="two" style="zoom:50%;" /></p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><ul><li>二维表格</li><li>通过行号和列号定位</li><li><strong>占数据库的主导地位</strong></li></ul><p><img src="https://i.loli.net/2020/07/01/ricl1Rg87oAECqd.png" alt="three" style="zoom:50%;" /></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>关系表中，除了每一列的名称，还需要定义每一列的<strong>数据类型</strong>。</li></ul><div class="table-container"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>INT</td><td>整型</td><td>4字节</td></tr><tr><td>BIGINT</td><td>长整型</td><td>8字节</td></tr><tr><td>REAL</td><td>浮点型</td><td>4字节</td></tr><tr><td>DOUBLE</td><td>浮点型</td><td>8字节</td></tr><tr><td>DECIMAL(M,N)</td><td>高精度小数</td><td>M表示数字总共多少位，N表示小数有多少位，常用于财务计算。</td></tr><tr><td>CHAR(N)</td><td>定长字符串</td><td>N表示字符串长度</td></tr><tr><td>VARCHAR(N)</td><td>变长字符串</td><td>N表示长度上限</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td><td>True/False</td></tr><tr><td>DATE</td><td>日期类型</td><td>2020-07-01</td></tr><tr><td>TIME</td><td>时间类型</td><td>12:20:25</td></tr><tr><td>DATETIME</td><td>日期和时间类型</td><td>2020-07-01 12:20:25</td></tr></tbody></table></div><blockquote><p><code>BIGINT</code>和<code>VARCHAR</code>是使用<strong>最广泛</strong>的两种类型</p></blockquote><h4 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h4><p>SQL关键字<strong>不区分</strong>大小写，但是规范如下：</p><ul><li>关键字统一使用<strong>大写</strong></li><li>表名和列名统一使用<strong>小写</strong></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="关系模型-1"><a href="#关系模型-1" class="headerlink" title="关系模型"></a>关系模型</h1><p>全文共<code>1315</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>关系数据库是建立在关系模型上的</li><li>关系模型本质上就是<strong>若干个</strong>存储数据的<strong>二维表</strong>（看作很多Excel表）</li><li>表的<strong>每一行</strong>称为<strong>记录</strong>(Record)，记录是一个<strong>逻辑意义</strong>上的数据。</li><li>表的<strong>每一列</strong>称为<strong>字段</strong>(Column)，同一个表的<strong>每一行</strong>记录都拥有<strong>相同类型</strong>的若干<strong>字段（列）</strong>。<ul><li>字段定义数据类型</li><li>字段定义数据是否可以为<code>NULL</code>，<code>NULL</code>表示数据<strong>不存在</strong>，<strong>不是</strong>0/空串。</li></ul></li></ul><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul><li>记录需要一个<strong>唯一</strong>的标识来进行区分</li><li>所有的记录的<strong>主键</strong>一定是不同的</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>主键是一个<strong>字段</strong></li><li>主键是用来区分记录的，各个记录的主键字段值<strong>不能相同</strong>。</li></ul><blockquote><p>主键在建立起字段后最后<strong>不要</strong>再进行修改</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>不能用业务相关的字段作为主键</p><blockquote><p>业务相关：变更不可控，例如身份证号的位数可能会发生<strong>变更</strong>。</p></blockquote></li><li><p>不应该允许NULL</p></li><li><p>主键常命名为id</p><ul><li><p>自增整数类型(<code>BIGINT NOT_NULL AUTO_INCREMENT</code>)</p><p>数据库会在插入数据时<strong>自动</strong>为每一条记录分配一个自增整数</p></li><li><p>全局唯一GUID类型</p><p>使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。</p></li></ul></li></ul><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><ul><li>关系数据库实际上还允许通过<strong>多个字段唯一标识记录</strong>，即<strong>两个或更多的字段</strong>都设置为主键，这种主键被称为联合主键。</li></ul><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li><p>在表1中增加表2的主键id，命名为<code>table2_id</code>，即可在<strong>表一</strong>中查找到记录在<strong>表二</strong>中相关字段的索引。</p><blockquote><p>通常用来实现实现<strong>一对多</strong>关系：例如一个班级（<strong>表2</strong>）对应多个学生（<strong>表1</strong>）。</p></blockquote></li></ul><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><ul><li><p><strong>正规外键</strong>不是通过新增字段实现的，而是通过定义外键约束实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><ul><li><code>fk_class_id</code>：外键约束的名称，可以任意。</li><li><code>FOREIGN KEY (class_id)</code>：指定<code>class_id</code>是<strong>外键</strong></li><li><code>REFERENCES classes (id)</code>：指定将<code>class_id</code>这个外键关联到<code>classes</code>的<code>id</code><strong>主键</strong>上</li></ul></li><li><p>通过定义外键约束，关系数据库可以保证<strong>无法插入</strong>无效的数据。即如果<code>classes</code>表<strong>不存在</strong><code>id=99</code>的记录，<code>students</code>表就<strong>无法</strong>插入<code>class_id=99</code>的记录。</p></li><li><p>由于外键约束会<strong>降低</strong>数据库的性能，可以采用变种外键，即<code>class_id</code>仅仅是一个<strong>普通的列</strong>，只是它<strong>起到了</strong>外键的作用而已。</p></li><li><p>删除外键约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><blockquote><p>删除外键约束<strong>并没有</strong>删除外键这一列。<strong>删除列</strong>是通过<code>DROP COLUMN ...</code>实现的。</p></blockquote></li></ul><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><ul><li><p>通过两个一对多关系实现</p><ul><li><p>通过一张中间表，关联两个一对多关系。</p><p>| id   | teacher_id | class_id |<br>| —— | ————— | ———— |<br>| 1    | 1          | 1        |<br>| 2    | 1          | 2        |<br>| 3    | 2          | 1        |<br>| 4    | 3          | 1        |</p></li></ul></li></ul><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><ul><li>一个表的记录对应到另一个表的<strong>唯一一个</strong>记录</li></ul><blockquote><p>一对一表理论上可以合并为一个表，但是一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得<strong>更高的性能</strong>。</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>为了在大数据库中取得较高的查找速度提出的方法</li><li>索引是关系数据库中对<strong>某一列</strong>或<strong>多个列</strong>的<strong>值</strong>进行<strong>预排序</strong>的数据结构（本质是为了缩小查找的范围）</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>情景：经常根据列表的<code>score</code>字段进行查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>索引名称是任意的，索引如果有多列，可以在括号里依次写上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果记录的列存在大量<strong>相同</strong>的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，此时对该列创建索引就<strong>没有意义</strong>。</li><li>索引越<strong>多</strong>，插入、更新和删除记录的速度就越<strong>慢</strong>。</li><li>对于<strong>主键</strong>，关系数据库会<strong>自动</strong>对其创建主键索引。使用主键索引的效率是<strong>最高</strong>的，因为主键会保证绝对唯一。</li></ul></blockquote><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul><li><p>当记录的该字段不会发生重复时，就可以为该列增加唯一索引。</p><p>例如不重名时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD UNIQUE INDEX uni_name (name);</span><br></pre></td></tr></table></figure></li><li><p>唯一索引<strong>不是</strong>主键，例如身份证号，就算位数变化，也不影响唯一性，但是会影响主键的查找。</p></li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会<strong>自动使用索引</strong>来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中<strong>逐步优化</strong>。</p><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><p>全文共<code>1349</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;table_name&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>SELECT</code>：表示要执行一个查询</li><li><code>*</code>：表示所有<strong>列</strong></li><li><code>FROM</code>：表示将要从哪个表查询、</li></ul><blockquote><ul><li><code>SELECT 1;</code>常用来测试数据库连接</li><li>查询结果是一个<strong>二维表</strong></li></ul></blockquote><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><ul><li><p><code>WHERE</code>引出条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE score &gt;&#x3D; 80;</span><br></pre></td></tr></table></figure></li><li><p><code>AND</code>/<code>OR</code>/<code>NOT</code>进行逻辑运算</p></li><li><p><code>=</code>（<strong>一个</strong>等号）表示相等判断</p></li><li><p><code>&lt;&gt;</code>表示<strong>不等</strong>判断（等价于<code>NOT xxx = xxx;</code>）</p></li><li><p><code>()</code>进行条件分组</p></li></ul><h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><ul><li><p><code>BETWEEN...AND...</code>（<strong>闭</strong>区间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WHERE score &gt;&#x3D; 60 AND score &lt;&#x3D;90;</span><br><span class="line">WHERE score BETWEEN 60 AND 90;</span><br></pre></td></tr></table></figure></li><li><p><code>LIKE</code>判断相似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name LIKE &#39;ab%&#39;</span><br></pre></td></tr></table></figure><ul><li><code>%</code>表示<strong>任意字符</strong>，可以为<strong>空</strong>字符。</li></ul></li></ul><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>只查询<strong>某些列</strong>的操作被称为<strong>投影查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score, name FROM students;</span><br></pre></td></tr></table></figure><ul><li><p>为列增加别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score points, name FROM students;</span><br></pre></td></tr></table></figure><blockquote><p><code>SELECT row1, row2 name2, row3 FROM ...</code></p></blockquote></li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li><p>数据库的查询结果默认按照<code>id</code>（主键）排序</p></li><li><p>使用<code>ORDER BY</code>子句将记录根据字段值<strong>从低到高</strong>进行排序（默认升序<code>ASC</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score;</span><br></pre></td></tr></table></figure><blockquote><p>增加<code>DESC</code>表示<strong>倒序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>多要素排序：将要素依次列出，逗号分隔即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</span><br></pre></td></tr></table></figure></li><li><p>多行查询语句（关键词换行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id &#x3D; 1</span><br><span class="line">ORDER BY score DESC;</span><br></pre></td></tr></table></figure></li><li><p><code>ORDER BY</code>放在查询语句的<strong>最后</strong></p></li></ul><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>当查询结果量很大时，进行分页显示。</p><ul><li><p>实质上就是从结果中<strong>截取</strong>一部分进行显示，进行多次查询即可得知所有结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure><ul><li><code>LIMIT M OFFSET N</code>：从<code>N</code>开始的<strong>最多</strong><code>M</code>条记录（少于<code>M</code>条也不会报错）</li><li>可以简写为<code>LIMIT M, N</code></li><li><code>LIMIT M</code>默认<code>N</code>为0</li></ul></li></ul><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>对于总数、平均数的计算，SQL内置了聚合函数，使用聚合函数进行查询就叫聚合查询。</p><ul><li><p>查询表中<strong>记录</strong>总数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM students;</span><br></pre></td></tr></table></figure><blockquote><p>为返回的表设置别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students;</span><br><span class="line"></span><br><span class="line">&#x2F;* output</span><br><span class="line">    +-----+</span><br><span class="line">    | num |</span><br><span class="line">    +-----+</span><br><span class="line">    |  10 |</span><br><span class="line">    +-----+</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>查询特定记录总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(id) boys FROM students WHERE gender &#x3D; &#39;M&#39;;</span><br></pre></td></tr></table></figure><ul><li><code>COUNT(*)</code>和<code>COUNT(id)</code>等价</li><li>没有匹配到行返回<code>0</code></li></ul></li></ul><h3 id="其他聚合函数"><a href="#其他聚合函数" class="headerlink" title="其他聚合函数"></a>其他聚合函数</h3><ul><li><p><code>SUM</code>：计算某一列的和</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul></li><li><p><code>AVG</code>：计算某一列的平均值</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(score) average FROM students WHERE gender &#x3D; &#39;M&#39;;</span><br></pre></td></tr></table></figure></li><li><p><code>MAX</code>：计算某一列的最大值</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul></li><li><p><code>MIN</code>：计算某一列的最小值</p><ul><li>没有匹配到行返回<code>NULL</code></li></ul></li></ul><blockquote><p>后两个<strong>不限于</strong>数值类型</p></blockquote><ul><li><p><code>FLOOR</code>：向下取整函数</p></li><li><p><code>CEILING</code>：向上取整函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CEILING(COUNT(*) &#x2F; 3) FROM students;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li><p>根据字段值自动分组计数（不用多次查询）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><ul><li><p>为了区分输出的结果是哪个班的，可以多<code>SELECT</code>一个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><ul><li>注意只能<code>SELECT</code>用于分组的字段，加入其他字段可能会出现<strong>一个框内多个值</strong>的情况，MySQL会报错。</li></ul></li></ul></li><li><p>多字段分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, gender, COUNT(*) num </span><br><span class="line">FROM students </span><br><span class="line">GROUP BY class_id, gender;</span><br></pre></td></tr></table></figure></li><li><p>查询各个班级的平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, AVG(score) avg</span><br><span class="line">FROM students</span><br><span class="line">GROUP BY class_id;</span><br></pre></td></tr></table></figure></li><li><p>查出各个班级男生和女生的平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, gender, AVG(score) avg</span><br><span class="line">FROM students</span><br><span class="line">GROUP BY class_id, gender;</span><br><span class="line">-- ORDER BY gender;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>查询两个表的乘积，又称笛卡尔查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students, classes;</span><br></pre></td></tr></table></figure><ul><li><p>将两张表的行逐一进行枚举组合后拼在一起返回</p></li><li><p>结果集<strong>列数</strong>是两张表<strong>列数之和</strong></p></li><li><p>结果集<strong>行数</strong>是两张表<strong>行数之积</strong></p></li><li><p>查询时为了区分列，可以设置别名。（注意字段名的访问方式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">students.id sid,</span><br><span class="line">students.name,</span><br><span class="line">students.gender,</span><br><span class="line">students.score,</span><br><span class="line">classes.id cid,</span><br><span class="line">classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure><p>当表名过长时，可以选择给<strong>表</strong>再起一个别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">s.id sid,</span><br><span class="line">s.name,</span><br><span class="line">s.gender,</span><br><span class="line">s.score,</span><br><span class="line">c.id cid,</span><br><span class="line">c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure></li></ul><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>对多个表进行<code>JOIN</code>运算：先确定一个主表，然后从其他表中选择性地提取一些行加入到结果集中。</p><ul><li><p>查询学生信息的同时需要知道班级id对应的班级名</p><ul><li><p>内连接</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">ON s.class_id &#x3D; c.id;</span><br></pre></td></tr></table></figure><ul><li>确认主表(students)</li><li>确认连接表(classes)</li><li>确认连接条件(<code>ON</code>)：当条件满足时把主表和连接表的<strong>对应行</strong>连接起来</li><li>可以加上查询语句等辅助功能</li></ul></li><li><p>外连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id &#x3D; c.id;</span><br></pre></td></tr></table></figure><blockquote><p>相比于内连接会多出一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idnameclass_idclass_namegenderscore</span><br><span class="line">NULLNULLNULL四班   NULL    NULL</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>RIGHT OUTER JOIN</code>：返回<strong>右表</strong>（连接表）中存在的行（左表不存在无所谓）</li><li><code>LEFT OUTER JOIN</code>：返回<strong>左表</strong>（主表）中存在的行（右表不存在无所谓）</li><li><code>FULL OUTER JOIN</code>：两边表只要有一个存在就返回（<code>RIGHT</code>和<code>LEFT</code>的并集）</li><li><code>INNER JOIN</code>：返回两张表<strong>都存在</strong>的记录</li></ul></li></ul></li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><p>全文共<code>298</code>字，推荐阅读时间<code>3~5</code>分钟。</p><ul><li>关系数据库的基本操作：增删查改（CRUD）<ul><li>C：Create</li><li>R：Retrieve</li><li>U：Update</li><li>D：Delete</li></ul></li></ul><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><ul><li><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;xxx&#39;, &#39;M&#39;, 80);</span><br></pre></td></tr></table></figure><ul><li><p><strong>不需要</strong>列出<code>id</code>字段，这是一个由MySQL自己维护的自增字段。</p></li><li><p>语句中的字段顺序和表格中<strong>可以</strong>不一样，但是对应的值一定要按照<strong>语句中</strong>的顺序。</p></li><li><p>一次性添加多个记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">(1, &#39;A&#39;, &#39;M&#39;, 97),</span><br><span class="line">(2, &#39;B&#39;, &#39;M&#39;, 81);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><ul><li><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- UPDATE &lt;表名&gt; SET 字段1&#x3D;值1, 字段2&#x3D;值2, ... WHERE ...;</span><br><span class="line">UPDATE students SET name &#x3D; &#39;new_xxx&#39;, score&#x3D;66 WHERE id&#x3D;1;</span><br></pre></td></tr></table></figure><ul><li><p><code>WHERE</code>行为与<code>SELECT</code>中一致</p></li><li><p>更新多条记录（更改<code>WHERE</code>的判断条件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students SET name&#x3D;&#39;new_x&#39;, score&#x3D;77 WHERE id&gt;&#x3D;5 AND id&lt;&#x3D;7;</span><br></pre></td></tr></table></figure><ul><li>当没有匹配到记录时，<strong>不会</strong>报错。</li></ul></li><li><p>更新整个表（省略<code>WHERE</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students SET score&#x3D;60;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><ul><li><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- DELETE FROM &lt;表名&gt; WHERE ...;</span><br><span class="line">DELETE FROM students WHERE id&#x3D;1;</span><br></pre></td></tr></table></figure><ul><li><p><code>id=2</code>的记录<code>id</code><strong>不会</strong>变化</p></li><li><p>删除整个表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM students;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="MySQL操作"><a href="#MySQL操作" class="headerlink" title="MySQL操作"></a>MySQL操作</h1><p>全文共<code>664</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li><p><code>MySQL Client</code>是一个<strong>命令行</strong>客户端，对应的可执行程序是mysql.</p></li><li><p><code>MySQL Server</code>是真正的MySQL<strong>服务器</strong>，对应的可执行程序是mysqld.</p></li><li><p>Client通过TCP连接发送到Server，默认端口是3306，如果发送到本机的服务器，地址为<code>127.0.0.1:3306</code>.</p></li><li><p>连接到远程Server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h IP_addr_of_distant_server -u root -p</span><br></pre></td></tr></table></figure></li></ul><h2 id="管理MySQL"><a href="#管理MySQL" class="headerlink" title="管理MySQL"></a>管理MySQL</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>显示：<code>SHOW DATABASES;</code><ul><li><code>information_schema</code>/<code>mysql</code>/<code>performance_schema</code>/<code>sys</code>是系统库，不能改动，</li></ul></li><li>创建：<code>CREATE DATABASE test;</code></li><li>删除：<code>DROP DATABASE test;</code></li><li>切换：<code>USE test;</code></li></ul><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul><li><p>创建：<code>CREATE TABLE students(...);</code></p><ul><li>至少有一列，并且需要使用<code>PRIMARY KEY (xxx)</code>指定为主键列。</li></ul></li><li><p>删除：<code>DROP TABLE students;</code></p></li><li><p>显示：<code>SHOW TABLES;</code></p></li><li><p>查看结构：<code>DESC students;</code>/<code>SHOW CREATE TABLE students;</code></p></li><li><p>修改</p><ul><li><p>新增列<code>birth</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure></li><li><p>修改列名为<code>birthday</code>，并修改数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><ul><li><code>VARCHAR(xx) NOT NULL</code>：数据类型以及约束<strong>不能</strong>被省略</li></ul></li><li><p>删除列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="实用语句"><a href="#实用语句" class="headerlink" title="实用语句"></a>实用语句</h2><h3 id="插入或替换"><a href="#插入或替换" class="headerlink" title="插入或替换"></a>插入或替换</h3><p>插入记录时，<strong>如果</strong>需要对重复元素进行替换，直接使用<code>REPLACE</code>语句可以省略手动查询的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;C&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><ul><li>当<code>id=1</code>的记录不存在时会直接插入，如果存在则会删除后再插入。</li></ul><h3 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h3><p>插入记录时，<strong>如果</strong>记录已经存在，则对记录进行<strong>选择性</strong>更新，否则直接插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99) ON DUPLICATE KEY UPDATE name&#x3D;&#39;小明&#39;, gender&#x3D;&#39;F&#39;, score&#x3D;99;</span><br></pre></td></tr></table></figure><h3 id="插入或忽略"><a href="#插入或忽略" class="headerlink" title="插入或忽略"></a>插入或忽略</h3><p>插入记录时，<strong>如果</strong>记录已经存在，则不进行任何操作，否则直接插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>进行数据复制并创建新表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id&#x3D;1;</span><br></pre></td></tr></table></figure><ul><li>新表的结构和原表<strong>一致</strong></li></ul><h3 id="写入查询结果集"><a href="#写入查询结果集" class="headerlink" title="写入查询结果集"></a>写入查询结果集</h3><p>建立成绩统计表</p><ul><li><p>创建存储结果集的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE statistics (</span><br><span class="line">id BIGINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    class_id BIGINT NOT NULL,</span><br><span class="line">    average DOUBLE NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>写入各班平均成绩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(acore) FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure></li></ul><h3 id="强制使用指定索引"><a href="#强制使用指定索引" class="headerlink" title="强制使用指定索引"></a>强制使用指定索引</h3><p>解决数据库查询的索引<strong>不是</strong>最优解的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id&#x3D;1 ORDER BY id DESC;</span><br></pre></td></tr></table></figure><ul><li><code>idx_class_id</code>必须存在<strong>才能够</strong>使用强制索引</li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of database operation technology MySQL.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Backend" scheme="http://yoursite.com/categories/Backend/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB Course Note</title>
    <link href="http://yoursite.com/2021/06/23/MATLAB%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/MATLAB%20Course%20Note/</id>
    <published>2021-06-23T12:42:44.702Z</published>
    <updated>2021-06-23T12:43:13.208Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2020 BUAA MATLAB course.</strong></p><a id="more"></a><h1 id="Chapter0-概论"><a href="#Chapter0-概论" class="headerlink" title="Chapter0 概论"></a>Chapter0 概论</h1><p>全文<code>135</code>字，推荐阅读时间<code>3~5</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>MATLAB<strong>最初</strong>强调矩阵的运算</li></ul><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><ul><li><p><code>.m</code>：M文件</p><ul><li>命令文件：主程序/主函数</li><li>函数文件：子程序/被调函数</li></ul><blockquote><p>工具箱中所有的文件基本上是<strong>函数文件</strong></p></blockquote></li><li><p><code>.mat</code>：数据文件，保存了workspace中的变量数据</p></li><li><p><code>.fig</code>：图形文件，依然<strong>可以</strong>被修改。</p></li><li><p><code>.mex</code>/<code>.dll</code>：MATLAB的可执行文件</p></li><li><p><code>.mdl</code>：模型和仿真文件</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter1-数据类型"><a href="#Chapter1-数据类型" class="headerlink" title="Chapter1 数据类型"></a>Chapter1 数据类型</h1><p>全文共<code>1782</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li>每一种类型都以<strong>数组</strong>为基础</li><li>默认类型为<code>double</code>，可以利用转化函数改变类型。</li><li><strong>不用</strong>事先对变量的类型进行定义或说明</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>预定义的特殊变量</p><ul><li><code>ans</code>：<strong>未赋值运算</strong>结果自动赋值给<code>ans</code></li><li><code>eps</code>：容差变量，小于该值时可认为是0.</li><li><code>pi</code></li><li><code>i,j</code>：二者等价，虚数单位。</li><li><code>inf</code>：正无穷大，0作<strong>除数</strong>时出现。</li><li><code>NaN</code>：不合法数值，在$0*∞,0/0$等运算时产生。</li><li><code>version</code></li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li><code>clear name1 name2 name3;</code>：清除用户自定义的变量<ul><li><code>clear all;</code>：清除所有变量</li></ul></li><li>特殊常量的值可以在当前程序中被<strong>临时改变</strong></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>MATLAB中所有变量都以<strong>数组或矩阵</strong>形式保存</li></ul><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul><li>和C一致</li><li>对大小写敏感</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>变量查询<ul><li><code>who</code>：列出所有的变量名</li><li><code>whos</code>：给出所有变量及其大小、类别等性质。</li></ul></li><li><code>clear</code>：删除<strong>自定义</strong>变量，并重置<strong>除<code>eps</code>之外</strong>的常量。<ul><li><code>clear a*</code>：删除所有以<code>a</code>开头的变量</li></ul></li><li><code>pack</code>：重组和压缩已分配的内存碎块，在不影响变量的情况下腾出空间。<ul><li><code>pack filename</code>：自定义中间<code>mat</code>文件名（之后会被自动删掉）</li></ul></li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li><p>局部变量：函数内部定义的变量</p></li><li><p>全局变量：函数之间共享的变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> MAXLEN;MAXLEN=<span class="number">45</span>;</span><br></pre></td></tr></table></figure></li><li><p>永久变量：类似于<code>static</code>，在M文件中定义和使用，只在<code>clear</code>时被清除。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">persistent</span> MAXLEN; MAXLEN=<span class="number">45</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><ul><li><p>整型：带符号&amp;无符号</p></li><li><p>浮点型：单精度(single)&amp;双精度(double)</p><blockquote><p>单精度<strong>不是</strong><code>float</code></p></blockquote></li><li><p>比较</p><ul><li><code>~=</code></li><li><code>==</code></li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x1 = int8(<span class="number">11</span>); <span class="comment">% 11</span></span><br><span class="line">x2 = int8(<span class="number">15.49</span>); <span class="comment">% 15</span></span><br><span class="line">x3 = int8(<span class="number">15.5</span>); <span class="comment">% 16</span></span><br><span class="line">x4 = int8(<span class="number">130</span>); <span class="comment">% 127</span></span><br><span class="line">x5 = uint8(<span class="number">-1</span>); <span class="comment">% 0</span></span><br></pre></td></tr></table></figure><ul><li><p>浮点型转换为整型是<strong>四舍五入</strong></p></li><li><p>超过类型边界<strong>则取边界值</strong></p></li><li><p><code>intmax</code>/<code>intmin</code>：查询整型边界</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intmax(<span class="string">'int8'</span>); <span class="comment">% 127</span></span><br></pre></td></tr></table></figure><blockquote><p>类型传入需要<strong>引号</strong></p></blockquote></li><li><p><code>realmax</code>/<code>realmin</code>：查询浮点型边界</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">realmax</span>(<span class="string">'single'</span>);</span><br></pre></td></tr></table></figure></li><li><p>数值默认为双精度浮点数，需要手动转换为<code>single</code>或其它类型.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">35</span>;</span><br><span class="line">y = single(X);</span><br><span class="line">class(x) <span class="comment">% double</span></span><br><span class="line">class(y) <span class="comment">% single</span></span><br></pre></td></tr></table></figure><ul><li><code>;</code>：变量后加<code>;</code>限制变量输出，不会打印到控制台，和C作用不同。</li></ul></li></ul><h4 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h4><ul><li><code>round(x)</code>：四舍五入（负数可能<strong>向下</strong>五入）</li><li><code>fix(x)</code>：向0取整</li><li><code>floor(x)</code>：向<strong>下</strong>取整</li><li><code>ceil(x)</code>：向<strong>上</strong>取整</li></ul><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul><li><p>创建</p><ul><li><p>直接输入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span><span class="number">-3</span><span class="built_in">i</span> <span class="comment">% ans = 2.0000-3.0000i</span></span><br></pre></td></tr></table></figure><blockquote><p><code>format</code>默认设置小数点后保留4位，当数字大于1000时，使用科学计数法。</p></blockquote></li><li><p><code>complex(a, b)</code>：a是实部，b是虚部，且b不指定时默认为0.</p></li></ul></li></ul><h3 id="逻辑型变量"><a href="#逻辑型变量" class="headerlink" title="逻辑型变量"></a>逻辑型变量</h3><ul><li><p><code>true</code>对应1，<code>false</code>对应0.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>] &gt; <span class="number">5</span> <span class="comment">% y = [1, 0, 1]</span></span><br></pre></td></tr></table></figure></li><li><p><code>logical</code>：数值转换为逻辑型</p></li><li><p><code>any</code>/<code>all</code>：矩阵传入一维真值矩阵</p></li><li><p><code>is*(isspace)</code>：测试运算</p></li><li><p>逻辑数组：利用逻辑运算构造矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">rand</span>(<span class="number">3</span>), A(A&lt;<span class="number">0.5</span>)=<span class="number">0</span> <span class="comment">% assign val &lt; 0.5 positions to zero</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h3><ul><li>数组的运算都是<strong>点运算</strong>（逐个元素运算）</li><li>矩阵的乘法、乘方、除法有特殊含义，其他和数组没有区别。</li><li><strong>MATLAB的下标从1开始</strong></li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><p>直接构造法</p><ul><li><code>[]</code></li><li><code>,</code>：间隔<strong>行内</strong>元素，或者使用空格。</li><li><code>;</code>：间隔<strong>行间</strong>元素，或者使用回车。</li><li>元素可以为值/表达式</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">3.8</span>, <span class="number">1e-3</span>, <span class="built_in">sqrt</span>(<span class="number">2</span>)]</span><br><span class="line">b = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>增量法</p><ul><li><p>利用冒号生成向量（包括<strong>右端点</strong>）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">i</span>:<span class="built_in">j</span> <span class="comment">% [i,j] as an array(including j)</span></span><br><span class="line">x = <span class="built_in">i</span>:<span class="built_in">j</span>:k <span class="comment">% j is stride</span></span><br></pre></td></tr></table></figure></li><li><p><code>linspace(a,b)</code>：生成等差向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>) <span class="comment">% from 2 to 8 with 10 numbers(default to 100 numbers)</span></span><br></pre></td></tr></table></figure></li><li><p><code>logspace(a,b)</code>：等比向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = logspace(2, 8) # default to produce 50 numbers</span><br><span class="line">y = <span class="built_in">logspace</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>利用小矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">C = [a, <span class="built_in">eye</span>(<span class="built_in">size</span>(A)); <span class="built_in">ones</span>(<span class="number">3</span>), A*<span class="number">2</span>]</span><br></pre></td></tr></table></figure><ul><li><code>size()</code>：返回行数和列数<ul><li><code>length()</code>：返回行数和列数中的最大值</li></ul></li><li><code>eye(size)</code>：返回单位矩阵</li><li><code>ones(size)</code>：返回全一矩阵</li></ul></li></ul><h4 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h4><ul><li><p>元素赋值</p><ul><li>超过边界时，内存会<strong>自动扩展</strong>。</li></ul></li><li><p>运算</p><ul><li><code>*</code>：数学意义上的<strong>矩阵乘法</strong></li><li><code>.*</code>：<strong>点运算</strong>的数组乘法，对应元素相乘。</li></ul><blockquote><p><code>^</code>等运算符同上</p></blockquote></li><li>拆分：利用冒号表达式获得子矩阵<ul><li><code>A(r,c)</code>：(r,c)位置的元素</li><li><code>A(r,:)</code>：A的第r行的所有元素</li><li><code>A(:,c)</code>：A的第c列的所有元素</li><li><code>A(:)</code>：<strong>列优先</strong>使A变为一维数组</li><li><code>A(i)</code>：访问<code>A(:)</code>中的第<code>i</code>个元素</li><li><code>A(r,c)=Sa</code>：元素赋值</li><li><code>A(:)=D(:)</code></li></ul></li><li><p>删除：利用<code>[]</code>赋值</p><ul><li><p>删除不是清零，而是<strong>改变</strong>矩阵结构。</p><blockquote><p><code>clear</code>后矩阵变量则消失，不能再通过变量名操作。</p></blockquote></li></ul></li><li><p>其他</p><ul><li><p><code>diag</code>：提取矩阵对角线元素生成对角矩阵</p></li><li><p><code>flipud</code>：上下翻转</p></li><li><p><code>fliplr</code>：左右翻转</p></li><li><p><code>reshape(name, length, width)</code>：第一个参数是原矩阵，改变形状。</p><ul><li>注意矩阵<strong>列优先</strong></li></ul></li><li><p><code>rot90</code>：<strong>逆时针</strong>旋转90度</p></li><li><p><code>det</code>：矩阵行列式的值</p></li><li><p><code>rank</code>：矩阵的秩</p></li><li><p><code>trace</code>：矩阵的迹</p></li><li><p><code>max</code>：包含<strong>每一列</strong>最大值的向量</p></li><li><p>数组逆序</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = A(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>); <span class="comment">% end is a special symbol for iteration</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>一维字符数组</li><li>用<strong>单引号</strong>括起</li><li>字符串的<code>class</code>是<code>char</code></li><li>索引访问时应该使用<code>()</code>而不是<code>[]</code></li></ul><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul><li><p>单引号赋值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">'BUAA'</span>;</span><br><span class="line">b = c(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = char(<span class="number">97</span>) <span class="comment">% a</span></span><br><span class="line">c2 = num2str(<span class="number">97</span>) <span class="comment">% 97</span></span><br></pre></td></tr></table></figure><ul><li><p><code>setstr</code>：将ASCII码转换成字符串</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setstr(<span class="built_in">abs</span>(<span class="string">'c'</span>) + <span class="built_in">abs</span>(<span class="string">'a'</span>) - <span class="built_in">abs</span>(<span class="string">'A'</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>abs</code>：将字符串转换为ASCII码</p></li></ul><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><ul><li><p>水平</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="string">'I '</span>, <span class="string">'Love '</span>, <span class="string">'Matlab!'</span>] <span class="comment">% str = I Love Matlab</span></span><br><span class="line">str2 = strcat(<span class="string">'I '</span>, <span class="string">'Love '</span>, <span class="string">'Matlab!'</span>) <span class="comment">% str = ILoveMatlab</span></span><br></pre></td></tr></table></figure><ul><li><code>strcat</code>会自动去掉<strong>结尾处</strong>的空格，头部的<strong>不会被</strong>去掉。</li></ul></li><li><p>垂直</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="string">'Matrix    '</span>;<span class="string">'Lab'</span>]</span><br><span class="line">str2 = strvcat(<span class="string">'Matrix    '</span>,<span class="string">'Lab'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>strvcat</code>自动去掉<strong>结尾</strong>的空格</li></ul></li></ul><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><ul><li><p><code>isstrprop(str, &#39;category&#39;)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isstrprop(pw, <span class="string">'alphanum'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li><code>strcmp</code>：相等返回1</li><li><code>==</code>：逐个字符比较，返回一维数组，相等的位为1.</li></ul><h4 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h4><div class="table-container"><table><thead><tr><th>编码方式</th><th>英文（单位：字节）</th><th>中文（单位：字节）</th></tr></thead><tbody><tr><td><code>ASCII</code></td><td>1</td><td>/</td></tr><tr><td><code>UTF-8</code></td><td>1</td><td>3</td></tr><tr><td><code>UTF-16</code></td><td>2</td><td>2/4</td></tr><tr><td><code>UTF-32</code></td><td>4</td><td>4</td></tr><tr><td><code>GBK</code></td><td>1</td><td>2</td></tr></tbody></table></div><blockquote><p>在<code>R202a</code>中测试，无论是英文还是中文均占用两个字节。</p></blockquote><h3 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h3><ul><li>提供间接调用函数方法的数据类型</li></ul><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><ul><li><p>在已有函数名前加符号<code>@</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1 = @funcname;</span><br></pre></td></tr></table></figure></li><li><p>提供匿名函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqr = @(x)x.^<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><ul><li>将函数句柄看作函数名，和函数调用相同。</li></ul><h3 id="元胞数组"><a href="#元胞数组" class="headerlink" title="元胞数组"></a>元胞数组</h3><ul><li>其中的元素类型、尺寸可以不相同</li><li>创建、访问时用<code>{}</code>表示索引</li></ul><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><ul><li><p><code>cell</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=cell(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li><p><code>deal</code>：<strong>列优先</strong>查看内容，返回一个长向量进行解析。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,b] = deal(a&#123;:&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>[]</code>：赋值，删除元素。</p></li><li><p><code>num2cell</code>/<code>mat2cell</code>：数组、矩阵和元胞的转换。</p></li><li><p><code>celldisp</code>：逐个显示元胞数组内容</p></li></ul><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; stu = struct(<span class="string">'username'</span>, &#123;&#125;, <span class="string">'password'</span>, &#123;&#125;, <span class="string">'name'</span>, &#123;&#125;, <span class="string">'gender'</span>, &#123;&#125;); <span class="comment">% an empty struct array</span></span><br><span class="line">&gt;&gt; stu(<span class="number">1</span>).name=<span class="string">'Silence'</span>;</span><br><span class="line">&gt;&gt; stu(<span class="number">1</span>).course=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  struct with fields:</span><br><span class="line"></span><br><span class="line">      name: <span class="string">'Silence'</span></span><br><span class="line">    course: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>struct</code>函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; student(<span class="number">3</span>)=struct(<span class="string">'name'</span>,<span class="string">'Lex'</span>,<span class="string">'course'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">student = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">3</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br></pre></td></tr></table></figure></li></ul><h4 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; stu(<span class="number">2</span>).name=<span class="string">'Anita'</span></span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br></pre></td></tr></table></figure><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu(<span class="number">2</span>).name</span><br></pre></td></tr></table></figure><h4 id="删除域"><a href="#删除域" class="headerlink" title="删除域"></a>删除域</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; rmfield(stu,&#123;<span class="string">'course'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line"></span><br><span class="line">&gt;&gt; stu</span><br><span class="line"></span><br><span class="line">stu = </span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> struct array with fields:</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    course</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>不改变</strong>本来的结构数组</li></ul><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter2-程序设计"><a href="#Chapter2-程序设计" class="headerlink" title="Chapter2 程序设计"></a>Chapter2 程序设计</h1><p>全文共<code>869</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><ul><li><p>输入：<code>input(message, options)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">'What is your name'</span>,<span class="string">'s'</span>);</span><br></pre></td></tr></table></figure><ul><li><code>s</code>：允许用户输入一个字符串</li></ul></li><li><p>输出</p><ul><li><p><code>disp(messages)</code>：message可以是<strong>单独一个</strong>变量，按照默认<code>format</code>输出。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>([<span class="string">'x1='</span>,num2str(x(<span class="number">1</span>)),<span class="string">'x2='</span>,num2str(x(<span class="number">2</span>))]);</span><br></pre></td></tr></table></figure><ul><li>拼接时<strong>不会</strong>添加空格</li></ul></li><li><p><code>fprintf</code>：和C格式相同</p></li><li><p><code>magbox</code>：弹窗展示</p></li></ul></li><li><p>暂停：<code>pause(time)</code></p><ul><li>省略<code>time</code>则等待用户键入后继续执行</li></ul><blockquote><p>强行中止：<code>Ctrl+C</code></p></blockquote></li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">elseif</span> expression</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>expression</code>可以带括号，也可以不带。</li><li>为了<code>if</code>和<code>end</code>对称：<code>Ctrl+I</code>自动对齐</li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> expression</span><br><span class="line"><span class="keyword">case</span> const1</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">otherwise</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>switch</code>后的类型可以为任意类型，包括字符串、矩阵、数组。</li><li><strong>不</strong>需要<code>break</code>语句，每个<code>case</code>执行后会自动跳出。</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li><p><code>for</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=expression1:expression2:expression3</span><br><span class="line"> <span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>没有<code>()</code>和<code>;</code></p></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>步长为<strong>1</strong>时，表达式2可以省略。</p></li><li><p><code>a:b</code><strong>包括</strong>右端点</p></li></ul></li><li><p><code>while</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression)</span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p><code>break</code>：跳出循环</p></li><li><code>continue</code>：跳过循环体剩余语句</li><li><code>return</code>：退出脚本或函数</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line"><span class="comment">%...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">lasterr;</span><br></pre></td></tr></table></figure><ul><li><code>lasterr</code>存储上一次错误的信息</li></ul><h2 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h2><ul><li>扩展名为<code>.m</code></li><li>MATLAB在初次运行时会将<code>.m</code>文件装入内存，之后运行的速度会变快。</li></ul><h3 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h3><ul><li><p>也称为命令文件</p></li><li><p>不接受输入参数也不返回输出参数的M文件</p><blockquote><p>这里的参数指的是在命令行中调用时，脚本文件只需要输入文件名，但是函数文件需要使用<code>()</code>传参数。</p></blockquote></li><li><p>脚本文件新建的变量能够保存在MATLAB的内存空间中</p><ul><li><p>所有的变量都是<strong>全局变量</strong></p><blockquote><p>全局变量可以直接被使用，<strong>不需要</strong>预先声明<code>global</code>.</p></blockquote></li><li><p>每个脚本开始前使用<code>clear all;</code></p></li></ul></li></ul><h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><ul><li><p>对用户就是黑盒，只有输入和输出。</p></li><li><p>MATLAB函数和命令实际上都是函数文件</p></li><li><p>产生的变量默认为<strong>局部变量</strong>，存放在函数自身的工作空间中。</p><blockquote><p>在函数文件中使用全局变量需要预先声明<code>global</code></p></blockquote></li><li><p>结构</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">return_var</span>=<span class="title">funcname</span><span class="params">(input_var)</span> % <span class="title">function</span> <span class="title">definition</span></span></span><br><span class="line"><span class="comment">% help info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% annotation</span></span><br><span class="line"><span class="comment">% ...</span></span><br></pre></td></tr></table></figure><ul><li><code>help info</code>：help文档中显示，即第一个非空行前的所有注释。</li></ul></li><li><p>变量检测</p><ul><li><p><code>nargin</code>：输入实参<strong>数目</strong></p></li><li><p><code>nargout</code>：输出实参<strong>数目</strong></p><blockquote><p>在函数体外可以通过<code>nargin(&#39;func&#39;)</code>调用</p></blockquote></li><li><p><code>inputname(n)</code>：第<code>n</code>个输入参数的实际调用变量名（即函数调用出传进的参数的名字）</p><blockquote><p>如果参数本来是常量，则会返回空字符串。</p></blockquote></li><li><p><code>varargin</code>：变长输入参数<strong>列表</strong></p></li><li><p><code>varargout</code>：变长输出参数列表（直接输出则是数目）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varargout</span> = <span class="title">foo</span><span class="params">(varargin)</span></span></span><br><span class="line">fprintf(<span class="string">'How many output arguments? %d\nAnd they are:\n'</span>, nargout);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:nargout</span><br><span class="line">varargout(k) = varargin(k); <span class="comment">% the same as &#123;varargin&#123;k&#125;&#125;;</span></span><br><span class="line">fprintf(<span class="string">'%s '</span>, num2str(varargout&#123;k&#125;));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="调试和优化"><a href="#调试和优化" class="headerlink" title="调试和优化"></a>调试和优化</h2><ul><li><p><code>keyboard</code>：中断程序，用户可以在命令窗口查询内存信息。</p><ul><li>对于函数文件，将函数头注释掉即可使用<code>keyboard</code>.</li></ul></li><li><p>断点</p><ul><li><p>标准断点（小红点）</p></li><li><p>条件断点（小黄点）</p><ul><li><p>使用函数设置</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbstop in filename <span class="keyword">if</span> expression</span><br></pre></td></tr></table></figure></li></ul></li><li><p>错误断点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbstop <span class="keyword">if</span> error</span><br></pre></td></tr></table></figure><p>使程序在错误的地方停下，并且自动进入调试模式。</p></li></ul></li><li><p>优劣分析</p><ul><li><p><code>profile</code>：计算相对耗时和瓶颈</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">profile on;</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line">profile viewer;</span><br></pre></td></tr></table></figure></li><li><p><code>tic</code>/<code>toc</code>：计算绝对耗时</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tic;</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line">toc;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>优化</p><ul><li>向量化操作：使用向量替换循环</li><li>数据的预定义：一次性申请足够大的空间</li></ul></li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter3-数值计算"><a href="#Chapter3-数值计算" class="headerlink" title="Chapter3 数值计算"></a>Chapter3 数值计算</h1><p>全文共<code>1380</code>字，推荐阅读时间<code>12~15</code>分钟。</p><h2 id="数据统计处理"><a href="#数据统计处理" class="headerlink" title="数据统计处理"></a>数据统计处理</h2><h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><p>以<code>max()</code>为例，<code>min()</code>用法相同。</p><ul><li><p>向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">max</span>(A);</span><br><span class="line">[c, idx] = <span class="built_in">max</span>(A); <span class="comment">% idx is the index of max value</span></span><br></pre></td></tr></table></figure></li><li><p>矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A); <span class="comment">% return a row vector of max values in every column</span></span><br><span class="line">c = <span class="built_in">max</span>(A, [], dim); <span class="comment">% dim can be 1 or 2, default to 1(column max).</span></span><br><span class="line"> <span class="comment">% [] cannot be neglected for overloading of max(A, n).</span></span><br><span class="line">[c, idx] = <span class="built_in">max</span>(A);</span><br></pre></td></tr></table></figure><ul><li><p>求矩阵的最大元素（降维）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A(:));</span><br></pre></td></tr></table></figure></li><li><p>比较</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">max</span>(A, B); <span class="comment">% u is matrix with all max values</span></span><br><span class="line">u = <span class="built_in">max</span>(A, n); <span class="comment">% n is scalar, and u's elements are all &gt;= n.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">mean</span>(A);</span><br><span class="line">m = <span class="built_in">mean</span>(A, dim);</span><br></pre></td></tr></table></figure><h3 id="中值"><a href="#中值" class="headerlink" title="中值"></a>中值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = median(A);</span><br><span class="line">m - median(A, dim);</span><br></pre></td></tr></table></figure><h3 id="加和"><a href="#加和" class="headerlink" title="加和"></a>加和</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = sum(A); <span class="comment">% return a row vector of production of column</span></span><br><span class="line">b = aum(A, dim);</span><br></pre></td></tr></table></figure><ul><li><p>累加和</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = cumsum(A); <span class="comment">% return a row vector of cumulative sum of column</span></span><br><span class="line">b = cumsum(A, dim);</span><br></pre></td></tr></table></figure></li></ul><h3 id="乘积"><a href="#乘积" class="headerlink" title="乘积"></a>乘积</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = prod(A); <span class="comment">% return a row vector of production of column</span></span><br><span class="line">b = prod(A, dim);</span><br></pre></td></tr></table></figure><ul><li><p>累乘积</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = cumprod(A);</span><br><span class="line">b = cumprod(A, dim);</span><br></pre></td></tr></table></figure></li></ul><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = std(A);</span><br><span class="line">s = std(A, flag, dim); <span class="comment">% flag can be 0 or 1, and 0 is (N-1) normal std while 1 is (N).</span></span><br></pre></td></tr></table></figure><h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = corrcoef(A); <span class="comment">% take every column as a variable to caculate correlate coefficient</span></span><br><span class="line">r = corrcoef(x, y)；</span><br><span class="line">r = corrcoef([x, y]);</span><br></pre></td></tr></table></figure><ul><li>相关系数矩阵的大小和原矩阵是相同的，其他时候则根据向量数确定，例如<code>corrcoef([x, y])</code>的结果是<code>2*2</code>矩阵。</li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">sort</span>(A);</span><br><span class="line">[b, idx] = <span class="built_in">sort</span>(A, dim); <span class="comment">% idx contains the positions of B's elements in A.</span></span><br></pre></td></tr></table></figure><h2 id="复数-1"><a href="#复数-1" class="headerlink" title="复数"></a>复数</h2><ul><li>虚部使用<code>i</code>或者<code>j</code>表示</li><li>构造<ul><li>直接表示</li><li><code>complex(a, b)</code></li></ul></li></ul><h3 id="特殊运算"><a href="#特殊运算" class="headerlink" title="特殊运算"></a>特殊运算</h3><ul><li>提取实部和虚部<ul><li><code>real</code></li><li><code>imag</code></li></ul></li><li>计算模<ul><li><code>abs</code></li></ul></li><li>计算辐角<ul><li><code>angle</code></li></ul></li><li>复数共轭<ul><li><code>conj</code></li></ul></li></ul><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>直角坐标绘图和其他相同，特殊的在于<strong>极坐标</strong>绘图。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polar(theta, rho);</span><br><span class="line">polar(theta, tho, LineSpec);</span><br></pre></td></tr></table></figure><ul><li><code>theta</code>：极角</li><li><code>rho</code>：极轴</li></ul><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h3><ul><li><p>多项式表达为一个<strong>系数</strong>行向量，并且其元素是降幂排列的。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = [an, ..., a2, a1, a0];</span><br></pre></td></tr></table></figure><ul><li>指数为0的项的系数<strong>不能</strong>省略</li></ul></li><li><p><code>poly</code>：根据<strong>解向量</strong>产生<strong>特征多项式</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = poly(a);</span><br></pre></td></tr></table></figure><ul><li><p><code>roots</code>：逆函数，根据<strong>系数向量</strong>求<strong>解向量</strong>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = roots(p);</span><br></pre></td></tr></table></figure><blockquote><p>系数（<strong>行</strong>向量）：<code>1 * n</code></p><p>根（<strong>列</strong>向量）：<code>n * 1</code></p></blockquote></li></ul></li><li><p><code>poly2str</code>：把多项式系数转换为<strong>字符形式</strong>的函数，省略一些不影响阅读的运算符，例如<code>2*x</code>会被表示为<code>2x</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = poly2str(p, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>poly2sym</code>：把系数数组转换为<strong>符号多项式</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = poly2sym(p, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;a =[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]; p = poly(a)</span><br><span class="line">p = <span class="number">1</span> <span class="number">-6</span> <span class="number">11</span> <span class="number">-6</span></span><br><span class="line">&gt;&gt; p1 = poly2str(p, <span class="string">'x'</span>) p2 = poly2sym(p, <span class="string">'x'</span>)</span><br><span class="line">p1 = x^<span class="number">3</span> - <span class="number">6</span> x^<span class="number">2</span> + <span class="number">11</span> x – <span class="number">6</span></span><br><span class="line">P2 = x^<span class="number">3</span> - <span class="number">6</span>*x^<span class="number">2</span> + <span class="number">11</span>*x - <span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="算数运算与求导"><a href="#算数运算与求导" class="headerlink" title="算数运算与求导"></a>算数运算与求导</h3><h4 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h4><ul><li>阶次不同时，<strong>低阶多项式</strong>必须用0填补系数数组，使其与高阶多项式有相同的阶次。</li></ul><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = conv(a, b);</span><br></pre></td></tr></table></figure><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = deconv(c, a);</span><br><span class="line">[d, r] = deconv(c, a);</span><br></pre></td></tr></table></figure><ul><li><code>d</code>：整数部分</li><li><code>r</code>：余数</li></ul><h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><ul><li><p>数组变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = polyval(p, x);</span><br></pre></td></tr></table></figure></li><li><p>矩阵变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = polyvalm(p, x);</span><br></pre></td></tr></table></figure><ul><li>变量<code>x</code>是一个<strong>方阵</strong></li></ul></li></ul><h3 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k = polyder(p);</span><br><span class="line">k = polyder(a, b); <span class="comment">% differentiate a * b</span></span><br><span class="line">[p, q] = polyder(a, b); <span class="comment">% differentiate a / b, and result is q(x)/p(x)</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/15/bPF6VulXij3ZUrz.png" alt="image-20201015133030937" style="zoom:50%;" /></p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polyint(p, k); <span class="comment">% p is coef vector, and k is const item.</span></span><br><span class="line">polyint(p); <span class="comment">% k is default to 0.</span></span><br></pre></td></tr></table></figure><h4 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I,n]=quad(<span class="string">'fname'</span>,a,b,tol,trace);</span><br><span class="line">[I,n]=quadl(<span class="string">'fname'</span>,a,b,tol,trace);</span><br></pre></td></tr></table></figure><ul><li><p><code>fname</code>可以是内联函数名</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun = inline(<span class="string">'-x.^2+115'</span>, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure><ul><li>此时如果x不是矩阵，次方需要使用<code>.^</code>.</li></ul></li><li><p><code>tol</code>用来控制积分精度，缺省时取<code>tol=0.001</code>.</p></li><li><p><code>trace</code>控制是否展现积分过程，若取非0则展现积分过程，取0则不展现，缺省时取<code>trace=0</code>.</p></li></ul><h3 id="部分分式展开"><a href="#部分分式展开" class="headerlink" title="部分分式展开"></a>部分分式展开</h3><p><img src="https://i.loli.net/2020/10/15/8k6I7hp54mGlRDT.png" alt="image-20201015115600614" style="zoom:50%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[r, p, k] = residue(b, a);</span><br></pre></td></tr></table></figure><ul><li>求<code>b/a</code>的分式展开<ul><li><code>r</code>：留数行向量</li><li><code>p</code>：部分分式极点</li><li><code>k</code>：常数项</li></ul></li><li>当多项式分母有重根时，使用<code>resi2</code>函数。</li></ul><h2 id="曲线拟合与插值"><a href="#曲线拟合与插值" class="headerlink" title="曲线拟合与插值"></a>曲线拟合与插值</h2><h3 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h3><ul><li><p><code>polyfit</code>：最小二乘拟合</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = polyfit(x, y, n);</span><br></pre></td></tr></table></figure></li></ul><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ul><li>利用已知点确定未知点</li><li>常用于图像旋转、缩放</li></ul><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yi = interp1(x, y, xi, method)</span><br></pre></td></tr></table></figure><ul><li><code>method</code><ul><li><code>nearest</code>：最近邻内插</li><li><code>linear</code>：线性内插（默认）</li><li><code>spline</code>：三次样条内插</li><li><code>cubic</code>：三次多项式内插</li></ul></li></ul><h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi = interp2(x, y, z, xi, yi, method);</span><br></pre></td></tr></table></figure><ul><li><p><code>method</code></p><ul><li><code>nearest</code></li><li><code>bilinear</code>：二维线性内插法（默认）</li><li><code>spline</code>：二维样条内插法</li><li><code>bicubic</code>：二维三次多项式内插法</li></ul></li><li><p>二维<strong>散布点</strong>插值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi = griddata(x, y, z, xi, yi);</span><br></pre></td></tr></table></figure></li></ul><h4 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi = interp3(x, y, z, v, x1, yi, zi, method)</span><br></pre></td></tr></table></figure><ul><li><code>method</code><ul><li><code>nearest</code></li><li><code>linear</code>：默认</li><li><code>spline</code></li><li><code>cubic</code></li></ul></li></ul><h4 id="高维"><a href="#高维" class="headerlink" title="高维"></a>高维</h4><ul><li><code>interpn()</code></li></ul><h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><ul><li><p><code>fminbnd</code>：无约束<strong>单变量</strong>寻优函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fminbnd(fname, x0, x1); <span class="comment">% fname is function name, and [x0, x1] is range.</span></span><br></pre></td></tr></table></figure><ul><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fminbnd(<span class="string">'sin'</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fminsearch</code>：多元函数极小值点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval, exitflag, output] = fminsearch(fun, x0);</span><br></pre></td></tr></table></figure><ul><li><code>exitflag</code>为1表示计算成功</li><li><code>fun</code>可以是外部函数，也可以直接用字符串作参数。</li><li>函数中的变量必须是<code>x(i)</code></li></ul></li></ul><h2 id="代数方程组"><a href="#代数方程组" class="headerlink" title="代数方程组"></a>代数方程组</h2><ul><li>$ax-b=0(a是m*n矩阵)$的方程类型<ul><li>恰定：$m=n$</li><li>超定：$m&gt;n$</li><li>欠定：$m&lt;n$</li></ul></li></ul><h3 id="恰定"><a href="#恰定" class="headerlink" title="恰定"></a>恰定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = inv(a)*b;</span><br><span class="line">x = a/b;</span><br></pre></td></tr></table></figure><ul><li>$x=a^{-1}b$</li><li>除解法的速度<strong>更快</strong></li></ul><h3 id="超定"><a href="#超定" class="headerlink" title="超定"></a>超定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = a/b; <span class="comment">% 最小二乘法求近似解</span></span><br><span class="line">x = (a'*a)^<span class="number">-1</span>*a'*b;</span><br></pre></td></tr></table></figure><ul><li><code>a&#39;</code>：矩阵<code>a</code>的<strong>转置</strong></li></ul><h3 id="欠定"><a href="#欠定" class="headerlink" title="欠定"></a>欠定</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = a/b; <span class="comment">% 求出0最多的解</span></span><br><span class="line">x = pinv(a) * b; <span class="comment">% 求出最小范数解</span></span><br></pre></td></tr></table></figure><h2 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h2><p>$\begin{cases} \frac{dy}{dx}=f(x,y) \\ y(x_0)=y_0 \end{cases}$</p><h3 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = dsolve(<span class="string">'eq1, eq2, ...'</span>, <span class="string">'cond1, cond2,...'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>单个方程</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsolve(<span class="string">'Dy=x'</span>, <span class="string">'x'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不指定<code>x</code>时默认为<code>t</code></p></blockquote></li><li><p>方程组</p><p><img src="https://i.loli.net/2020/10/15/zQwahvJC9MHmbLs.png" alt="image-20201015134613691" style="zoom: 67%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[X,Y]=dsolve(<span class="string">'Dx+2*x-Dy=10*cos(t)'</span>, <span class="string">'Dx+Dy+2*y=4*exp(-2*t)'</span>, <span class="string">'x(0)=2, y(0)=0'</span>, <span class="string">'t'</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值解"><a href="#数值解" class="headerlink" title="数值解"></a>数值解</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[t, y] = solver(odefun, tspan, y0);</span><br></pre></td></tr></table></figure><ul><li>在区间<code>tspan</code>上用初始条件<code>y0</code>求解显式常微分方程</li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter4-符号运算"><a href="#Chapter4-符号运算" class="headerlink" title="Chapter4 符号运算"></a>Chapter4 符号运算</h1><p>全文共<code>1986</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul><li><p>和数值运算对应，使用<strong>符号</strong>表示计算结果（不给未知数赋值）。</p><ul><li><p>求解方程：$ax^2+bx+c=0$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms a b c x;</span><br><span class="line">solve(a*x^<span class="number">2</span>+b*x+c); <span class="comment">% note there is no single quote</span></span><br><span class="line">solve(a*x^<span class="number">2</span>+b*x+c==<span class="number">0</span>); <span class="comment">% note '==' instead of '='</span></span><br></pre></td></tr></table></figure></li><li><p>辨析</p><p>以$2/5+1/3$为例，数值运算的结果为$0.7333$；而$sym(2)/sym(5)+sym(1)/sym(3)$的结果为$11/15$，且这里$11/15$仍然是属于<code>sym</code>类型, 是<strong>符号数</strong>。</p><blockquote><p>符号运算只会化简到<strong>没有误差</strong>的最简形式</p></blockquote></li></ul></li><li><p>支持可变精度运算，以指定精度返回数值结果。</p></li><li><p>相比数值运算，符号运算所需运行时间较长。</p></li></ul><h2 id="符号对象"><a href="#符号对象" class="headerlink" title="符号对象"></a>符号对象</h2><ul><li><p>符号对象是一种数据结构</p></li><li><p>分类</p><ul><li><p>符号常量</p></li><li><p>符号变量</p></li><li><p>符号表达式：含有符号对象的表达式</p><blockquote><p>在MATLAB中将其存储为<strong>字符串</strong></p></blockquote></li></ul></li><li><p>符号矩阵/数组：元素是符号表达式的矩阵/数组</p></li></ul><h3 id="创建-6"><a href="#创建-6" class="headerlink" title="创建"></a>创建</h3><ul><li><p><code>sym</code>：创建<strong>单个</strong>符号对象</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = sym(A, flag);</span><br></pre></td></tr></table></figure><ul><li><p><code>A</code>：常量、变量、函数、表达式</p></li><li><p><code>flag</code>：缺省为有理数<code>r</code></p><ul><li><code>d</code>：最接近的十进制数值</li><li><code>f</code>：最接近的浮点数值</li><li><code>r</code>：最接近的有理表示</li></ul></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = sym(<span class="string">'q'</span>)      <span class="comment">% 符号变量，指定a在表达式字符串中的形式。</span></span><br><span class="line">a_1 = sym(<span class="string">'pi'</span>)  <span class="comment">% 符号变量，指定a_1在表达式字符串中的形式。</span></span><br><span class="line">b = sym(<span class="number">1</span>/<span class="number">3</span>)      <span class="comment">% 符号常量，指定b在表达式中的取值。</span></span><br><span class="line">b_1 = sym(<span class="built_in">pi</span>)  <span class="comment">% 符号常量，指定b_1在表达式中的取值。</span></span><br><span class="line">c = sym(<span class="number">2</span>*a+b)    <span class="comment">% 符号表达式</span></span><br><span class="line">d = sym(<span class="built_in">sin</span>(<span class="number">1</span>))   <span class="comment">% 符号函数</span></span><br></pre></td></tr></table></figure><ul><li><p>用<code>&#39;pi&#39;</code>创建的符号变量在<code>sin(pi)</code>时不会得到0；但是<code>sym(&#39;4&#39;)</code>和<code>sym(4)</code>没有区别，都可以运算。</p></li><li><p>符号表达式和符号函数<strong>不能够</strong>使用字符串参数，因此在构造符号表达式之前需要构造好所有的符号常量和符号变量。</p><ul><li><p>如果想要直接通过字符串创建符号表达式，则应该使用<code>str2sym</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = str2sym(<span class="string">'a*x^4+b*x^3+c*x^2+d*x+e'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>str2sym</code>对<strong>所有</strong>用字符串构造符号表达式的方式<strong>都适用</strong></p></blockquote></li></ul></li><li><p>使用符号对象创建符号对象（拷贝构造）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = sym(<span class="number">10</span>);</span><br><span class="line">b = sym(a);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>syms</code>：一次性创建多个符号对象</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syms a b c; <span class="comment">% 只能用空格分隔</span></span><br><span class="line"><span class="comment">% equals to</span></span><br><span class="line">a = sym(<span class="string">'a'</span>);</span><br><span class="line">b = sym(<span class="string">'b'</span>);</span><br><span class="line">c = sym(<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></li><li><p>符号表达式</p><ul><li><p>单引号（不推荐）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="string">'sin(x)+cos(x)'</span>;</span><br></pre></td></tr></table></figure><blockquote><ul><li>字符间<strong>不能</strong>添加空格</li><li>在2020版本中不能够创建表达式，只能够表示单纯的字符串。</li></ul></blockquote></li><li><p><code>sym</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = sym(<span class="string">'sin(x)+cos(x)'</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用已经定义的符号变量组（推荐）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syms x</span><br><span class="line">f = <span class="number">3</span>*<span class="built_in">sin</span>(x)+<span class="built_in">cos</span>(x)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>符号矩阵</p><ul><li><p><code>sym</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = sym(<span class="string">'[1+x,sin(x);5,exp(x)]'</span>);</span><br></pre></td></tr></table></figure></li><li><p>数值矩阵转换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = [<span class="number">2</span>/<span class="number">3</span>, <span class="built_in">sqrt</span>(<span class="number">2</span>); <span class="number">5.2</span>, <span class="built_in">log</span>(<span class="number">3</span>)];</span><br><span class="line">C = sym(B);</span><br></pre></td></tr></table></figure></li><li><p>符号矩阵的引用和修改和数值矩阵相同</p></li></ul></li></ul><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>和数值运算中的规则、符号都相同。</p><h3 id="符号表达式"><a href="#符号表达式" class="headerlink" title="符号表达式"></a>符号表达式</h3><ul><li><p><code>numden</code>：通分并提取符号表达式的分子和分母</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[N, D] = numden(f);</span><br></pre></td></tr></table></figure><ul><li><code>N</code>：通分后的<strong>分子</strong></li><li><code>D</code>：通分后的<strong>分母</strong></li></ul></li><li><p><code>factor</code>：因式分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = x^<span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">factor</span>(f);</span><br></pre></td></tr></table></figure><ul><li><p>可以用于<strong>正整数</strong>的分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">factor</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">% s = 2 2 5 5</span></span><br></pre></td></tr></table></figure></li><li><p>可以用于<strong>大正整数符号变量</strong>的分解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">factor</span>(sym(<span class="string">'1234567891011121314'</span>));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>expand</code>：符号表达式展开</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = (x+<span class="number">1</span>)^<span class="number">6</span>;</span><br><span class="line">expand(f);</span><br></pre></td></tr></table></figure></li><li><p><code>collect</code>：合并同类项</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collect(s); <span class="comment">% 对符号表达式默认变量合并</span></span><br><span class="line">collect(s, v); <span class="comment">% 对符号表达式s按变量v合并</span></span><br></pre></td></tr></table></figure></li><li><p>化简</p><ul><li><p><code>simplify(f)</code></p><ul><li><p>获取最短的化简结果</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simplify(f, <span class="string">'IgnoreAnalyticConstraints'</span>, <span class="built_in">true</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>simple</code>：多种规则返回最少数目字符的字符</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[How, y] = simple(f);</span><br></pre></td></tr></table></figure><ul><li><code>How</code>：记录使用的方法</li><li><code>y</code>：最简短形式</li></ul></li></ul></li><li><p><code>horner</code>：求多项式的嵌套形式（秦九韶算法）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">f = x^<span class="number">4</span> + <span class="number">2</span>*x^<span class="number">3</span> + <span class="number">4</span>*x^<span class="number">2</span> + x + <span class="number">1</span>;</span><br><span class="line">g = horner(f);</span><br><span class="line"><span class="comment">% g = x*(x*(x*(x+2)+4)+1)+1</span></span><br></pre></td></tr></table></figure></li><li><p><code>pretty</code>：格式美化，转换为手写格式。</p></li><li><p>多项式转换</p><ul><li><p><code>sym2poly</code>：将符号表达式转换为<strong>降幂排列</strong>的<strong>系数行向量</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = sym(<span class="string">'2*x+3*x^2+1'</span>);</span><br><span class="line">sym2poly(f);</span><br></pre></td></tr></table></figure></li><li><p><code>poly2sym</code>：将行向量按<strong>幂降序</strong>转换为符号表达式，变量默认为<code>x</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = poly2sym([<span class="number">1</span> <span class="number">3</span> <span class="number">2</span>])</span><br><span class="line"><span class="comment">% x^2 + 3*x + 2</span></span><br></pre></td></tr></table></figure></li><li><p>只能对<strong>单符号</strong>表达式进行转换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">c = sym(<span class="number">1</span>);</span><br><span class="line">f = str2sym(<span class="string">'x+c'</span>);</span><br><span class="line">sym2poly(f);</span><br></pre></td></tr></table></figure><ul><li>尽管<code>c</code>是符号常量，但是依然不能够转换。</li></ul></li></ul></li><li><p><code>findsym</code>：查找符号<strong>变量</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findsym(s, n); <span class="comment">% 返回符号表达式s中的n个符号变量</span></span><br></pre></td></tr></table></figure><ul><li><p>当<code>n</code>不指定时，<strong>无序</strong>返回所有符号变量。</p></li><li><p>默认符号变量的选取：先选择<code>x</code>，如果<code>x</code>不存在，则选择在字母顺序中<strong>最接近</strong><code>x</code>的字符变量；如果距离相等，则选择<code>x</code><strong>后面</strong>的字符变量。</p><blockquote><p>注意：<strong>大写</strong>字母比<strong>小写</strong>字母都靠后（和ASCII码<strong>相反</strong>）</p></blockquote></li><li><p>符号常量<strong>不会</strong>被返回</p></li></ul></li><li><p><code>subs</code>：符号变量的替换</p><ul><li><code>subs(f, a)</code>：用<code>a</code>替换表达式<code>f</code>中的（第一）自由变量</li><li><code>subs(f, x, a)</code>：用<code>a</code>替换<code>f</code>中的指定符号变量<code>x</code></li></ul><blockquote><p>在数字信号处理中，进行移位、反褶、尺度变换。</p></blockquote></li><li><p><code>compose</code>：复合函数运算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compose(f, g); <span class="comment">% f(g(X))</span></span><br><span class="line">compose(f, g, z); <span class="comment">% f(g(z))</span></span><br></pre></td></tr></table></figure></li><li><p><code>finverse</code>：反函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = finverse(f);</span><br><span class="line">g = finverse(f, v); <span class="comment">% 指定默认变量</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h3><h4 id="运算方式"><a href="#运算方式" class="headerlink" title="运算方式"></a>运算方式</h4><ul><li>数值型</li><li>有理数型</li><li><code>VPA</code>型：Maple的任意精度运算</li></ul><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="number">2</span>/<span class="number">3</span>; <span class="comment">% 0.6667</span></span><br><span class="line">a2 = sym(<span class="number">2</span>/<span class="number">3</span>); <span class="comment">% 2/3</span></span><br><span class="line">a3 = vpa(<span class="string">'2/3'</span>, <span class="number">32</span>); <span class="comment">% 0.66666666666666666666666666666667</span></span><br></pre></td></tr></table></figure><ul><li><code>digits</code>：显示当前计算精度</li><li><code>digits(n)</code>：设置数值型计算精度</li><li><code>xr = vpa(x)</code>：在<code>digits</code>精度下的数值型结果<code>xr</code></li><li><code>xr = vpa(x, n)</code>：在指定精度<code>n</code>下的数值型结果<code>xr</code></li></ul><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><ul><li><code>sym</code>：数值型转换为有理数型的符号对象</li><li><code>vpa(x, n)</code>：转换为VPA型符号对象</li><li><code>double</code>：转换为数值对象</li></ul><h2 id="符号微积分"><a href="#符号微积分" class="headerlink" title="符号微积分"></a>符号微积分</h2><ul><li><p><code>limit</code>：符号极限</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">limit(f); <span class="comment">% 函数在x=0的极限值</span></span><br><span class="line">limit(f, x, a); <span class="comment">% 函数在x趋于a的极限值</span></span><br><span class="line">limit(f, x, a, <span class="string">'left'</span>); <span class="comment">% 左极限</span></span><br><span class="line">limit(f, x, a, <span class="string">'right'</span>); <span class="comment">% 右极限</span></span><br></pre></td></tr></table></figure></li><li><p><code>diff</code>：符号导数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = diff(f);</span><br><span class="line">g = diff(f, v);</span><br><span class="line">g = diff(f, n); <span class="comment">% 对默认变量求n阶导</span></span><br><span class="line">g = diff(f, v, n); <span class="comment">% 对指定变量v求n阶导</span></span><br></pre></td></tr></table></figure></li><li><p><code>int</code>：符号积分</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int(f);</span><br><span class="line">int(f, v);</span><br><span class="line">int(f, a, b); <span class="comment">% 定积分</span></span><br><span class="line">int(f, v, a, b);</span><br></pre></td></tr></table></figure><ul><li><p>与数值积分辨析</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">digits(<span class="number">128</span>);</span><br><span class="line">fun = inline(<span class="string">'-x.^2+115'</span>, <span class="string">'x'</span>);</span><br><span class="line"><span class="comment">% numerical</span></span><br><span class="line">rn_1 = polyint([<span class="number">-1</span>, <span class="number">0</span>, <span class="number">115</span>]);</span><br><span class="line">fn_2 = quad(fun, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">fn_3 = quadl(fun, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">% symbolic</span></span><br><span class="line">rs = int(str2sym(<span class="string">'-x^2+115'</span>), <span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fourier</code>：傅里叶变换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fourier(ft, t, w);</span><br><span class="line">ifourier(Fw, w, t)</span><br></pre></td></tr></table></figure></li><li><p><code>symsum</code>：级数求和</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">symsum(f, v, a, b);</span><br><span class="line">symsum(f, a, b);</span><br></pre></td></tr></table></figure></li><li><p><code>laplace</code></p></li><li><p><code>taylor</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taylor(f); <span class="comment">% 默认为6阶麦克劳林多项式</span></span><br><span class="line">taylor(f, n, v); <span class="comment">% (n-1)阶麦克劳林多项式</span></span><br><span class="line">taylor(f, n, v, a); <span class="comment">% 在a附近的(n-1)阶展开式</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="符号方程"><a href="#符号方程" class="headerlink" title="符号方程"></a>符号方程</h2><ul><li><p><code>solve</code>：解析解</p><ul><li><code>solve(f)</code></li></ul></li><li><p><code>solve(&#39;eq1&#39;, &#39;eq2&#39;, ..., &#39;v1&#39;, &#39;v2&#39;, ...)</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x;</span><br><span class="line">eq1 = str2sym(<span class="string">'x^2+2*x+1=0'</span>);</span><br><span class="line">solve(eql);</span><br><span class="line">solve(x^<span class="number">2</span>+<span class="number">2</span>*x+<span class="number">1</span>==<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p>如果用<code>=</code>则必须传入符号表达式对象，如果是现场构造则是<code>==</code>.</p><blockquote><p>如果是<code>=0/==0</code>则可以直接省略</p></blockquote></li></ul></li><li><p><code>dsolve</code>：微分方程解析解</p></li></ul><h2 id="符号函数可视化"><a href="#符号函数可视化" class="headerlink" title="符号函数可视化"></a>符号函数可视化</h2><ul><li><p><code>ezplot()</code>：绘制符号表达式的函数曲线</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ezplot(<span class="string">'x^2*y+y+2'</span>);</span><br></pre></td></tr></table></figure><ul><li><code>ezplot(3)</code>：三维曲线</li></ul></li><li><p><code>ezcontour</code>：绘制带填充颜色的等高线</p></li><li><p><code>ezmesh</code>：绘制带等位线的<strong>三维网格图</strong></p></li><li><p><code>ezsurf</code>：绘制带等位线的<strong>曲面图</strong></p></li><li><p><code>ezploar</code>：绘制极坐标曲线</p></li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter5-图形绘制"><a href="#Chapter5-图形绘制" class="headerlink" title="Chapter5 图形绘制"></a>Chapter5 图形绘制</h1><p>全文共<code>2134</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="二维图形"><a href="#二维图形" class="headerlink" title="二维图形"></a>二维图形</h2><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p><code>plot</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(Y) <span class="comment">% 以Y的索引/向量实部为横坐标</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y) <span class="comment">% X和Y的维度需要相同</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y, s) <span class="comment">% s设置线形 颜色 标记</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y, <span class="string">'PropName'</span>, PropVal) <span class="comment">% 设置图形属性</span></span><br><span class="line"><span class="built_in">plot</span>(X1, Y1, s1, X2, Y2, s2)</span><br></pre></td></tr></table></figure><ul><li><p>默认按照<strong>蓝色实线</strong>绘制，并做<strong>平滑</strong>处理。</p></li><li><p>统一<code>x</code>轴绘制</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(t,[y',y1',y2',y3',y4',y5'])</span><br></pre></td></tr></table></figure><blockquote><p>纵坐标<strong>行</strong>向量需要<strong>转置</strong>变成<strong>列</strong>向量</p></blockquote></li></ul></li><li><p><code>plotyy</code>：双<code>y</code>轴绘图，绘制横坐标相同，但是纵坐标对应的变量量纲、范围等不同的图形。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plotyy(X1, Y1, X2, Y2)</span><br><span class="line">plotyy(X1, Y1, X2, Y2, FUN) <span class="comment">% FUN指定绘图函数如@plot/@semilogx/@semilogy@loglog</span></span><br><span class="line">plotyy(X1, Y1, X2, Y2, fun1, fun2)</span><br></pre></td></tr></table></figure><ul><li><p><code>Y1</code>默认在左侧，<code>Y2</code>默认在右侧。</p></li><li><p><code>plotyy</code><strong>不能够</strong>直接对曲线属性进行设置，需要使用<strong>句柄图形</strong>控制完成。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">  y1 = <span class="number">200</span> * <span class="built_in">exp</span>(<span class="number">-0.05</span> * x) .* <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="number">0.8</span> * <span class="built_in">exp</span>(<span class="number">-0.5</span> * x) .* <span class="built_in">sin</span>(<span class="number">10</span> * x);</span><br><span class="line">  [AX, H1, H2] = plotyy(x, y1, x, y2, <span class="string">'plot'</span>);</span><br><span class="line">pause;</span><br><span class="line">  set(H1, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>AX(1)</code>和<code>AX(2)</code>对应两侧坐标轴的句柄，表示坐标轴属性。</p></li><li><p><code>H1</code>和<code>H2</code>是对应的曲线的句柄，可以根据函数的返回值进行操作。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(H1, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>)</span><br><span class="line">set(H2, <span class="string">'LineStyle'</span>, <span class="string">':'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>semilogx</code>：<code>x</code>轴取对数（<strong>10</strong>为底）的绘图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semilogx(x, y, <span class="string">'-*'</span>)</span><br><span class="line">semilogy(x, <span class="number">10.</span>^x)</span><br></pre></td></tr></table></figure></li><li><p><code>semilogy</code></p></li><li><p><code>loglog</code>：两个维度上都取对数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">logspace</span>(<span class="number">-1</span>,<span class="number">2</span>); <span class="comment">% 10^-1 ~ 10^2</span></span><br><span class="line">loglog(x,<span class="built_in">exp</span>(x),<span class="string">'-s'</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><ul><li><code>logspace</code>：对数空间中，以10为底数生成值（和<code>linspace</code>对应）。</li></ul></li><li><p><code>polar</code>：极坐标图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polar(theta, rho)</span><br><span class="line">polar(theta, rho, s)</span><br></pre></td></tr></table></figure><ul><li><p><code>theta</code>是<strong>弧度制</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="number">2</span> * <span class="built_in">pi</span> / <span class="number">90</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(<span class="number">4</span> * t);</span><br><span class="line">polar(t, y);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h3><h4 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h4><ul><li><code>-</code>：实线</li><li><code>--</code>：虚线</li><li><code>:</code>：点线</li><li><code>-.</code>：点划线</li><li><code>none</code>：无线</li></ul><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><ul><li><code>b</code>：蓝色</li><li><code>g</code>：绿色</li><li><code>m</code>：红紫色</li><li><code>w</code>：白色</li><li><code>c</code>：蓝绿色</li><li><code>k</code>：黑色</li><li><code>r</code>：红色</li><li><code>y</code>：黄色</li></ul><h4 id="标记符号"><a href="#标记符号" class="headerlink" title="标记符号"></a>标记符号</h4><p>对曲线上有值的点进行标记</p><ul><li><code>*</code>：星号</li><li><code>x</code>：叉号</li><li><code>s</code>：方块</li><li><code>p</code>：五角星</li><li><code>^</code>/<code>&gt;</code>/<code>.</code>/<code>O</code>/<code>d</code>/<code>h</code>/<code>v</code>/<code>&lt;</code></li></ul><h4 id="图形属性"><a href="#图形属性" class="headerlink" title="图形属性"></a>图形属性</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">tan</span>(<span class="built_in">sin</span>(x)) - <span class="built_in">cos</span>(<span class="built_in">tan</span>(x));</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">'--rp'</span>, <span class="string">'LineWidth'</span>, <span class="number">3</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'k'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'m'</span>, <span class="string">'MarkerSize'</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure><ul><li><code>LineStyle</code></li><li><code>LineWidth</code></li><li><code>Marker</code>：数据点标记符号</li><li><code>MarkerSize</code>：标记符大小</li><li><code>MarkerEdgeColor</code>：标记符<strong>边缘</strong>颜色</li><li><code>MarkerFaceColor</code>：标记符<strong>填充</strong>颜色</li></ul><h4 id="文字标注"><a href="#文字标注" class="headerlink" title="文字标注"></a>文字标注</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">y1 = <span class="built_in">sin</span>(t); y2 = <span class="built_in">cos</span>(t); <span class="built_in">plot</span>(t, y1, <span class="string">'r'</span>, t, y2, <span class="string">'b--'</span>);</span><br><span class="line">x = [<span class="number">1.7</span> * <span class="built_in">pi</span>; <span class="number">1.6</span> * <span class="built_in">pi</span>];</span><br><span class="line">y = [<span class="number">-0.3</span>; <span class="number">0.8</span>];</span><br><span class="line">s = [<span class="string">'sin(t)'</span>; <span class="string">'cos(t)'</span>];</span><br><span class="line">text(x, y, s);</span><br><span class="line">title(<span class="string">'正弦和余弦曲线'</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'正弦'</span>, <span class="string">'余弦'</span>)</span><br><span class="line">xlabel(<span class="string">'时间t'</span>), ylabel(<span class="string">'正弦、余弦'</span>)</span><br><span class="line">grid</span><br><span class="line">axis square</span><br></pre></td></tr></table></figure><ul><li><p><code>title(s)</code>：图标题</p></li><li><p><code>xlabel(s)</code>：横坐标名</p></li><li><p><code>ylabel(s)</code></p></li><li><p><code>legend(s, position)</code>：在指定位置建立<strong>图例</strong>，按照绘图函数的<strong>参数顺序</strong>生成。</p><ul><li><code>s</code>：图例中的文字注释，可用<code>s1,s2,...</code>表示。</li><li><code>position</code>：指定图例位置<ul><li><code>0</code>：自动最佳位置（<strong>不</strong>覆盖原图）</li><li><code>1</code>：右上角<strong>（默认）</strong></li><li><code>2</code>：左上角</li><li><code>3</code>：左下角</li><li><code>4</code>：右下角</li><li><code>-1</code>：图<strong>右侧</strong></li></ul></li></ul></li><li><p><code>text(x, y, s)</code>：在<code>x</code>轴和<code>y</code>轴的指定位置添加<strong>文字注释</strong></p><blockquote><p><code>x</code>和<code>y</code>是值列表</p></blockquote></li></ul><h4 id="重叠绘图"><a href="#重叠绘图" class="headerlink" title="重叠绘图"></a>重叠绘图</h4><ul><li><code>hold on</code>：保持当前图形</li><li><code>hold off</code>：<strong>取消</strong>当前图形的保持功能</li><li><code>hold</code>：<strong>双向</strong>切换开关（对当前状态取反）</li></ul><h4 id="多子图绘制"><a href="#多子图绘制" class="headerlink" title="多子图绘制"></a>多子图绘制</h4><ul><li><p><code>subplot</code>：在一图形中同时显示<strong>多幅独立</strong>的子图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplot(m, n, k) <span class="comment">% m行n列个子图 k是子图编号</span></span><br><span class="line">subplot(<span class="string">'Position'</span>, [left bottom width height]) <span class="comment">% 在指定位置上分割子图 并成为当前图</span></span><br></pre></td></tr></table></figure><ul><li><p>所有子图<strong>彼此独立</strong>，绘图命令可以在子图中使用。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">y0 = <span class="built_in">sin</span>(t); y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t); y3 = <span class="built_in">cos</span>(<span class="number">2</span> * t);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">% 左上</span></span><br><span class="line"><span class="built_in">plot</span>(t, y0)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">% 右上</span></span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">% 左下</span></span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">% 右下</span></span><br><span class="line"><span class="built_in">plot</span>(t, y3)</span><br></pre></td></tr></table></figure><blockquote><p>注意和<code>legend</code>中的位置进行区分</p></blockquote></li><li><p>非等比例子图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">y0 = <span class="built_in">sin</span>(t); y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t); y3 = <span class="built_in">cos</span>(<span class="number">2</span> * t);</span><br><span class="line">positionVector1 = [<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">0.3</span>];</span><br><span class="line">subplot(<span class="string">'Position'</span>, positionVector1)</span><br><span class="line"><span class="built_in">plot</span>(t, y0)</span><br><span class="line">positionVector2 = [<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.3</span>];</span><br><span class="line">subplot(<span class="string">'Position'</span>, positionVector2)</span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line">subplot(<span class="string">'Position'</span>, [<span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>])</span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="多窗口绘图"><a href="#多窗口绘图" class="headerlink" title="多窗口绘图"></a>多窗口绘图</h4><ul><li><p><code>figure(n)</code>：创建绘图窗口，<code>n</code>是窗口顺序号。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(t);</span><br><span class="line">y1 = <span class="built_in">sin</span>(<span class="number">2</span> * t);</span><br><span class="line">y2 = <span class="built_in">cos</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(t, y)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t, y1)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(t, y2)</span><br></pre></td></tr></table></figure><blockquote><p><code>figure1</code><strong>不需要</strong>单独指定</p></blockquote></li></ul><h4 id="坐标轴控制"><a href="#坐标轴控制" class="headerlink" title="坐标轴控制"></a>坐标轴控制</h4><ul><li><p><code>axis</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">x = <span class="built_in">cos</span>(t);</span><br><span class="line">y = <span class="number">2</span> * <span class="built_in">sin</span>(t);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="built_in">plot</span>(x, y); title(<span class="string">'nomal'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="built_in">plot</span>(x, y); axis equal; title(<span class="string">'equal'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="built_in">plot</span>(x, y); axis square; title(<span class="string">'square'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="built_in">plot</span>(x, y); axis image; title(<span class="string">'image'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="built_in">plot</span>(x, y); axis tight; title(<span class="string">'tight'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>); <span class="built_in">plot</span>(x, y); axis off; title(<span class="string">'axis off'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="网格线与坐标框"><a href="#网格线与坐标框" class="headerlink" title="网格线与坐标框"></a>网格线与坐标框</h4><ul><li><code>grid</code><ul><li><code>grid on</code></li><li><code>grid off</code></li><li><code>grid</code></li></ul></li><li><code>box</code>：确定当前坐标框是否呈封闭形式（省略上框线和右框线）<ul><li><code>box on</code></li><li><code>box off</code></li><li><code>box</code></li></ul></li></ul><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul><li><p><code>bar</code>：垂直条形图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Y = <span class="built_in">round</span>(<span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">3</span>)*<span class="number">10</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">bar(Y,<span class="string">'grouped'</span>)</span><br><span class="line">title <span class="string">'Group'</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">bar(Y,<span class="string">'stacked'</span>)</span><br><span class="line">title <span class="string">'Stack'</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">bar(Y,<span class="number">2.0</span>)</span><br><span class="line">title <span class="string">'Width = 2.0’</span></span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>和<code>.*</code>的区别</p><ul><li><p>对于矩阵运算来说，<code>*</code>是标准的矩阵点乘。</p></li><li><p>对于矩阵和数字的运算来说，二者<strong>没有</strong>区别。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[a b c d]</span><br><span class="line"><span class="number">2.</span>*A=[<span class="number">2</span>*a  <span class="number">2</span>*b  <span class="number">2</span>*c  <span class="number">2</span>*d]</span><br><span class="line"><span class="number">2</span>*A=[<span class="number">2</span>*a  <span class="number">2</span>*b  <span class="number">2</span>*c  <span class="number">2</span>*d]</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p><code>barh</code>：水平条形图（横向是<code>Y</code>轴）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">barh(x, y, <span class="string">'grouped'</span>); <span class="comment">% groups by row</span></span><br><span class="line">title(<span class="string">'Grouped Style'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">barh(x, y, <span class="string">'stacked'</span>); <span class="comment">% stacks values in each row together</span></span><br><span class="line">title(<span class="string">'Stacked Style'</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">barh(x, y, <span class="string">'hist'</span>); <span class="comment">% centers bars over x values</span></span><br><span class="line">title(<span class="string">'hist Style'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>errorbar</code>：误差图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="built_in">pi</span>;</span><br><span class="line">Y = <span class="built_in">sin</span>(X);</span><br><span class="line">E = std(Y) * <span class="built_in">ones</span>(<span class="built_in">size</span>(X));</span><br><span class="line">errorbar(X, Y, E)</span><br></pre></td></tr></table></figure></li><li><p><code>area</code>：面积图，即填充曲线的积分面积。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span> / <span class="number">100</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="number">2</span> * <span class="built_in">sin</span>(t);</span><br><span class="line">area(t, y)</span><br></pre></td></tr></table></figure></li><li><p><code>hist</code>：柱形图，用于显示数据分布情况。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = <span class="built_in">randn</span>(<span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line">hist(y, x)</span><br><span class="line"><span class="comment">% 设置柱形图的效果</span></span><br><span class="line">h = findobj(gca, <span class="string">'Type'</span>, <span class="string">'patch'</span>);</span><br><span class="line">set(h, <span class="string">'FaceColor'</span>, <span class="string">'r'</span>, <span class="string">'EdgeColor'</span>, <span class="string">'w'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>柱形图和条形图的区别</p><ul><li>条形图用来表达数据间的比较关系，例如不同产品的销售情况。（自变量是产品种类）</li><li>柱形图用来展示数据的分布或趋势变化，自变量通常是<strong>量化数据</strong>。</li><li>柱形图不同柱一般<strong>不能</strong>重新排序，而条形图不同条<strong>可以任意</strong>重新排序。</li><li>柱形图各个柱之间通常<strong>没有</strong>空隙</li><li>柱形图的<strong>纵轴</strong>通常是横轴元素的<strong>计数结果</strong></li></ul></blockquote></li><li><p><code>stem</code>：火柴杆图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">25</span>;</span><br><span class="line">y = [<span class="built_in">exp</span>(<span class="number">-.07</span> * x) .* <span class="built_in">cos</span>(x); <span class="built_in">exp</span>(<span class="number">.05</span> * x) .* <span class="built_in">cos</span>(x)]';</span><br><span class="line">h = stem(x, y);</span><br><span class="line">set(h(<span class="number">1</span>), <span class="string">'MarkerFaceColor'</span>, <span class="string">'blue'</span>)</span><br><span class="line">set(h(<span class="number">2</span>), <span class="string">'MarkerFaceColor'</span>, <span class="string">'red'</span>, <span class="string">'Marker'</span>, <span class="string">'square'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>stairs</code>：阶梯图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-2</span> * <span class="built_in">pi</span>:<span class="built_in">pi</span> / <span class="number">10</span>:<span class="number">2</span> * <span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(x);</span><br><span class="line">stairs(x, y);</span><br></pre></td></tr></table></figure></li><li><p><code>pie</code>：扇形图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2.5</span> <span class="number">4.5</span> <span class="number">1.5</span> <span class="number">0.5</span>];</span><br><span class="line">explode = [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">pie(x, explode);</span><br><span class="line">colormap jet</span><br></pre></td></tr></table></figure></li><li><p><code>compass</code>：罗盘图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">randn</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">%实部对应的数据</span></span><br><span class="line">v = <span class="built_in">randn</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">%虚部对应的数据</span></span><br><span class="line">z = <span class="built_in">exp</span>(<span class="built_in">i</span> * <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">6</span>)); <span class="comment">%复数数组</span></span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">compass(u, v)<span class="comment">%利用实部与虚部绘制罗盘图</span></span><br><span class="line">xlabel(<span class="string">'(a) 利用实部与虚部绘制罗盘图'</span>);</span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">compass(z); <span class="comment">%利用复数绘制罗盘图</span></span><br><span class="line">xlabel(<span class="string">'(b) 利用复数绘制罗盘图'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>feather</code>：羽毛图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">theta = (<span class="number">-90</span>:<span class="number">10</span>:<span class="number">90</span>) * <span class="built_in">pi</span> / <span class="number">180</span>;</span><br><span class="line">r = <span class="number">2</span> * <span class="built_in">ones</span>(<span class="built_in">size</span>(theta));</span><br><span class="line"><span class="comment">%将极坐标系转换为笛卡儿坐标系</span></span><br><span class="line">[u, v] = <span class="built_in">pol2cart</span>(theta, r);</span><br><span class="line">feather(u, v);</span><br></pre></td></tr></table></figure></li></ul><h2 id="三维图形"><a href="#三维图形" class="headerlink" title="三维图形"></a>三维图形</h2><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p><code>plot3</code>：调用格式和<code>plot</code>一致</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot3</span>(x, y, z, <span class="string">'r*-'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>ezplot3</code>：对符号函数进行绘制</li></ul></li><li><p><code>mesh</code>：网格图函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x, y, z] = peaks(<span class="number">30</span>);</span><br><span class="line">mesh(x, y, z)</span><br></pre></td></tr></table></figure><ul><li><code>ezmesh</code>：符号函数的网格图绘制</li></ul></li><li><p><code>surf</code>：对网格进行填充</p><ul><li><code>ezsurf</code></li></ul></li><li><p><code>meshgrid</code>：生成二元函数$z=f(x,y)$中$X-Y$平面上的句型定义域中的数据点矩阵$X$和$Y$.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[X, Y] = <span class="built_in">meshgrid</span>(<span class="number">-2</span>:<span class="number">.2</span>:<span class="number">2</span>, <span class="number">-2</span>:<span class="number">.2</span>:<span class="number">2</span>);</span><br><span class="line">Z = X .* <span class="built_in">exp</span>(-X.^<span class="number">2</span> - Y.^<span class="number">2</span>);</span><br><span class="line">surf(X, Y, Z)</span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊情况-1"><a href="#特殊情况-1" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul><li><code>bar3</code></li><li><code>bar3h</code></li><li><code>cylinder</code></li><li><code>sphere</code></li><li><code>stem3</code></li><li><code>contour3</code></li><li><code>waterfall</code></li><li><code>pie3</code></li><li><code>surfnorm</code></li></ul><h3 id="修饰-1"><a href="#修饰-1" class="headerlink" title="修饰"></a>修饰</h3><ul><li><p><code>view</code>：控制三维图形的观察点和视角</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view(AZ, EL)</span><br></pre></td></tr></table></figure><ul><li><p><code>AZ</code>：方位角，<strong>角度制</strong>。</p><blockquote><p>绕<code>Z</code>轴<strong>顺时针为正</strong>，逆时针为负。</p></blockquote></li><li><p><code>EL</code>：仰角</p></li></ul></li><li><p><code>colormap</code>：图形颜色</p></li><li><p><code>alpha</code>：透明度</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha(v) <span class="comment">% v介于0和1之间 表示透明度大小</span></span><br><span class="line">alpha(<span class="string">'x'</span>) <span class="comment">% 随x变大透明度值变大</span></span><br><span class="line">alpha(<span class="string">'rand'</span>) <span class="comment">% 随机设置透明度</span></span><br></pre></td></tr></table></figure><ul><li>透明度值<strong>越大</strong>，图像越<strong>不透明</strong>。</li></ul></li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul><h1 id="Chapter6-图像处理"><a href="#Chapter6-图像处理" class="headerlink" title="Chapter6 图像处理"></a>Chapter6 图像处理</h1><p>全文共<code>3427</code>字，推荐阅读时间<code>25~30</code>分钟。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><p>采样（空间离散）：将连续图像变化为离散点的操作，即将图像划分为$M * N$网格，每个网格只提取出一个值。</p><blockquote><ul><li>上采样（图像插值、放大）：放大原图像，从而可以显示在更高分辨率的显示设备上。</li><li>下采样（池化、缩小）：使得图像符合显示区域的大小；生成对应图像的缩略图；降低特征的维度并保留有效信息，一定程度上避免过拟合，保持旋转、平移、伸缩不变形。</li></ul></blockquote></li><li><p>分辨率：采样划分网格矩阵的形状尺寸</p></li><li><p>量化（灰度离散）：确定离散点数值表示的位数，反映了采样的质量。</p><ul><li><p>灰度图：1个通道，每个离散点8bit(0-255).</p><blockquote><ul><li>256个值对应的是从黑到白的不同<strong>亮度</strong>等级，<code>0</code>是纯黑，<code>255</code>是纯白。</li><li>彩色图中的RGB值也并不是各个颜色的“浓度”，只是三个分量的灰度值，分别命名为R，G，B.也就是说，RGB图各分量<strong>并不是</strong>彩色的，而是三张灰度图，RGB只是一种来自三原色的命名。</li><li>当三色灰度”效果“相同时，产生不同灰度值的灰色调。<ul><li><code>Gray = R*0.299 + G*0.587 + B*0.114</code>（心理学公式）</li><li><code>Gray = (R*299 + G*587 + B*114 + 500) / 1000</code></li></ul></li></ul></blockquote></li><li><p>二值图：1个通道，每个离散点1bit(0-1).</p></li><li><p>彩色图：3个通道（3张灰度图），各个通道每个离散点8bit(0-255)，合成为24bit.</p><ul><li><p>以红色椅子的显示为例。</p><p>R分量的图上，椅子对应的部分比较浅（灰度值高），而在G分量和了B分量上很深。<br>随便在椅子上取一个样点，其灰度值分别是（R:179,G:45,B:9）。所以在显示的时候，红色通道里灰度值大，绿色通道和蓝色通道里的灰度值小，显示出来的就是红色。</p><blockquote><p>用灰度图的<strong>亮暗</strong>来表示三种颜色的浓度，每个通道就是指定了颜色的”颜料“，然后合并出不同的颜色，和自然界中的光的合成<strong>并不相同</strong>。</p></blockquote></li></ul></li></ul><blockquote><p>视频尺寸：时域离散*空域（空间）离散*灰度离散=<u>FPS</u>*<u>1080*720</u>*<u>3*8</u></p></blockquote></li><li><p>矢量图（图形）：一般由轮廓线构成，是用软件绘制的。不易失真，但是颜色相对没有那么丰富。</p></li><li><p>点阵图（位图，图像）：设备捕捉实际画面产生的数字矩阵，存储空间大，颜色丰富。</p></li></ul><h2 id="类型及转换"><a href="#类型及转换" class="headerlink" title="类型及转换"></a>类型及转换</h2><ul><li><p>格式</p><ul><li><p><code>double</code>：亮度值范围是<code>[0,1]</code></p><blockquote><p>通常使用<code>double</code>减少图像失真</p></blockquote></li><li><p><code>uint8</code>：亮度值范围是<code>[0,255]</code></p></li></ul></li><li><p>真彩色图像</p><ul><li>大小：<code>m*n*3</code></li><li>红色分量：<code>(:,:,1)</code>（绿色，蓝色同理）</li></ul></li><li><p>索引图像：创建调色板及对应的索引图，使用索引下标表示图像的每个像素点。</p><ul><li>调色板中色彩强度范围是<code>[0,1]</code>，大小和亮度成正比。</li><li>使用索引可以有效节省存储空间</li></ul></li><li><p>图像序列</p><ul><li><p>合并</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">cat</span> (<span class="number">1</span>，A1，A2，A3，A4，A5) <span class="comment">%按列连接（列数相同）</span></span><br><span class="line">A = <span class="built_in">cat</span> (<span class="number">2</span>，A1，A2，A3，A4，A5) <span class="comment">%按行连接（行数相同）</span></span><br><span class="line">A = <span class="built_in">cat</span> (<span class="number">3</span>，A1，A2，A3，A4，A5) <span class="comment">%按矩阵连接（行列数相同）</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cat</code>的参数是几就是<strong>改变</strong>第几维</p></blockquote></li></ul></li></ul><h2 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p><code>imread</code>：读入图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=imread(filename, fmt) <span class="comment">% imread('filename.fmt')</span></span><br><span class="line">[A, map]=imread(filename, fmt) <span class="comment">% index image</span></span><br></pre></td></tr></table></figure><ul><li>读入的图像大多数为<code>uint8</code>，对于索引图则将颜色映象表存储为双精度浮点型矩阵。</li><li>如果将<code>filename</code>和<code>fmt</code>合并，则需要保证<code>filename.fmt</code>后缀的合法性。</li></ul></li><li><p><code>imwrite</code>：输出图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imwrite(A, filename, fmt) <span class="comment">% imwrite(A, 'filename.fmt')</span></span><br><span class="line">imwrite(A, map, filename, fmt)</span><br></pre></td></tr></table></figure></li><li><p><code>imfinfo</code>：获取图片信息</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imfinfo(<span class="string">'filename.fmt'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>load/save</code>：使用<code>.mat</code>文件管理图片</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lena=imread(<span class="string">'lena.jpg'</span>); </span><br><span class="line">imshow(lena);</span><br><span class="line">save lena; <span class="comment">%保存图像数据，生成lena.mat</span></span><br><span class="line">clear;</span><br><span class="line">load lena;</span><br><span class="line"><span class="built_in">figure</span>, imshow(lena);</span><br></pre></td></tr></table></figure></li></ul><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><ul><li><p>灰度图</p><ul><li><p>格式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imshow(I)</span><br><span class="line">imshow(I, n) <span class="comment">% n为显示灰度级数目，缺省值为256.</span></span><br><span class="line">imshow(I, [low high]) <span class="comment">% [low high]为图像数据的值域，范围外的取0或255.</span></span><br><span class="line">imshow(I, []) <span class="comment">% 默认显示范围为[min(I(:);), max(I(:);)]</span></span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(I);</span><br><span class="line"><span class="comment">%设置显示的范围，低于100的全黑，高于200的全白</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,[<span class="number">100</span> <span class="number">200</span>]);</span><br><span class="line"><span class="comment">%设置灰度级别为2; 部分版本不支持</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%设置灰度级别为8 ; 同上</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">8</span>);</span><br><span class="line"><span class="comment">%设置灰度级别为全256 ; 同上</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I,<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二值图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BW=imread(<span class="string">'circles.png'</span>);</span><br><span class="line">imshow(BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(~BW);</span><br></pre></td></tr></table></figure></li><li><p>索引图像</p><ul><li><p>格式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imshow(X, map);</span><br></pre></td></tr></table></figure><ul><li><code>map</code>是一个p×3的矩阵，元素值均为[0, 1]之间双精度浮点型数据。每一行分别表示红、绿、蓝的颜色值。</li><li>如一幅包含256色的uint8<strong>索引图像</strong>，使用一个仅有16色的调色板显示，则所有索引值大于或等于15的像素都将被显示为调色板的最后一个颜色。</li><li>常用后缀名：<code>.tiff</code>/<code>.tif</code></li></ul></li><li><p>实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X=imread(<span class="string">'cameraman.tif'</span>); </span><br><span class="line">imshow(X); </span><br><span class="line">colorbar;</span><br><span class="line">map=pink(<span class="number">256</span>); <span class="comment">%借助不同的调色板显示图像</span></span><br><span class="line"><span class="built_in">figure</span>, imshow(X,map); colorbar; <span class="comment">%显示颜色条</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>彩色图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%调整RGB的显示顺序</span></span><br><span class="line">img=imread(<span class="string">'i.png'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(img);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(img(:,:,[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]));</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>), imshow(img(:,:,[<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]));</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>), imshow(img(:,:,[<span class="number">3</span> <span class="number">1</span> <span class="number">2</span>]));</span><br></pre></td></tr></table></figure><blockquote><p>Q：RGB的顺序为什么对显示效果有影响</p><p>A：不同通道对应的”颜料“不同，成像时根据放进该通道的<strong>灰度图分量</strong>的灰度值，来决定显示的颜色。</p></blockquote></li></ul><h2 id="代数运算"><a href="#代数运算" class="headerlink" title="代数运算"></a>代数运算</h2><ul><li><p><code>imadd</code>：加法，数值变大。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line"><span class="comment">%图像整体亮度增加</span></span><br><span class="line">J=imadd(I, <span class="number">50</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(J);</span><br></pre></td></tr></table></figure><ul><li>超出范围的部分<strong>不会</strong>溢出，而是取<strong>边界值</strong>。</li></ul><blockquote><ul><li>图像增强</li><li>图像重叠</li><li>水印加密</li><li>图像去噪</li></ul></blockquote></li><li><p><code>imsubtract</code>：减法，数值变小。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line">J=imsubtract(I, <span class="number">50</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), imshow(J);</span><br></pre></td></tr></table></figure></li><li><p><code>immultiply</code></p><ul><li><p><code>immultiply(I, n)</code>：亮度缩放</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lena.jpg'</span>);</span><br><span class="line">J = immultiply(I,<span class="number">0.5</span>);</span><br><span class="line">K = immultiply(I,<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>), imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>), imshow(J)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>), imshow(K)</span><br></pre></td></tr></table></figure></li><li><p><code>immultiply(I, mask)</code>：掩模</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Img=imread(<span class="string">'pears.png'</span>);</span><br><span class="line">subplot(<span class="number">131</span>), imshow(Img);</span><br><span class="line">Mask=imread(<span class="string">'PearMask.bmp'</span>);</span><br><span class="line">subplot(<span class="number">132</span>), imshow(Mask);</span><br><span class="line">PearR=immultiply(Img(:,:,<span class="number">1</span>),Mask);</span><br><span class="line">PearG=immultiply(Img(:,:,<span class="number">2</span>),Mask);</span><br><span class="line">PearB=immultiply(Img(:,:,<span class="number">3</span>),Mask);</span><br><span class="line">Pear=<span class="built_in">cat</span>(<span class="number">3</span>,PearR,PearG,PearB);</span><br><span class="line">subplot(<span class="number">133</span>), imshow(Pear);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>imdivide</code></p><ul><li><p><code>imdivide(I, n)</code>：亮度缩放</p></li><li><p><code>imdivide(I, J)</code>：去除背景</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'rice.png'</span>);</span><br><span class="line">subplot(<span class="number">131</span>),imshow(I);</span><br><span class="line">background = imopen(I,strel(<span class="string">'disk'</span>,<span class="number">15</span>));</span><br><span class="line">subplot(<span class="number">132</span>), imshow(background);</span><br><span class="line">Ip = imdivide(I,background);</span><br><span class="line">subplot(<span class="number">133</span>),imshow(Ip,[])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>直接线性运算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I)</span><br><span class="line">J=(double(I))*<span class="number">1.5</span>+<span class="number">30</span>;</span><br><span class="line"><span class="built_in">figure</span>, imshow(uint8(J))</span><br><span class="line">K=(double(I))*<span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">figure</span>, imshow(uint8(K));</span><br></pre></td></tr></table></figure></li></ul><h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><ul><li><p><code>imtransform(I, T, Interp)</code>：二维空间</p><ul><li><code>T</code>：变换结构，由<code>maketform</code>产生。</li><li><code>Interp</code>：插值方法</li></ul></li><li><p>仿射变换</p><p><img src="https://i.loli.net/2020/11/19/E5Sm6GgzvuiwZOn.png" alt="image-20201119133406026" style="zoom:50%;" /></p><ul><li><p>平移</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[height,width,dim]=<span class="built_in">size</span>(A);</span><br><span class="line">tform=maketform(<span class="string">'affine'</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">20</span> <span class="number">30</span> <span class="number">1</span>]); <span class="comment">% downward</span></span><br><span class="line">B = imtransform(A,tform,<span class="string">'nearest'</span>,<span class="string">'XData'</span>,[<span class="number">1</span></span><br><span class="line"><span class="built_in">size</span>(A,<span class="number">2</span>)],<span class="string">'YData'</span>,[<span class="number">1</span> <span class="built_in">size</span>(A,<span class="number">1</span>)])</span><br><span class="line">subplot(<span class="number">121</span>);imshow(A);</span><br><span class="line">subplot(<span class="number">122</span>); imshow(B);</span><br></pre></td></tr></table></figure></li><li><p>镜像</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[height,width,dim]=<span class="built_in">size</span>(A);</span><br><span class="line">tform=maketform(<span class="string">'affine'</span>,[<span class="number">-1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]); <span class="comment">% horizontal</span></span><br><span class="line">B=imtransform(A,tform,<span class="string">'nearest'</span>);</span><br><span class="line">tform2=maketform(<span class="string">'affine'</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]); <span class="comment">% vertical</span></span><br><span class="line">C=imtransform(A,tform2,<span class="string">'nearest'</span>);</span><br><span class="line">subplot(<span class="number">131</span>); imshow(A);</span><br><span class="line">subplot(<span class="number">132</span>); imshow(B);</span><br><span class="line">subplot(<span class="number">133</span>); imshow(C);</span><br></pre></td></tr></table></figure></li><li><p>旋转</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">transformtype = <span class="string">'affine'</span>;</span><br><span class="line">transformmatrix = [<span class="built_in">cos</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="number">0</span>;</span><br><span class="line">   -<span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="built_in">cos</span>(<span class="built_in">pi</span>/<span class="number">6</span>) <span class="number">0</span>;</span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]; <span class="comment">% rotate 30 degrees</span></span><br><span class="line">T = maketform(transformtype,transformmatrix);</span><br><span class="line">nI = imtransform(I,T);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(nI)</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>imrotate(A, angle)</code>，指定<code>crop</code>参数后会裁剪新图以维持画布大小不变，</p></blockquote></li><li><p>缩放</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>); <span class="built_in">figure</span>, imshow(I)</span><br><span class="line">transformtype = <span class="string">'affine'</span>;</span><br><span class="line">transformmatrix1 = [<span class="number">0.5</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0.5</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">transformmatrix2 = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">2</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">T1 = maketform(transformtype,transformmatrix1);</span><br><span class="line">T2 = maketform(transformtype,transformmatrix2);</span><br><span class="line">nI1 = imtransform(I,T1);</span><br><span class="line">nI2 = imtransform(I,T2);</span><br><span class="line"><span class="built_in">figure</span>,imshow(nI1)</span><br><span class="line"><span class="built_in">figure</span>,imshow(nI2)</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>imresize(A, times)</code>，默认等比例缩放。</p></blockquote></li></ul></li><li><p>投影变换：将二维图像按照“近大远小”的规则投影到一个平面，追求立体感。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">transformtype = <span class="string">'projective'</span>;</span><br><span class="line">transformmatrix1 =[<span class="number">0.8</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">-0.2</span> <span class="number">0.8</span> <span class="number">-0.003</span>; <span class="number">3.5</span> <span class="number">1.5</span> <span class="number">1.5</span>];</span><br><span class="line">T = maketform(transformtype,transformmatrix1);</span><br><span class="line">nI = imtransform(I,T);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(nI);</span><br></pre></td></tr></table></figure><blockquote><ul><li>对失真图像进行逆变换，就可以得到正常比例的图像。</li><li>仿射变换可看作是一种特殊的投影变换。它要求变换矩阵的最后一列除最后一个元素为<code>1</code>之外，其它的均为<code>0</code>。</li></ul></blockquote></li><li><p><code>imcrop</code>：图像裁剪</p><ul><li><p>指定区域</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = imread(<span class="string">'liftingbody.png'</span>);</span><br><span class="line">pc = imcrop(p,[<span class="number">80</span> <span class="number">180</span> <span class="number">260</span> <span class="number">220</span>]); <span class="comment">%输入矩形尺度进行选取</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>); imshow(p);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>); imshow(pc);</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>参数格式：<code>[left, bottom, width, height]</code></p></blockquote><ul><li><p><code>roipoly</code>：多边形裁剪</p><ul><li><p>人工选区</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Img=imread(<span class="string">'pears.png'</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(Img)</span><br><span class="line">bw=roipoly(Img); <span class="comment">%设定区域，用鼠标选择多边形区域</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(bw) <span class="comment">%用二值色彩显示多边形区域</span></span><br><span class="line">r=Img (:,:,<span class="number">1</span>); g=Img (:,:,<span class="number">2</span>);b=Img (:,:,<span class="number">3</span>);</span><br><span class="line">cr=bw.*double(r); cg=bw.*double(g);cb=bw.*double(b);</span><br><span class="line">J=<span class="built_in">cat</span>(<span class="number">3</span>,uint8(cr),uint8(cg),uint8(cb)); <span class="comment">%联结数组作为图像色彩</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(J)</span><br></pre></td></tr></table></figure></li><li><p>指定顶点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'eight.tif'</span>);</span><br><span class="line">c = [<span class="number">222</span> <span class="number">272</span> <span class="number">300</span> <span class="number">270</span> <span class="number">221</span> <span class="number">194</span>];</span><br><span class="line">r = [<span class="number">21</span> <span class="number">21</span> <span class="number">75</span> <span class="number">121</span> <span class="number">121</span> <span class="number">75</span>];</span><br><span class="line">BW = roipoly(I,c,r);</span><br><span class="line">Ic=immultiply(I, BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I)</span><br><span class="line"><span class="built_in">figure</span>, imshow(BW)</span><br><span class="line"><span class="built_in">figure</span>, imshow(Ic)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h2><ul><li><p><code>imadjust</code>：对某一区间内的灰度值进行变换，从而符合人眼的非线性特征。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'pout.tif'</span>); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>); imshow(I);</span><br><span class="line">J=imadjust(I); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>); imshow(J); <span class="comment">% default gamma = 1</span></span><br><span class="line">K=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>); imshow(K);</span><br><span class="line">L=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>], <span class="number">2</span>); <span class="comment">% gamma = 2</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); imshow(L);</span><br><span class="line">M=imadjust(I,[<span class="number">0.3</span> <span class="number">0.7</span>],[<span class="number">0</span> <span class="number">0.4</span>], <span class="number">0.3</span>); <span class="comment">% gamma = 0.3</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>); imshow(M);</span><br><span class="line">N=imadjust(I,[<span class="number">0</span> <span class="number">1</span>],[<span class="number">1</span> <span class="number">0</span>]); subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>); imshow(N);</span><br></pre></td></tr></table></figure><ul><li>不指定参数时，默认处理最高和最低的<code>1%</code>，从而提高图像饱和度。</li><li><code>gamma</code>越大，图像亮度越大。</li></ul></li><li><p><code>imhist</code>：灰度分布直方图</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), imshow(I);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), imhist(I);</span><br></pre></td></tr></table></figure><ul><li>可以通过参数指定灰度等级数</li><li>占满整个区间的图像通常质量更高</li></ul></li><li><p><code>histeq</code>：直方图均衡化</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'pout.tif'</span>);</span><br><span class="line">subplot(<span class="number">221</span>),imshow(I);title(<span class="string">'原图'</span>);</span><br><span class="line">subplot(<span class="number">222</span>),imhist(I);title(<span class="string">'原图直方图'</span>);</span><br><span class="line">hI=histeq(I);</span><br><span class="line">subplot(<span class="number">223</span>),imshow(hI);</span><br><span class="line">title(<span class="string">'原图均衡化处理'</span>);</span><br><span class="line">subplot(<span class="number">224</span>),imhist(hI);</span><br><span class="line">title(<span class="string">'均衡处理后直方图'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h2><ul><li><p>平滑</p><ul><li>低通滤波：低频段保留</li><li>均值滤波</li><li>中值滤波</li></ul></li><li><p>锐化</p><ul><li>高通滤波：高频段保留</li></ul></li><li><p><code>imnoise</code>：模拟图像噪声</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'coins.png'</span>);</span><br><span class="line">J=imnoise(I, <span class="string">'salt &amp; pepper'</span>,<span class="number">0.06</span>); <span class="comment">%添加椒盐噪声</span></span><br><span class="line">subplot(<span class="number">221</span>),imshow(I),title(<span class="string">'原图'</span>)</span><br><span class="line">subplot(<span class="number">222</span>),imshow(J),title(<span class="string">'含椒盐噪声图'</span>)</span><br><span class="line">H = fspecial(<span class="string">'average'</span>,[<span class="number">3</span> <span class="number">4</span>]); <span class="comment">%设计均值滤波器H</span></span><br><span class="line">am = imfilter(J,H);<span class="comment">%均值滤波</span></span><br><span class="line">subplot(<span class="number">223</span>),imshow(am),title(<span class="string">'均值滤波'</span>)</span><br><span class="line">zm=medfilt2(J);<span class="comment">%中值滤波</span></span><br><span class="line">subplot(<span class="number">224</span>),imshow(zm),title(<span class="string">'中值滤波‘)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="边缘检测与分割"><a href="#边缘检测与分割" class="headerlink" title="边缘检测与分割"></a>边缘检测与分割</h2><ul><li><p><code>edge</code>：边缘处值为1，否则为0.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">[e1,s1] = edge(p,<span class="string">'sobel'</span>,<span class="number">0.03</span>,<span class="string">'both'</span>); <span class="comment">% sobel算子</span></span><br><span class="line">[e2,s2] = edge(p,<span class="string">'roberts'</span>,<span class="number">0.03</span>,<span class="string">'both'</span>); <span class="comment">% roberts算子</span></span><br><span class="line">[e3,s3] = edge(p,<span class="string">'prewitt'</span>,<span class="number">0.04</span>,<span class="string">'both'</span>); <span class="comment">% prewitt算子</span></span><br><span class="line">[e4,s4] = edge(p, <span class="string">'log'</span>,<span class="number">0.003</span>,<span class="number">2.10</span>); <span class="comment">% LoG算子</span></span><br><span class="line">[e5,s5] = edge(p, <span class="string">'canny'</span>,[<span class="number">0.05</span> <span class="number">0.12</span>],<span class="number">1.6</span>); <span class="comment">%canny算子</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>),imshow(p);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>),imshow(e1);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),imshow(e2);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);imshow(e3);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>),imshow(e4);subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>),imshow(e5);</span><br></pre></td></tr></table></figure></li><li><p><code>imcontour</code>：轮廓提取函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'lenaG.bmp'</span>);</span><br><span class="line">subplot(<span class="number">131</span>), imcontour(I,<span class="number">1</span>)</span><br><span class="line">subplot(<span class="number">132</span>), imcontour(I,<span class="number">2</span>)</span><br><span class="line">subplot(<span class="number">133</span>), imcontour(I,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>阈值分割</p><ul><li><p>极小值点</p></li><li><p>迭代</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p= imread(<span class="string">'bugs.bmp'</span>);</span><br><span class="line">p=rgb2gray(p); p=im2double(p); <span class="comment">%转换为double</span></span><br><span class="line">thresh = <span class="number">0.5</span>*(<span class="built_in">min</span>(p(:)) + <span class="built_in">max</span>(p(:))); <span class="comment">%初值为中间值</span></span><br><span class="line">flag = <span class="built_in">false</span>; <span class="comment">%迭代步长控制</span></span><br><span class="line"><span class="keyword">while</span> ~flag</span><br><span class="line">g = p&gt;=thresh; <span class="comment">%按当前阈值划分</span></span><br><span class="line">thresh_1= <span class="number">0.5</span>*(<span class="built_in">mean</span>(p(g)) + <span class="built_in">mean</span>(p(~g))); <span class="comment">%新阈值</span></span><br><span class="line">flag = <span class="built_in">abs</span>(thresh - thresh_1)&lt;<span class="number">0.5</span>; <span class="comment">%更新迭代标志</span></span><br><span class="line">thresh = thresh_1; <span class="comment">%更新阈值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>最大方差</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p= imread(<span class="string">'bugs.bmp'</span>);</span><br><span class="line">p1=rgb2gray(p);</span><br><span class="line">thresh = graythresh(p1); <span class="comment">%使用Ostu算法求得新阈值</span></span><br><span class="line">g = im2bw(p1,thresh); <span class="comment">%使用thresh对图像进行分割</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>), imshow(p);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>roifilt2</code>：特定区域增强</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'pout.tif'</span>);</span><br><span class="line">imshow(I)</span><br><span class="line">BW = roipoly(I);</span><br><span class="line">H = fspecial(<span class="string">'unsharp'</span>);</span><br><span class="line">J = roifilt2(H,I,BW);</span><br><span class="line"><span class="built_in">figure</span>, imshow(J)</span><br></pre></td></tr></table></figure></li><li><p><code>roifill</code>：区域填充</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I=ind2gray(X,map);</span><br><span class="line"><span class="built_in">figure</span>,imshow(I)</span><br><span class="line">J=roifill;</span><br><span class="line"><span class="built_in">figure</span>,imshow(J)</span><br></pre></td></tr></table></figure></li></ul><h2 id="直线检测"><a href="#直线检测" class="headerlink" title="直线检测"></a>直线检测</h2><ul><li><p>基本思想：点-线对偶性，<code>xy</code>平面上直线，对应参数<code>ab</code>平面上的一个点。</p><ul><li>过<code>xy</code>平面一个点<code>(x,y)</code>的所有直线，构成参数<code>ab</code>平面上的一条直线。</li><li>如果点<code>(x1,y1)</code>与点<code>(x2,y2)</code>共线，那么这两点在参数<code>ab</code>平面上的直线将有一个交点。</li><li>在参数<code>ab</code>平面上相交直线最多的点，对应的<code>xy</code>平面上的直线就是需要的解。</li></ul></li><li><p><code>hough</code>：霍夫变换</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'circuit.tif'</span>);</span><br><span class="line">I = imrotate(I,<span class="number">33</span>,<span class="string">'crop'</span>);</span><br><span class="line"><span class="built_in">figure</span>, imshow(I), <span class="built_in">hold</span> on</span><br><span class="line">BW = edge(I,<span class="string">'canny'</span>);</span><br><span class="line">[H,T,R] = hough(BW);</span><br><span class="line"><span class="built_in">figure</span>; imshow(H,[],<span class="string">'XData'</span>,T,<span class="string">'YData'</span>,R,<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);</span><br><span class="line">xlabel(<span class="string">'\theta'</span>), ylabel(<span class="string">'\rho'</span>);</span><br><span class="line">axis on, axis normal, <span class="built_in">hold</span> on;</span><br></pre></td></tr></table></figure></li><li><p><code>houghpeaks</code>：霍夫变换矩阵中的极值点</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P = houghpeaks(H,<span class="number">3</span>,<span class="string">'threshold'</span>,<span class="built_in">ceil</span>(<span class="number">0.3</span>*<span class="built_in">max</span>(H(:))));</span><br><span class="line">x = T(P(:,<span class="number">2</span>));</span><br><span class="line">y = R(P(:,<span class="number">1</span>));</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">'s'</span>,<span class="string">'color'</span>,<span class="string">'white'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>houghlines</code>：从霍夫变换矩阵中提取线段</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lines = houghlines(BW,T,R,P,<span class="string">'FillGap'</span>,<span class="number">25</span>,<span class="string">'MinLength'</span>,<span class="number">40</span>);</span><br><span class="line">max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">length</span>(lines)</span><br><span class="line">xy = [lines(k).point1; lines(k).point2];</span><br><span class="line"><span class="built_in">plot</span>(xy(:,<span class="number">1</span>),xy(:,<span class="number">2</span>),<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'green'</span>);</span><br><span class="line"><span class="comment">% Plot beginnings and ends of lines</span></span><br><span class="line"><span class="built_in">plot</span>(xy(<span class="number">1</span>,<span class="number">1</span>),xy(<span class="number">1</span>,<span class="number">2</span>),<span class="string">'x'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'yellow'</span>);</span><br><span class="line"><span class="built_in">plot</span>(xy(<span class="number">2</span>,<span class="number">1</span>),xy(<span class="number">2</span>,<span class="number">2</span>),<span class="string">'x'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'red'</span>);</span><br><span class="line"><span class="comment">% Determine the endpoints of the longest line segment</span></span><br><span class="line">len = norm(lines(k).point1 - lines(k).point2);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; max_len)</span><br><span class="line">max_len = len; xy_long = xy;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% highlight the longest line segment</span></span><br><span class="line"><span class="built_in">plot</span>(xy_long(:,<span class="number">1</span>),xy_long(:,<span class="number">2</span>),<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'Color'</span>,<span class="string">'blue'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>拓展：霍夫变换同样可以适用于圆的检测，此时需要三个参数的参数空间。</p></blockquote><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA MATLAB Lecture, Autumn of 2020.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2020 BUAA MATLAB course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/JavaScript%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/JavaScript%20Learning%20Note/</id>
    <published>2021-06-23T12:41:59.122Z</published>
    <updated>2021-06-23T12:44:32.912Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of frontend language JavaScript.</strong></p><a id="more"></a><h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><p>全文共<code>2099</code>字，推荐阅读时间<code>10~15</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">'Hello, world'</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>也可以把JavaScript代码放到一个单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src = &quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/js/abc.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li><p>语句以<code>;</code>结束，语句块用<code>{...}</code>.</p><blockquote><p>和Java相同</p></blockquote></li><li><p>注释</p><ul><li>行：<code>//</code></li><li>块：<code>/*...*/</code></li></ul></li></ul><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ul><li><p>Number</p><p>不区分整数和浮点数，统一用Number表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>;</span><br><span class="line"><span class="number">0.456</span>;</span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// Not a Number 表示无法计算的结果</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// 无限大</span></span><br></pre></td></tr></table></figure></li><li><p>字符串</p><p>单引号或双引号括起来的文本</p></li><li><p>布尔值</p><ul><li><p><code>true</code>/<code>false</code></p></li><li><p>逻辑运算：<code>&amp;&amp;</code>/<code>||</code>/<code>!</code></p></li><li><p>比较运算符</p><ul><li><p><code>==</code>：<strong>会自动转换</strong>数据类型，可能得到奇怪的结果。</p></li><li><p><code>===</code>：<strong>不会自动转换</strong>数据类型，类型不一致会返回<code>false</code>.</p><blockquote><p>使用<code>===</code>进行比较</p></blockquote></li><li><p><code>NaN</code>和其他所有值都不相等，<strong>包括自己</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>通过<code>isNaN</code>对NaN进行判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);</span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ul></li><li><p><code>null</code>/<code>undefined</code></p><p>  两者意义相近，通常使用<code>null</code>，<code>undefined</code>仅在<strong>判断函数参数是否传递</strong>的情况下有用。</p></li><li><p>数组</p><ul><li><p>可以包括任意数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li><li><p>创建数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象</p><p>  一组由键值对组成的<strong>无序</strong>集合</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">'js'</span>, <span class="string">'web'</span>],</span><br><span class="line">    zipcode: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>key都是<strong>字符串</strong>类型</li><li>value可以是<strong>任意</strong>数据类型</li><li>使用<code>person.name</code>访问值</li></ul></li><li><p>变量</p><p>  JavaScript是<strong>动态语言</strong></p><ul><li><p>声明变量</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// $ can be used as a part of var name</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>显示变量内容：<code>console.log(x)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>alert</code>会弹出对话框，但是<code>console.log</code>不会。</li><li><code>log</code>会自动增加<strong>换行</strong></li></ul></blockquote></li><li><p>strict模式</p><ul><li><p>如果声明变量时<strong>不</strong>使用<code>var</code>，则变量就会被声明为<strong>全局变量</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>strict模式在遇到<strong>未使用</strong><code>var</code>声明的变量时会报错</p></li><li><p>开启strict模式：在第一行写上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>尽量在所有的<code>.js</code>文件中都启用strict模式</p></blockquote></li></ul></li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>多行字符串</p><p>用反引号<strong>`</strong>表示</p></li><li><p>模板字符串</p><ul><li><p>字符串可以使用<code>+</code>号链接</p></li><li><p>使用<code>${}</code>进行字符串替换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>, I'm <span class="subst">$&#123;age&#125;</span> years old!`</span></span><br></pre></td></tr></table></figure><blockquote><p>反引号也可以引出<strong>单行</strong>字符串</p></blockquote></li></ul></li><li><p>操作字符串</p><ul><li><p>获取长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</span><br><span class="line">s.length; <span class="comment">// length是一个属性</span></span><br></pre></td></tr></table></figure></li><li><p>指定索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong>超过</strong>s长度（<strong>包括</strong>访问空字符<code>\0</code>位置）时返回<code>undefined</code></p></blockquote></li><li><p>字符串<strong>不可变</strong>，对<strong>索引</strong>赋值不会引起错误，但是也<strong>不会改变</strong>字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Test'</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'X'</span>;</span><br><span class="line">alert(s); <span class="comment">// 'Test'</span></span><br></pre></td></tr></table></figure><blockquote><p>但是如果对将字符串变量<strong>整个</strong>重新赋值，就会指向一个<strong>新的字符串</strong>。</p></blockquote></li><li><p>以下函数不会改变原有字符串，而是<strong>返回</strong>新字符串。</p><ul><li><p><code>toUpperCase</code>/<code>toLowerCase</code>：改变<strong>所有字符</strong>的大小写</p></li><li><p><code>indexOf</code>：搜索指定<strong>字符串</strong>出现的<strong>首字母</strong>位置</p><blockquote><p>没有找到时返回<code>-1</code></p></blockquote></li><li><p><code>substring</code>：字符串切片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'0123456789'</span>;</span><br><span class="line">s.substring(<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// 012</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 789</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>不包括<strong>右</strong>端点</li><li>超过字符串长度<strong>不会</strong>报错，而是返回一个<strong>空字符串</strong>。</li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>数组长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr.length;</span><br></pre></td></tr></table></figure><ul><li><p><code>arr.length</code><strong>可以</strong>直接被改变，多余的位置填充<code>undefined</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// [1, 2, 3, null, true, undefined]</span></span><br><span class="line">arr.length = <span class="number">1</span>;</span><br><span class="line">arr; <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组是<strong>可变</strong>的，因此可以直接对索引赋值改变数组。</p><ul><li><p>如果赋值时索引超过了长度返回，<strong>不会报错</strong>，数组长度同样会发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// [1, 2, 3, undefined, undefined, 99]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>indexOf</code>：搜索一个指定元素的位置</p></li><li><p><code>slice</code>：行为和substring类似</p><ul><li><p><strong>不指定</strong>索引参数时，可以进行数组<strong>深复制</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy === a; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>push</code>：向数组<strong>末尾</strong>添加元素（直接改变数组）</p><ul><li><p>可以一次性添加多个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>pop</code>：把<strong>最后</strong>一个元素删除掉（直接改变数组）</p><ul><li>空数组<code>pop</code><strong>不会</strong>报错，而是返回<code>undefined</code>.</li></ul></li><li><p><code>unshift</code>/<code>shift</code>：对数组<strong>首</strong>元素进行操作，和<code>push</code>/<code>pop</code>对应。</p></li><li><p><code>sort</code>：对数组排序并返回新数组（<strong>同时</strong>直接修改数组）</p></li><li><p><code>reverse</code>：反转数组（直接修改数组）</p></li><li><p><code>splice</code>：从指定索引开始<strong>删除</strong>若干元素<strong>并返回</strong>，然后再从该位置<strong>添加</strong>若干元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br></pre></td></tr></table></figure></li><li><p><code>concat</code>：连接两个数组，并返回新的数组。（<strong>不改变</strong>原数组）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">added; <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ul><li><p><code>concat</code>还可以接收多个数组并执行<strong>拆解后合并</strong>（不论多少层<strong>都会被</strong>拆开）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">added1 = arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [1, 2, 3, 1, 2, 3, 4]</span></span><br><span class="line">added2 = arr.concat(<span class="number">1</span>, <span class="number">2</span>, [[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]); <span class="comment">// [1, 2, 3, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>join</code>：把数组元素都当作字符串，用<strong>指定字符</strong>连接起来，然后返回一个长字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure></li><li><p>多维数组：数组嵌套</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="string">'-'</span>];</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p>当属性名包含<strong>特殊字符</strong>时</p><ul><li>必须用<code>&#39;&#39;</code>括起来</li><li>访问时需要使用<code>[&#39;xxx&#39;]</code>表示</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">'小红'</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'No.1 Middle School'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaohong[<span class="string">'middle-school'</span>];</span><br></pre></td></tr></table></figure></li><li><p>访问不存在的值不会报错，而是返回<code>undefined</code>.</p></li><li><p>对象是动态类型，可以随时添加和删除属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">'name'</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure></li><li><p>检测对象是否拥有某一属性：使用<code>in</code>操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">'No.1 Middle School'</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">'grade'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>使用<code>in</code>时会同时<strong>包括继承</strong>得到的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不考虑继承</strong>属性时使用<code>hasOwnProperty</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li>JavaScript把<strong><code>null</code>/<code>undefined</code>/<code>0</code>/<code>NaN</code>和空字符串</strong>视为<code>false</code>，其他都是<code>true</code>.</li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li><p><code>for</code>循环</p></li><li><p><code>for-in</code>循环</p><ul><li><p>用于遍历一个对象的所有<strong>属性</strong></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 'name', 'age', 'city'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历数组</p><p>数组也是一个对象，<strong>key是索引</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// '0', '1', '2'</span></span><br><span class="line">    <span class="built_in">console</span>.log(a[i]); <span class="comment">// 'A', 'B', 'C'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map是一种键值对结构，查找速度快。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">18</span>); <span class="comment">// add element</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">20</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 18</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>);</span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>如果重复<code>set</code>，后面的值会把前面的值冲掉。</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是key的集合，并且key<strong>不能</strong>重复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a set</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// number and string are different</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add element</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete element</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h2><p>包括<code>Array</code>/<code>Map</code>/<code>Set</code>类型</p><ul><li><p><code>for-of</code>遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]); <span class="comment">// 0 stands for key and 1 stands for value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组遍历通常使用<code>for-of</code>而<strong>不是</strong><code>for-in</code></p></blockquote></li><li><p><strong><code>forEach</code>（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素</span></span><br><span class="line"><span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">    <span class="built_in">console</span>.log(element + <span class="string">', index = '</span> + index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(element); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// neglect some args</span></span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>全文共<code>3321</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="定义与调用"><a href="#定义与调用" class="headerlink" title="定义与调用"></a>定义与调用</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>返回值、函数参数<strong>不用</strong>标注类型</p></li><li><p>如果<strong>没有</strong><code>return</code>语句或<code>return</code>后没有值，函数执行完毕后返回<code>undefined</code>.</p><blockquote><p>相当于函数体最后默认添加<code>return undefined;</code></p></blockquote></li><li><p>函数实际上是一个函数对象，函数名可以视为指向该函数的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>此时<code>abs</code>是一个函数变量，指向的函数被称作<strong>匿名函数</strong>。</li><li>注意函数体后有一个<code>;</code></li><li>调用方式依然为<code>abs(x)</code></li></ul></li></ul><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><ul><li><p><code>JavaScript</code>允许传入任意多个参数，即使比规定的参数要多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abs(<span class="number">10</span>, <span class="string">'balabala'</span>); <span class="comment">// return 10</span></span><br><span class="line">abs();<span class="comment">// return NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>参数无效时返回<code>NaN</code>而不是<code>undefined</code></p></blockquote></li><li><p>无效参数的过滤方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x !== <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Not a number'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>arguments</code>：在函数内部存储所有参数的一个<strong>类数组</strong>（不是数组）</p><ul><li><p>过滤空参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rest</code>：用于存储变长参数的<strong>数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行<code>return</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号 因为&#123;表示语句尚未结束</span></span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>return</code>所在行一定要有<code>{</code>，否则引擎会自动添加分号导致<code>return</code>一个<code>undefined</code>.</p></blockquote></li></ul><h2 id="作用域和解构赋值"><a href="#作用域和解构赋值" class="headerlink" title="作用域和解构赋值"></a>作用域和解构赋值</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li><p>变量的作用域就在函数体内部，如果出现嵌套函数中<strong>变量重名</strong>的情况，则以<strong>内部函数自己</strong>的变量为准。(变量栈)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x in bar() = '</span> + x); <span class="comment">// 'A'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x in foo() = '</span> + x); <span class="comment">// 1</span></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><blockquote><p>内部函数的<code>x</code>值也<strong>不会</strong>影响外部函数</p></blockquote></li><li><p>变量提升：<strong>函数</strong>（普通代码段<strong>也是</strong>）在执行前会先扫描整个函数体的语句，并且把所有声明都移动到<strong>函数顶部</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>函数可以正常执行，但是输出是<code>Hello, undefined</code>.</p></li><li><p>提升的<strong>仅仅是</strong>变量的<strong>声明</strong>，而<strong>不是</strong>变量的<strong>赋值</strong>。</p></li><li><p>良好的编码习惯是<strong>手动</strong>在函数顶部就声明所有的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">    x = <span class="number">1</span>,</span><br><span class="line">    y = x + <span class="number">1</span>,</span><br><span class="line">        z, i; <span class="comment">// init as undefined</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>全局作用域：不在任何一个函数内定义的变量</p><ul><li><p>JavaScript默认有一个<strong>全局对象<code>window</code></strong>，全局作用域的变量实际上会被绑定为<code>window</code>的一个<strong>属性</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> course = <span class="string">'Learn JavaScript'</span>;</span><br><span class="line">alert(course); <span class="comment">// Learn JavaScript</span></span><br><span class="line">alert(<span class="built_in">window</span>.course); <span class="comment">// Learn JavaScript</span></span><br><span class="line">course === <span class="built_in">window</span>.course; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>顶层函数</strong>也会被视为一个全局变量绑定到<code>window</code>上</p></li></ul><blockquote><p><code>window.xxx</code>的效果和<code>xxx</code>的全局变量其实是一样的（与对象的<code>this</code><strong>无关</strong>）</p></blockquote></li><li><p>名字空间</p><ul><li><p>当不同文件使用了<strong>相同的</strong>全局变量（包括顶层函数）就会造成命名冲突</p></li><li><p>把自己的所有变量和函数全部绑定到<strong>一个自定义的全局变量</strong>中就可以解决命名冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MYAPP.name = <span class="string">'myapp'</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>MYAPP</code>被称作<strong>名字空间</strong></p></blockquote></li></ul></li><li><p>局部作用域</p><ul><li><p>for语句<code>var</code>定义的循环变量<strong>不是</strong>局部作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将<code>var</code>改为<code>let</code>就可以声明一个<strong>块级作用域</strong>的变量</p></blockquote></li></ul></li><li><p>常量：<code>const</code>定义，<strong>初始化后不能被修改</strong>，具有<strong>块级</strong>作用域。</p></li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul><li><p>同时对一组变量进行赋值的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">'hello'</span>, [<span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]];</span><br><span class="line">x; <span class="comment">// 'hello'</span></span><br><span class="line">y; <span class="comment">// 'JavaScript'</span></span><br><span class="line">z; <span class="comment">// 'ES6'</span></span><br></pre></td></tr></table></figure><ul><li>保证左右两边的<strong>结构相同</strong></li></ul></li><li><p>忽略元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]; <span class="comment">// 忽略前两个元素，只对z赋值第三个元素</span></span><br><span class="line">z; <span class="comment">// 'ES6'</span></span><br></pre></td></tr></table></figure></li><li><p>拆解对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>拆解对象时<strong>不是</strong>按照顺序，而是按照<strong>指定的属性名字</strong>。</p></li><li><p>变换赋值变量的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person; <span class="comment">// id's value is 'G-12345678'</span></span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>嵌套对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        city: <span class="string">'Beijing'</span>,</span><br><span class="line">        street: <span class="string">'No.1 Road'</span>,</span><br><span class="line">        zipcode: <span class="string">'100001'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>当属性不存在时，会得到<code>undefined</code>.</p></li><li><p>使用默认值可以避免<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>以上情况都是把变量声明和赋值放在一起执行的，当分开并且是<strong>对象间赋值时（大括号）</strong>，需要进行特殊处理，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量:</span></span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correction : add brackets</span></span><br><span class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>交换变量值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>JavaScript的对象方法设计存在缺陷，因此需要单独设立新的<strong>对象方法调用方式</strong>。</p><ul><li><p><code>apply</code>/<code>call</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 30</span></span><br><span class="line">getAge.apply(xiaoming,[]);</span><br><span class="line">getAge.call(xiaoming,); <span class="comment">// comma can be neglected</span></span><br></pre></td></tr></table></figure><ul><li><code>apply</code>的第一个参数是使用对象，第二个参数是所有函数参数组成的数组。</li><li><code>call</code>的方法参数<strong>不按数组</strong>传入，而是<strong>按照顺序</strong>传入。</li><li><code>obj.xxx()</code>的方式<strong>不推荐</strong>使用，因为对于嵌套函数，<code>this</code>在<strong>内层</strong>的指向是<code>undefined</code>/<code>window</code>（取决于是否打开strict模式）</li></ul></li><li><p>装饰器</p><p>使用apply动态改变函数的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>新的自定义函数<code>parseInt</code>可以统计函数调用次数</p></blockquote></li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>接受<strong>函数作为参数</strong>的函数叫做高阶函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">-3</span>, <span class="built_in">Math</span>.abs);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><p><code>map()</code>定义在<code>Array</code>上，调用<code>Array</code>的<code>map()</code>方法并传入我们自己的函数，作用于数组的每一个元素，就能得到一个新的<code>Array</code>并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow);</span><br><span class="line"><span class="built_in">console</span>.log(results); <span class="comment">// 1,4,9</span></span><br></pre></td></tr></table></figure><ul><li><p>整数数组转换为字符串数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.map(<span class="built_in">String</span>); <span class="comment">// ['1', '2', '3']</span></span><br></pre></td></tr></table></figure></li><li><p>字符串数组变为整数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">arr.map(<span class="built_in">parseInt</span>); <span class="comment">// 1,NaN,NaN</span></span><br><span class="line">arr,map(<span class="built_in">Number</span>); <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>map()</code>接收的回调函数可以有3个参数：<code>callback(currentValue, index, array)</code>，通常我们仅需要第一个参数，而忽略了传入的后面两个参数。不幸的是，<code>parseInt(string, radix)</code><strong>没有</strong>忽略第二个参数，导致实际执行的函数分别是：</p><ul><li>parseInt(‘1’, 0); // 1, 按十进制转换</li><li>parseInt(‘2’, 1); // NaN, 没有一进制</li><li>parseInt(‘3’, 2); // NaN, 按二进制转换不允许出现3</li></ul><p>可以改为<code>r = arr.map(Number);</code>，因为<code>Number(value)</code>函数仅接收<strong>一个</strong>参数。</p></blockquote></li></ul></li></ul><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul><li><p>二元参数函数的迭代运算</p><p>$[x1,\ x2,\ x3,\ x4].reduce(f)\ =\ f(f(f(x1,\ x2),\ x3),\ x4)$</p></li><li><p>数组求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>把某些元素过滤掉，返回剩下的元素组成的数组。</p><h4 id="过滤函数"><a href="#过滤函数" class="headerlink" title="过滤函数"></a>过滤函数</h4><p>返回值为<strong><code>true</code>则保留</strong>，返回值为<strong><code>false</code>则删除</strong>。（不能省略<code>return</code>）</p><ul><li><p>删除偶数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>删除空字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">'C'</span>, <span class="string">'  '</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s &amp;&amp; s.trim(); <span class="comment">// 注意：IE9以下的版本没有trim()方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>删除重复元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数通常有三个参数</p><ul><li><code>element</code>：数组元素</li><li><code>index</code>：数组索引</li><li><code>self</code>：数组本身</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul><li><p>JavaScript的<code>sort</code>方法默认把<strong>所有元素</strong>先转换为<code>String</code>再排序（整数数组也按<strong>字典序</strong>排序）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure></li><li><p><code>sort</code>方法接受自定义排序函数</p></li></ul><h3 id="其他高阶函数"><a href="#其他高阶函数" class="headerlink" title="其他高阶函数"></a>其他高阶函数</h3><ul><li><p><code>every</code>：判断所有元素是否满足测试条件，有一个不满足就返回<code>false</code>.</p></li><li><p><code>find</code>：查找符合条件的第一个元素，找到了返回该元素，否则返回<code>undefined</code>.</p></li><li><p><code>findIndex</code>：类似<code>find</code>，但是查找失败时返回<code>-1</code>.</p></li><li><p><code>forEach</code>：类似<code>map</code>但是<strong>不会</strong>返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>];</span><br><span class="line">arr.forEach(<span class="built_in">console</span>.log); <span class="comment">// 依次打印每个元素</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为<strong>返回值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当调用<code>lazy_sum()</code>时，返回的<strong>不是求和结果</strong>，而是<strong>求和函数</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure></li><li><p>调用函数<code>f</code>时才返回求和结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li>在<code>lazy_sum</code>中定义函数<code>sum</code>时虽然<code>arr</code>有效，但是此时<strong>是定义而不是调用</strong>，因此不会计算。</li><li>每次调用<code>lazy_sum</code>都会返回一个<strong>新函数</strong></li></ul></blockquote><h3 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h3><p>在<code>lazy_sum</code>返回<code>sum</code>后，<code>lazy_sum</code>中的<strong>参数和变量</strong>都保存在返回的函数中，这种程序结构被称作闭包。</p><ul><li><p>闭包中函数的调用时机</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 16</span></span><br><span class="line">f2(); <span class="comment">// 16</span></span><br><span class="line">f3(); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><ul><li>首先<code>var results = count();</code>，函数<code>count</code>已经被调用了，所以依次执行函数内的各段代码。</li><li>此时循环体执行了push方法，将一个个函数<code>function () { return i * i;}</code>添加到数组内，但是这个函数并没有被调用，还只是一个变量，所以for循环依次执行，直到<code>i = 4</code>.</li><li>因为闭包，内部函数<code>function () { return i * i;}</code>引用的<code>i</code>就是for循环中的<code>i = 4</code>。所以，之后数组<code>arr</code>内的函数的<code>i</code>都是4。</li><li>调用函数<code>count</code>后，变量<code>results</code>已经是数组<code>arr</code>了。数组里面元素依次是<ul><li><code>function f1() { return i * i;}</code></li><li><code>function f2() { return i * i;}</code> </li><li><code>function f3() { return i * i;}</code></li></ul></li><li>但是三个函数都没有被调用，<strong>直到</strong><code>f1()</code>.（闭包内函数的调用）</li><li>此时<code>function f1() { return i * i;}</code>开始执行，如上段所写，此时的<code>i = 4</code>，所以，返回值就<strong>都是</strong>16了。</li></ul></li><li><p>闭包函数调用注意事项</p><ul><li><p>返回函数不要引用任何<strong>循环变量</strong>，或者<strong>后续会发生变化的变量</strong>。</p></li><li><p>一定要引用循环变量时，用<strong>函数参数</strong>绑定<strong>循环变量</strong>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push((<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> n * n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 1</span></span><br><span class="line">f2(); <span class="comment">// 4</span></span><br><span class="line">f3(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><ul><li><p>创建匿名函数并<strong>绑定参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)(<span class="number">3</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><blockquote><p>注意函数部分（不包括参数）需要单独再多加<strong>一对括号</strong>。</p></blockquote></li></ul></li></ul></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>创建<strong>延迟执行</strong>的函数</p></li><li><p>在没有<code>class</code>机制的<code>JavaScript</code>中封装一个私有变量</p><p>利用闭包返回一个对象，在该对象中的变量无法通过外界访问到，相当于实现了私有变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = initial || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = create_counter();</span><br><span class="line">c1.inc(); <span class="comment">// 1</span></span><br><span class="line">c1.inc(); <span class="comment">// 2</span></span><br><span class="line">c1.inc(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</span><br><span class="line">c2.inc(); <span class="comment">// 11</span></span><br><span class="line">c2.inc(); <span class="comment">// 12</span></span><br><span class="line">c2.inc(); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><blockquote><p>此时只有<code>c1</code>/<code>c2</code>可以修改各自的<code>x</code></p></blockquote></li><li><p>利用闭包将<strong>多参数</strong>函数变为<strong>单参数</strong>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_pow</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>和装饰器不同，闭包封装函数并没有立即执行。</li></ul></li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li><p>结构</p><p>$(参数列表)+\{…\}$</p><ul><li>参数只有<strong>一个</strong>时可以<strong>不需要</strong>用括号把参数包起来</li></ul></li><li><p>返回对象时，因为对象的外层是<code>{}</code>和块结构语法冲突，所以需要<strong>单独</strong>加一层<code>()</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure></li><li><p>和匿名函数的区别：箭头函数内的<code>this</code>由词法作用域决定，而不是<code>window</code>或<code>undefined</code>.</p><ul><li>匿名函数中的<code>this</code>在没有开启<code>strict</code>模式时指向<code>window</code>对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anonymous function</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window或undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>箭头函数中的<code>this</code>指向词法作用域，也就是<code>obj</code>对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrow function</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>此时箭头函数在一个函数内，因此词法作用域是这个函数的作用域，因此<code>this</code>指向<code>obj</code>.</li><li>但是对于<code>toJSON</code>函数，因为箭头函数不在某个函数内，并且<strong>对象不能够定义作用域</strong>，此时的<code>this</code>指向的是<code>window</code>.（toJSON不建议使用箭头函数）</li></ul></blockquote></li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul><li>类似于函数，但是除了<code>return</code>外，还可以<code>yield</code>返回多次。</li><li>一个可以记住执行状态的函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>生成器实现fib数列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        arr = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (arr.length &lt; max) &#123;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        arr.push(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试:</span></span><br><span class="line">fib(<span class="number">5</span>); <span class="comment">// [0, 1, 1, 2, 3]</span></span><br><span class="line">fib(<span class="number">10</span>); <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = fib(<span class="number">5</span>);</span><br><span class="line">f.next(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> fib(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 依次输出0, 1, 1, 2, 3, ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次<code>next</code>调用就会返回一次<code>yield</code>对象</li><li>碰到<code>return</code>后返回的对象中<code>done</code>为<code>true</code></li><li>直接使用<code>for-of</code>循环遍历也可以得到结果</li></ul></li></ul><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h1><p>全文共<code>1397</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li><p>使用<code>typeof</code>操作符获取对象的类型（返回一个<strong>小写字符串</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'str'</span>; <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// 'function'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure><ul><li><code>null</code>的类型属于<code>object</code></li></ul></li><li><p>包装对象：类似Java中<code>int</code>和<code>Integer</code>的关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>) === <span class="string">'str'</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p>通常<strong>不使用</strong>包装对象</p></li><li><p>当不写<code>new</code>时，<code>Number()</code>/<code>Boolean()</code>/<code>String()</code>会被当作<strong>普通函数</strong>，把其他数据转换成自己的<strong>基本数据类型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">Number</span>(<span class="string">'123'</span>); <span class="comment">// 123，相当于parseInt()或parseFloat()</span></span><br><span class="line"><span class="keyword">typeof</span> n; <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Boolean</span>(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// 'boolean'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Boolean</span>(<span class="string">'false'</span>); <span class="comment">// true! 'false'字符串转换结果为true！因为它是非空字符串！</span></span><br><span class="line"><span class="keyword">var</span> b3 = <span class="built_in">Boolean</span>(<span class="string">''</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">String</span>(<span class="number">123.45</span>); <span class="comment">// '123.45'</span></span><br><span class="line"><span class="keyword">typeof</span> s; <span class="comment">// 'string'</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>类型判断</p><ul><li><code>Array</code>：<code>Array.isArray(arr)</code></li><li><code>null</code>：<code>myVar === null</code></li><li>全局变量是否存在：<code>typeof window.myVar === &#39;undefined&#39;</code></li><li>局部变量是否存在：<code>typeof myVar === &#39;undefined&#39;</code></li></ul></li><li><p>注意事项</p><ul><li><p><code>null</code>和<code>undefined</code>没有<code>toString()</code>方法</p><blockquote><p>尽管<code>null</code>是<code>object</code>类型</p></blockquote></li><li><p>数字转换为字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span>.toString(); <span class="comment">// two dots</span></span><br><span class="line">(<span class="number">123</span>).toString(); <span class="comment">// add brackets</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>不能</strong>使用<code>123.toStirng()</code></p></blockquote></li></ul></li></ul><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p><code>Date</code>对象表示日期和时间</p><ul><li><p>获取当前时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br><span class="line"><span class="built_in">Date</span>.now(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个指定日期和时间的<code>Date</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mannully set arguments</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</span><br><span class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// format string of ISO 8601</span></span><br><span class="line"><span class="keyword">var</span> timeStamp = <span class="built_in">Date</span>.parse(<span class="string">'2015-06-24T19:49:22.875+08:00'</span>);</span><br><span class="line">timeStamp; <span class="comment">// 1435146562875</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp);</span><br><span class="line">d; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">d.getMonth(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><ul><li><p>JavaScript中月份范围用整数表示是<code>0~11</code>，所以5表示6月。</p><blockquote><p>使用<code>Date.parse()</code>时传入的字符串使用实际月份<code>01~12</code>，转换为Date对象后<code>getMonth()</code>获取的月份值为<code>0~11</code>.</p></blockquote></li></ul></li><li><p>时区转换</p><p>Date显示的时间总是按<strong>浏览器所在时区</strong>显示的，也可以转换为UTC时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>);</span><br><span class="line">d.toLocaleString(); <span class="comment">// '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关</span></span><br><span class="line">d.toUTCString(); <span class="comment">// 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>通过<code>//</code>引出</p></li><li><p>通过<code>RegExp</code>声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ABC\\-001'</span>);</span><br><span class="line"></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure><blockquote><p>第二种写法要同时考虑<strong>字符串中<code>\</code>的转义问题</strong></p></blockquote></li></ul><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;</span><br><span class="line">re.test(<span class="string">'010-12345'</span>); <span class="comment">// true</span></span><br><span class="line">re.test(<span class="string">'010-1234x'</span>); <span class="comment">// false</span></span><br><span class="line">re.test(<span class="string">'010 12345'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a b   c'</span>.split(<span class="string">' '</span>); <span class="comment">// ['a', 'b', '', '', 'c']</span></span><br><span class="line"><span class="string">'a b   c'</span>.split(<span class="regexp">/\s+/</span>); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"><span class="string">'a,b, c  d'</span>.split(<span class="regexp">/[\s\,]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br><span class="line"><span class="string">'a,b;; c  d'</span>.split(<span class="regexp">/[\s\,\;]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>在正则中进行分组可以直接在字符串中提取出想要的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</span><br><span class="line">re.exec(<span class="string">'010-12345'</span>); <span class="comment">// ['010-12345', '010', '12345']</span></span><br><span class="line">re.exec(<span class="string">'010 12345'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><ul><li>匹配成功时，返回的数组的第一个元素的整个字符串。</li><li>匹配失败时，返回<code>null</code>.</li></ul><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>JavaScript默认采用贪婪匹配，也就是匹配尽可能多的字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '102300', '']</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p></blockquote><ul><li><p>开启非贪婪匹配：加一个<code>?</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '1023', '00']</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h3><p>全局匹配可以对同一个字符串进行多次匹配，并且下一次匹配的起点是这一次匹配终点的下一个字符索引。</p><h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'test'</span>, <span class="string">'g'</span>);</span><br></pre></td></tr></table></figure><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'JavaScript, VBScript, JScript and ECMAScript'</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s); <span class="comment">// ['JavaScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['VBScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['JScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['ECMAScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure><h3 id="其他标志"><a href="#其他标志" class="headerlink" title="其他标志"></a>其他标志</h3><ul><li><code>i</code>表示忽略大小写</li><li><code>m</code>表示执行多行匹配</li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是JavaScript Object Notation的缩写，是一种数据交换格式。</p><ul><li>JSON的序列集必须是UTF-8</li><li>JSON的<strong>字符串和Object的key</strong>必须使用<code>&quot;&quot;</code></li><li>JSON反序列化后即可成为JavaScript对象</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</span><br><span class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>普通序列化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);</span><br></pre></td></tr></table></figure></li><li><p>格式序列化：二、三参数只是为了<strong>占位</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">' '</span>);</span><br></pre></td></tr></table></figure><blockquote><p>输出一个键值对就换一次行</p></blockquote></li><li><p>筛选格式化：第二个参数传入数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, [<span class="string">'name'</span>, <span class="string">'skills'</span>], <span class="string">' '</span>);</span><br></pre></td></tr></table></figure><blockquote><p>只输出指定的属性</p></blockquote></li><li><p>预处理格式化：第二个参数传入函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, convert, <span class="string">'  '</span>);</span><br></pre></td></tr></table></figure></li><li><p>精确序列化：为对象增加<code>toJSON</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</span><br><span class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>],</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 只输出name和age，并且改变了key：</span></span><br><span class="line">            <span class="string">'Name'</span>: <span class="keyword">this</span>.name,</span><br><span class="line">            <span class="string">'Age'</span>: <span class="keyword">this</span>.age</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p><code>JSON.parse</code>可以把输入元素解析为JavaScript对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1,2,3,true]'</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>); <span class="comment">// Object &#123;name: '小明', age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'123.45'</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><ul><li><p>指定处理函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'name'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">'同学'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;name: '小明同学', age: 14&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>全文共<code>1107</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>不同于Java，JavaScript的OO中没有Class和实例的概念。</p><ul><li><p>在JavaScript中，通过<strong>原型</strong>实现OO编程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'Robot'</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Student;</span><br></pre></td></tr></table></figure><ul><li><p>定义一个模型变量<code>Student</code></p></li><li><p>通过修改对象的<code>__proto__</code>域可以实现对象的<strong>动态</strong>改变，但是在编程时<strong>不推荐</strong>使用这种方式创建对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Bird = &#123;</span><br><span class="line">    fly: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is flying...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Bird;</span><br></pre></td></tr></table></figure><blockquote><p>此时<code>xiaoming</code>就<strong>没有</strong><code>run</code>方法了</p></blockquote></li></ul></li><li><p>JavaScript中所有对象<strong>都是实例</strong></p></li><li><p>使用封装好的<code>Object.create()</code>方法改变对象继承的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'Robot'</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'is running...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</span><br><span class="line">    s.name = name;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">'xiaoming'</span>);</span><br><span class="line">xiaoming.run();</span><br><span class="line">xiaoming.__proto___ === Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>所有原型最后都会回到<code>null</code></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>如果不写<code>new</code>，则<code>Student</code>函数就是一个普通函数；如果写了<code>new</code>，则<code>Student</code>就是一个构造函数，它<strong>根据原型对象</strong>创建一个<strong>新对象</strong>并把<code>this</code>指向它，同时<strong>不需要</strong>显式<code>return</code>.</p></li><li><p><code>xiaoming</code><strong>从新对象</strong>得到了一个<code>constructor</code>属性，指向函数<code>Student</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.constructor === Student.prototype.constructor; <span class="comment">// true</span></span><br><span class="line">Student === Student.prototype.constructor; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(xiaoming) === Student.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>关系示意图<br><img src="https://static.liaoxuefeng.com/files/attachments/1024698721053600/l"  /></p><ul><li>某个对象即构造函数对应的<strong>唯一的原型对象</strong></li></ul></li><li><p>不同对象尽管由同一个原型对象创建得到，但是其中的属性除了<code>constructor</code>之外都是<strong>独立的</strong>。（但是访问<code>constructor</code>直接<code>xxx.constructor</code>，<strong>而不是</strong>使用<code>xxx.prototype.constructor</code>.）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.name; <span class="comment">// '小明'</span></span><br><span class="line">xiaohong.name; <span class="comment">// '小红'</span></span><br><span class="line">xiaoming.hello; <span class="comment">// function: Student.hello()</span></span><br><span class="line">xiaohong.hello; <span class="comment">// function: Student.hello()</span></span><br><span class="line">xiaoming.hello === xiaohong.hello; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p>对于可共享函数，可以采用直接对<strong>原型对象域</strong>操作的办法进行设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>此时所有的<code>Student</code>对象共享同一个<code>hello</code></p><blockquote><p>构造函数中的属性都是独立的，直接在<code>prototype</code>中修改的就是共享的。</p></blockquote></li><li><p>此时<code>this</code>指向调用<strong>该方法</strong>的对象</p></li><li><p><code>prototype</code>这个属性只有构造函数有，对象只有<code>__proto__</code>.</p></li></ul></li></ul></li><li><p>普通函数的首字母小写，构造函数的<strong>首字母大写</strong>。</p></li><li><p>为了省略显示<code>new</code>操作，可以进行封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = props.name || <span class="string">'匿名'</span>; <span class="comment">// 默认值为'匿名'</span></span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>; <span class="comment">// 默认值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Student(props || &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(&#123;</span><br><span class="line">    name: <span class="string">'xiaoming'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>使用<code>||</code>实现默认值操作</li><li>注意传入的参数是<strong>对象</strong></li></ul></li></ul><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><ul><li><p>定义新的构造函数，并在内部调用被继承的函数，并绑定<code>this</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Student构造函数，绑定this变量:</span></span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>借助中间函数<code>F</code>实现原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrimaryStudent构造函数:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空函数F:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把F的原型指向Student.prototype:</span></span><br><span class="line">F.prototype = Student.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span></span><br><span class="line">PrimaryStudent.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span></span><br><span class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建xiaoming:</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> PrimaryStudent(&#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    grade: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">xiaoming.name; <span class="comment">// '小明'</span></span><br><span class="line">xiaoming.grade; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型:</span></span><br><span class="line">xiaoming.__proto__ === PrimaryStudent.prototype; <span class="comment">// true</span></span><br><span class="line">xiaoming.__proto__.__proto__ === Student.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承关系:</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> PrimaryStudent; <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>一个函数本身就算不是构造函数，加了<code>new</code>也能正常执行。</p></blockquote><ul><li><p>关系图</p><p><img src="https://static.liaoxuefeng.com/files/attachments/1034288859918112/l" alt=""></p></li><li><p>为了简化，可以把继承封装为一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line">    Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在新的构造函数的原型上定义新方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = props.name || <span class="string">'Unnamed'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现原型继承链:</span></span><br><span class="line">inherits(PrimaryStudent, Student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h2><p>为了简化原型继承提出了新关键字<code>class</code></p><ul><li><p>使用<code>class</code>直接编写类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hello() &#123;</span><br><span class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义方法<strong>不需要</strong><code>function</code>关键字</li></ul></li><li><p>继承实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, grade) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myGrade() &#123;</span><br><span class="line">        alert(<span class="string">'I am at grade '</span> + <span class="keyword">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>class继承就是为了简化原型继承，但是可能会碰到不兼容的情况，可以使用<code>Babel</code>工具进行<code>class</code>继承到传统原型继承的转换。</p></blockquote></li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>全文共<code>4625</code>字，推荐阅读时间<code>30~45</code>分钟。</p><h2 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h2><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><ul><li><p><code>window</code>对象不但是全局作用域变量，而且表示<strong>浏览器窗口</strong>。</p></li><li><p><code>window</code>对象有<code>innerWidth</code>和<code>innderHeight</code>属性，分别表示浏览器窗口<strong>内部宽度和高度</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'window inner size: '</span> + <span class="built_in">window</span>.innerWidth + <span class="string">'*'</span> + <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure><ul><li><p>内部宽高需要去掉菜单栏、工具栏、边框等占位元素。</p></li><li><p>对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。</p></li></ul></li></ul><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p><code>navigator</code>表示浏览器的信息</p><ul><li><code>navigator.appName</code>：浏览器名称</li><li><code>navigator.appVersion</code>：浏览器版本</li><li><code>navigator.language</code>：浏览器设置的语言</li><li><code>navigator.platform</code>：操作系统类型</li><li><code>navigator.userAgent</code>：浏览器设定的<code>User-Agent</code>字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'appName = '</span> + navigator.appName);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'appVersion = '</span> + navigator.appVersion);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'language = '</span> + navigator.language);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'platform = '</span> + navigator.platform);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'userAgent = '</span> + navigator.userAgent);</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>navigator</code>的属性<strong>可以</strong>被用户修改，所以读到的值不一定是实际值。</p><p>例如判断浏览器版本</p><ul><li><p>使用if语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width;</span><br><span class="line"><span class="keyword">if</span> (getIEVersion(navigator.userAgent) &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    width = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    width = <span class="built_in">window</span>.innerWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当IE版本低于9时window没有<code>innerwidth</code>属性</p></blockquote></li><li><p>使用<code>undefined</code>的短路特性<strong>（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width = width.innerWidth || <span class="built_in">document</span>.body.clientWidth;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p><code>screen</code>表示屏幕的信息</p><ul><li><code>screen.width</code>：屏幕宽度，以像素为单位。</li><li><code>screen.height</code>：屏幕高度</li><li><code>screen.colorDepth</code>：返回屏幕颜色位数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Screen size = '</span> + screen.width + <span class="string">' x '</span> + screen.height);</span><br><span class="line"><span class="built_in">console</span>.log(screen.colorDepth);</span><br></pre></td></tr></table></figure><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p><code>location</code>表示<strong>当前页面</strong>的<code>URL</code>信息</p><ul><li><code>location.href</code>：完整的<code>URL</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location.href; <span class="comment">// 'http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP'</span></span><br><span class="line">location.protocol; <span class="comment">// 'http'</span></span><br><span class="line">location.host; <span class="comment">// 'www.example.com'</span></span><br><span class="line">location.port; <span class="comment">// '8080'</span></span><br><span class="line">location.pathname; <span class="comment">// '/path/index.html'</span></span><br><span class="line">location.search; <span class="comment">// '?a=1&amp;b=2'</span></span><br><span class="line">location.hash; <span class="comment">// 'TOP'</span></span><br></pre></td></tr></table></figure><ul><li><code>location.assign()</code>：接受<strong>新</strong><code>path</code>作为参数，加载一个页面。</li><li><code>location.reload()</code>：<strong>重新</strong>加载当前页面</li></ul><h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><p><code>document</code>表示当前页面，由于HTML以<strong>DOM(Document Object Model)</strong>形式表现为树结构，因此<code>document</code>对象就是整个DOM树的根节点。</p><ul><li><p><code>document.title</code>：当前页面的标题，<strong>可以被用户动态改变</strong>。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.title);</span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">'努力学习JavaScript!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.title);</span><br></pre></td></tr></table></figure></li><li><p><code>document.getElementById()</code>/<code>document.getElementsByTagName()</code>按照HTML的<code>id</code>获得一个DOM节点以及按<code>Tag</code>名称获取一组DOM节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span> <span class="attr">id</span>=<span class="string">"drink-menu"</span> <span class="attr">style</span>=<span class="string">"border:solid 1px #ccc;padding:6px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>摩卡<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>热摩卡咖啡<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>酸奶<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>北京老酸奶<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>果汁<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>鲜榨苹果汁<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'drink-menu'</span>);</span><br><span class="line"><span class="keyword">var</span> drinks = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'dt'</span>);</span><br><span class="line"><span class="keyword">var</span> i, s;</span><br><span class="line"></span><br><span class="line">s = <span class="string">'提供的饮料有:'</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;drinks.length; i++) &#123;</span><br><span class="line">    s = s + drinks[i].innerHTML + <span class="string">','</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure></li><li><p><code>document.cookie</code>：获取当前页面的<code>cookie</code>属性</p><blockquote><p>cookie的用途</p><ul><li><p>因为HTTP协议是无状态的，因此服务器使用cookie区分是哪个用户发来的请求。</p><p>当一个用户成功登录后，服务器发送一个cookie给浏览器，例如<code>user=ABC123XYZ</code>（加密字符串）。之后浏览器访问该网站时都会在<strong>请求头</strong>附上这个cookie.</p></li><li><p>因为JavaScript可以读取cookie，当引入恶意第三方代码时，就会造成信息泄露。为此，服务器设置cookie会加上<code>httpOnly</code>选项，此时JavaScript不能够读取cookie.</p></li></ul></blockquote></li></ul><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p><code>history</code>保存了浏览器的历史记录，<strong>是一个不应该继续使用的对象</strong>。</p><ul><li><code>history.back()</code>：相当于点了浏览器的后退按钮</li><li><code>history.forward()</code>：相当于点了浏览器的前进按钮</li></ul><h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>HTML文件解析后是一棵DOM树，因此JavaScript操作DOM就可以改变HTML的结构。</p><ul><li><p>获取节点（所有的操作都是针对某个节点）</p><ul><li><code>document.getElementById()</code>：可以直接获取<strong>唯一一个</strong>节点</li><li><code>document.getElementsByTagName()</code></li><li><code>document.getElementByClassName()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回ID为'test'的节点：</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：</span></span><br><span class="line"><span class="keyword">var</span> trs = <span class="built_in">document</span>.getElementById(<span class="string">'test-table'</span>).getElementsByTagName(<span class="string">'tr'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：</span></span><br><span class="line"><span class="keyword">var</span> reds = <span class="built_in">document</span>.getElementById(<span class="string">'test-div'</span>).getElementsByClassName(<span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下的所有直属子节点:</span></span><br><span class="line"><span class="keyword">var</span> cs = test.children;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下第一个、最后一个子节点：</span></span><br><span class="line"><span class="keyword">var</span> first = test.firstElementChild;</span><br><span class="line"><span class="keyword">var</span> last = test.lastElementChild;</span><br></pre></td></tr></table></figure><ul><li><p><code>querySelector()</code>/<code>querySelectorAll()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过querySelector获取ID为q1的节点：</span></span><br><span class="line"><span class="keyword">var</span> q1 = <span class="built_in">document</span>.querySelector(<span class="string">'#q1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span></span><br><span class="line"><span class="keyword">var</span> ps = q1.querySelectorAll(<span class="string">'div.highlighted &gt; p'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>低版本IE不支持</p></blockquote></li></ul></li><li><p>更新：更新DOM节点的内容，相当于更新DOM节点表示的HTML的内容。</p></li><li><p>遍历：遍历该DOM节点下的子节点</p></li><li><p>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点。</p></li><li><p>删除：将该节点从HTML删除，同时会删除它的子节点。</p></li></ul><blockquote><p>严格说，这里的DOM节点仅指<code>Element</code>，而不是<code>Node</code>.</p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-div"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c-red"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test-p"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c-red c-green"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ruby<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c-green"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择&lt;p&gt;JavaScript&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> js = <span class="built_in">document</span>.getElementById(<span class="string">'test-p'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c-red c-green'</span>)[<span class="number">0</span>].getElementsByTagName(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>].innerText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;Haskell&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> haskell = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c-green'</span>)[<span class="number">1</span>].getElementsByTagName(<span class="string">'p'</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(haskell.innerText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;JavaScript&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> js =  <span class="built_in">document</span>.querySelector(<span class="string">'#test-p'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c-red c-green'</span>)[<span class="number">0</span>].children;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择&lt;p&gt;Haskell&lt;/p&gt;:</span></span><br><span class="line"><span class="keyword">var</span> haskell = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c-green'</span>)[<span class="number">1</span>].lastElementChild;</span><br></pre></td></tr></table></figure><ul><li><code>getElementsByClassName</code>是<strong>部分匹配查找</strong></li><li>查找到的DOM节点需要使用<code>innerText</code>获取内容</li></ul><h3 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h3><ul><li><p>直接修改<code>innerHTML</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC'</span>; <span class="comment">// &lt;p id="p-id"&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ'</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure><blockquote><p>直接修改<code>HTML</code>要小心<code>XSS</code>攻击</p></blockquote></li><li><p>修改<code>innerText</code>或<code>innerContent</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.innerText = <span class="string">'&lt;script&gt;alert("Hi")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id="p-id"&gt;&amp;lt;script&amp;gt;alert("Hi")&amp;lt;/script&amp;gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此时HTML会被自动编码，不会修改原有HTML.</p></blockquote><ul><li><code>innerText</code><strong>不返回</strong>隐藏元素的文本</li><li><code>textContent</code>返回所有文本（IE9前不支持）</li></ul></li><li><p>修改节点对应的CSS</p><p>修改节点的<code>style</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.style.color = <span class="string">'#ff0000'</span>;</span><br><span class="line">p.style.fontSize = <span class="string">'20px'</span>; <span class="comment">// font-size in CSS</span></span><br><span class="line">p.style.paddingTop = <span class="string">'2em'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>CSS中<code>font-size</code>这样的名称在JavaScript中需要变化为<strong>驼峰命名</strong>法</p></blockquote></li></ul><h3 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h3><ul><li><p>直接修改<code>innerHTML</code></p><p>仅仅适用于原节点内部是空的情况，例如<code>&lt;div&gt;&lt;/div&gt;</code>，否则会替换掉<strong>所有</strong>的子节点。</p></li><li><p><code>appendChild</code>：把一个子节点添加到父节点的最后一个子节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 Before --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"scheme"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML结构 After --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"scheme"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    js = <span class="built_in">document</span>.getElementById(<span class="string">'js'</span>),</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line">list.appendChild(js);</span><br></pre></td></tr></table></figure><ul><li><p>这个操作会先把原来的语句<strong>删除</strong>，然后在新的节点进行追加。</p></li><li><p>新建节点后再插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;p&gt;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>); <span class="comment">// choose type of DOM point</span></span><br><span class="line">haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">list.appendChild(haskell);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;style&gt;</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">d.setAttribute(<span class="string">'type'</span>, <span class="string">'text/css'</span>);</span><br><span class="line">d.innerHTML = <span class="string">'p &#123; color: red &#125;'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(d);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>insertBefore</code>：把元素插在<strong>指定位置之前</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"scheme"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在python之前插入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    ref = <span class="built_in">document</span>.getElementById(<span class="string">'python'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">list.insertBefore(haskell, ref);</span><br></pre></td></tr></table></figure><ul><li><p>当<code>ref</code>节点不能够直接得到时，可以通过遍历子节点实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">i, c,</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.children.length; i++) &#123;</span><br><span class="line">    c = list.children[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>按字符串顺序重新排序DOM节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">id</span>=<span class="string">"test-list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>Ruby<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort list:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"lang"</span>);</span><br><span class="line"><span class="keyword">var</span> arrList = <span class="built_in">Array</span>.from(list); <span class="comment">// transform Collection into Array</span></span><br><span class="line"></span><br><span class="line">arrList.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( x.innerText.toLowerCase() &gt; y.innerText.toLowerCase() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.innerText.toLowerCase() &lt; y.innerText.toLowerCase()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testList = <span class="built_in">document</span>.getElementById(<span class="string">"test-list"</span>);</span><br><span class="line">testList.innerHTML = <span class="string">""</span>;</span><br><span class="line">arrList.forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> testList.appendChild(x)); <span class="comment">// no need to create new elements</span></span><br></pre></td></tr></table></figure><h3 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h3><ul><li><p>找到待删除节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>);</span><br></pre></td></tr></table></figure></li><li><p>找到其<strong>父节点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br></pre></td></tr></table></figure></li><li><p>删除（返回被删除元素）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>删除多个节点时，注意索引可能在发生变化。（可以使用<strong>倒序</strong>删除）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>);</span><br><span class="line">parent.removeChild(parent.children[<span class="number">0</span>]);</span><br><span class="line">parent.removeChild(parent.children[<span class="number">1</span>]); <span class="comment">// &lt;-- 浏览器报错</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h2><p>因为表单本身也是DOM树，所以操作表单和操作DOM是类似的。不同的是，表单可以接收用户输入。</p><h3 id="输入控件"><a href="#输入控件" class="headerlink" title="输入控件"></a>输入控件</h3><ul><li><p>文本框：用于输入文本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"text"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>口令框：用于输入口令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"password"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>单选框：用于选择一项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"radio"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>复选框：用于选择多项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"checkbox"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>下拉框：用于选择一项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br></pre></td></tr></table></figure></li><li><p>隐藏文本：用户不可见，会把隐藏文本发送到服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"hidden"</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><ul><li><p>如果有一个<code>&lt;input&gt;</code>节点的引用，其<code>value</code>属性即对应<strong>输入值</strong>。<strong>（不是<code>innerText</code>）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type = "text" id = "email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value;</span><br></pre></td></tr></table></figure><blockquote><p>对<code>text</code>/<code>password</code>/<code>hidden</code>/<code>select</code>均适用</p></blockquote></li><li><p>对于<strong>单选框和复选框</strong>，<code>value</code>属性的值永远是<strong>默认值</strong>，含有<strong>有效信息</strong>的是<code>checked</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;</span></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="tuesday" value="2"&gt; Tuesday&lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">'monday'</span>);</span><br><span class="line"><span class="keyword">var</span> tue = <span class="built_in">document</span>.getElementById(<span class="string">'tuesday'</span>);</span><br><span class="line">mon.value; <span class="comment">// '1'</span></span><br><span class="line">tue.value; <span class="comment">// '2'</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br><span class="line">tue.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h3><ul><li><p>对于<code>text</code>/<code>password</code>/<code>hidden</code>/<code>select</code>，直接设置<code>value</code>即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" id="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value = <span class="string">'test@example.com'</span>; <span class="comment">// 文本框的内容已更新</span></span><br></pre></td></tr></table></figure></li><li><p>对于单选框和复选框，设置<code>checked</code>的布尔值即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type = "radio" name = "weekday" id = "monday" value = "1"&gt; Monday &lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">'monday'</span>);</span><br><span class="line">mon.checked = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTML5控件"><a href="#HTML5控件" class="headerlink" title="HTML5控件"></a>HTML5控件</h3><ul><li><p><code>date</code>：输入年月日</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"date"</span> value = <span class="string">"2020-07-09"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>datetime-local</code>：精确到秒的本地时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">"datetime-local"</span> value = <span class="string">"2020-07-09T14:49:49"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>color</code>：显示一个色块供颜色选择</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input<span class="built_in"> type </span>= <span class="string">"color"</span> value = <span class="string">""</span>#ff0000<span class="string">"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><ul><li><p>通过AJAX实现</p></li><li><p>通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span> = <span class="string">"test-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span> = <span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"doSubmitForm()"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="actionscript"><span class="comment">// modify form here</span></span></span><br><span class="line">    form.submit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这种方式和浏览器默认的<code>&lt;button type = &quot;submit&quot;&gt;</code>重复</p></blockquote></li><li><p>响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span> = <span class="string">"test-form"</span> <span class="attr">onsubmit</span> = <span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span> = <span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// modify form here</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>返回<code>true</code>提醒浏览器继续提交</p></blockquote></li><li><p><code>hidden</code>元素的处理</p><p>在普通的密码输入表单中，提交表单时不输入明文口令，而是口令的MD5.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line">    pwd.value = toMD5(pwd.value);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当执行<code>toMD5</code>时，会出现密码框的几个<code>*</code>突然变成32个<code>*</code>的情况。</p></blockquote><p>使用<code>hidden</code>把存储<code>MD5</code>密码的输入端隐藏起来，就可以不改变用户本来输入的<code>*</code>的位数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"input-password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"md5-password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'input-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'md5-password'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line">    md5_pwd.value = toMD5(input_pwd.value);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>password</code>控件没有<code>name</code>属性，<strong>不会被</strong>上传。</p><blockquote><p>没有<code>name</code>的属性都不会被上传</p></blockquote></li><li><p>相当于用户输入<code>password</code>控件中，但是我们把处理的结果放在了<strong>被隐藏</strong>的<code>md5-password</code>中，<strong>而不是</strong>原来的<code>password</code>中，所以能够不影响用户本来的输入。</p></li></ul></li></ul><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul><li><p>在HTML表单中，上传文件的唯一控件是<code>&lt;input type = &quot;file&quot;&gt;</code></p><blockquote><p>当一个表单中含有该控件时，表单的<strong><code>enctype</code></strong>必须指定为<strong><code>multipart/form-data</code></strong>，<strong><code>method</code></strong>必须指定为<strong><code>post</code></strong>.</p></blockquote></li><li><p>JavaScript对控件的<code>value</code>修改不会造成影响，并且<strong>无法知道</strong>真实路径。</p></li><li><p>JavaScript可以在提交表单时对<strong>文件扩展名</strong>进行检查，防止无效文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>);</span><br><span class="line"><span class="keyword">var</span> filename = f.value;</span><br><span class="line"><span class="keyword">if</span> (!filename || !(filename.endsWith(<span class="string">'.jpg'</span>)) || filename.endsWith(<span class="string">'.png'</span>)) &#123;</span><br><span class="line">    alert(<span class="string">'Can only upload image file.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h3><p>HTML提供了<code>File</code>和<code>FileReader</code>两个主要对象，可以获取文件信息并读取文件。</p><ul><li><p>上传图片并解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-file'</span>),</span><br><span class="line">    info = <span class="built_in">document</span>.getElementById(<span class="string">'test-file-info'</span>),</span><br><span class="line">    preview = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-preview'</span>);</span><br><span class="line"><span class="comment">// 监听change事件:</span></span><br><span class="line">fileInput.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清除背景图片:</span></span><br><span class="line">    preview.style.backgroundImage = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">    <span class="keyword">if</span> (!fileInput.value) &#123;</span><br><span class="line">        info.innerHTML = <span class="string">'没有选择文件'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取File引用:</span></span><br><span class="line">    <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取File信息:</span></span><br><span class="line">    info.innerHTML = <span class="string">'文件: '</span> + file.name + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                     <span class="string">'大小: '</span> + file.size + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                     <span class="string">'修改: '</span> + file.lastModifiedDate;</span><br><span class="line">    <span class="keyword">if</span> (file.type !== <span class="string">'image/jpeg'</span> &amp;&amp; file.type !== <span class="string">'image/png'</span> &amp;&amp; file.type !== <span class="string">'image/gif'</span>) &#123;</span><br><span class="line">        alert(<span class="string">'不是有效的图片文件!'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件:</span></span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span></span><br><span class="line">            data = e.target.result; <span class="comment">// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            </span></span><br><span class="line">        preview.style.backgroundImage = <span class="string">'url('</span> + data + <span class="string">')'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 以DataURL的形式读取文件:</span></span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><ul><li><p>JavaScript永远是<strong>单线程</strong>模式执行的，因此JavaScript的多任务都是<strong>异步</strong>调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader.readAsDataURL(file);</span><br></pre></td></tr></table></figure><ul><li><p>发起一个<strong>异步操作</strong>读取文件内容，即原有JS代码<strong>继续</strong>执行。</p></li><li><p>因为是异步操作，所以不能确定什么时候操作结束。</p></li><li><p>增加一个<strong>回调函数</strong>解决上述问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// After reading file, this function will be called automatically.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>所谓回调函数就是在异步操作结束后会自动执行的程序片段</p></blockquote></li></ul></li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ul><li><p>Asynchronized JavaScript and XML, 使用JavaScript执行<strong>异步网络请求</strong>。</p></li><li><p>Web运作原理：一次HTTP请求对应一个页面</p><p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p></li><li><p>通过AJAX发送请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>创建<code>XMLHttpRequest</code>对象</p><p>通过检测<code>window</code>对象有没有<code>XMLHttpRequest</code>属性来确定浏览器是否支持，不要通过<code>navigator.userAgent</code>判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    request = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置<code>onreadystatechange</code>回调函数</p><ul><li>通过<code>readyState === 4</code>判断请求是否完成</li><li>通过<code>status === 200</code>判断相应是否成功</li></ul></li><li><p>设置<code>open</code>请求参数</p><ul><li><p><code>GET</code>/<code>POST</code></p></li><li><p>URL地址<strong>（相对路径）</strong></p><blockquote><p>默认情况下，JavaScript在发送AJAX请求时，URL<strong>域名</strong>必须和当前页面完全一致）</p><ul><li>域名要相同（<code>www.example.com</code>和<code>example.com</code>不同）</li><li>协议要相同（<code>http</code>和<code>https</code>不同）</li><li>端口号要相同（默认是<code>:80</code>）</li></ul></blockquote></li><li><p>操作是否异步，默认为<code>true</code>（异步）。</p></li></ul></li><li><p>使用<code>send</code>发送请求</p><ul><li><code>GET</code>请求不需要参数</li><li><code>POST</code>请求需要把body部分以字符串或者<code>FormDate</code>对象传进去</li></ul></li></ul></li></ul><h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><p>JavaScript访问外域网站</p><ul><li><p>通过Flash（不推荐）</p></li><li><p>通过在同源域名下架设一个代理服务器来转发，JavaScript可以把请求发送到代理服务器。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'<span class="string">/proxy</span>?url=http:<span class="string">//www.sina.com.cn</span>'</span><br></pre></td></tr></table></figure><ul><li>代理服务器把结果返回，这样就遵循了浏览器的同源策略。</li></ul></li><li><p>JSONP</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://example.com/abc.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>只能用<code>GET</code>请求，并且要求返回JavaScript</li></ul><p>获取股票指数</p><ul><li><p>创建回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshPrice</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'test-jsonp'</span>);</span><br><span class="line">    p.innerHTML = <span class="string">'当前价格：'</span> +</span><br><span class="line">        data[<span class="string">'0000001'</span>].name +<span class="string">': '</span> + </span><br><span class="line">        data[<span class="string">'0000001'</span>].price + <span class="string">'；'</span> +</span><br><span class="line">        data[<span class="string">'1399001'</span>].name + <span class="string">': '</span> +</span><br><span class="line">        data[<span class="string">'1399001'</span>].price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>触发请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPrice</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        js = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>),</span><br><span class="line">        head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">    js.src = <span class="string">'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice'</span>;</span><br><span class="line">    head.appendChild(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>CORS(HTML5推荐)：Cross-Origin Resource Sharing</p><p>跨域是否成功取决于：对方服务器是否为当前域请求设置一个正确的<code>Access-Control-Allow-Origin</code>.</p></li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>“承诺在将来会执行”的对象被称为<code>Promise</code>对象</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeOut = <span class="built_in">Math</span>.random() * <span class="number">2</span>;</span><br><span class="line">    log(<span class="string">'set timeout to: '</span> + timeOut + <span class="string">' seconds.'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            log(<span class="string">'call resolve()...'</span>);</span><br><span class="line">            resolve(<span class="string">'200 OK'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            log(<span class="string">'call reject()...'</span>);</span><br><span class="line">            reject(<span class="string">'timeout in '</span> + timeOut + <span class="string">' seconds.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test);</span><br><span class="line"><span class="keyword">var</span> p2 = p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = p2.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><code>p1</code>是一个<code>Promise</code>对象，它负责执行<code>test</code>函数。由于<code>test</code>函数在内部是异步执行的，当<code>test</code>函数执行成功时，执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当执行失败时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p2.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>Promise</code>对象可以串联起来进行代码简化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(test).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>Promise</code>可以按顺序执行若干个<strong>异步任务</strong>（都是<code>Promise</code>对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job1.then(job2).then(job3).catch(handleError);</span><br></pre></td></tr></table></figure><blockquote><p><code>job1</code>成功才会执行<code>job2</code>，以此类推。</p></blockquote></li><li><p><code>Promise</code>可以<strong>并行</strong>执行异步任务</p><ul><li><p>独立的并行任务（汇合）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 同时执行p1和p2，并在它们都完成后执行then:</span></span><br><span class="line">  <span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(results); <span class="comment">// 获得一个Array: ['P1', 'P2']</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>为了容错时，例如向两个URL读取用户的个人信息，只需要获得先返回的结果即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 'P1'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><ul><li><p>HTML5提供的控件，用于替代Flash.</p></li><li><p>一个<code>Canvas</code>定义了一个指定尺寸的矩形框，在这个范围内可以随意绘制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span> = <span class="string">"test-canvas"</span> <span class="attr">width</span> = <span class="string">"300"</span> <span class="attr">height</span> = <span class="string">"200"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>浏览器如果<strong>支持</strong><code>Canvas</code>，则会<strong>忽略</strong><code>Canvas</code>内的HTML代码。</li></ul></li></ul><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><ul><li><p>绘制2D图像</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br></pre></td></tr></table></figure></li><li><p>绘制3D图像</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gl = canvas.getContext(<span class="string">'webgl'</span>);</span><br></pre></td></tr></table></figure></li><li><p>绘制带阴影的文字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">'test-text-canvas'</span>),</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height); <span class="comment">// 擦除(0,0)位置大小为Canvas大小的矩形，擦除的意思是把该区域变为透明</span></span><br><span class="line">ctx.shadowOffsetX = <span class="number">2</span>;</span><br><span class="line">ctx.shadowOffsetY = <span class="number">2</span>;</span><br><span class="line">ctx.shadowBlur = <span class="number">2</span>;</span><br><span class="line">ctx.shadowColor = <span class="string">'#666666'</span>;</span><br><span class="line">ctx.font = <span class="string">'24px Arial'</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'#333333'</span>; <span class="comment">// 设置颜色</span></span><br><span class="line">ctx.fillText(<span class="string">'带阴影的文字'</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中。</li><li>尽量使用整数坐标而不是浮点数</li><li>创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图。</li><li>背景图片如果不变可以直接用<code>img</code>标签并放到<strong>最底层</strong></li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>全文共<code>5160</code>字，推荐阅读时间<code>30~45</code>分钟。</p><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><ul><li>消除浏览器差异</li><li>简化DOM操作</li><li>轻松实现动画、修改CSS等各种操作</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>在页面的<code>&lt;head&gt;</code>引入jQuery文件即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//code.jquery.com/jquery-1.11.3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>$</code>符号</p><p>jQuery把所有的功能都封装在一个全局变量<code>jQuery</code>中，而<code>$</code>就是它的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line"><span class="built_in">window</span>.$;</span><br><span class="line">$ === jQuery; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span>($); <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><ul><li><p><code>$</code>本质上就是一个对象，可以是函数，<strong>也有</strong>其他属性。</p></li><li><p>当原有代码<strong>已经</strong>使用了<script type="math/tex">`这个变量时，需要让`jQuery`放弃`</script>，并且之后仅能使用<code>jQuery</code>变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">jQuery.noConflict();</span><br><span class="line">$; <span class="comment">// undefined or old value</span></span><br><span class="line">jQuery; <span class="comment">// jQuery(selector, context)</span></span><br></pre></td></tr></table></figure><blockquote><p>原理是<code>jQuery</code>在占用<script type="math/tex">`之前会保存原有`</script>，当放弃<code>$</code>时会将原来保存的变量还原。</p></blockquote></li></ul></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>选择器是jQuery的核心</p><ul><li><p>按<code>id</code>查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找&lt;div id="abc"&gt;:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>返回对象是jQuery对象，<strong>类似数组</strong>（但不是数组），每个元素都是一个DOM对象的引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"abc"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>选择器<strong>不会返回</strong><code>undefined</code>或者<code>null</code></p></blockquote></li><li><p>jQuery和DOM对象转化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>); <span class="comment">// jQuery object</span></span><br><span class="line"><span class="keyword">var</span> divDom = div.get(<span class="number">0</span>); <span class="comment">// first DOM object</span></span><br><span class="line"><span class="keyword">var</span> another = $(divDom); <span class="comment">// DOM object -&gt; jQuery object</span></span><br></pre></td></tr></table></figure><ul><li>获取元素的value<ul><li>DOM:<code>xxx.value</code></li><li>jQuery:<code>xxx.get(xxx).value</code>/<code>xxx.val()</code></li></ul></li></ul><blockquote><p>通常<strong>直接使用</strong>jQuery对象更方便</p></blockquote></li></ul></li><li><p>按<code>tag</code>查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">'p'</span>); <span class="comment">// all &lt;p&gt; nodes</span></span><br><span class="line">ps.length; <span class="comment">// count of &lt;p&gt; nodes</span></span><br></pre></td></tr></table></figure></li><li><p>按<code>class</code>查找</p><ul><li>在<code>class</code>名称<strong>前</strong>加一个<code>.</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'.red'</span>);</span><br></pre></td></tr></table></figure><ul><li>查找有<strong>多个</strong><code>class</code>的节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'.red.green'</span>); <span class="comment">// no space between classnames</span></span><br></pre></td></tr></table></figure></li><li><p>按属性查找</p><ul><li>当属性的值包含<strong>空格</strong>等特殊字符时，需要使用双引号括起来。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> email = $(<span class="string">'[name=email]'</span>); <span class="comment">// find &lt;??? name="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> passwordInput = $(<span class="string">'[type=password]'</span>); <span class="comment">// 找出&lt;??? type="password"&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'[items="A B"]'</span>); <span class="comment">// 找出&lt;??? items="A B"&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以使用前缀查找和后缀查找</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'[name^=icon]'</span>); <span class="comment">// 找出所有name属性值以icon开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: name="icon-1", name="icon-2"</span></span><br><span class="line"><span class="keyword">var</span> names = $(<span class="string">'[name$=with]'</span>); <span class="comment">// 找出所有name属性值以with结尾的DOM</span></span><br><span class="line"><span class="comment">// 例如: name="startswith", name="endswith"</span></span><br></pre></td></tr></table></figure><ul><li>前后缀查找法<strong>不受</strong><code>class</code>个数的影响</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'[class^="icon-"]'</span>);</span><br><span class="line"><span class="comment">// 例如: class="icon-clock", class="abc icon-home"</span></span><br></pre></td></tr></table></figure></li><li><p>组合查找</p><p>解决查找结果混入表单外元素的情况，例如<code>$(&#39;[name=email]&#39;)</code>可能返回表单外的<code>&lt;div name=&quot;email&quot;&gt;</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emailInput = $(<span class="string">'input[name=email]'</span>); <span class="comment">// mix input and name</span></span><br><span class="line"><span class="keyword">var</span> tr = $(<span class="string">'tr.red'</span>); <span class="comment">// mix tag and class to find &lt;tr class = "red..."&gt;&lt;/tr&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>多项选择器</p><p>使用<code>,</code>组合多个选择器，结果取<strong>并集</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p,div'</span>); <span class="comment">// select all &lt;p&gt; and &lt;div&gt;</span></span><br><span class="line">$(<span class="string">'p.red,p.green'</span>); <span class="comment">// select all &lt;p class="red"&gt; and &lt;p class="green"&gt;</span></span><br></pre></td></tr></table></figure><ul><li>数组中的元素是按照他们在HTML中出现的顺序排列的，而且<strong>不会有重复</strong>元素。</li></ul></li></ul><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><p>如果两个DOM元素具有层级关系，就可以用<code>$(&#39;ancestor descendant&#39;)</code>进行选择，层级之间使用<strong>空格</strong>隔开。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"testing"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang-javascript"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang-python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang-lua"</span>&gt;</span>Lua<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用层级选择器选出JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.testing li.lang-javascript'</span>); <span class="comment">// &lt;li class="lang-javascript"&gt;javascript&lt;/li&gt;</span></span><br><span class="line">$(<span class="string">'ul.lang li.lang-javascript'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>只要是<strong>祖先</strong>节点，<strong>都</strong>可以查找到对应的DOM子节点。</p></li><li><p>选择所有的<code>&lt;li&gt;</code>节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li'</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>多层</strong>选择</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'form.test p input'</span>); <span class="comment">// 在form表单选择被&lt;p&gt;包含的&lt;input&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><p><code>$(&#39;parent&gt;child&#39;)</code>类层级选择器，但是限定了两个元素必须是<strong>父子</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang&gt;li.lang-javascript'</span>); <span class="comment">// 可以选出[&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]</span></span><br></pre></td></tr></table></figure><blockquote><p>使用<code>&lt;div.testing&gt;</code>当父节点则<strong>无法</strong>选出</p></blockquote><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>通常使用<code>:</code>附加在选择器上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li'</span>); <span class="comment">// 选出JavaScript、Python和Lua 3个节点</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'ul.lang li:first-child'</span>); <span class="comment">// 仅选出JavaScript</span></span><br><span class="line">$(<span class="string">'ul.lang li:last-child'</span>); <span class="comment">// 仅选出Lua</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(2)'</span>); <span class="comment">// 选出第N个元素，N从1开始</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(even)'</span>); <span class="comment">// 选出序号为偶数的元素</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(odd)'</span>); <span class="comment">// 选出序号为奇数的元素</span></span><br></pre></td></tr></table></figure><h4 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h4><p>使用格式：<code>$(&#39;:input&#39;)</code>/<code>$(&#39;form :input&#39;)</code></p><ul><li><p><code>:input</code>：可以选择<code>&lt;input&gt;</code>/<code>&lt;textarea&gt;</code>/<code>&lt;select&gt;</code>/<code>&lt;button&gt;</code></p></li><li><p><code>:file</code>：可以选择<code>&lt;input type=&quot;file&quot;&gt;</code>，等价于<code>input[type=file]</code>.</p></li><li><p><code>:checkbox</code>：选择复选框，等价于<code>input[type=checkbox]</code>.</p></li><li><p><code>:radio</code>：选择单选框</p></li><li><p><code>:focus</code>：选择当前输入焦点的元素，即当前光标所在的<code>&lt;input&gt;</code></p></li><li><p><code>:checked</code>：选择<strong>当前勾上</strong>的单选框和复选框，等价于<code>$(&#39;input[type=radio]:checked&#39;)</code>.</p><blockquote><p>复选框<code>&lt;checkbox&gt;</code>同理，但是有时候复选框内是<code>&lt;option&gt;</code>，则需要使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'option:checked'</span>).val();</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>:enabled</code>：正常的<code>&lt;input&gt;</code>/<code>&lt;select&gt;</code></p></li><li><p><code>:disabled</code>：选择不能输入的</p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><code>$(&#39;div:visible&#39;);</code>：选择所有可见的<code>&lt;div&gt;</code></li><li><code>$(&#39;div:hidden&#39;);</code>：选择所有隐藏的<code>&lt;div&gt;</code></li></ul><h3 id="查找和过滤"><a href="#查找和过滤" class="headerlink" title="查找和过滤"></a>查找和过滤</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>除了直接定位对象，还可以在拿到一个jQuery对象之后以它为基准进行查找。</p><ul><li><p><code>find()</code>：本身接收一个<strong>任意的选择器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js dy"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dy"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"swift"</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dy"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">"haskell"</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'ul.lang'</span>); <span class="comment">// 获得&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> dy = ul.find(<span class="string">'.dy'</span>); <span class="comment">// 获得JavaScript, Python, Scheme</span></span><br><span class="line"><span class="keyword">var</span> swf = ul.find(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> hsk = ul.find(<span class="string">'[name=haskell]'</span>); <span class="comment">// 获得Haskell</span></span><br></pre></td></tr></table></figure></li><li><p><code>parent()</code>：从当前节点<strong>向上</strong>查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swf = $(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> parent = swf.parent(); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = swf.parent(<span class="string">'.red'</span>); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象</span></span><br></pre></td></tr></table></figure></li><li><p><code>next()</code>/<code>prev()</code>：查找同一层级的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swift = $(<span class="string">'#swift'</span>);</span><br><span class="line"></span><br><span class="line">swift.next(); <span class="comment">// Scheme</span></span><br><span class="line">swift.next(<span class="string">'[name=haskell]'</span>); <span class="comment">// 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]</span></span><br><span class="line"></span><br><span class="line">swift.prev(); <span class="comment">// Python</span></span><br><span class="line">swift.prev(<span class="string">'.dy'</span>); <span class="comment">// Python，因为Python同时符合过滤器条件.dy</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p><code>filter()</code>可以<strong>过滤掉不符合</strong>选择器条件的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> a = langs.filter(<span class="string">'.dy'</span>); <span class="comment">// 拿到JavaScript, Python, Scheme</span></span><br></pre></td></tr></table></figure><ul><li><p>传入函数参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line">langs.filter(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML.indexOf(<span class="string">'S'</span>) === <span class="number">0</span>; <span class="comment">// 返回S开头的节点</span></span><br><span class="line">&#125;); <span class="comment">// 拿到Swift, Scheme</span></span><br></pre></td></tr></table></figure><ul><li><p><code>this</code>被绑定为<code>DOM</code>对象，而<strong>不是</strong>jQuery对象。</p></li><li><p>使用<code>map</code>将jQuery数组进行转化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> arr = langs.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML;</span><br><span class="line">&#125;).get(); <span class="comment">// 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']</span></span><br></pre></td></tr></table></figure><ul><li><strong>不带参数</strong>的<code>get()</code>可以得到jQuery类数组中<strong>所有的</strong>DOM元素组成的数组</li></ul></li></ul></li><li><p>其他操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> js = langs.first(); <span class="comment">// JavaScript，相当于$('ul.lang li:first-child')</span></span><br><span class="line"><span class="keyword">var</span> haskell = langs.last(); <span class="comment">// Haskell, 相当于$('ul.lang li:last-child')</span></span><br><span class="line"><span class="keyword">var</span> sub = langs.slice(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// Swift, Scheme, 参数和数组的slice()方法一致</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="操作DOM-1"><a href="#操作DOM-1" class="headerlink" title="操作DOM"></a>操作DOM</h2><h3 id="修改DOM节点"><a href="#修改DOM节点" class="headerlink" title="修改DOM节点"></a>修改DOM节点</h3><ul><li><p>修改Text和HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test-ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">"book"</span>&gt;</span>Java <span class="symbol">&amp;amp;</span> JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).text(); <span class="comment">// 'Java &amp; JavaScript'</span></span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).html(); <span class="comment">// 'Java &amp;amp; JavaScript'</span></span><br></pre></td></tr></table></figure><ul><li><p>无参数调用<code>text()</code>/<code>html()</code>是获取文本，传入参数就变成<strong>设置</strong>文本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j1.html(<span class="string">'&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;'</span>);</span><br><span class="line">j2.text(<span class="string">'JavaScript &amp; ECMAScript'</span>);</span><br></pre></td></tr></table></figure></li><li><p>对jQuery对象的修改会影响其中的<strong>所有</strong>DOM元素</p></li><li><p>当jQuery对象是<strong>空</strong>时尝试修改也<strong>不会报错</strong>（省略<code>if</code>判断）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'not-exist'</span>).text(<span class="string">'Hello'</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改CSS</p><p>利用jQuery<strong>批量修改</strong>的特点实现高亮显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test-css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang dy"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang dy"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"lang dy"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-css li.dy&gt;span'</span>).css(<span class="string">'background-color'</span>, <span class="string">'#ffd351'</span>).css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>css(&#39;name&#39;, &#39;value&#39;)</code>：作用于DOM节点的<code>style</code>属性，修改CSS样式表中对应域的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.css(<span class="string">'color'</span>); <span class="comment">// '#000033', 获取CSS属性</span></span><br><span class="line">div.css(<span class="string">'color'</span>, <span class="string">'#336699'</span>); <span class="comment">// 设置CSS属性</span></span><br><span class="line">div.css(<span class="string">'color'</span>, <span class="string">''</span>); <span class="comment">// 清除CSS属性</span></span><br></pre></td></tr></table></figure></li><li><p><code>background-color</code>和<code>backgroundColor</code>等价</p></li><li><p>修改DOM节点的<code>class</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.hasClass(<span class="string">'highlight'</span>); <span class="comment">// false， class是否包含highlight</span></span><br><span class="line">div.addClass(<span class="string">'highlight'</span>); <span class="comment">// 添加highlight这个class</span></span><br><span class="line">div.removeClass(<span class="string">'highlight'</span>); <span class="comment">// 删除highlight这个class</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>显示和隐藏DOM</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'a[target=_blank]'</span>);</span><br><span class="line">a.hide(); <span class="comment">// 隐藏</span></span><br><span class="line">a.show(); <span class="comment">// 显示</span></span><br></pre></td></tr></table></figure><blockquote><p>显示和隐藏<strong>不改变</strong>原有的DOM树结构</p></blockquote></li><li><p>获取DOM信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器可视窗口大小:</span></span><br><span class="line">$(<span class="built_in">window</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">window</span>).height(); <span class="comment">// 600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML文档大小:</span></span><br><span class="line">$(<span class="built_in">document</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">document</span>).height(); <span class="comment">// 3500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个div的大小:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.width(); <span class="comment">// 600</span></span><br><span class="line">div.height(); <span class="comment">// 300</span></span><br><span class="line">div.width(<span class="number">400</span>); <span class="comment">// 设置CSS属性 width: 400px，是否生效要看CSS是否有效</span></span><br><span class="line">div.height(<span class="string">'200px'</span>); <span class="comment">// 设置CSS属性 height: 200px，是否生效要看CSS是否有效</span></span><br></pre></td></tr></table></figure><ul><li><p><code>attr()</code>/<code>removeAttr()</code>常用于操作DOM节点的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id="test-div" name="Test" start="1"&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.attr(<span class="string">'data'</span>); <span class="comment">// undefined, 属性不存在</span></span><br><span class="line">div.attr(<span class="string">'name'</span>); <span class="comment">// 'Test'</span></span><br><span class="line">div.attr(<span class="string">'name'</span>, <span class="string">'Hello'</span>); <span class="comment">// div的name属性变为'Hello'</span></span><br><span class="line">div.removeAttr(<span class="string">'name'</span>); <span class="comment">// 删除name属性</span></span><br><span class="line">div.attr(<span class="string">'name'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><p><code>prop()</code>方法和<code>attr()</code>类似，但是在<code>checked</code>的处理上不同。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test-radio"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">checked</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test-radio"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>两种<code>checked</code>的表示都是合法的</p></li><li><p>两个方法的返回值<strong>不同</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radio = $(<span class="string">'#test-radio'</span>);</span><br><span class="line">radio.attr(<span class="string">'checked'</span>); <span class="comment">// 'checked'</span></span><br><span class="line">radio.prop(<span class="string">'checked'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>推荐</strong>使用<code>is()</code>判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radio = $(<span class="string">'#test-radio'</span>);</span><br><span class="line">radio.is(<span class="string">':checked'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>类似的<code>selected</code>使用<code>is(&#39;:selected&#39;)</code>处理</p></blockquote></li></ul></li></ul></li></ul></li><li><p>操作表单</p><p>jQuery对象统一使用<code>val()</code>方法<strong>获取和设置</strong>对应的<code>value</code>属性</p></li></ul><h3 id="修改DOM结构"><a href="#修改DOM结构" class="headerlink" title="修改DOM结构"></a>修改DOM结构</h3><ul><li><p>添加DOM</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-div"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>拿到节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'#test-div&gt;ul'</span>);</span><br></pre></td></tr></table></figure></li><li><p>调用<code>append</code>传入<code>HTML</code>片段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>append</code>还可以传入其他对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建DOM对象:</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">ps.innerHTML = <span class="string">'&lt;span&gt;Pascal&lt;/span&gt;'</span>;</span><br><span class="line"><span class="comment">// 添加DOM对象:</span></span><br><span class="line">ul.append(ps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加jQuery对象:</span></span><br><span class="line">ul.append($(<span class="string">'#scheme'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加函数对象:</span></span><br><span class="line">ul.append(<span class="function"><span class="keyword">function</span> (<span class="params">index, html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;li&gt;&lt;span&gt;Language - '</span> + index + <span class="string">'&lt;/span&gt;&lt;/li&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>在添加函数对象时，要求返回一个字符串/DOM对象/jQuery对象。</li></ul></li><li><p><code>prepend</code>和<code>append</code>相对</p></li><li><p><strong>同级节点</strong>的插入可以使用<code>before()</code>/<code>after()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = $(<span class="string">'#test-div&gt;ul&gt;li:first-child'</span>);</span><br><span class="line">js.after(<span class="string">'&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>删除节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> li = $(<span class="string">'#test-div&gt;ul&gt;li'</span>);</span><br><span class="line">li.remove(); <span class="comment">// delete all li DOM nodes</span></span><br></pre></td></tr></table></figure></li><li><p><code>innerText</code>&amp;<code>innerHTML</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>   This element has extra spacing     and contains <span class="tag">&lt;<span class="name">span</span>&gt;</span>a span element<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = $(<span class="string">'#demo'</span>).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>p.innerText</code>：<code>&quot;This element has extra spacing and contains a span element.&quot;</code></p><p>返回忽略<strong>所有的tag和多余空格</strong>的字符串</p></li><li><p><code>p.innerHTML</code>：<code>&quot;  This element has extra spacing   and contains &lt;span&gt;a span element&lt;/span&gt;.&quot;</code></p><p>返回<strong>原样</strong>字符串</p></li><li><p><code>p.textContent</code>：<code>&quot;  This element has extra spacing  and contains a span element.&quot;</code></p><p>返回<strong>含有多余空格</strong>的字符串</p></li></ul></li></ul><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>除了列出的3种语言外，请再添加Pascal、Lua和Ruby，然后按字母顺序排序节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-div"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    arr,</span><br><span class="line">    li,</span><br><span class="line">    ul = $(<span class="string">'#test-div ul'</span>);</span><br><span class="line"></span><br><span class="line">ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;Pascal&lt;/span&gt;&lt;/li&gt;'</span>).append(<span class="string">'&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'</span>).append(<span class="string">'&lt;li&gt;&lt;span&gt;Ruby&lt;/span&gt;&lt;/li&gt;'</span>);</span><br><span class="line">li = ul.find(<span class="string">'li'</span>);</span><br><span class="line">span = li.find(<span class="string">'span'</span>);</span><br><span class="line"></span><br><span class="line">span.each(<span class="function">(<span class="params">x, elem</span>) =&gt;</span> &#123;</span><br><span class="line">    arr.push(elem);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.innerText &gt; b.innerText) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a.innerText &lt; b.innerText) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ul.empty();</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;'</span>+ x.innerHTML +<span class="string">'&lt;/span&gt;&lt;/li&gt;'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>jQuery元素的遍历：<code>each(index, elem)</code></p><blockquote><p>可以先转换为DOM后遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.get().forEach(elem, index, array);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>数组的遍历<code>forEach(elem, index, array)</code>（和前者<strong>参数顺序</strong>区别）</p></li><li><p><code>sort</code>函数返回的<strong>不是</strong>布尔值，而是<code>-1 0 1</code>.</p></li><li><p>数据层次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">jQuery--&gt;DOM</span><br><span class="line">DOM--&gt;innerHTML&#x2F;innerText</span><br></pre></td></tr></table></figure></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li>页面加载后，一旦页面上默认执行的JS代码被执行完之后，就只能依赖触发事件来执行JS代码。</li></ul><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul><li>click：单击触发</li><li>dblclick：双击触发</li><li>mouseenter：鼠标进入触发</li><li>mouseleave：鼠标离开触发</li><li>mousemove：鼠标在DOM内移动触发</li><li>hover：相当于mouseenter加上mouseleave</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;a id="test-link" href="#0"&gt;点我试试&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取超链接的jQuery对象:</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'#test-link'</span>);</span><br><span class="line">a.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>事件捕捉可以简化<strong>（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p><strong>仅作用</strong>在当前焦点的DOM上，通常是<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>.</p><ul><li>keydown：键盘按下时触发</li><li>keyup：键盘松开时触发</li><li>keypress：按一次键后触发</li></ul><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><ul><li><p>focus：当DOM获得焦点时触发</p></li><li><p>blur：当DOM失去焦点时触发</p></li><li><p>change：当<code>&lt;input&gt;</code>/<code>&lt;select&gt;</code>/<code>&lt;textarea&gt;</code>的内容改变时触发</p></li><li><p>submit：当<code>&lt;form&gt;</code>提交时触发</p></li><li><p>ready：当页面被载入并且DOM树<strong>完成初始化</strong>后触发</p><ul><li><p>仅作用于<code>document</code>对象</p></li><li><p>常用来约束初始化的先后顺序</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 代码有误:</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">'#testForm'</span>).on(<span class="string">'submit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">'submit!'</span>);</span></span><br><span class="line">        &#125;);</span><br><span class="line"><span class="actionscript"><span class="comment">// correct:</span></span></span><br><span class="line"><span class="javascript">$(<span class="built_in">document</span>).on(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">'#testForm'</span>).on(<span class="string">'submit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">                alert(<span class="string">'submit!'</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testForm"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>不使用<code>ready</code>约束时，<code>testForm</code>表单还没有初始化，<code>submit</code>事件就发起了绑定请求，此时绑定不会成功。</p></li><li><p>使用<code>ready</code>和<code>submit</code>简化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testForm'</span>).submit(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'submit!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>直接省略<code>ready</code></strong>（常用且推荐）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testForm'</span>).submit(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'submit!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h3><p>所有的事件都会传入<code>Event</code>对象作为参数，可以从<code>Event</code>对象上获取更多信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testMouseMoveDiv'</span>).mousemove(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testMouseMoveSpan'</span>).text(<span class="string">'pageX = '</span> + e.pageX + <span class="string">', pageY = '</span> + e.pageY);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>此时<code>e</code>就是一个<code>Event</code>对象</p></blockquote><h4 id="解除绑定"><a href="#解除绑定" class="headerlink" title="解除绑定"></a>解除绑定</h4><p>一个被绑定的事件可以解除绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.click(hello);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">a.off(<span class="string">'click'</span>, hello);</span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>off</code>中的函数参数必须和绑定的函数<strong>完全一致</strong>，也就是说在<code>click</code>绑定时就<strong>不能使用</strong>匿名函数。</p></li><li><p>一次性移除<code>click</code>事件绑定的所有函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.off(<span class="string">'click'</span>);</span><br></pre></td></tr></table></figure></li><li><p>移除DOM绑定的所有函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.off();</span><br></pre></td></tr></table></figure></li></ul><h4 id="事件触发条件"><a href="#事件触发条件" class="headerlink" title="事件触发条件"></a>事件触发条件</h4><p>事件的触发<strong>总是</strong>由用户决定的</p><ul><li><p>监控文本框改动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.change(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'changed...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>这个函数只会被<strong>用户</strong>输入触发，使用JS修改不会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.val(<span class="string">'change it!'</span>); <span class="comment">// 无法触发change事件</span></span><br></pre></td></tr></table></figure><ul><li><p>特殊情况下，JS中无参数<code>change()</code>会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.val(<span class="string">'change it!'</span>);</span><br><span class="line">input.change(); <span class="comment">// input.trigger('change');</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="浏览器安全限制"><a href="#浏览器安全限制" class="headerlink" title="浏览器安全限制"></a>浏览器安全限制</h3><p>部分JS代码只能在<strong>用户触发</strong>下才能执行，例如<code>window.open()</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法弹出新窗口，将被浏览器屏蔽:</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">'/'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button1 = $(<span class="string">'#testPopupButton1'</span>);</span><br><span class="line"><span class="keyword">var</span> button2 = $(<span class="string">'#testPopupButton2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popupTestWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">'/'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button1.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    popupTestWindow();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">button2.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不立刻执行popupTestWindow()，3秒后执行:</span></span><br><span class="line">    setTimeout(popupTestWindow, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>对于<code>button1</code>，因为函数在事件中<strong>立即</strong>执行，因此可以成功。</li><li>对于<code>button2</code>，因为函数被<strong>延迟执行</strong>，当开始执行时<code>click</code>事件已经结束，故<strong>不会执行</strong>。（不同的浏览器行为存在差异，safari可以屏蔽，但是chrome存在打开情况）</li></ul><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>对如下的Form表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span> <span class="attr">action</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>请选择想要学习的编程语言：<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"selectAll"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"selectAll"</span>&gt;</span>全选<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">"deselectAll"</span>&gt;</span>全不选<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#0"</span> <span class="attr">class</span>=<span class="string">"invertSelect"</span>&gt;</span>反选<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"javascript"</span>&gt;</span> JavaScript<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"python"</span>&gt;</span> Python<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"ruby"</span>&gt;</span> Ruby<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"haskell"</span>&gt;</span> Haskell<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lang"</span> <span class="attr">value</span>=<span class="string">"scheme"</span>&gt;</span> Scheme<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绑定合适的事件处理函数，实现以下逻辑：</p><ul><li>当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选”；</li><li>当用户去掉“全不选”时，自动不选中所有语言；</li><li>当用户点击“反选”时，自动把所有语言状态反转（选中的变为未选，未选的变为选中）；</li><li>当用户把所有语言都手动勾上时，“全选”被自动勾上，并变为“全不选”；</li><li>当用户手动去掉选中至少一种语言时，“全不选”自动被去掉选中，并变为“全选”。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    form = $(<span class="string">'#test-form'</span>),</span><br><span class="line">    langs = form.find(<span class="string">'[name=lang]'</span>),</span><br><span class="line">    selectAll = form.find(<span class="string">'label.selectAll :checkbox'</span>),</span><br><span class="line">    selectAllLabel = form.find(<span class="string">'label.selectAll span.selectAll'</span>),</span><br><span class="line">    deselectAllLabel = form.find(<span class="string">'label.selectAll span.deselectAll'</span>),</span><br><span class="line">    invertSelect = form.find(<span class="string">'a.invertSelect'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置初始化状态:</span></span><br><span class="line">form.find(<span class="string">'*'</span>).show().off();</span><br><span class="line">form.find(<span class="string">':checkbox'</span>).prop(<span class="string">'checked'</span>, <span class="literal">false</span>).off();</span><br><span class="line">deselectAllLabel.hide();</span><br><span class="line"><span class="comment">// 拦截form提交事件:</span></span><br><span class="line">form.off().submit(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    alert(form.serialize());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    form = $(<span class="string">'#test-form'</span>),</span><br><span class="line">    langs = form.find(<span class="string">'[name=lang]'</span>),</span><br><span class="line">    selectAll = form.find(<span class="string">'label.selectAll :checkbox'</span>),</span><br><span class="line">    selectAllLabel = form.find(<span class="string">'label.selectAll span.selectAll'</span>),</span><br><span class="line">    deselectAllLabel = form.find(<span class="string">'label.selectAll span.deselectAll'</span>),</span><br><span class="line">    invertSelect = form.find(<span class="string">'a.invertSelect'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置初始化状态:</span></span><br><span class="line">form.find(<span class="string">'*'</span>).show().off();</span><br><span class="line">form.find(<span class="string">':checkbox'</span>).prop(<span class="string">'checked'</span>, <span class="literal">false</span>).off();</span><br><span class="line">deselectAllLabel.hide();</span><br><span class="line"><span class="comment">// 拦截form提交事件:</span></span><br><span class="line">form.off().submit(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    alert(form.serialize());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectAll.prop(<span class="string">'checked'</span>)) &#123;</span><br><span class="line">        selectAllLabel.hide();</span><br><span class="line">        deselectAllLabel.show();</span><br><span class="line">        langs.prop(<span class="string">'checked'</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        langs.prop(<span class="string">'checked'</span>, <span class="literal">false</span>);</span><br><span class="line">        deselectAllLabel.hide();</span><br><span class="line">        selectAllLabel.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selectAll.change(setAll);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invertSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    langs.get().forEach(<span class="function">(<span class="params">elem</span>) =&gt;</span> elem.checked = !elem.checked);</span><br><span class="line">    <span class="comment">// langs.each((i, elem) =&gt; &#123;elem.checked = !elem.checked&#125;);</span></span><br><span class="line">    checkAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invertSelect.click(invertSet);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> allLangs = langs.get().every(<span class="function">(<span class="params">x</span>) =&gt;</span> x.checked);</span><br><span class="line">    <span class="keyword">if</span> (allLangs) &#123;</span><br><span class="line">        selectAllLabel.hide();</span><br><span class="line">        deselectAllLabel.show();</span><br><span class="line">        selectAll.prop(<span class="string">'checked'</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        selectAllLabel.show();</span><br><span class="line">        deselectAllLabel.hide();</span><br><span class="line">        selectAll.prop(<span class="string">'checked'</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">langs.change(checkAll);</span><br></pre></td></tr></table></figure><ul><li>在使用箭头函数时，就算<strong>只有一条语句</strong>也最好加上<code>{}</code>，否则<code>each</code>会有异常。</li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>原理：以固定的时间间隔（如0.1s），每次把DOM元素的CSS样式修改一点，看起来就像动画了。</p><h3 id="show-hide"><a href="#show-hide" class="headerlink" title="show/hide"></a>show/hide</h3><p>调用<code>show()</code>和<code>hide()</code>时传进一个参数，就变成了动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-show-hide'</span>);</span><br><span class="line">div.hide(<span class="number">3000</span>); <span class="comment">// 3000ms</span></span><br><span class="line">div.show(<span class="string">'slow'</span>); <span class="comment">// 600ms</span></span><br></pre></td></tr></table></figure><ul><li><code>toggle</code>根据当前状态取反决定<code>show</code>还是<code>hide</code></li><li>动画都从<strong>左上角</strong>展开/收缩的</li></ul><h3 id="slideUp-slideDown"><a href="#slideUp-slideDown" class="headerlink" title="slideUp/slideDown"></a>slideUp/slideDown</h3><ul><li>动画像卷帘一样（上下）</li><li>一样有<code>slideToggle()</code>函数</li></ul><h3 id="fadeIn-fadeOut"><a href="#fadeIn-fadeOut" class="headerlink" title="fadeIn/fadeOut"></a>fadeIn/fadeOut</h3><ul><li>动画效果是<strong>原地淡入淡出</strong>（原理是设置<code>opacity</code>属性）</li><li>一样有<code>fadeToggle()</code>函数</li></ul><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><ul><li><p>通过<code>animate()</code>实现</p><p>参数是DOM元素<strong>最终的</strong>CSS状态和时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animate'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li><p>传入函数参数作为<strong>回调</strong>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animate'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"end of cartoon."</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="串行动画"><a href="#串行动画" class="headerlink" title="串行动画"></a>串行动画</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animates'</span>);</span><br><span class="line"><span class="comment">// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小</span></span><br><span class="line">div.slideDown(<span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'256px'</span>,</span><br><span class="line">       height: <span class="string">'256px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'128px'</span>,</span><br><span class="line">       height: <span class="string">'128px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AJAX-1"><a href="#AJAX-1" class="headerlink" title="AJAX"></a>AJAX</h2><ul><li><p>全局对象<code>jQuery</code>绑定了<code>ajax()</code>函数</p></li><li><p><code>ajax(url, settings)</code>接收一个URL和可选的<code>settings</code>对象</p><ul><li>async：异步执行AJAX，<strong>默认</strong>为<code>true</code>.（最好<strong>不要修改</strong>）</li><li>method：<strong>缺省</strong>为<code>&#39;GET&#39;</code>，可指定为<code>&#39;POST&#39;</code>/<code>&#39;PUT&#39;</code>.</li><li>contentType：发送POST请求所使用的格式</li><li>data：发送的数据，字符串/数组/object.</li><li>headers：发送额外的HTTP头，必须是一个object.</li><li>dataType：接收得数据格式，可以指定为html/xml/json/text.</li></ul></li><li><p>下例发送一个<code>GET</code>请求，并返回一个<code>JSON</code>格式的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'xxx'</span>, &#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用链式写法模拟回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxLog</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> txt = $(<span class="string">'#test-response-text'</span>);</span><br><span class="line">    txt.val(txt.val() + <span class="string">'\n'</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#test-response-text'</span>).val(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'/api/categories'</span>, &#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'成功, 收到的数据: '</span> + <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;).fail(<span class="function"><span class="keyword">function</span> (<span class="params">xhr, status</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'失败: '</span> + xhr.status + <span class="string">', 原因: '</span> + status);</span><br><span class="line">&#125;).always(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'请求完成: 无论成功或失败都会调用'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.<span class="keyword">get</span>('xxx', &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>第二个参数是对象时，会自动变成query string追加到url后面，不需要手动编码。</li></ul><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.post(<span class="string">'xxx'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>和<code>get</code>类似，只是第二个参数（对象）序列化方式不同。</li></ul><h3 id="getJSON"><a href="#getJSON" class="headerlink" title="getJSON"></a>getJSON</h3><p>用于快速获取一个JSON对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.getJSON(<span class="string">'xxx'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// data is already in JSON format</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="安全限制-1"><a href="#安全限制-1" class="headerlink" title="安全限制"></a>安全限制</h3><p>和AJAX的安全限制一致</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>通过扩展jQuery来实现自定义方法</p><h3 id="编写jQuery插件"><a href="#编写jQuery插件" class="headerlink" title="编写jQuery插件"></a>编写jQuery插件</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>通过向<code>$.fn</code>绑定新对象实现</li><li>插件函数最后要<code>return this;</code></li><li>插件函数要有默认值，绑定在<code>$.fn.&lt;pluginName&gt;.defaults</code>对象上。</li><li>用户在调用时可以传入自定义值覆盖调用值</li></ul><h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><ul><li><p>新增高亮插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, <span class="string">'#fffceb'</span>).css(<span class="string">'color'</span>, <span class="string">'#d85030'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>this</code>在调用时被绑定为<strong>jQuery对象</strong>，所有的jQuery对象都可以<strong>直接调用</strong>（不需要<code>,fn</code>）该方法。</p></li><li><p><code>return this;</code>是为了支持jQuery的链式操作特征</p></li><li><p>验证</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-highlight1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>什么是<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span>是目前最流行的<span class="tag">&lt;<span class="name">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span>库。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-highlight1 span'</span>).highlight1();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>改进高亮插件，增加颜色自定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight2 = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bgcolor = options &amp;&amp; options.backgroundColor || <span class="string">'#fffceb'</span>;</span><br><span class="line">    <span class="keyword">var</span> color = options &amp;&amp; options.color || <span class="string">'#d85030'</span>;</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, bgcolor).css(<span class="string">'color'</span>, color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意过滤options本身及其属性为<code>undefined</code>的情况</p></li><li><p>验证</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-highlight2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>什么是<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Plugin<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>编写<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Plugin<span class="tag">&lt;/<span class="name">span</span>&gt;</span>可以用来扩展<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的功能。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-highlight2 span'</span>).highlight2(&#123;</span><br><span class="line">    backgroundColor: <span class="string">'#00a8e6'</span>,</span><br><span class="line">    color: <span class="string">'#ffffff'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>升级高亮插件，增加<strong>自定义缺省值</strong>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> opts = $.extend(&#123;&#125;, $.fn.highlight.defaults, options);</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, opts.backgroundColor).css(<span class="string">'color'</span>, opts.color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.fn.highlight.defaults = &#123;</span><br><span class="line">    color: <span class="string">'#d85030'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'#fff8de'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>$.extend(target, obj1, obj2, ...)</code>：<strong>高级短路操作</strong>，将<code>target</code>之后的对象拆开，将其属性求并集加入<code>target</code>中。对于同名属性，<strong>位置越靠后优先级越高</strong>。</p></li><li><p>验证</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-highlight"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>如何编写<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Plugin<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>编写<span class="tag">&lt;<span class="name">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Plugin<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，要设置<span class="tag">&lt;<span class="name">span</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，并允许用户修改<span class="tag">&lt;<span class="name">span</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，或者运行时传入<span class="tag">&lt;<span class="name">span</span>&gt;</span>其他值<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight.defaults.color = <span class="string">'#659f13'</span>;</span><br><span class="line">$.fn.highlight.defaults.backgroundColor = <span class="string">'#f2fae3'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#test-highlight p:first-child span'</span>).highlight();</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#test-highlight p:last-child span'</span>).highlight(&#123;</span><br><span class="line">    color: <span class="string">'#dd1144'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="针对特定元素扩展"><a href="#针对特定元素扩展" class="headerlink" title="针对特定元素扩展"></a>针对特定元素扩展</h3><p>让插件只能在特定的DOM元素上使用</p><h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4><p>为所有指向外链的超链接加上跳转提示</p><ul><li><p>用户调用代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#main a'</span>).external();</span><br></pre></td></tr></table></figure></li><li><p>编写<code>external</code>扩展</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.fn.external = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return返回的each()返回结果，支持链式调用:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="string">'a'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注意: each()内部的回调函数的this绑定为DOM本身!</span></span><br><span class="line">        <span class="keyword">var</span> a = $(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">var</span> url = a.attr(<span class="string">'href'</span>);</span><br><span class="line">        <span class="keyword">if</span>(url &amp;&amp; (url.indexOf(<span class="string">'https://'</span>) === <span class="number">0</span>) || url.indexOf(<span class="string">'https://'</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">            a.attr(<span class="string">'href'</span>, <span class="string">"#0"</span>)</span><br><span class="line">             .removeAttr(<span class="string">'target'</span>)</span><br><span class="line">             .append(<span class="string">' &lt;i class="uk-icon-external-link"&gt;&lt;/i&gt;'</span>)</span><br><span class="line">             .click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                 <span class="keyword">if</span>(confirm(<span class="string">'sure to go to '</span> + url + <span class="string">'?'</span>)) &#123;</span><br><span class="line">                     <span class="built_in">window</span>.open(url);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>全文共<code>633</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><ul><li><p>错误类型</p><ul><li><p>程序逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> len = s.length;</span><br></pre></td></tr></table></figure><ul><li><code>null</code>对象访问<code>length</code>对象会出错</li></ul></li><li><p>无法预测</p><ul><li>网络中断</li><li>文件不存在</li><li>权限问题</li></ul></li></ul></li><li><p>处理机制</p><p>和Java类似，采用<code>try...catch...finally</code>机制</p><ul><li><code>catch</code>和<code>finally</code>都可以省略</li></ul></li><li><p>错误类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">Error--&gt;TypeError</span><br><span class="line">Error--&gt;ReferenceError</span><br><span class="line">Error--&gt;...</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>) &#123;</span><br><span class="line">        alert(<span class="string">'Type error!'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">        alert(e.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'Error: '</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不同于Java，在JavaScript中只<code>catch</code><strong>一次</strong>，各个错误的分类处理通过<code>if</code>实现。</li></ul></li><li><p>抛出错误</p><p>和Java类似，使用<code>throw</code>语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r, n, s;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    s = prompt(<span class="string">'Please input a number:'</span>);</span><br><span class="line">    n = <span class="built_in">parseInt</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(n)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not a Number!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// Error: Not a Number!</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h2><ul><li>和Java类似，JavaScript的错误会逐层向上抛出，直到<strong>第一个</strong><code>try...catch</code>语句。</li><li>抛出错误的方法<strong>不需要</strong>特殊声明<code>throws ...</code></li></ul><h2 id="异步错误处理"><a href="#异步错误处理" class="headerlink" title="异步错误处理"></a>异步错误处理</h2><p>异步代码无法确保在调用时捕获错误，因为在捕获有效时，回调函数可能并未执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    setTimeout(printTime, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行时<strong>不会</strong>触发<code>catch</code>语句</p></li><li><p>同理，对于事件处理，在<strong>绑定事件的代码处</strong>处理错误是没有效果的。</p><ul><li><p>以下js代码在输入错误时按键<strong>不会</strong>报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $btn.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span></span><br><span class="line">            x = <span class="built_in">parseFloat</span>($(<span class="string">'#x'</span>).val()),</span><br><span class="line">            y = <span class="built_in">parseFloat</span>($(<span class="string">'#y'</span>).val()),</span><br><span class="line">            r;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(x) || <span class="built_in">isNaN</span>(y)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'输入有误'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r = x + y;</span><br><span class="line">        alert(<span class="string">'计算结果：'</span> + r);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    alert(<span class="string">'输入有误！'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题在于<code>try...catch</code>在按下按钮前已经执行完了，因此输入错误不能够找到对应的错误处理函数。</li></ul></li><li><p>修改后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        x = <span class="built_in">parseFloat</span>($(<span class="string">'#x'</span>).val()),</span><br><span class="line">        y = <span class="built_in">parseFloat</span>($(<span class="string">'#y'</span>).val()),</span><br><span class="line">        r;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(x) || <span class="built_in">isNaN</span>(y)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'输入有误'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    r = x + y;</span><br><span class="line">    alert(<span class="string">'计算结果：'</span> + r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callCal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cal();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        alert(<span class="string">'输入有误！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$btn.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cal();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        alert(<span class="string">'输入有误！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>修改的要点：<code>click</code>绑定的函数在每次<code>click</code>时<strong>都会执行</strong>，所以错误处理逻辑需要封装进<code>click</code>绑定的函数。</p></li><li><p><code>click</code>的参数列表是<code>[ [ data ,]  handler ]</code></p><p>因此如果传入的参数是<strong>匿名函数</strong>即<code>function(xxx){...}</code>，此时<code>click</code>把参数解析为<code>handler</code>.但是如果传入的是一个封装好的函数，就会被识别成<code>data</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$btn.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cal();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        alert(<span class="string">'输入有误！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// equals</span></span><br><span class="line">$btn.click(callCal, callCal);</span><br></pre></td></tr></table></figure><ul><li>第一个<code>callCal</code>是用来<strong>占位</strong>的</li></ul></li></ul></li></ul></li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul><h1 id="underscore"><a href="#underscore" class="headerlink" title="underscore"></a>underscore</h1><p>全文共<code>1858</code>字，推荐阅读时间<code>10~15</code>分钟。</p><h2 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h2><p>在<code>Object</code>上使用数组才有的<code>map()</code>/<code>filter()</code>等操作</p><ul><li>在<code>Object.prototype</code>中加上<code>mapObject()</code>等类似的方法</li><li>找一个成熟的第三方开源库，统一使用的函数。<ul><li>underscore就是这样一个库</li></ul></li></ul><p>与jQuery类似</p><ul><li><p>underscore把自己绑定在<code>_</code>上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x); <span class="comment">// Array</span></span><br><span class="line">_.map(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;, (value, key) =&gt; key + <span class="string">'='</span> + value); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><ul><li>注意箭头函数传入对象参数时，第一个参数是<code>value</code>，<strong>不是<code>key</code></strong>.</li></ul></li></ul><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>underscore支持集合类（Array/Object），不支持Map和Set.</p><h3 id="map-filter"><a href="#map-filter" class="headerlink" title="map/filter"></a>map/filter</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> upperArr = _.map(obj, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> upperObj = _.mapObject(obj, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">upperArr; <span class="comment">// ["BOB","NO.1 MIDDLE SCHOOL","XUEYUAN ROAD"]</span></span><br><span class="line">upperObj; <span class="comment">// &#123;"name":"BOB","school":"NO.1 MIDDLE SCHOOL","address":"XUEYUAN ROAD"&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意两种<code>map</code>操作的返回值类型<strong>不同</strong></p></blockquote><h3 id="every-some"><a href="#every-some" class="headerlink" title="every/some"></a>every/some</h3><ul><li><p>当集合的<strong>所有元素</strong>都满足条件时，<code>_.every()</code>返回<code>true</code>；当集合<strong>至少一个元素</strong>满足条件时，<code>_.some()</code>函数返回<code>true</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.every([<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x &gt; <span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line">_.some([<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x &lt; <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数获取对象的<code>value</code>和<code>key</code>的顺序和<code>map</code>一致</p></li><li><p>例子：判断对象中键值对的小写情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = _.every(obj, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cmp1 = key.toLowerCase() === key;</span><br><span class="line">    <span class="keyword">var</span> cmp2 = value.toLowerCase() === value;</span><br><span class="line">    <span class="keyword">return</span> cmp1 &amp;&amp; cmp2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> r2 = _.some(obj, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cmp1 = key.toLowerCase() === key;</span><br><span class="line">    <span class="keyword">var</span> cmp2 = value.toLowerCase() === value;</span><br><span class="line">    <span class="comment">// console.log(key + ' ' +cmp1 + ' ' + cmp2);</span></span><br><span class="line">    <span class="keyword">return</span> cmp1 || cmp2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>字符串之间的比较<strong>不能</strong>使用<code>-</code>，但是可以使用<code>&gt;</code>/<code>&lt;</code>.</li><li>字符串之间相等<strong>可以</strong>直接用<code>===</code>（和Java的引用相等不同）</li></ul></li></ul><h3 id="max-min"><a href="#max-min" class="headerlink" title="max/min"></a>max/min</h3><p>返回集合中最大/最小的数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">_.max(arr); <span class="comment">// 5</span></span><br><span class="line">_.min(arr); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li><p>空集合的返回结果是无穷，因此在使用<code>max</code>/<code>min</code>之前要判断集合是否为空。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.max([]); <span class="comment">// -Infinity</span></span><br><span class="line">_.min([]); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><ul><li>注意<code>max</code>返回的是<strong><code>-Infinity</code></strong></li></ul></li><li><p>当集合是对象时，<code>max()</code>和<code>min()</code><strong>只作用</strong>于<code>value</code>，忽略<code>key</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.max(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><p>把集合的元素按照<code>key</code>归类并返回一个<strong>对象</strong>，其中<code>key</code>由函数参数指定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = [<span class="number">20</span>, <span class="number">81</span>, <span class="number">75</span>, <span class="number">40</span>, <span class="number">91</span>, <span class="number">59</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">72</span>, <span class="number">88</span>, <span class="number">99</span>];</span><br><span class="line"><span class="keyword">var</span> groups = _.groupBy(scores, <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   A: [81, 91, 88, 99],</span></span><br><span class="line"><span class="comment">//   B: [75, 77, 66, 72],</span></span><br><span class="line"><span class="comment">//   C: [20, 40, 59]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="shuffle-sample"><a href="#shuffle-sample" class="headerlink" title="shuffle/sample"></a>shuffle/sample</h3><ul><li><p><code>shuffle()</code>随机打乱一个集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.shuffle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure></li><li><p><code>sample()</code>随机选择<strong>一个或多个</strong>元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.sample([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">_.sample([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>); <span class="comment">// pick up three elements</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="first-last"><a href="#first-last" class="headerlink" title="first/last"></a>first/last</h3><p>取第一个/最后一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line">_.first(arr); <span class="comment">// 2</span></span><br><span class="line">_.last(arr); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><p>接收一个<code>Array</code>，无论<code>Array</code>中嵌套了多少层，都全部拆开提取元素成为一维数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.flatten([<span class="number">1</span>, [<span class="number">2</span>], [<span class="number">3</span>, [[<span class="number">4</span>], [<span class="number">5</span>]]]]); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><ul><li><p><code>zip</code>把两个/多个数组的所有元素<strong>按索引</strong>合并成<strong>新数组</strong>，然后多个新数组一起组成<strong>大数组</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">85</span>, <span class="number">92</span>, <span class="number">59</span>];</span><br><span class="line">_.zip(names, scores);</span><br><span class="line"><span class="comment">// [['Adam', 85], ['Lisa', 92], ['Bart', 59]]</span></span><br></pre></td></tr></table></figure></li><li><p><code>unzip</code>是<code>zip</code>的逆过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameAndScores = [[<span class="string">'Adam'</span>, <span class="number">85</span>], [<span class="string">'Lisa'</span>, <span class="number">92</span>], [<span class="string">'Bart'</span>, <span class="number">59</span>]];</span><br><span class="line">_.unzip(nameAndScores);</span><br><span class="line"><span class="comment">// [['Adam', 'Lisa', 'Bart'], [85, 92, 59]]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>和<code>zip</code>类似，但是是直接转换成对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">85</span>, <span class="number">92</span>, <span class="number">59</span>];</span><br><span class="line">_.object(names, scores);</span><br><span class="line"><span class="comment">// &#123;Adam: 85, Lisa: 92, Bart: 59&#125;</span></span><br></pre></td></tr></table></figure><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>快速生成一个序列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从0开始小于10:</span></span><br><span class="line">_.range(<span class="number">10</span>); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从1开始小于11：</span></span><br><span class="line">_.range(<span class="number">1</span>, <span class="number">11</span>); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0开始小于30，步长5:</span></span><br><span class="line">_.range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>); <span class="comment">// [0, 5, 10, 15, 20, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0开始大于-10，步长-1:</span></span><br><span class="line">_.range(<span class="number">0</span>, <span class="number">-10</span>, <span class="number">-1</span>); <span class="comment">// [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span></span><br></pre></td></tr></table></figure><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>对数组元素去重</p><ul><li><p><code>_.uniq(array, [isSorted], [iteratee])</code></p><ul><li>如果数组已经排序，第二个参数传<code>true</code>可以进行加速。</li><li>如果想要<strong>自定义</strong>去重判断属性，传入<code>iteratee</code>.</li></ul></li><li><p>例子：对数组元素进行不区分大小写去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = _.uniq(arr, (x) =&gt; x.toLowerCase());</span><br></pre></td></tr></table></figure><ul><li><code>uniq</code><strong>不会</strong>改变原数组，而是返回一个没有重复元素的副本。</li></ul></li></ul><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>当使用一个变量<code>fn</code>指向一个对象的方法时，直接调用<code>fn()</code>因为<code>this</code>没有意义会失败，所以使用<code>bind</code>修复这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">' Hello '</span>;</span><br><span class="line"><span class="keyword">var</span> fn = _.bind(s.trim, s);</span><br><span class="line">fn(); <span class="comment">// Hello;</span></span><br></pre></td></tr></table></figure><ul><li><code>trim</code><strong>不会</strong>直接修改字符串</li></ul><h3 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h3><p>为一个函数创建<strong>偏函数</strong>，将原函数的某些参数固定住，方便调用常用的参数搭配。</p><ul><li><p>使用<code>pow</code>固定底数（第一个参数）为2来创建<code>pow2N</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pow2N = _.partial(<span class="built_in">Math</span>.pow, <span class="number">2</span>);</span><br><span class="line">pow2N(<span class="number">3</span>);</span><br><span class="line">pow2N(<span class="number">5</span>);</span><br><span class="line">pow2N(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>固定第二个参数：使用<code>_</code>占位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cube = _.partial(<span class="built_in">Math</span>.pow, _, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>多个参数时也用<code>_</code>占位</li></ul></li></ul><h3 id="memoize"><a href="#memoize" class="headerlink" title="memoize"></a>memoize</h3><ul><li><p><strong>不是</strong><code>memorize</code></p></li><li><p>用于缓存结果，可以在后续调用时直接获得。</p></li><li><p>例子：阶乘加速</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = _.memoize(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start calculate '</span> + n + <span class="string">'!...'</span>);</span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">1</span>, i = n;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        s = s * i;</span><br><span class="line">        i --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(n + <span class="string">'! = '</span> + s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用:</span></span><br><span class="line">factorial(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br><span class="line"><span class="comment">// 注意控制台输出:</span></span><br><span class="line"><span class="comment">// start calculate 10!...</span></span><br><span class="line"><span class="comment">// 10! = 3628800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次调用:</span></span><br><span class="line">factorial(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br><span class="line"><span class="comment">// 控制台没有输出</span></span><br></pre></td></tr></table></figure><ul><li><p>如果计算9的阶乘还是会重新计算，所以进行改进——变为递归调用，就可以记录下每一次的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = _.memoize(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="once"><a href="#once" class="headerlink" title="once"></a>once</h3><p>保证某个函数仅执行一次，用于解决一个函数有多个按键都可以索引到的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> register = _.once(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>让一个函数延迟执行，效果和<code>setTimeOut</code>是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.delay(alert, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><ul><li><p>函数有参数时，在时间参数后<strong>依次</strong>传入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = _.bind(<span class="built_in">console</span>.log, <span class="built_in">console</span>);</span><br><span class="line">_.delay(log, <span class="number">2000</span>, <span class="string">'Hello, '</span>, <span class="string">'World!'</span>); <span class="comment">// 2秒后打印'Hello, World!'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><h3 id="keys-allKeys"><a href="#keys-allKeys" class="headerlink" title="keys/allKeys"></a>keys/allKeys</h3><ul><li><p><code>keys()</code>返回一个object自身所有的key，但不包含从原型继承下来的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>, <span class="number">20</span>);</span><br><span class="line">_.keys(xiaoming); <span class="comment">// ['name', 'age']</span></span><br></pre></td></tr></table></figure></li><li><p><code>allKeys()</code>除了自身属性之外，还包含继承得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.school = <span class="string">'No.1 Middle School'</span>;</span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>, <span class="number">20</span>);</span><br><span class="line">_.allKeys(xiaoming); <span class="comment">// ['name', 'age', 'school']</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><p>与<code>keys()</code>对应，返回object自身的属性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'xiaoming'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.values(obj); <span class="comment">// ['xiaoming', 20]</span></span><br></pre></td></tr></table></figure><h3 id="mapObject"><a href="#mapObject" class="headerlink" title="mapObject"></a>mapObject</h3><p>object的<code>map()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.mapObject(obj, (v, k) =&gt; <span class="number">100</span> + v); <span class="comment">// &#123; a: 101, b: 102, c: 103 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="invert"><a href="#invert" class="headerlink" title="invert"></a>invert</h3><p>将key和value进行交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    Adam: <span class="number">90</span>,</span><br><span class="line">    Lisa: <span class="number">85</span>,</span><br><span class="line">    Bart: <span class="number">59</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.invert(obj); <span class="comment">// &#123; '59': 'Bart', '85': 'Lisa', '90': 'Adam' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="extend-extendOwn"><a href="#extend-extendOwn" class="headerlink" title="extend/extendOwn"></a>extend/extendOwn</h3><ul><li><p><code>extend</code>把多个对象合并到第一个对象参数中，返回合并后的对象，<strong>同时修改原对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.extend(a, &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">88</span>, <span class="attr">city</span>: <span class="string">'Beijing'</span>&#125;); <span class="comment">// &#123;name: 'Bob', age: 88, city: 'Beijing'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>extendOwn()</code>在获取每个对象参数的属性时，<strong>忽略</strong>继承得到的属性。</p></li></ul><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>实现对象<strong>浅复制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'CSS'</span>, <span class="string">'HTML'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> copied = _.clone(source);</span><br></pre></td></tr></table></figure><h3 id="isEqual"><a href="#isEqual" class="headerlink" title="isEqual"></a>isEqual</h3><p>对两个对象进行深度比较，如果<strong>内容完全相同</strong>就返回<code>true</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">name</span>: <span class="string">'Bob'</span>, <span class="attr">skills</span>: &#123; <span class="attr">Java</span>: <span class="number">90</span>, <span class="attr">JavaScript</span>: <span class="number">99</span> &#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">name</span>: <span class="string">'Bob'</span>, <span class="attr">skills</span>: &#123; <span class="attr">JavaScript</span>: <span class="number">99</span>, <span class="attr">Java</span>: <span class="number">90</span> &#125;&#125;;</span><br><span class="line"></span><br><span class="line">o1 === o2; <span class="comment">// false</span></span><br><span class="line">_.isEqual(o1, o2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><p><code>Array</code>也可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = [<span class="string">'Bob'</span>, &#123; <span class="attr">skills</span>: [<span class="string">'Java'</span>, <span class="string">'JavaScript'</span>] &#125;];</span><br><span class="line"><span class="keyword">var</span> o2 = [<span class="string">'Bob'</span>, &#123; <span class="attr">skills</span>: [<span class="string">'Java'</span>, <span class="string">'JavaScript'</span>] &#125;];</span><br><span class="line"></span><br><span class="line">o1 === o2; <span class="comment">// false</span></span><br><span class="line">_.isEqual(o1, o2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Chaining"><a href="#Chaining" class="headerlink" title="Chaining"></a>Chaining</h2><p>通过<code>chain()</code>函数实现underscore函数的链式调用</p><ul><li><p>例子</p><p>非链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.filter(_.map([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>], <span class="built_in">Math</span>.sqrt), (x) =&gt; x % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure><p>链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = _.chain([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>])</span><br><span class="line"> .map(<span class="built_in">Math</span>.sqrt)</span><br><span class="line"> .filter(<span class="function"><span class="params">x</span> =&gt;</span> x &amp; <span class="number">2</span> === <span class="number">1</span>)</span><br><span class="line"> .value();</span><br><span class="line">r; <span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>chain</code>函数后每一步都是<strong>包装对象</strong>，所以最后一步的结果需要使用<code>value</code>获取值。</li></ul></li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of frontend language JavaScript.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Frontend" scheme="http://yoursite.com/categories/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>Database Course Note</title>
    <link href="http://yoursite.com/2021/06/23/Database%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/Database%20Course%20Note/</id>
    <published>2021-06-23T12:39:10.027Z</published>
    <updated>2021-06-23T12:44:42.962Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2020 BUAA Database course.</strong></p><a id="more"></a><h1 id="Chapter0-概论"><a href="#Chapter0-概论" class="headerlink" title="Chapter0 概论"></a>Chapter0 概论</h1><p>全文共<code>430</code>字，推荐阅读时间<code>5~10</code>分钟。</p><h2 id="数据和信息"><a href="#数据和信息" class="headerlink" title="数据和信息"></a>数据和信息</h2><ul><li>信息是<strong>一种</strong>已经被加工为<strong>特定形式</strong>的数据</li><li>数据是信息的载体，是信息的具体表现形式。</li></ul><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ul><li>对数据进行加工得到信息的过程</li></ul><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><ul><li>数据处理的<strong>基本操作</strong></li><li>数据库技术就是一种数据管理技术<ul><li>提供数据共享</li></ul></li></ul><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><ul><li>建立在DBMS之上，以<strong>数据管理</strong>为<strong>主要功能</strong>的计算机软件系统。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;DBMS</span><br><span class="line">DBMS--&gt;数据库</span><br></pre></td></tr></table></figure><blockquote><p>DBS &gt; DBMS &gt; DB</p><ul><li>DBS包括了<strong>用户/应用程序</strong>构成的交互层</li></ul></blockquote><h3 id="架构-B-S"><a href="#架构-B-S" class="headerlink" title="架构(B/S)"></a>架构(B/S)</h3><ul><li>Browser</li><li>Server<ul><li>Web Server</li><li>DB Server(DBMS location)</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>数据模型</li><li>底层实现技术、事务处理、数据库安全、完整性控制</li><li>关系数据理论、数据库设计方法</li></ul><blockquote><p>事务处理（原子性）是DBMS的工作，不是DBS.</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>图书馆</li><li>电商</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter1-概述"><a href="#Chapter1-概述" class="headerlink" title="Chapter1 概述"></a>Chapter1 概述</h1><p>全文共<code>2102</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="数据管理技术发展"><a href="#数据管理技术发展" class="headerlink" title="数据管理技术发展"></a>数据管理技术发展</h2><ul><li><p>人工管理</p><ul><li><p>数据<strong>不在</strong>计算机上保存</p></li><li><p>程序决定数据的逻辑结构和物理结构，数据与程序之间<strong>不具有独立性</strong>。</p><blockquote><p>要改变数据的结构就要改变程序</p></blockquote></li><li><p>数据面向应用，程序之间<strong>不能共享</strong>数据。</p></li></ul></li><li><p>文件系统</p><ul><li><p>存取方法作为中介出现</p></li><li><p>数据以<strong>文件形式</strong>保存在<strong>外存</strong>上</p></li><li><p>数据的存取以<strong>记录</strong>为单位</p></li><li><p>程序和数据具有<strong>一定的独立性</strong></p></li><li><p>缺点：</p><ul><li>数据冗余度大（因为数据<strong>不能</strong>被程序共享，即不能够同时进行操作，必须创建多个副本），可能带来数据的不一致性。</li><li>数据和程序之间的独立性依然<strong>不</strong>明显，缺乏<strong>逻辑独立性</strong>。（改文件逻辑结构时还要修改程序）</li></ul><blockquote><p>文件系统是<strong>不具弹性</strong>的<strong>无结构</strong>的数据集合，<strong>数据之间</strong>（<strong>不是</strong>程序和数据）是孤立的，不能反映现实世界事物之间的内在联系。</p><ul><li>不具弹性：改变数据的结构就得改程序</li><li>无结构：数据之间孤立</li></ul></blockquote></li></ul></li><li><p>数据库系统</p><ul><li><p>数据结构化：描述数据时，不仅描述数据本身，还要描述数据之间的联系。</p><blockquote><p><strong>数据结构化</strong>是数据库与文件系统的<strong>根本区别</strong></p></blockquote></li><li><p>数据冗余度小，易扩充。</p></li><li><p>数据和程序的独立性<strong>较高</strong></p><ul><li><p>数据独立性</p><ul><li>物理：数据的物理结构改变时，数据的逻辑结构可以不变，从而程序也不用改变。</li><li>逻辑：数据的逻辑结构改变时，程序不用改变。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;局部逻辑结构</span><br><span class="line">局部逻辑结构--&gt;全局逻辑结构</span><br><span class="line">全局逻辑结构--&gt;物理结构</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据库映象：不同结构之间数据的<strong>转换关系</strong></p><p>物理结构发生变化时，可以通过调整数据库映象来确保逻辑结构不变。</p></li><li><p>统一的数据控制功能</p><ul><li><p>安全性控制</p></li><li><p>完整性控制：数据的正确性和相容性</p><blockquote><p>相容性：同一条数据在不同的程序应该是相同的</p></blockquote></li><li><p>并发控制</p></li><li><p>恢复</p></li><li><p>存取单位是数据项</p><p>可以存取一组记录，也可以取一组数据项。</p><blockquote><p>数据项的粒度小于文件</p><p>Q：数据项和记录的区别</p><p>A：数据项是列，记录是行。</p></blockquote></li></ul></li></ul></li></ul><h2 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>集成：本质是数据结构化</li><li>共享</li></ul><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul><li>DBMS</li><li>应用系统</li></ul><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>存储数据</li><li>运行系统</li></ul><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><ul><li>终端用户</li><li>应用程序员</li><li>数据库管理员</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul><li>用于抽象和表示现实世界中的<strong>数据和信息</strong></li><li>层次<ul><li>概念模型（信息模型）</li><li>数据模型（层次、网状、关系模型）</li></ul></li></ul><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">现实世界--&gt;信息世界</span><br><span class="line">信息世界--&gt;机器世界</span><br></pre></td></tr></table></figure><ul><li>信息世界就是<strong>概念</strong>模型：E-R图</li><li>机器世界就是<strong>数据</strong>模型：数据表</li></ul><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><ul><li>基于信息世界的主要概念，表达语义。</li><li>语义表达能力强</li><li>清晰</li><li>最常用的表示方法：E-R法(Entity-Relation)</li></ul><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>实体(Entity)：客观存在并可以<strong>相互区分</strong>的食物，在E-R图中为<strong>矩形</strong>。</p></li><li><p>属性(Attribute)：实体具有的某一<strong>特性</strong>，在E-R图中为<strong>椭圆形</strong>。</p></li><li><p>码(Key)：<strong>唯一</strong>的标识实体的<strong>属性集</strong>（至少一个，最多由属性集大小确定）</p></li><li><p>域(Domain)：某些属性的<strong>取值范围</strong></p></li><li><p>实体型(Entity Type)：表示一类实体(Class)</p><ul><li>用名称和属性集表示</li></ul></li><li><p>联系(Relation)：实体型之间的联系，在E-R图中为<strong>菱形</strong>。</p><ul><li>名称：产品<strong>由</strong>若干零件<strong>构成</strong></li><li>类型<ul><li>一对一(1:1)</li><li>一对多(1:n)</li><li>多对多(m:n)</li></ul></li></ul><blockquote><ul><li>联系可以具有<strong>属性</strong>，例如产品-组装-零件中，组装可以有<strong>零件数</strong>属性。</li><li>联系是有方向的，一对多<strong>不等价于反向</strong>的多对一。</li></ul></blockquote></li></ul><h4 id="E-R"><a href="#E-R" class="headerlink" title="E-R"></a>E-R</h4><ul><li>用E-R图描述现实世界</li><li>将E-R图转换为数据模型</li></ul><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul><li>实体</li><li>属性<ul><li>作为Key的属性<ul><li>在属性下画线，多个属性就都画。</li><li>在无向边上画两条杠</li><li>组合属性作为Key：在两条无向边之间画一条弧之后，在弧上画两条杠。</li></ul></li></ul></li><li>联系：无向边旁需要标注联系的类型（三选一）<ul><li>可能存在<strong>自相联</strong>关系</li><li>三个或多个实体可能通过<strong>一个联系</strong>建立关系</li><li>两个实体之间可能存在多种联系<ul><li>工人使用/维修仪器</li></ul></li></ul></li></ul><h5 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h5><ul><li>存在依赖：<strong>有向边</strong>指向<strong>弱实体</strong>（依赖于其他实体的实体）<ul><li>弱实体是双层框</li></ul></li><li>标识依赖：<strong>有向边</strong>指向<strong>被标识实体</strong>（不能由自己的属性来唯一标识，需要和其他实体的属性组合起来作为Key）</li><li>实体的子类：<strong>无向边</strong>上画一个圆<ul><li>子类是外侧框加两条竖线</li><li>子类的交<strong>不一定</strong>为空</li></ul></li></ul><h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><ul><li>数据结构</li><li>数据操作</li><li>完整性约束</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>描述对象的相关性质</li><li>描述对象之间的联系，如关系模型中的关系。</li><li>数据<strong>静态特征</strong>的描述</li><li>三要素中<strong>最重要</strong>的方面</li></ul><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><ul><li><p>操作及操作规则</p></li><li><p>操作符号、操作规则、操作语言</p><blockquote><p>SQL就是一种操作语言</p></blockquote></li><li><p>数据<strong>动态特征</strong>的描述</p></li><li><p>数据库中主要有<strong>检索和更新</strong>两大类操作</p></li></ul><h4 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h4><ul><li>完整性规则的集合</li><li>模型通用的完整性约束条件</li><li>针对具体数据的特定语义的约束条件</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>层次模型：树<ul><li>最早出现</li><li>有向树，连线表示一对多的联系（包含一对一）。</li><li>结构简单，效率高，但是支持的联系的种类太少（只能直接表示<strong>二元一对多</strong>联系）</li></ul></li><li>网状模型：图<ul><li>有向图，连线表示一对多的联系（包含一对一）。</li><li>结构复杂，效率高。</li></ul></li><li>关系模型：二维表<ul><li>用二维表格表示实体及实体之间的联系</li><li><strong>规范化关系</strong>：每个分量（域）是<strong>不可分割</strong>的数据项，并且不能出现表中套表的情况。</li><li>有数学基础</li></ul></li></ul><h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><ul><li>三级模式<ul><li>外模式</li><li>模式</li><li>内模式</li></ul></li><li>两级映象<ul><li>外模式/模式映象</li><li>模式/内模式映象</li></ul></li><li>优点<ul><li>数据独立性</li><li>简化用户接口</li><li>有利于数据共享（外模式可以相互覆盖）</li><li>利于数据的安全保密</li></ul></li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li><strong>逻辑模式/概念模式</strong></li><li><strong>全体数据</strong>的逻辑结构和特性的描述，例如所有关系模式构成的集合。</li><li><strong>三级模式的核心</strong></li><li>模式描述语言(DDL, Data Description Language)</li></ul><h3 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h3><ul><li><p>个别用户的数据<strong>视图</strong>（与某一应用有关的数据逻辑表示）</p></li><li><p>通常是<strong>模式的子集</strong>（子模式）</p></li><li><p>不同的外模式可以相互覆盖，<strong>一个</strong>应用只能启用<strong>一个</strong>外模式。</p><blockquote><p>外模式和应用是<strong>一对多</strong>的关系</p></blockquote></li><li><p>外模式DDL，通常和应用具有相同的语法。</p></li></ul><h3 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h3><ul><li>存储模式，数据的物理结构和存储方式的描述。</li><li>内模式DDL</li></ul><h3 id="两级映象"><a href="#两级映象" class="headerlink" title="两级映象"></a>两级映象</h3><ul><li>数据<strong>逻辑</strong>独立性：外模式/模式映象</li><li>数据<strong>物理</strong>独立性：模式/内模式映象</li></ul><h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul><li>数据库的定义功能<ul><li>使用DDL语言描述外模式、模式、内模式（源模式）</li></ul></li><li>数据存取功能<ul><li>提供DML(Data Manipulation Language)语言进行CRUD</li></ul></li><li>数据库运行管理<ul><li>并发控制</li><li>存取控制</li><li>完整性</li><li>日志组织和管理</li><li>事务管理</li><li>自动恢复</li></ul></li></ul><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>语言编译处理程序</li><li>系统运行控制程序</li><li>系统建立和维护</li><li>数据字典（数据目录）：由若干个表组成</li></ul><h3 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h3><p>数据库管理员</p><ul><li>建库</li><li>用库</li></ul><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter2-关系数据库"><a href="#Chapter2-关系数据库" class="headerlink" title="Chapter2 关系数据库"></a>Chapter2 关系数据库</h1><p>全文共<code>1694</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>关系理论建立在集合代数（离散数学）理论之上</li></ul><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>关系模型的数据结构：关系</p></li><li><p>域(Domain)：一组具有<strong>相同数据类型</strong>的值的集合</p></li><li><p>元组和分量</p><blockquote><p>多个<strong>域</strong>进行笛卡尔积运算可以表示为<strong>二维表</strong></p></blockquote></li><li><p>关系：笛卡尔积$D_1 \times D_2 \times …\times D_n$的<strong>子集</strong>叫做这些域上的关系，用$R(D_1,D_2,…,D_n)$表示。</p><ul><li><p>$R$：关系名</p></li><li><p>$n$：度/目</p></li><li><p><strong>关系二维表</strong></p><ul><li><p>每个列附加一个名称，被称为<strong>属性</strong>(Attribute)。</p><blockquote><p>属性的名字需要<strong>唯一</strong></p></blockquote></li><li><p>关系是元组构成的集合</p></li></ul></li><li><p>关系的列是<strong>同质</strong>的</p></li><li><p>不同的列可以出自同一域（自相关）</p></li><li><p>列的顺序可以互换</p></li><li><p>任何两个元组（行）<strong>不能</strong>完全相同</p></li><li><p>规范性：分量不可再分，即1NF（First Normal Form，第一范式）</p></li></ul></li></ul><h2 id="数据模型-2"><a href="#数据模型-2" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>数据结构：关系</p></li><li><p>码</p><ul><li><p>候选码(Candidate Key)：具有<strong>最小性</strong>和唯一标识功能的<strong>属性组</strong></p><ul><li>最小性：指候选码的子集不能够唯一标识当前记录，和候选码的<strong>属性个数</strong>无关。例如候选码A中可能只有一个属性，但是在候选码B中可能有两个其他的属性。</li></ul><blockquote><p>属性组中<strong>可以</strong>只有一个属性</p></blockquote></li><li><p>主码(Primary Key)：简称为码，在多个候选码中选定一个为主码。</p></li></ul></li><li><p>属性</p><ul><li>主属性：<strong>所有候选码</strong>中的属性</li><li>非主属性：<strong>不包含</strong>在任何候选码中的属性</li></ul><blockquote><p>属性<strong>要么为</strong>主属性，<strong>要么为</strong>非主属性。</p></blockquote></li><li><p>关系模式：$R(U,D,dom,F,I)$</p><ul><li><p>$U$：属性名集合</p></li><li><p>$D$：域集合</p></li><li><p>$dom$：属性$\rightarrow$域的映象集合</p></li><li><p>$F$：数据依赖关系集合</p></li><li><p>$I$：完整性约束集合</p></li><li><p>关系是关系模式在<strong>某一时刻</strong>的<strong>状态或内容</strong></p><blockquote><p>关系模式相对稳定，可以理解成<strong>设计表</strong>；关系是动态的，是一张表的<strong>具体内容</strong>。</p></blockquote></li></ul></li></ul><h3 id="语义约束"><a href="#语义约束" class="headerlink" title="语义约束"></a>语义约束</h3><p>前两个是<strong>模型</strong>必须支持的约束条件</p><ul><li><p>实体完整性</p><ul><li><p>主码必须存在，<strong>其中任何一个域</strong>都不能为空。</p><blockquote><p>空：不知道/不存在的值</p></blockquote></li></ul></li><li><p>参照完整性</p><ul><li><p>外部码(Foreign Key)如果有效，则对应的外表必须存在对应记录。</p><blockquote><ul><li>外部码可以是<strong>同一个关系</strong>之间的联系（即同<strong>一张表</strong>中<strong>不同</strong>元组之间的联系）</li><li>外部码可以为空</li><li>外部码可以是<strong>属性组</strong></li></ul></blockquote></li></ul></li><li><p>用户定义完整性</p><ul><li>用户根据特定的应用环境定义的完整性约束条件</li></ul></li></ul><h3 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li><p>集合操作：操作的对象和结果<strong>都是</strong>集合</p></li><li><p>关系运算</p><ul><li>关系代数（代数方式）</li><li>关系演算（逻辑方式）<ul><li>元组关系</li><li>域关系</li></ul></li></ul><blockquote><p>各种运算之间等价，可以相互转换。</p></blockquote></li></ul><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><ul><li><p>常规集合运算：并、差、交、广义笛卡尔积</p><ul><li><p>广义笛卡尔积</p><p>对度为<code>n</code>、<code>m</code>的两个集合，元组数分别为<code>k1</code>、<code>k2</code>，它们笛卡尔积的结果</p><ul><li><p>度为$(n+m)$</p></li><li><p>元组共$k1*k2$个</p></li><li><p>当出现重名属性时，需要进行重命名。</p><blockquote><p>通常使用<code>Tablename.Fieldname</code>的组合进行重命名</p></blockquote></li></ul></li></ul></li><li><p>特殊关系运算：选择、投影、连接、自然连接、除法</p><ul><li><p>选择：在关系R中选择<strong>满足给定条件</strong>的元组，记为$\sigma_F(R)=\{t|t\in R,F(t)=True\}$.</p></li><li><p>投影：从关系中取若干属性列，并删去重复行，组成新的关系，记为$\Pi_A(R)=\{t[A]|t \in R, A \subseteq U\}$.</p></li><li><p>连接：在两个关系的<strong>广义笛卡尔积</strong>中，指定属性<strong>组</strong>$X,Y$，并且选择其中满足条件$\theta$的<strong>元组</strong>并返回<strong>整条组合记录</strong>构成的集合。</p><ul><li><p>$\theta$</p><ul><li><code>=</code>：等值连接</li><li><code>&lt;</code>：小于连接</li><li><code>&gt;</code>：大于连接</li></ul></li><li><strong>一个元组</strong>可能和<strong>多个元组</strong>进行连接</li></ul></li></ul></li><li><p>自然连接（更常用）：在笛卡尔积中选取在<strong>相同属性组列</strong>上<strong>取值相等</strong>的记录，并<strong>去掉重复</strong>的列。</p><ul><li>不能自定义$X,Y$</li><li>不能更换连接条件$\theta$</li></ul></li><li><p>除法：对关系$R(X,Y),S(Z)$，它们的除法记为：</p><p>$R \div S=\{t|t \in \Pi_X(R) \and \forall s\in S \and <t,s> \in R\}$.</p><ul><li>要求$Y,Z$域等价<ul><li>属性数相同</li><li>对应属性出自同样的域</li></ul></li><li>除法$A \div B$的意义就是<strong>A包含了多少个B</strong></li><li>通俗地说，把B认为是组别，除法的意义就是得到A中指定属性满足<strong>同时在B中所有组</strong>的<strong>投影</strong>。</li></ul></li><li><p>运算组合</p><ul><li>从内套外嵌套</li><li>（自然）连接的语义：指定域后跨表查找，同时<strong>保留其他域</strong>。</li><li>除法：解决<strong>“任意”</strong>问题</li><li>先投影再运算效率更高</li></ul></li><li><p>基本运算（可以推出其他运算）</p><ul><li>并</li><li>差</li><li>笛卡尔积</li><li>选择</li><li>投影</li></ul></li></ul><h2 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h2><ul><li>将<strong>谓词演算</strong>应用到关系运算中就是关系演算</li></ul><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul><li>以元组为变量</li><li>基本结构：元组演算表达式$\{t|\Phi(t)\}$表示所有使$\Phi$为真的<strong>元组</strong>集合</li><li>优先级<ul><li>算术比较</li><li>量词($\exists &gt; \forall$)</li><li>逻辑运算符</li></ul></li><li>例子<ul><li>$R1=\{t|R(t) \and t[3] \geq 4\}$：关系R中第三个域大于等于4的元组集合<ul><li>$R(t)$：$t$是关系$R$中的元组</li></ul></li><li>$R2=\{(\exists u)(R(t) \and W(u) \and t[3] &lt; u[3])\}$</li></ul></li></ul><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><ul><li>变量对应元组各个分量的域变量<ul><li>$R(t) \Rightarrow R(x_1,x_2,…x_n)$</li></ul></li><li>例子<ul><li>$R1=\{xyz|R(xyz) \and Z&lt;8 \and x=d\}$</li></ul></li></ul><h2 id="安全约束"><a href="#安全约束" class="headerlink" title="安全约束"></a>安全约束</h2><ul><li>关系代数是安全的，但是关系演算<strong>不一定</strong>安全。</li><li>无限关系：$\{t|\neg R(t)\}$集合有无穷多个元素</li><li>无穷运算：$\forall t(R(t))$，当$t$域无穷时，即为无穷验证运算。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对$\Phi$定义一个有限符号集$DOM(\Phi)$，使$\Phi$中的运算结果和中间过程中产生的元组及其分量均属于$DOM(\Phi)$</li><li>在实现安全约束后，三种运算方式<strong>才是</strong>等价并且可以相互转换的。</li></ul><h2 id="关系数据语言"><a href="#关系数据语言" class="headerlink" title="关系数据语言"></a>关系数据语言</h2><ul><li>核心是查询，所以也称为查询语言。</li></ul><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>数据定义（描述）语言(DDL)：包括模式DDL、外模式DDL、内模式DDL.</li><li>数据模拟语言(DML)：CRUD<ul><li>联机交互：独立于系统存在</li><li>宿主语言：嵌入在高级语言中</li></ul></li><li>数据控制语言(DCL)：安全性和完整性控制</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>一体化：例如SQL将DDL、DML、DCL的功能集成在一起</li><li>非过程化：用户不需要关注底层的实现细节</li><li>面向集合的存取方式<ul><li>操作对象是一个或多个关系</li><li>操作结果是新的关系</li></ul></li><li>可独立也可嵌套</li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter3-SQL"><a href="#Chapter3-SQL" class="headerlink" title="Chapter3 SQL"></a>Chapter3 SQL</h1><p>全文共<code>3006</code>字，推荐阅读时间<code>25~30</code>分钟</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>综合统一</li><li>高度<strong>非过程化</strong>（只注重交互结果，而不是具体的实现）</li><li>面向集合操作</li><li>同一个语法结构可以实现关系代数和关系演算两种使用方式</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>基本表：独立、实际存在的，有对应的实体文件。</p><blockquote><p>在SQL中，一个关系对应一个表。</p></blockquote></li><li><p>导出表：从<strong>一个或多个</strong>基本表导出的表，分为视图(View)和快照(Snapshot).</p><ul><li><p>视图</p><ul><li>虚表，只在数据字典中存储视图的定义。</li><li>视图可以进行CRUD基本操作，也可以用来定义新的视图。</li></ul><blockquote><p>SQL可以直接操作基本表（模式）和导出表（外模式）</p></blockquote></li></ul></li></ul><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q;</span><br></pre></td></tr></table></figure><ul><li><p>从目标表<code>T</code>中选择符合条件<code>Q</code>的目标列<code>C</code></p><blockquote><p><code>WHERE</code>相当于是<code>filter()</code></p></blockquote></li><li><p>表的水平方向：根据检索条件选择<strong>元组</strong>（记录）</p></li><li><p>表的垂直方向：对<strong>目标列</strong>进行投影</p></li></ul><h3 id="投影检索"><a href="#投影检索" class="headerlink" title="投影检索"></a>投影检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT C</span><br><span class="line">FROM T;</span><br></pre></td></tr></table></figure><ul><li><code>DISTINCT</code>删去结果中的重复行</li></ul><h3 id="选取检索"><a href="#选取检索" class="headerlink" title="选取检索"></a>选取检索</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><code>=</code>/<code>&lt;</code>等</li><li><code>AND</code>/<code>OR</code>/<code>NOT</code></li><li><code>()</code></li><li><code>BETWEEN ... AND ...</code></li></ul><blockquote><p><code>WHERE</code>子句<code>Q</code>中出现的列通常会在<code>SELECT C</code>中出现</p></blockquote><h3 id="排序检索"><a href="#排序检索" class="headerlink" title="排序检索"></a>排序检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q</span><br><span class="line">ORDER BY A ASC&#x2F;DESC;</span><br></pre></td></tr></table></figure><ul><li><p><code>ASC</code>：根据<code>A</code>升序（<strong>缺省</strong>）</p></li><li><p><code>DESC</code>：根据<code>A</code>降序</p></li><li><p>多列排序，按照<strong>语句顺序</strong>进行多要素排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S</span><br><span class="line">ORDER BY SD ASC, SA DESC;</span><br></pre></td></tr></table></figure></li><li><p>排序语句通常放在<code>SELECT</code>语句的<strong>最后</strong></p></li></ul><h3 id="连接（连表）检索"><a href="#连接（连表）检索" class="headerlink" title="连接（连表）检索"></a>连接（连表）检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T1, T2</span><br><span class="line">WHERE T1.c1 &#x3D; T2.c2;</span><br></pre></td></tr></table></figure><ul><li><code>c1</code>/<code>c2</code>被称为<strong>连接字段</strong></li><li>本质就是将<code>T1</code>，<code>T2</code>进行<strong>笛卡尔积</strong>操作，然后对新的表的符合条件的元组进行筛选。</li></ul><h4 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT X.SN, X.SA</span><br><span class="line">FROM S X, S Y</span><br><span class="line">WHERE X.SA&gt;Y.SA AND Y.SN&#x3D;&#39;xxx&#39;;</span><br></pre></td></tr></table></figure><ul><li>连接后选取的属性（<code>SELECT</code>选择的属性）中如果有重名属性，<strong>也要加上表名</strong>用以区分。同时，在查询的时候不会被起别名，即返回结果中依然是<code>SN</code>/<code>SA</code>.</li><li>起别名后，原有的<code>S</code><strong>不能够</strong>再使用。</li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S, SC</span><br><span class="line">WHERE S.S &#x3D; SC.S(*);</span><br></pre></td></tr></table></figure><ul><li>单纯使用连接语句可能造成信息丢失，例如没有选课的学生在连接学生表和选课表时会被忽略。</li><li>增加<code>*/+</code>的表中会<strong>增加</strong>万能空行与<strong>另一个表</strong>进行连接</li></ul><h3 id="嵌套检索"><a href="#嵌套检索" class="headerlink" title="嵌套检索"></a>嵌套检索</h3><ul><li>子查询（嵌套查询）：<code>WHERE</code>中包含的另一个查询块<ul><li>普通：与外部查询无关，<strong>可以单独执行</strong>获得一组值。</li><li>相关：把<strong>外查询的值</strong>作为检索的条件值，<strong>不可以</strong>单独执行。</li></ul></li><li>外部查询：包含子查询的语句</li></ul><h4 id="自身嵌套"><a href="#自身嵌套" class="headerlink" title="自身嵌套"></a>自身嵌套</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM s</span><br><span class="line">WHERE S.SA &#x3D; (SELECT SA FROM S WHERE S.SN &#x3D; &#39;xxx&#39;);</span><br></pre></td></tr></table></figure><blockquote><p>嵌套运算的效率<strong>高于</strong>连表运算，空间开销也更低。</p></blockquote><ul><li><p>子查询返回<strong>单值</strong>时可以直接使用<strong>运算符</strong>进行连接</p></li><li><p>子查询返回<strong>一组值</strong>，则需要在子查询结果前加上<code>ANY</code>/<code>ALL</code>.</p><ul><li><p><code>IN</code>可以替代<code>=ANY</code></p></li><li><p><code>NOT IN</code>可以替代<code>!=ALL</code>，<strong>不是</strong><code>!=ANY</code>.</p><blockquote><p><code>!=ALL</code>和<code>!=ANY</code>的区别</p><ul><li><code>!=ALL</code>：当左值和<strong>任意</strong>右值<strong>都不相等</strong>的时候为真</li><li><code>!=ANY</code>：当左值和<strong>某个</strong>右值<strong>不相等</strong>的时候为真</li></ul></blockquote></li><li><p><code>EXISTS</code>：当仅当<strong>子查询</strong>结果为<strong>非空</strong>时为真，即<code>filter()</code>的拓展，可以在<code>filter()</code>中放更加复杂的筛选条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE EXISTS</span><br><span class="line">(SELECT * FROM SC WHERE SC.S&#x3D;S.S AND C&#x3D;&#39;xxx&#39;);</span><br></pre></td></tr></table></figure><blockquote><ul><li>相当于遍历S表中的每一个学生，然后利用学号在SC中进行检索。</li><li><strong>相关</strong>子查询，因为子查询的<code>S</code>不独立。</li><li><code>EXISTS</code>判定的方式决定了<code>SELECT</code><strong>不需要</strong>明确某一列</li></ul></blockquote></li><li><p><code>NOT EXISTS</code>：在子查询结果为<strong>空</strong>时返回真，可以使用<code>NOT EXISTS</code>表示谓词逻辑。</p><ul><li><p>单层<code>NOT EXISTS</code>：即<code>exclude()</code>，排除掉所有满足嵌套条件的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM C</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM SC WHERE SC.C &#x3D; C.S);</span><br></pre></td></tr></table></figure></li><li><p>全称量词$\forall$：$(\forall x)P=\neg(\exist x(\neg P))$</p><ul><li><p>对命题和子命题都取反，把任意变成存在，然后根据等价命题进行SQL语句构造。</p></li><li><p><strong>检索选修所有课程的学生的姓名</strong></p><ul><li><p>$Given\ s,\forall cP(s,c).$</p><p>其中$P(s,c)$表示学生选上了这门课，为了能够返回布尔值，我们使用$EXISTS$语句进行包装。</p><p>将其转换为$Given\ s, \neg\exist c(\neg P(s,c))$（其中$\neg$就是<code>NOT</code>）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM C</span><br><span class="line">     WHERE NOT EXISTS</span><br><span class="line">      (SELECT * FROM SC WHERE SC.S&#x3D;S.S AND SC.C&#x3D;C.C))</span><br></pre></td></tr></table></figure><blockquote><p>命题等价于：不存在没有选修的课程的学生的姓名，即排除没有全部选修的学生。</p></blockquote></li></ul></li><li><p>蕴涵：$p \rightarrow q = \neg p \or q$</p><ul><li><p><strong>检索至少选修了学生S2选修的全部课程的学生学号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT S</span><br><span class="line">FROM SC SCX</span><br><span class="line">WHERE NOT EXISTS # 不存在S2选了但是该学生没选的课程，所以下面是S2选了但是他没选的。</span><br><span class="line">(SELECT * FROM SC SCY</span><br><span class="line">     WHERE SCY.S&#x3D;S2 AND NOT EXISTS ( # 他没有选择这门课</span><br><span class="line">     SELECT * FROM SC SCZ WHERE SCZ.S&#x3D;SCX.S AND SCZ.C&#x3D;SCY.C))</span><br></pre></td></tr></table></figure><ul><li><code>p</code>：S2选修了某门课</li><li><code>q</code>：该学生也要选修这门课</li></ul><blockquote><p>命题等价于：不存在S2选修但是他没有选修的课程</p></blockquote></li></ul></li></ul><blockquote><p>用<code>NOT EXISTS</code>表示谓词逻辑：</p><ul><li>使用纯数理逻辑进行推导，但是对于谓词过多的情况可能出现问题。</li><li><strong>把命题改写成“不存在…”的形式，然后逐层使用<code>NOT EXISTS</code>.</strong></li></ul></blockquote></li></ul></li></ul><h3 id="并、差、交检索"><a href="#并、差、交检索" class="headerlink" title="并、差、交检索"></a>并、差、交检索</h3><p>操作对象必须是<strong>相容</strong>的：有相同的属性列。</p><ul><li><p>UNION</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c1&#39;</span><br><span class="line">UNION</span><br><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c2&#39;;</span><br></pre></td></tr></table></figure></li><li><p>MINUS</p></li><li><p>INTERSECT</p></li></ul><h3 id="库函数检索"><a href="#库函数检索" class="headerlink" title="库函数检索"></a>库函数检索</h3><ul><li><p><code>COUNT()</code>：按<strong>列值</strong>计数，统计<strong>属性数</strong>。</p><blockquote><p><code>COUNT(*)</code>：对<strong>行</strong>计数，统计<strong>记录数</strong>。</p></blockquote></li><li><p><code>SUM()</code>：对数值列求总和</p></li><li><p><code>AVG()</code>：对数值列求平均</p></li><li><p><code>MAX()</code>：在列中找出最大值</p></li><li><p><code>MIN()</code>：在列中找出最小值</p></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>只能在<code>SELECT</code>和<code>HAVING</code>子句中出现</p></li><li><p>检索学生总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM S;</span><br></pre></td></tr></table></figure></li><li><p>检索选择了课程的学生总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT S)</span><br><span class="line">FROM SC;</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>DISTINCT</code>的位置</p></blockquote></li><li><p>求S4的总分和平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(G), AVG(G)</span><br><span class="line">FROM SC</span><br><span class="line">WHERE SC.S&#x3D;&#39;S4&#39;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组检索"><a href="#分组检索" class="headerlink" title="分组检索"></a>分组检索</h3><p>按<strong>属性列</strong>将记录分组，每组具有某个共同特征，然后对每一组进行<code>SELECT</code>操作。（相当于对记录进行了<strong>打包</strong>）</p><ul><li><p>分组子句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GROUP BY C</span><br><span class="line">[HAVING conditionExpression]</span><br></pre></td></tr></table></figure><ul><li><p><code>WHERE</code>是对<strong>行</strong>进行过滤，去掉不符合条件的行。</p></li><li><p><code>HAVING</code>只能对<strong>分组</strong>进行过滤，必须建立在<code>GROUP BY</code>之上.</p><blockquote><p><code>WHERE-&gt;GROUP BY-&gt;HAVING</code></p></blockquote></li></ul></li><li><p>检索至少选修了三门课的学生学号和选课门数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, COUNT(*)</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY S</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 3;</span><br></pre></td></tr></table></figure><blockquote><p><code>GROUP BY</code>同时影响了<code>SELECT</code>的范围，相当于是<code>FROM SC GROUP BY S</code>.</p></blockquote></li></ul><h3 id="算术表达式值检索"><a href="#算术表达式值检索" class="headerlink" title="算术表达式值检索"></a>算术表达式值检索</h3><ul><li><p>为算术表达式起别名提高可读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT EMPN, BONUS&#x2F;SALARY BS</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><ul><li><p><code>LIKE/NOT LIKE</code>：对字符型列适用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># &lt;列名&gt; LIKE&#x2F;NOT LIKE &lt;字符串常量&gt;</span><br><span class="line">SELECT S, SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE SN LIKE &#39;刘%&#39;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;字符串常量&gt;</code>可包含特殊符号<ul><li><code>%</code>：通配<strong>0或多个</strong>字符</li><li><code>_</code>：通配<strong>单个</strong>字符</li></ul></li></ul></li></ul><h3 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h3><ul><li><p>MySQL目前不支持</p></li><li><p>出现在<code>FROM</code>中的子查询生成的表叫做派生表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, C</span><br><span class="line">FROM SC, (SELECT S, AVG(G) FROM SC GROUP BY S) AS AVG_SC(AVG_S,AVG_G)</span><br><span class="line"># WHERE ...</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><ul><li>基本表：定义、删除、<strong>修改</strong></li><li>视图：定义、删除</li><li>索引：定义、删除</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><code>char(n)</code>：固定长度的字符串</li><li><code>varchar(n)</code>：可变长字符串</li><li><code>numeric(p, q)</code>：定点数共<code>p</code>位，小数点右边<code>q</code>位。</li><li><code>interval</code>：两个<code>date</code>或<code>time</code>类型数据之间的差</li></ul><h3 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;tablename&gt; (&lt;columnname&gt;&lt;datatype&gt;[&lt;columnintegrity&gt;],...);</span><br><span class="line">ALTER TABLE &lt;tablename&gt; (ADD&#x2F;DROP&#x2F;MODIFY);</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li><p>创建学生表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(S CHAR(5) NOT NULL UNIQUE,</span><br><span class="line"> SN CHAR(50) NOT NULL,</span><br><span class="line"> SA INT NOT NULL,</span><br><span class="line"> PRIMARY KEY(S),</span><br><span class="line"> CHECK (SA&gt;&#x3D;18 AND SA&lt;&#x3D;45));</span><br></pre></td></tr></table></figure></li><li><p>修改属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE S ADD SCOME DATE;</span><br><span class="line">ALTER TABLE S MODIFY SA SMALLINT; # modify the data type</span><br></pre></td></tr></table></figure></li><li><p>删除基本表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE S;</span><br></pre></td></tr></table></figure></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>为了对<strong>经常查询的属性</strong>的存取进行<strong>加速</strong>而提出的策略</p><ul><li>索引项：属性组取值</li><li>位置指针：索引对应的记录存储的位置</li><li>索引文件是<strong>排序文件</strong>，进而加快了查找速度。</li></ul><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE][CLUSTER] INDEX &lt;indexname&gt; ON &lt;tablename&gt; (&lt;columnname&gt;[sequence]);</span><br><span class="line">DROP UNIQUE INDEX &lt;indexname&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>CLUSTER</code>：索引项的指针所指的<strong>内存顺序</strong>和<strong>实际数据库</strong>中的顺序是相同的（不常使用）</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX Scno ON SC (S ASC, C DESC);</span><br><span class="line">DROP INDEX Scno ON S;</span><br></pre></td></tr></table></figure><ul><li><p><code>DROP INDEX</code>可以作为<code>ALTER TABLE</code>的子句使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON tablename;</span><br><span class="line">ALTER TABLE tablename DROP INDEX index_name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>视图是一个虚表，属于外模式。</li><li>视图消解(View Resolution)：对视图的操作会被等价的转化为对<strong>基本表</strong>的操作，然后再执行。</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>简化用户操作</li><li>为同样的原始数据提供不同的角度（为一间房子在不同的方向开了窗）</li><li>逻辑独立性（数据的逻辑结构改变时，应用程序对数据的操作不需要改变）</li><li>安全保护（权限管理）</li></ul><h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW &lt;viewname&gt; [&lt;columnname&gt;] AS &lt;subquery&gt; [WITH CHECK OPTION];</span><br><span class="line">DROP VIEW &lt;viewname&gt; [IF EXISTS &lt;viewname&gt;];</span><br></pre></td></tr></table></figure><ul><li><code>WITH CHECK OPTION</code>：让用户只能对视图中的数据进行CRUD，从而保护了数据库中的其他数据。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW CS_Student</span><br><span class="line">AS</span><br><span class="line">SELECT S, SN, SA FROM S</span><br><span class="line">WHERE SD&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure><ul><li><p>在视图上查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S,SA</span><br><span class="line">FROM CS_Student</span><br><span class="line">WHERE SA&lt;20;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><p>单个元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;tablename&gt; (&lt;columnname1&gt;,...) VALUES (&lt;value1&gt;,...);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO S VALUES (&#39;xxx&#39;, &#39;yyy&#39;, &#39;zzz&#39;);</span><br><span class="line">INSERT INTO SC (S, C) VALUES (&#39;xxx&#39;, &#39;yyy&#39;);</span><br></pre></td></tr></table></figure></li><li><p>子查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO DA(SD, Aveage)</span><br><span class="line">SELECT SD, AVG(SA) FROM S GROUP BY SD;</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;tablename&gt; SET &lt;columnname&gt;&#x3D;&lt;expression&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE SC</span><br><span class="line">SET G&#x3D;666</span><br><span class="line">WHERE &#39;CS&#39;&#x3D;(SELECT SD FROM S</span><br><span class="line">           WHERE S.S&#x3D;SC.S);</span><br></pre></td></tr></table></figure><blockquote><p><code>WHERE</code>中可以把常量放在等号<strong>左边</strong></p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;tablename&gt; [WHERE &lt;conditions&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>注意<strong>不是</strong><code>DROP</code></p></blockquote><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><ul><li><p>空值用<code>NULL</code>表示</p><ul><li>不能确定的值</li><li>属性不应该被赋值</li><li>属性值不方便填写</li></ul></li><li><p>属性有<code>NOT NULL</code>或者<code>UNIQUE</code>约束的，以及主属性不能够为<code>NULL</code>.</p><blockquote><p>部分系统允许<code>UNIQUE</code>为空</p></blockquote></li></ul><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li>算数运算：<code>NULL</code></li><li>比较运算：<code>UNKNOWN</code></li><li>逻辑运算：除了<code>False AND NULL</code>和<code>True OR NULL</code>可以确定之外，其余都为<code>UNKNOWN</code>.</li></ul><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><ul><li>使用<code>IS NULL</code>或<code>IS NOT NULL</code>判断</li></ul><h2 id="数据控制"><a href="#数据控制" class="headerlink" title="数据控制"></a>数据控制</h2><ul><li><p>完整性约束</p></li><li><p>事务操作</p></li><li><p>安全控制</p><ul><li><p>授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; TO &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure></li><li><p>收回权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; FROM &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h2><ul><li><p>将SQL的特性和程序设计语言的<strong>过程处理能力</strong>结合起来</p></li><li><p>预编译</p><ul><li>把嵌入在程序中的SQL语句翻译为高级语言源码，然后再编译、链接、执行。</li></ul></li><li><p>实现</p><ul><li><p>区分SQL和高级语言：在SQL语句前加<code>EXEC SQL</code></p></li><li><p>数据库工作单元和程序工作单元之间的通信：通过主变量（主程序语言变量）的值来传递</p></li><li><p>SQL和主语言之间操作方式的协调：通过游标(<code>Cursor</code>)解决，由游标进行记录的操作，然后将结果传递给主变量。</p><blockquote><p>游标时系统开辟的存放SQL执行结果的缓冲区</p></blockquote></li></ul></li><li><p>动态SQL：允许嵌入式语句的某些参数不确定，在运行时动态生成<code>SQL</code>语句。</p></li><li><p>ODBC/JDBC</p><ul><li><p>执行效率相比嵌入式SQL低，但是开发效率高。</p></li><li><p>组件</p><ul><li>应用程序</li><li>驱动程序管理器</li><li>驱动程序</li><li>数据源</li></ul><blockquote><p>不同的数据库提供相同的API接口，通过驱动管理程序即可以实现程序的移植性。</p></blockquote></li></ul></li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter4-数据库设计"><a href="#Chapter4-数据库设计" class="headerlink" title="Chapter4 数据库设计"></a>Chapter4 数据库设计</h1><p>全文共<code>2640</code>字，推荐阅读时间<code>20~25</code>分钟。</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><ul><li>直接设计法（手工试凑）<ul><li>高度依赖开发人员经验</li><li>后期维护困难</li><li>移植困难</li><li>难以合作设计</li></ul></li><li>规范设计法<ul><li>将设计过程分为若干个阶段，每个阶段只解决整个设计中的部分问题。<ul><li>需求分析：调查应用环境</li><li>概念结构设计（在三级模式两级映象中<strong>没有</strong>对应的部分）：形成可以<strong>用E-R图</strong>表示的模型</li><li>逻辑结构设计（<strong>概念模型</strong>，即模式、信息世界）：将E-R图转换成DBMS的模式和子模式</li><li>物理结构设计（<strong>数据模型</strong>，即内模式、机器世界）：存储结构（内模式）和存取方法（例如索引）</li><li>数据库实施：建立数据库</li><li>数据库运行和维护</li></ul></li></ul></li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>处理要求</li><li>信息要求</li><li>安全性和完整性要求</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>和用户交流</p></li><li><p>分析、表达用户需求</p><ul><li><p>用<strong>数据流图</strong>表达数据和处理之间的关系</p><ul><li>数据流图(Data Flow Diagram, DFD)：表达系统逻辑功能和数据逻辑流向和逻辑变换<ul><li><strong>自顶向下</strong></li></ul></li></ul></li><li><p>用<strong>数据字典</strong>描述系统中各类数据</p><ul><li><p>数据字典：对数据进行集中的说明，包含数据元素的名字、含义等。</p><ul><li>从数据流图中提取原子数据项</li><li>把有联系的数据项组合为数据组</li></ul><blockquote><p>上述数据字典和在数据库实施阶段的数据字典<strong>不同</strong>，前者可以看作是现实世界的<strong>数据元素表</strong>，后者是数据库系统的组成部分。</p></blockquote></li></ul></li></ul></li></ul><h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><ul><li>概念结构是信息世界的结构，即概念模型。</li></ul><h3 id="E-R法"><a href="#E-R法" class="headerlink" title="E-R法"></a>E-R法</h3><ul><li>描述概念模型</li><li>组成部分<ul><li>E-R图</li><li>转换E-R图为对应的数据模型</li></ul></li></ul><h4 id="E-R图概述"><a href="#E-R图概述" class="headerlink" title="E-R图概述"></a>E-R图概述</h4><ul><li>组成<ul><li>实体（方框）</li><li>属性（椭圆框）</li><li>联系（菱形框）<ul><li>联系也可以有属性，例如学生和课程的选修联系可以拥有成绩属性。</li><li>两个实体型之间可以具有多种联系，例如机器和工人可以有使用、维修两种联系。</li><li>语义扩充<ul><li>存在依赖(<code>E</code>)</li><li>标识依赖(<code>E&amp;I</code>)</li><li>实体的子类（连线上有一个圈）</li></ul></li></ul></li></ul></li></ul><h3 id="E-R图设计"><a href="#E-R图设计" class="headerlink" title="E-R图设计"></a>E-R图设计</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li><p>自顶向下</p></li><li><p>自底向上<strong>（最常用）</strong></p><blockquote><p>自顶向下需求分析，自底向上概念设计。</p></blockquote></li><li><p>逐步扩张：先定义核心概念结构</p></li><li><p>混合策略</p></li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>以自底向上为例</p><h5 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h5><ul><li>分类</li><li>聚集：定义某个实体型的组成成分</li><li>概括：定义类型之间的子集联系</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li><p>设计<strong>局部</strong>E-R图</p><ul><li><p>选择局部应用</p></li><li><p>利用数据抽象建立实体模型</p></li><li><p>确定实体之间的联系</p></li><li><p>必要调整（属性上升为实体）</p><ul><li><p>属性规范化（不可分割）：E-R图中属性不能和其他属性有<strong>关系</strong>（包括联系）</p></li><li><p>一个属性不能和多个实体之间有联系</p></li><li><p>属性和实体之间应该是“一对一”或者“多对一”的关系，不能“多对多”或者“一对多”。（即实体的某个属性取值是否确定）</p><blockquote><p>例如学生和课程号可能是“多对多”的关系，因此需要将课程号上升为实体。</p><ul><li>这里的多对多和<strong>实体</strong>之间的多对多不同，后者是靠<strong>联系</strong>体现的。但前者指<strong>取值的个数</strong>，例如存在一个学生有多门课，那么课程号的取值有多个，即一对多。</li></ul></blockquote></li></ul></li></ul></li><li><p>综合<strong>局部</strong>E-R图</p><ul><li><p>集成</p><ul><li>一次集成</li><li>逐步集成：累加</li></ul></li><li><p>消除冲突</p><ul><li><p>属性：类型、取值范围、取值单位</p><blockquote><p>协商讨论</p></blockquote></li><li><p>命名</p><blockquote><p>建立命名表</p></blockquote></li><li><p>结构</p><ul><li><p>同一个对象在不同应用中抽象层次不同，例如一个为实体，在另一个中为属性。</p><blockquote><p>实体上升或属性下降，通常为前者。</p></blockquote></li><li><p>同一个实体在不同应用中描述不同，例如属性个数、次序不同。</p><blockquote><p>取并集</p></blockquote></li><li><p>联系类型不同</p><blockquote><p>根据语义综合</p></blockquote></li></ul></li></ul></li><li><p>消除冗余：集成得到的初步E-R图可能存在<strong>数据冗余</strong>和<strong>联系冗余</strong>，调整过后得到<strong>基本E-R图</strong>。</p><ul><li>分析法<ul><li>重点考察<strong>联系的属性</strong>（可能由其他的属性表示，<strong>不一定成环</strong>）</li></ul></li><li>规范化方法</li></ul><blockquote><p>冗余危害：数据不一致。当某个属性变化时，需要更改所有相关的冗余属性，少改任何一个就会出问题。</p></blockquote></li></ul></li></ul><h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><ul><li><p>把概念模型（E-R图）转换为DBMS支持的数据模型（模式）的过程</p></li><li><p>任务</p><ul><li><p>形成初始关系数据库模式：关系</p><blockquote><p>其他的数据库可能是网状、层次等结构。</p></blockquote></li><li><p>关系模式规范化：特定DBMS支持下的数据模型</p></li><li><p>关系模式优化</p></li><li><p>子模式定义（定义外模式）</p><blockquote><p>模式是很多张表的<strong>规范</strong>（设计表），关系是具体的<strong>数据内容</strong>。</p></blockquote></li></ul></li></ul><h3 id="E-R图与关系模型"><a href="#E-R图与关系模型" class="headerlink" title="E-R图与关系模型"></a>E-R图与关系模型</h3><h4 id="普适转换规则"><a href="#普适转换规则" class="headerlink" title="普适转换规则"></a>普适转换规则</h4><blockquote><p>一个关系模式就是一种<strong>数据模型</strong></p></blockquote><ul><li><p>前提：确定每个关系模式的<strong>码</strong></p></li><li><p>一个实体型转换为一个关系模式</p></li><li><p>一个联系转换为一个关系模式</p><ul><li><p><code>1:1</code>：每个实体的码均是该联系的候选码，任意选择一个作为联系模型的主码即可。</p><blockquote><p><strong>不可以</strong>同时选，因为不满足码的<strong>最小性</strong>。</p></blockquote></li><li><p><code>1:n</code>：关系的码是<strong><code>n</code>端实体</strong>的码</p><blockquote><ul><li><code>n</code>端实体码才有唯一标识作用</li><li><strong>不是<code>n</code>端所有实体码的组合</strong></li></ul></blockquote></li><li><p><code>m:n</code>：关系的码是<strong>两端所有</strong>实体码的组合</p></li></ul><blockquote><ul><li>一般只有<code>n:m</code>关系才有属性，其他的联系都可以整合进属性，例如<code>1:n</code>可以在<code>n</code>端实体增加存放<code>1</code>端的码。</li><li>只选择一端实体的码<strong>不代表</strong>只存储一端实体的属性</li></ul></blockquote></li><li><p>多元联系转换为一个关系模式</p></li><li><p>具有相同的码的关系可以<strong>合并</strong>。例如消耗关系和零件的码都是零件号，就可以合并为一个关系。</p><blockquote><p>合并后可能和概念模型E-R图规范不符，但是在逻辑结构设计环节是合法的。</p></blockquote></li></ul><h4 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h4><p>存在依赖中依赖别的实体的实体</p><ul><li>为每个弱实体创建新的关系</li><li>将<strong>被依赖关系的码</strong>作为新关系的<strong>外码</strong></li><li>新关系的主码是<strong>被依赖实体的码</strong>和<strong>自身部分标识属性</strong>的组合</li></ul><h4 id="超类-子类联系"><a href="#超类-子类联系" class="headerlink" title="超类/子类联系"></a>超类/子类联系</h4><ul><li><p>为超类和每个子类创建单独的关系</p></li><li><p>超类关系中，<strong>包含所有子类共有的属性</strong>，包括<strong>主码</strong>。</p></li><li><p>在超类中选定属性组作为子类的判定符</p></li><li><p>子类关系中，包含超类主码以及子类特有的属性。（<strong>没有</strong>共有属性）</p><blockquote><p>子类使用超类的主码作为自己的主码</p></blockquote></li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul><li>确定范式等级（通常需要达到3NF）</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>模式的合并和分解</li><li>关系模式的分解可以提高存取效率和存储空间的利用率</li></ul><h4 id="水平分解"><a href="#水平分解" class="headerlink" title="水平分解"></a>水平分解</h4><ul><li><p>选取操作</p></li><li><p><code>2-8</code>原则：常使用的部分提取出来作为一个关系</p></li><li><p>数据分片：根据不相交的事务将关系分解为多个子关系</p><blockquote><p>事务：一组相对独立的操作</p></blockquote></li><li><p>恢复：并运算</p></li></ul><h4 id="垂直分解"><a href="#垂直分解" class="headerlink" title="垂直分解"></a>垂直分解</h4><ul><li><p>投影操作</p></li><li><p>将经常使用的属性提取出来作为一个子关系模式</p></li><li><p>垂直分解需要保证<strong>无损连接性</strong>和<strong>保持函数依赖</strong>（能够完全复原关系）</p><blockquote><p>完全复原的必要条件：垂直分解得到的子关系模式保留了主码</p></blockquote></li><li><p>恢复：连表运算</p></li></ul><h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><ul><li>用户需求</li><li>具体DBMS的特点，例如MySQL是<code>CREATE VIEW</code>.<ul><li>根据不同的用户设置不同的列名</li><li>权限管理保证系统的安全性</li><li>降低复杂查询的难度</li></ul></li></ul><h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><ul><li>确定数据库的存储结构（内模式）</li><li>存取方法</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>存放位置<ul><li>冷热数据分开存放</li><li>数据和日志备份放在<strong>不同的磁盘</strong>上</li></ul></li><li>系统配置<ul><li>存储分配参数</li><li>物理优化</li></ul></li></ul><h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><ul><li><p>索引记录/索引项：索引文件的记录</p><ul><li>索引域：数据文件中属性组的<strong>一个取值</strong></li><li>指针：指向索引域对应的磁盘块地址</li></ul><blockquote><p>在MySQL的底层，在发起查询时会先查找记录索引域的数据区，然后确定是否对索引进行查找。</p></blockquote></li><li><p>分类</p><ul><li>稀疏索引：把所有数据记录按索引值分组，每组设立一个索引项。</li><li>稠密索引：为每个记录设置一个索引项，记录的存放是任意的，但是<strong>索引是有序</strong>的。</li></ul></li><li><p>多级索引</p><ul><li>（排序）二叉树索引</li><li>多叉树索引：每个结点有<code>D</code>个值作为分界点，共<code>(D+1)</code>个指针。</li><li>平衡树索引：限制每个结点放置的关键字和指针最小/最大个数，从而使所有的叶子结点都在一层。</li><li><code>B+</code>树索引（常用）：把树中所有关键字按<strong>递增次序</strong>从左到右安排在叶结点上，并<strong>链接</strong>起来。</li></ul></li><li><p>索引域选择</p><ul><li>经常被查询的属性</li><li>经常作为库函数的参数</li><li>经常作为连接属性</li></ul><blockquote><p>索引并非越多越好</p></blockquote></li></ul><h4 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h4><ul><li><p>将关系中<strong>某个属性组值相同</strong>的记录集中存放在<strong>连续的物理块</strong>中，可以提高查询速度。</p><blockquote><p>就像同学院的同学安排在一栋宿舍楼中</p></blockquote></li><li><p><strong>一个</strong>关系<strong>只能</strong>参与<strong>一个</strong>聚集（一个关系只能被存储一次）</p></li><li><p>选择原则</p><ul><li>经常进行连接操作的关系</li><li>单个关系中经常比较的属性组</li><li>关系<strong>属性组值</strong>重复率高的属性组</li><li>更新操作较多时<strong>不应该</strong>使用聚集方法</li></ul></li></ul><h4 id="HASH文件"><a href="#HASH文件" class="headerlink" title="HASH文件"></a>HASH文件</h4><ul><li><p>通过HASH函数将记录关键字转换成地址，并将这个地址作为<strong>记录</strong>的存储地址。</p></li><li><p>选择原则</p><ul><li><p>关系大小可预知，并且不变。</p><blockquote><p>如果大小会变化，DBMS需要提供对应的动态HASH存取方法。</p></blockquote></li></ul></li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter5-关系数据理论"><a href="#Chapter5-关系数据理论" class="headerlink" title="Chapter5 关系数据理论"></a>Chapter5 关系数据理论</h1><p>全文共<code>4341</code>字，推荐阅读时间<code>30~45</code>分钟。</p><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul><li>数据依赖：影响<strong>模式质量</strong>的因素<ul><li>关系内部属性之间的约束关系</li><li>分类<ul><li>函数依赖</li><li>多值依赖</li></ul></li></ul></li><li>范式理论：衡量模式质量的标准</li><li>规范化方法与算法：提升模式质量的办法</li></ul><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>给定属性集$U$，及其子集$X$，$Y$，$R(U)$是其上的<strong>关系模式</strong>（域名元组），$r$是$R$的<strong>任意一个</strong>具体关系（填入了任意的具体内容），$t$，$s$是$r$中<strong>任意</strong>两个元组。</p><ul><li>如果$t[X]=s[X]$，则$t[Y]=s[Y]$.此时称“$X$函数确定$Y$”或“$Y$函数依赖于$X$”，记作$X\rightarrow Y$.</li></ul><blockquote><p>等价定义：对于$X$的每个具体值，$Y$有唯一的值与之对应。</p></blockquote></li><li><p>函数依赖属于<strong>语义</strong>范畴</p></li><li><p>函数依赖具有时间稳定性，<strong>不随</strong>时间改变。</p><blockquote><p><code>r</code>（具体关系）可能会发生变化，但是函数依赖<strong>不会</strong>发生改变。</p></blockquote></li></ul><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>平凡依赖：若$Y\subseteq X$，则$X\rightarrow Y$是平凡依赖。</li><li>非平凡</li><li>决定因素：$X$被称为决定因素</li></ul><h4 id="属性联系"><a href="#属性联系" class="headerlink" title="属性联系"></a>属性联系</h4><ul><li><code>1:1</code>：$X\rightarrow Y,Y \rightarrow X$，即两者<strong>相互决定</strong>。</li><li><code>1:n</code>：<code>n</code>端项($X$)决定<code>1</code>端项($Y$)，即$X\rightarrow Y$.</li><li><code>m:n</code>：两者之间<strong>不存在</strong>函数依赖</li></ul><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li><p>完全：$X$的<strong>任意</strong>真子集（除空集）都<strong>不能够</strong>确定$Y$，记为$X \rightarrow Y$（箭头上有一个<code>f</code>）。</p></li><li><p>部分：$X\rightarrow Y$（箭头上有一个<code>p</code>）</p></li><li><p>传递：若$X\rightarrow Y(Y\nsubseteq X),Y\rightarrow Z(Z\nsubseteq Y)$，且$Y$<strong>不确定</strong>$X$，则称为$Z$对$X$<strong>传递</strong>函数依赖（箭头上有一个<code>t</code>）。</p><blockquote><ul><li>如果$Y$可以确定$X$，则$Z$对$X$是<strong>直接</strong>依赖（因为可以归为以上三种类型之一，因此<strong>不是</strong>独立的类型）。</li><li>注意传递依赖要求两个函数依赖都是<strong>非平凡</strong>的</li></ul></blockquote></li></ul><h3 id="关系键"><a href="#关系键" class="headerlink" title="关系键"></a>关系键</h3><ul><li>候选码：设$K$是$R<U,F>$（$F$是属性集$U$上的函数依赖<strong>集</strong>）的属性或属性组合，若$U$<strong>完全依赖</strong>于$K$，则称$K$是$R$的候选码。当候选码多于一个时，选定其中一个作为主码。</li><li>性质<ul><li>唯一性</li><li>最小性</li></ul></li><li>属性分类<ul><li>主属性：包含在<strong>任一候选码</strong>中的属性</li><li>非主属性：不包含在任何候选码中的属性</li></ul></li><li>外码：关系模式$R$中的属性或属性组$X$并非$R$的码，但$X$是另一个关系模式的码，则称$X$是$R$的外码。</li></ul><h3 id="逻辑蕴涵"><a href="#逻辑蕴涵" class="headerlink" title="逻辑蕴涵"></a>逻辑蕴涵</h3><ul><li>通过函数依赖集$F$能够推出$X\rightarrow Y$，则称$F$逻辑蕴涵$X\rightarrow Y$.</li><li>$F$的闭包：$F$蕴涵的<strong>全体函数依赖</strong>称为$F$的闭包，记为$F^+$.</li></ul><h3 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h3><ul><li><p>定律（可从蕴涵定义出发证明）</p><p>对$R<U,F>$</p><ul><li><p>自反律：属性集蕴涵其<strong>子集</strong></p></li><li><p>增广率：对属性$Z\subseteq U$，若$X\rightarrow Y$，则$XZ\rightarrow YZ$.</p><blockquote><p>$XZ$：将两个属性组<strong>直接拼接</strong></p></blockquote></li><li><p>传递率</p></li></ul></li><li><p>推论</p><ul><li>合并：若$X\rightarrow Y, X\rightarrow Z$，则$X\rightarrow YZ$.</li><li>伪传递：若$X \rightarrow Y, WY\rightarrow Z$，则$WX\rightarrow Z$.</li><li>分解：若$X\rightarrow Y$且$Z\subseteq Y$，则$X \rightarrow Z$.</li></ul></li><li><p>定理</p><p>$X\rightarrow A_1A_2…A_k \Longleftrightarrow X\rightarrow A_i(i=1,2,…,k)$</p></li><li><p>属性集闭包：$X\subseteq U$，将所有从$X$出发，通过$F$能够导出的<strong>属性的集合</strong>，记为$X_F^+$.</p><ul><li>$K_F^+=U$，即通过主码能够推出全体属性。</li><li>定理：$X\rightarrow Y \Longleftrightarrow Y\subseteq X_F^+$</li></ul></li><li><p>有效性（正确性）：从$F$出发，根据Armstrong公理导出的所有函数依赖一定在$F$蕴涵的<strong>全体函数依赖</strong>中</p></li><li><p>完备性（实用性）：$F^+$一定可以由Armstrong公理系统导出</p><blockquote><p>证明逆否命题：如果$X\rightarrow Y$不能用Armstrong公理从$F$中导出，则它一定不被$F$逻辑蕴涵。（即不属于该函数依赖集合下的关系模式）</p></blockquote></li></ul><blockquote><p>Armstrong公理系统是一种操作$F$的方式，还可以有其他公理系统，<strong>不</strong>影响$F$本身的存在。</p></blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>算法：求$X_F^+$</p><ul><li>以$X$为起始属性集，对其所有<strong>子集</strong>（不只是元素）进行迭代推导。</li><li>属性集在某一次迭代中没有更新或者等于全集$U$时终止算法</li></ul><blockquote><p>闭包表示</p><ul><li>函数依赖闭包$F^+$：<code>{}</code></li><li>属性集闭包$X_F^+$：<strong>直接列举元素</strong>，外层不需要<code>{}</code>或<code>()</code>修饰。</li></ul></blockquote><h3 id="函数依赖集"><a href="#函数依赖集" class="headerlink" title="函数依赖集"></a>函数依赖集</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>对于$F,G$，若$F^+=G^+$，即两者能推出的全体函数依赖相同，则称两者等价。<ul><li>此时称$F$和$G$相互覆盖</li><li>$F^+=G^+\Longleftrightarrow F \subseteq G^+ \Longleftrightarrow G \subseteq F^+$</li></ul></li><li>最小依赖集<ul><li>右部单属性化：$F$中任一函数依赖$X\rightarrow A$，$A$必是单属性。</li><li>函数依赖<strong>左部</strong>没有多余属性：<strong>不存在</strong>部分函数依赖</li><li>没有多余的函数依赖：$F$中<strong>不存在</strong>可以被其他函数依赖导出的函数依赖</li></ul></li></ul><h4 id="极小化"><a href="#极小化" class="headerlink" title="极小化"></a>极小化</h4><ul><li><p>定理：每个函数依赖集$F$<strong>均等价于</strong>一个极小函数依赖集$Fm$</p></li><li><p>算法</p><ul><li><p>对于<strong>右部</strong>是属性集合的函数依赖进行分解，转换为<strong>多个</strong>单属性依赖。</p></li><li><p>对于<strong>左部</strong>是属性集合的函数依赖，对左侧进行消融检查。对于消融后函数依赖不受影响属性，均从左侧属性集中删除<strong>并更新迭代集</strong>。</p><blockquote><p>也可能消融实验后，左部依然是属性组。</p></blockquote></li><li><p>对于<strong>每个函数依赖</strong>做消融检查，如果消融某个依赖后依然可以推导出该函数依赖，则可以将该函数依赖删除<strong>并更新迭代集</strong>。</p><ul><li>算法一：转化为图的连通性判定</li><li>算法二：求该函数依赖左侧属性<strong>新的属性集闭包</strong>，判断是否包含该消融函数依赖的右侧元素。</li></ul></li></ul><blockquote><p>对于算法的2，3步而言，如果消融的顺序不一样，可能会得到不一样的$Fm$，即$Fm$不唯一。</p></blockquote></li></ul><h2 id="规范化-1"><a href="#规范化-1" class="headerlink" title="规范化"></a>规范化</h2><ul><li>目的：消除冗余和异常</li><li>思想：“一事一地”，一个关系只描述一个实体或者实体间的一种联系。</li><li>消除部分函数依赖和传递函数依赖</li></ul><h3 id="范式-Normal-Form"><a href="#范式-Normal-Form" class="headerlink" title="范式(Normal Form)"></a>范式(Normal Form)</h3><ul><li>一个关系满足的某个<strong>指定的约束集</strong></li><li>各级范式联系：$5NF \sub 4NF\sub BCNF \sub 3CNF \sub 2NF \sub 1NF$（反证法）</li><li>规范化：通过<strong>模式分解</strong>将低级范式的关系模式提升到更高的范式等级</li></ul><h4 id="分级"><a href="#分级" class="headerlink" title="分级"></a>分级</h4><ul><li><p>第一范式(1NF)：最低要求，满足的关系被称为<strong>规范化关系</strong>。</p><ul><li>一个关系只包含原子值（属性<strong>不可</strong>再分）</li></ul></li><li><p>第二范式(2NF)</p><ul><li><p>$R\in 1NF$，并且每个<strong>非主属性完全依赖</strong>于码，则称$R\in2NF$.</p></li><li><p><strong>允许主属性部分依赖于码</strong></p><blockquote><ul><li>任一主属性<strong>均部分依赖</strong>于码</li><li>某些所有属性都是主属性，但是码<strong>不是</strong>全体主属性的情况，例如<code>STC(S, T, C)</code>.</li></ul></blockquote></li><li><p>如果$R$的全体属性都是主属性，则$R\in 2NF$.</p></li><li><p>从$1NF$中消除非主属性对码的部分函数依赖即可升级为2NF</p><ul><li>画函数依赖图</li><li>投影分解法（选择部分列）</li></ul></li></ul></li><li><p>第三范式(3NF)</p><ul><li><p>若$R\in2NF$，并且每个<strong>非主属性</strong>都<strong>不传递依赖</strong>于$R$的任何码，则$R\in3NF$.</p><ul><li><p>推论：若非主属性$Z$<strong>部分依赖</strong>于码$X$，则$R\notin 3NF$.</p><blockquote><p>此时$R\notin 2NF$</p></blockquote></li></ul></li><li><p>投影分解法</p></li></ul></li><li><p>BCNF</p><ul><li><p>3NF<strong>没有限制主属性</strong>对码的<strong>部分及传递函数依赖</strong>，依然会在某些情况下带来异常。</p></li><li><p>若$R\in 1NF$，对任意函数依赖$X\to Y$，且$Y\nsubseteq X$时，$X$必含有码，则$R\in BCNF$.</p><blockquote><p>等价定义：BCNF中任意<strong>非平凡</strong>函数依赖的<strong>左部</strong>含有码</p></blockquote></li><li><p>性质（反证法）</p><ul><li><p><strong>所有</strong>非主属性<strong>完全函数依赖</strong>于任一候选码(2NF)</p></li><li><p><strong>所有</strong>主属性<strong>完全函数依赖</strong>于每个<strong>不包含它</strong>的候选码(BCNF)</p></li><li><p><strong>没有</strong>属性<strong>完全函数依赖</strong>于非码的任意属性组(3NF, BCNF)</p><blockquote><p>如果没有完全函数依赖，则不可能有部分函数依赖。</p></blockquote></li><li><p>全码（所有属性一起作为码的关系模式）关系就是BCNF</p></li></ul></li><li><p>BCNF是只考虑函数依赖的<strong>最高标准</strong></p><blockquote><p>和多值依赖对应，不是指保持函数依赖。</p></blockquote></li></ul></li></ul><h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li><p>给定属性组$X$，$Y$，$Z$，满足$Z=U-X-Y$.当给定一组$(x,z)$可以得到一个$Y$的取值集合，若该集合与$X$有关而与$Z$无关，则称$Y$多值依赖于$X$，记为$X\to \to Y$.</p><blockquote><ul><li>即$(x,z)$中$z$任意变化对$Y$的取值集合<strong>没有</strong>影响，由$X$确定了$Y$的一组取值。</li><li>因为一个自变量对应了多个因变量，因此叫做多值依赖而不是函数依赖。</li><li>函数依赖是多值依赖的特殊情况。</li></ul></blockquote></li><li><p>有效性范围</p></li><li><p>现实场景：各个域之间均为多对多关系，即<strong>不能够</strong>提取出函数依赖关系的模式。</p></li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>给定$Z=U-X-Y$</p><ul><li><p>对称性：若$X\to \to Y$，则$X\to\to Z$.</p></li><li><p>若$X\to Y$，则$X\to\to Y$，即函数依赖可以看作多值依赖的特例。</p></li><li><p>平凡：若$X\to\to Y$，且$Z= \phi$.</p><blockquote><p>即$U$只被划分为了$X$和$Y$</p></blockquote></li><li><p>非平凡：若$X\to\to Y$，且$Z\neq \phi$.</p></li></ul><h3 id="第四范式-4NF"><a href="#第四范式-4NF" class="headerlink" title="第四范式(4NF)"></a>第四范式(4NF)</h3><ul><li><p>对任意<strong>非平凡</strong>多值依赖$X\to\to Y(Y\nsubseteq X)$，$X$都含有码，则称$R\in 4NF$.</p><blockquote><p>若关系已经满足BCNF，且所有的多值依赖都是平凡的，则关系也满足4NF.</p></blockquote></li><li><p>意义：降低数据冗余程度，减少修改异常。</p></li></ul><h2 id="模式分解理论"><a href="#模式分解理论" class="headerlink" title="模式分解理论"></a>模式分解理论</h2><ul><li><p>目的：通过模式分解，将关系模式的范式等级提高，同时保有原关系模式的一定信息。</p><blockquote><p>如果不保有信息，分解是没有意义的。因此，所有的分解算法都和性质的保持有关。</p></blockquote></li></ul><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>分解$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>,…,R_n<U_n,F_n>\}$，满足：</p><ul><li><p>$U=\bigcup_{i=1}^n U_i$，且$\forall 1\leq i,j \leq n,U_i\nsubseteq U_j$.</p><blockquote><p>可以相交但<strong>不能</strong>包含</p></blockquote></li><li><p>$F_i$是$F$在$U_i$上的一个投影，即选择了$F^+$中相关属性<strong>都在</strong>$U_i$中($XY\subseteq U_i)$的函数依赖作为$F_i$.（可以只选择一部分，不一定全选）</p></li><li><p>表示</p><p>$\rho=\{R_1&lt;\{Sno,Sdept\},\{Sno \to Sdept\}&gt;,R_2&lt;\{Sno,Mname\},\{Sno \to Mname\}&gt; \}$</p></li></ul><h3 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性"></a>无损连接性</h3><ul><li><p>将分解后的关系模式做<strong>自然连接</strong>得到合成的新关系模式，如果新关系模式中的关系和分解前的原关系模式中的关系逐一相等，则称该分解$\rho$具有无损连接性，记为<strong>无损分解</strong>。</p></li><li><p>判定</p><ul><li><p>算法</p></li><li><p>定理（无损连接性的充要条件）：以分解为两个子模式为例，若$R_1$和$R_2$的共同属性<strong>至少构成二者之一</strong>的候选码，则为无损分解。</p><blockquote><p>扩展为<code>n</code>个子关系模式：将子模式间<strong>两两进行比较</strong>，若<strong>所有</strong>的比较都满足以上条件，则该分解无损连接性。（每一次都是无损连接，则合成后的连接也是无损连接）</p></blockquote></li></ul></li></ul><h3 id="保持函数依赖性"><a href="#保持函数依赖性" class="headerlink" title="保持函数依赖性"></a>保持函数依赖性</h3><ul><li>若$F^+=(\bigcup_{i=1}^nF_i)^+$，即两个函数依赖集等价，则称$\rho$是保持函数依赖性的分解。</li><li>判定：设$G=(\bigcup_{i=1}^nF_i)$，$G\subseteq F^+$一定成立，则只需要判断$F^+\subseteq G$是否成立。<ul><li>$\forall (X\to Y) \in F$，判断$Y$是否属于$X_G^+$.</li><li>对于$F$中的每个函数依赖，判断是否可以从$G$中的函数依赖导出。</li></ul></li></ul><blockquote><p>分解$\rho$可以无损连接性和保持函数依赖性，也可以只满足其中一个，也可以同时都不满足。</p></blockquote><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>规范化过程中采用的投影分解可能不唯一，但是好的无损分解应该无损连接并且保持函数依赖。</li><li>若要保持函数依赖，则最高可能只能到3NF.（BCNF的粒度过小，可能<strong>不保持</strong>函数依赖）</li><li>若要进行无损分解，则可以到达4NF或更高。</li></ul><blockquote><ul><li>模式分解是在求当前模式的“数据等价子集”，在保证<strong>数据完整性（无损连接）</strong>的条件下尽可能地减小单个模式的复杂度，因此某些不影响数据完整性的函数依赖可能被舍弃。</li><li>大多数情况下，3NF是最为合适的规范化等级，因为它是能够无损连接并且保持函数依赖的最高等级。</li></ul></blockquote><h3 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h3><ul><li><p>3NF+函数依赖</p><ul><li><p>对$F$进行<strong>极小化</strong>处理，记为$F$.</p></li><li><p>将<strong>不在</strong>$F$中出现的属性从$U$中删除，记为$U$.</p><blockquote><p>删除了部分元素，所以<strong>不具有</strong>无损连接性。</p></blockquote></li><li><p>若$F$只有一个函数依赖，则$\rho=\{R\}$.</p></li><li><p>对$F$按照<strong>“具有相同左部”</strong>的原则进行分组，由$F_i$求出$U_i$，则$\rho=\{R_1<U_1,F_1>,…R_k<U_k,F_k>\}$为所求。</p></li></ul></li><li><p>3NF+无损连接性+函数依赖</p><p>从<strong>满足保持函数依赖</strong>的分解$\rho$出发，设$X$是$R<U,F>$的码。</p><ul><li><p>若$\exist U_i, X\subseteq U_i$，则$\rho$为所求。</p></li><li><p>否则，令$\tau=\rho \cup\{R^*<X,F_X>\}$，则$\tau$为所求。</p><blockquote><ul><li>$F_X$是以$X$为属性集的函数依赖的投影</li><li>$X_F$是属性$X$蕴涵的属性集</li><li>在满足函数依赖的算法中，删去了<strong>不出现</strong>在$F$中的属性，但是它们是<strong>主属性</strong>，因此通过$X$对无损连接性进行了恢复。</li><li>注意，$\tau$求解时是直接把$R^<em>$并入，而<em>*不是</em></em>把$X$添加进$U_i$.</li></ul></blockquote></li></ul></li><li><p>BCNF+无损连接性</p><p>设$\rho$中$R_i<U_i,F_i>\notin BCNF$</p><ul><li>则$R_i$中存在$X\to A\in F_i^+(A\notin X)$，且$X$不是$R_i$的码（也不含有），则$XA$是$U_i$的真子集，将$R_i$分解为$\sigma=\{S_1,S_2\}$，其中$U_{S_1}=XA$，$U_{S_2}=U_i-\{A\}$.</li></ul><blockquote><p>$A$是<strong>单属性</strong>，而<strong>不是</strong>属性组。</p></blockquote><ul><li><p>使用$\sigma$进行迭代，直到$\sigma \in BCNF$.</p><blockquote><p>相当于逐步分离不符合BCNF的函数依赖</p></blockquote></li></ul></li></ul><h2 id="候选码求解"><a href="#候选码求解" class="headerlink" title="候选码求解"></a>候选码求解</h2><h3 id="单属性"><a href="#单属性" class="headerlink" title="单属性"></a>单属性</h3><h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><ul><li>$L$：<strong>仅</strong>出现在左部</li><li>$R$：<strong>仅</strong>出现在右部</li><li>$N$：两边均未出现</li><li>$LR$：两边均出现</li></ul><blockquote><p>以上是<strong>属性</strong>分类，而不是<strong>属性组</strong>分类。</p><p>例如，$BC\to A$和$C\to B$均成立时，$BC\notin L$.</p></blockquote><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><ul><li>L类属性一定是<strong>所有候选码</strong>中的成员（<strong>强于</strong>主属性）<ul><li>若L类属性能够推出全体属性，则该属性单独作为候选码，且由码的极小性，该候选码唯一，即<strong>主码</strong>为该属性。</li></ul></li><li>R类属性一定<strong>不是</strong>任意候选码成员</li><li>N类属性一定是<strong>所有候选码</strong>中的成员<ul><li>若L和N类属性组成的集合能够推出全体属性，则该属性集是<strong>主码</strong>。</li></ul></li></ul><h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><p>将<strong>单属性依赖</strong>关系模式转换为图$G(U,F)$，其中$F$为有向边集合，表示<strong>单属性</strong>函数依赖。</p><ul><li>关键点（原始点+孤立点）对应的属性必在$R$的任何候选码中</li><li>属性集$X$是$R$的唯一候选码$\Leftrightarrow$X能到达$G$中的任一结点<ul><li>在单属性条件下，即不存在独立回路。</li></ul></li><li>对途中点而言，成为候选码成员$\Leftrightarrow$途中点是独立回路中的结点。</li><li>对于存在独立回路的关系模式而言，候选码=关键属性集+独立回路笛卡尔积中的任意元素。</li></ul><h3 id="多属性"><a href="#多属性" class="headerlink" title="多属性"></a>多属性</h3><ul><li><p>$X=L\cup N，Y=LR$.</p></li><li><p>判断$X$是否可以推出全体属性集，如果不可以的话就从$Y$中取一个并进$X$，然后再次判断。</p></li><li><p>依次迭代取的个数，直到能够推出全体属性。</p><blockquote><ul><li>这是一个穷举算法，取两个不只是在取的第一个的基础上再取，而是遍历所有取两个的情况。</li><li>证明了独立回路存在时，主码$K\neq L\cup N$.</li></ul></blockquote></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>通过最小函数依赖集消除<strong>冗余</strong>联系</li><li>$D=F-F_m$中的函数依赖<strong>不一定</strong>是冗余的，因此除了$F_m$中的函数依赖外，可能$D$中也有需要保留的函数依赖。</li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter6-关系查询处理与查询优化"><a href="#Chapter6-关系查询处理与查询优化" class="headerlink" title="Chapter6 关系查询处理与查询优化"></a>Chapter6 关系查询处理与查询优化</h1><p>全文共<code>448</code>字，推荐阅读时间<code>3~5</code>分钟。</p><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul><li>分析</li><li>检查<ul><li>将查询转换为<strong>查询树</strong>（语法分析树）</li></ul></li><li>优化<ul><li>代数：恒等变换</li><li>物理：根据数据规模、分布等确定对应的底层存储策略。</li></ul></li><li>执行</li></ul><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><ul><li>查询代价=I/O代价<strong>（主要）</strong>+CPU代价+内存代价</li></ul><h3 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h3><ul><li>变换规则：主要是优化<strong>连接</strong>（笛卡尔积为主）运算。<ul><li>交换律</li><li>结合律</li></ul></li><li>特殊优化：先缩小范围再运算一般效率更高<ul><li>投影、选择的串接：合并操作减小遍历次数</li><li>投影、选择的交换律：先投影再选择</li><li>选择、笛卡尔积的交换律：能先投影时，先投影再作笛卡尔积。</li></ul></li><li>查询树的启发式优化<ul><li>减少<strong>中间</strong>（临时）关系：选择、投影尽可能先做。</li><li>减少扫描次数：投影、选择并行等操作。</li><li>减少操作总数：连接=笛卡尔积+选择</li><li>中间结果复用：使用中间文件存储公共表达式的结果</li></ul></li></ul><h3 id="物理优化"><a href="#物理优化" class="headerlink" title="物理优化"></a>物理优化</h3><ul><li><p>存取路径选择</p><ul><li><p>选择操作</p><ul><li>小关系：全表扫描</li><li>大关系：索引扫描</li></ul></li><li><p>连接操作</p><ul><li><p>排序-合并</p></li><li><p>索引连接：为连接属性建立索引</p></li><li><p>Hash Join：为小表建Hash文件</p></li><li><p>嵌套循环：小表在外层</p><blockquote><p>原因：分配时通常给外表的内存更大</p><ul><li><p>设外表分配$(K-1)$块，内表$1$块。</p><p>$Cost=Cost_{out}+Cost_{in}*\frac{B_{out}}{K-1}$</p></li></ul></blockquote></li></ul></li></ul></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul><li>将查询转换成语法树</li><li>代数优化</li><li>物理优化，确定底层的存储路径</li><li>生成查询计划</li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li></ul><h1 id="Chapter7-事务处理技术"><a href="#Chapter7-事务处理技术" class="headerlink" title="Chapter7 事务处理技术"></a>Chapter7 事务处理技术</h1><p>全文共<code>2870</code>字，推荐阅读时间<code>15~20</code>分钟。</p><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ul><li>事务(Transaction)：用户定义的数据库操作序列，这些操作要么一起做，要么都不做，是一个不可分割的<strong>工作单位</strong>。<ul><li>应用程序可以包含<strong>多个</strong>事务</li><li>事务的开始和结束可以由用户显式控制（DBMS也会缺省定义一部分事务划分），从而保证数据的<strong>完整性</strong>。</li></ul></li><li>事务是<strong>数据库恢复</strong>及<strong>并发控制</strong>的基本单位</li></ul><h3 id="特性-ACID"><a href="#特性-ACID" class="headerlink" title="特性(ACID)"></a>特性(ACID)</h3><ul><li><p>原子性</p><ul><li>基础：恢复机制<ul><li>回退，将已经执行的部分进行撤销。</li></ul></li></ul></li><li><p>一致性：事务执行前后数据库均为一致性状态</p><ul><li>基础：原子性</li></ul><blockquote><p>Q：什么是一致性状态</p><p>A：满足数据库约束的状态</p></blockquote></li><li><p>隔离性：并发事务之间不能相互影响</p><ul><li>基础：并发控制机制</li></ul></li><li><p>持久性：事务<strong>提交后</strong>对数据库的改变应该是永久的，故障等情况不应该有影响。</p><ul><li>基础：恢复机制</li></ul></li></ul><blockquote><p><code>ACID</code>里的<code>AID</code>都是数据库的特征,也就是<strong>依赖数据库的具体实现</strong>。而唯独这个C，实际上它依赖于<strong>应用层</strong>，也就是依赖于开发者。做个比喻事务就好比一个保镖，我们提到事务就会说ACID，而我们提到保镖会说强壮、保护安全、好功夫、踏实。这里强壮、好功夫和踏实都是保镖自己的特征，而安全是属于你的，即你通过保镖的特征来保护你的安全。</p></blockquote><h4 id="破坏"><a href="#破坏" class="headerlink" title="破坏"></a>破坏</h4><ul><li><p>事务并行时，不同事务的操作交叉进行。（隔离性）</p><blockquote><p>交叉是指<strong>完整</strong>事务间，而<strong>不是</strong>在某个事务中进行切换。</p></blockquote></li><li><p>事务运行时被强行停止（持久性）</p></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li><p>开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br></pre></td></tr></table></figure></li><li><p>结束</p><ul><li><p>正常结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT</span><br></pre></td></tr></table></figure></li><li><p>非正常结束：撤销全部更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h2><ul><li>从<strong>错误</strong>状态恢复到某一已知<strong>正确</strong>状态</li><li>通过DBMS的<strong>恢复子系统</strong>完成</li></ul><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><ul><li>事务<ul><li>可预期：事务根据<strong>内部</strong>测试条件而触发的回滚</li><li>不可预期：不能由应用程序处理</li></ul></li><li><p>系统</p><ul><li><p>事务异常中断：数据库本身不会受到破坏。</p><blockquote><p>指数据不会丢失，而<strong>不是数据的正确性</strong>。</p></blockquote></li></ul></li><li><p>介质</p><ul><li>数据库本身受到破坏及正在使用这部分数据的相关事务</li></ul></li><li><p>病毒</p><ul><li>对数据进行非法修改</li></ul></li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><ul><li><p>基本原理：冗余</p></li><li><p>建立冗余</p><ul><li><p>数据转储（备份）</p><ul><li>静态：保证一致性，但是可用性低。</li><li>动态：不影响可用性，不能保证一致性。<ul><li>建立日志文件，在使用副本进行数据库恢复时，需要经过一遍日志处理。</li></ul></li><li>海量：每次转储全部数据库</li><li>增量：每次只转储上一次转储后更新的部分</li></ul></li><li><p>登录日志文件：记录事务对数据库的更新操作</p><ul><li>记录单位：事务驱动</li><li>数据块单位：数据驱动</li></ul><blockquote><ul><li>事务、系统故障必须使用日志文件</li><li>写入规则<ul><li>按照并发事务的时间顺序</li><li><strong>先写</strong>日志文件，<strong>再写</strong>数据库。</li></ul></li></ul></blockquote></li></ul></li></ul><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>事务：UNDO<ul><li><strong>反向</strong>扫描日志，对更新执行逆操作，直到事务开始标志。</li></ul></li><li>系统：UNDO+REDO<ul><li>未完成的事务已经修改了数据库，此时采取<strong>撤销</strong>操作。</li><li>已经提交的事务还留在缓冲区中，没有写入数据库，此时采取<strong>重做</strong>操作。<ul><li><strong>正向</strong>扫描日志，获得撤销队列和重做队列。</li><li>对队列中的事务分别执行<strong>撤销</strong>和<strong>重做</strong>操作</li></ul></li></ul></li><li>介质：REDO<ul><li>装入最新数据库的后备副本</li><li>装入日志文件副本，重做已完成的事务。</li></ul></li></ul><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><ul><li><p>缩小日志文件的检查范围</p></li><li><p>新增“重新开始”文件记录检查点在日志的位置</p></li><li><p>在日志文件增加检查点记录</p><ul><li><p>存储检查点时正在运行的事务清单</p></li><li><p>维护</p><ul><li><p>将<strong>日志缓存</strong>写入磁盘，同时增加一个检查点记录。</p></li><li><p>将<strong>数据缓存</strong>写入磁盘</p><blockquote><p>由此，检查点<strong>之前</strong>的提交的缓存事务<strong>不需要</strong>被加入正在执行的事务清单。</p></blockquote></li><li><p>将检查点记录的地址写入“重新开始”文件</p></li></ul></li><li><p>恢复</p><ul><li><p>从检查点开始进行日志扫描，从而对事务清单进行分类，得到撤销列表和重做列表。</p><blockquote><p>在正向扫描的过程中，可能会存在检查点之后才开始的事务。对于这些事务，一样需要把它们加入<strong>正在执行</strong>的事务清单。</p></blockquote></li><li><p>对两个列表中的事务采取不同操作</p></li></ul></li></ul></li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul><li>利用镜像来维护原始数据库</li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul><li>并发(Concurrency)：<strong>单</strong>处理器，<strong>逻辑</strong>并列。</li><li>并行(Parallel)：<strong>多</strong>处理器，<strong>物理</strong>并列。</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>主要：数据不一致</p><ul><li>丢失更新(Lost Update)：并发事务的结果出现了“不正常”覆盖</li><li>脏数据读出(Dirty Read)：数据处理未完成时被读出</li><li>不能重复读(Non-Repeatable Read)：数据在相邻读之间被更新，导致读操作无法复现。</li></ul><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li>合理调度并发事务，避免事务之间的互相干扰造成数据的不一致。</li></ul><h3 id="基本手段"><a href="#基本手段" class="headerlink" title="基本手段"></a>基本手段</h3><ul><li><p>封锁（上锁）</p></li><li><p>分类</p><ul><li><p>排它锁（<code>X</code>锁、独占锁）：<strong>只允许</strong>上锁事务<strong>读取和修改</strong>数据对象</p></li><li><p>共享锁（<code>S</code>锁）：上锁事务<strong>只能读</strong>数据对象，其他事务能够继续上<code>S</code>锁，但是不能上<code>X</code>锁。</p><blockquote><p>同一个数据对象可以有多个<code>S</code>锁，但是只能有一个<code>X</code>锁，并且两个锁不能同时出现。</p></blockquote></li></ul></li><li><p>相容矩阵</p><p><img src="https://i.loli.net/2020/11/20/VgGK16P2QrdtBqf.png" alt="image-20201120114606476" style="zoom:50%;" /></p></li><li><p>封锁协议：各级协议间是<strong>包含关系</strong>，<strong>不是并列</strong>。</p><ul><li><p>一级：事务在修改数据对象之前必须上<code>X</code>锁，等到<strong>事务结束</strong>后再释放锁。</p><blockquote><ul><li><p>事务结束$\neq$修改完成，因为可能是<strong>非正常结束(ROLLBACK)</strong>。</p></li><li><p>限制写，解决<strong>写间冲突</strong><code>Lost Update</code>；因为没有限制读操作，所以没有解决<strong>读写冲突</strong><code>Dirty Read</code>和<code>Non-Repeatable Read</code>.</p></li><li><p>Q：上了<code>X</code>锁不也限制了其他事务的读吗？</p><p>A：上<code>X</code>锁<strong>并不是不允许</strong>其他事务读，而是限制了其他事务上<code>S</code>锁。因此如果读之前不进行上锁操作，则不会受到<code>X</code>锁的限制，一样能够读到脏数据。</p></li></ul></blockquote></li><li><p>二级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>读完之后</strong>释放。</p><blockquote><p>解决了<code>Dirty Read</code>，但是由于<strong>上锁时间较短</strong>，所以依然可能出现<code>Non-Repeatable Read</code>.</p></blockquote></li><li><p>三级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>事务结束之后</strong>释放。</p><blockquote><p>解决了三种数据不一致问题</p></blockquote></li></ul></li><li><p>粒度：封锁对象的大小（被上锁的对象的大小）</p><ul><li><p>常见封锁对象：属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库、物理页、块等。</p></li><li><p>多粒度封锁：一个系统的封锁机制可以提供多种粒度</p><ul><li><p>多粒度树：根据数据对象及其之间的关系构造的树</p><ul><li><p>显式：锁<strong>直接</strong>加在事务需要的数据对象上 </p></li><li><p>隐式：锁加在事务需要的<strong>数据对象的上级结点</strong>上</p></li><li><p>上锁检查：显式锁和隐式锁都需要检查</p><ul><li>隐式锁需要检查<strong>所有</strong>的上级节点</li></ul><blockquote><p>包括<strong>下级结点的显式锁</strong>（下级结点的隐式锁在对当前结点的检查中就已经被判断了）</p></blockquote></li></ul></li></ul></li></ul></li><li><p>意向锁：表示<strong>下级节点</strong>被上了相应类型的锁（优化多粒度树上锁检查）</p><ul><li><p>在为对象上锁时，需要先对其<strong>所有</strong>上级节点添加意向锁。</p></li><li><p>在为对象解锁时，需要向上逐级为上级节点释放锁。</p><blockquote><p><strong>不能</strong>优化当前结点的<strong>隐式锁</strong>检查</p></blockquote></li><li><p>分类</p><ul><li><p>意向共享锁(<code>IS</code>, Intent Share Lock)</p></li><li><p>意向排它锁(<code>IX</code>, Intent Exclusive Lock)</p></li><li><p>意向共享排它锁(<code>SIX</code>, Share Intent Exclusive Lock)：对该对象加<code>S</code>锁后，再加<code>IX</code>锁。</p><blockquote><p><strong>不是</strong>下级对象的<code>IS</code>和<code>IX</code>的叠加</p></blockquote></li></ul></li><li><p>相容矩阵</p><p><img src="https://i.loli.net/2020/11/20/8KL7aMQVrhPAmRF.png" alt="image-20201120115143845" style="zoom:50%;" /></p><ul><li><p>上了<code>IS</code>后，可以上<code>IX</code>，反之亦然。</p><blockquote><p>意向锁来自不同的结点，所以<code>S</code>和<code>X</code>能够“同时出现”。</p></blockquote></li><li><p>可以多次上<code>IS</code>和<code>IX</code>锁</p></li><li><p>上了<code>IS</code>后，还可以上<code>S</code>和<code>IX</code>变成<code>SIX</code>；但是上了<code>IX</code>之后，<strong>不能</strong>再上<code>S</code>和<code>IX</code>变成<code>SIX</code>了。</p><blockquote><p>上了<code>IX</code>后<strong>不能</strong>再为下级结点隐式上<code>S</code>锁了</p></blockquote></li><li><p>上了<code>SIX</code>之后，还可以上<code>IS</code>，但是不能再上<code>IX</code>了。</p><blockquote><p>因为下级结点已经隐式上了<code>S</code>，不能再上<code>X</code>了。</p></blockquote></li></ul></li></ul></li></ul><h3 id="活锁和死锁"><a href="#活锁和死锁" class="headerlink" title="活锁和死锁"></a>活锁和死锁</h3><ul><li><p>活锁：系统正常运行，但是有些事务可能永远不能得到上锁机会。</p><ul><li>采用<code>FCFS</code>解决</li></ul></li><li><p>死锁</p><ul><li><p>预防</p><ul><li><p>一次封锁法：事务执行前为<strong>所有</strong>需要的资源上锁</p><ul><li>降低系统并发度</li></ul></li><li><p>顺序封锁法：为资源编号，事务执行时必须按照顺序对所需的资源上锁。</p><ul><li>实现难度大</li></ul><blockquote><p>不是按照顺序获取<strong>所有</strong>资源，而是在获取所需对象时按照顺序进行。</p></blockquote></li></ul></li><li><p>检测</p><ul><li>超时法：事务等待时间过长时认为发生死锁</li><li>等待图法：结点表示事务，边指向等待的事务，出现回路则发生死锁。</li></ul></li><li><p>恢复（解除）</p><ul><li><p>选择代价小的事务撤销</p><blockquote><p>撤销后，需要回滚该事务的所有操作</p></blockquote></li></ul></li></ul></li></ul><h3 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h3><ul><li><p>调度的单位是事务的<strong>操作</strong>，而<strong>不是</strong>事务本身。</p></li><li><p>事务执行正确性：保证数据库<strong>一致性</strong>的都是正确的执行结果</p><blockquote><p>不同执行顺序可能有不一样的执行结果（随机性），但可能都是正确的。</p></blockquote></li><li><p>可串行化：事务的并发执行正确$\Leftrightarrow$按照某一次序<strong>串行执行</strong>的结果和<strong>并发执行</strong>结果相同</p><ul><li>可串行化的并发调度是正确调度</li></ul></li><li><p>判定</p><ul><li><p><strong>冲突可串行化</strong>调度：调度$Sc$交换<strong>事务间不冲突</strong>操作的次序后，得到<strong>串行调度</strong>$Sc’$.</p><ul><li>不能交换<strong>事务间</strong>的冲突操作</li><li>不能交换<strong>一个事务内</strong>的操作</li></ul></li><li><p>冲突操作：读-写、写-写</p></li><li><p>充分条件：冲突可串行化调度$\Rightarrow$可串行化调度</p><blockquote><p>冲突可串行化调度$\Rightarrow$可串行化调度$\Rightarrow$正确调度</p></blockquote></li></ul></li><li><p>两段锁协议：保证并发调度可串行</p><ul><li>扩展阶段：读写操作执行前需要上锁</li><li>收缩阶段：开始释放锁之后，事务不再获取其他任何锁。</li></ul><blockquote><p>依然可能发生死锁</p></blockquote></li></ul><h2 id="Reference-7"><a href="#Reference-7" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li><a href="https://www.zhihu.com/question/31346392" target="_blank" rel="noopener">https://www.zhihu.com/question/31346392</a></li></ul><h1 id="Chapter8-数据库保护"><a href="#Chapter8-数据库保护" class="headerlink" title="Chapter8 数据库保护"></a>Chapter8 数据库保护</h1><p>全文共<code>732</code>字，推荐阅读时间<code>7~10</code>分钟。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul><li>安全性(<code>security</code>)：防止不合法的使用造成的<strong>数据泄露</strong>、<strong>更改</strong>、<strong>破坏</strong>。</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul><li><p>用户标识和认证（最外层）</p><ul><li>常用：用户名和密码（口令）</li></ul></li><li><p>存取控制</p><ul><li><p>权限定义</p></li><li><p>权限检查</p></li><li><p>方法</p><ul><li><p>自主(<code>DAC</code>)：用户可以将权限转授</p><ul><li><p>权限=数据对象+操作类型</p></li><li><p>SQL</p><ul><li>用户级：操作数据库，例如创建外模式、创建会话、创建表等。</li><li>关系级：操作某个关系和视图，针对具体的对象，例如在某个表中进行CRUD操作。</li></ul></li><li><p>角色：一组权限的集合，可以授给<strong>用户或其他角色</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT CREATE SESSION to xxx; # 用户级</span><br><span class="line">GRANT CREATE TABLE to xxx; # 用户级</span><br><span class="line">REVOKE CREATE TABLE FROM xxx; # 用户级</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>强制(<code>MAC</code>)：不同数据对象有不同的加密等价，每个用户的许可证级别决定了能够访问哪些数据，由系统<strong>直接指定</strong>级别。</p><ul><li>实体=主体+客体</li><li>主体：实际用户</li><li>客体：系统中的被动实体，包括文件、基本表、索引、视图等。</li><li>许可证级别(<code>Label</code>，敏感度标记)<ul><li>主体<strong>大于等于</strong>客体：读</li><li>主体<strong>等于</strong>客体：写</li></ul></li></ul></li></ul></li><li><p>操作系统/网络安全保护</p></li><li><p>数据加密</p></li><li><p>其他</p><ul><li>视图：不同用户有不同的视图</li><li>审计：将用户对数据库的操作记录在审计日志中，出现安全问题时进行审查。</li></ul></li></ul><h3 id="可信系统评测"><a href="#可信系统评测" class="headerlink" title="可信系统评测"></a>可信系统评测</h3><ul><li>TCSEC</li><li>TDI</li></ul><h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul><li>完整性=正确性+相容性<ul><li>正确性：类型、取值范围</li><li>相容性：同一个事实的值应该相同</li></ul></li><li>确保数据库语义正确</li></ul><h3 id="约束条件-1"><a href="#约束条件-1" class="headerlink" title="约束条件"></a>约束条件</h3><ul><li>作用对象<ul><li>列：对属性进行约束</li><li>元组：元组间的<strong>字段</strong>约束（属性间约束）</li><li>关系：元组之间、关系之间的约束，例如实体完整性、参照完整性。</li></ul></li><li>时机<ul><li>静态：数据库在每一确定状态应该满足的约束</li><li>动态：新、旧值之间的约束，例如年龄只能上升不能下降。</li></ul></li></ul><blockquote><p>总共可以组合出3*2=6种约束条件</p></blockquote><h3 id="控制-1"><a href="#控制-1" class="headerlink" title="控制"></a>控制</h3><ul><li><p>定义</p></li><li><p>检查</p><ul><li>立即执行：<strong>语句</strong>执行完后立即检查</li><li>延迟执行：<strong>事务</strong>执行完毕后再进行检查</li></ul></li><li><p>违约相应</p></li><li><p>规则：$(D,O,A,C,P)$</p><ul><li><code>D</code>：数据本身</li><li><code>O</code>：操作</li><li><code>A</code>：断言</li><li><p><code>C</code>：<code>A</code>指定的谓词（自然语言约束的主语）</p></li><li><p><code>P</code>：违反规则时触发的过程</p></li></ul></li><li><p>SQL</p><ul><li><p><code>CREATE TABLE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NULL</span><br><span class="line">NOT NULL</span><br><span class="line">UNIQUE</span><br><span class="line">PRIMARY KEY</span><br><span class="line">FOREIGN KEY</span><br><span class="line">CHECK</span><br></pre></td></tr></table></figure></li><li><p><code>CREATE ASSERTION</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSERTION ASSE_NAME</span><br><span class="line">CHECK (60 &gt;&#x3D; ALL(SELECT COUNT(*) FROM SD GROUP BY C));</span><br></pre></td></tr></table></figure></li><li><p><code>CREATE TRIGGER</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Reference-8"><a href="#Reference-8" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li></ul><h1 id="Chapter9-数据库新技术"><a href="#Chapter9-数据库新技术" class="headerlink" title="Chapter9-数据库新技术"></a>Chapter9-数据库新技术</h1><p>全文共<code>2031</code>字，推荐阅读时间<code>10~15</code>分钟。</p><h2 id="数据仓库-Data-Warehouse"><a href="#数据仓库-Data-Warehouse" class="headerlink" title="数据仓库(Data Warehouse)"></a>数据仓库(<code>Data Warehouse</code>)</h2><ul><li><p>支持管理决策过程</p><blockquote><p>不同于数据库提供的<strong>日常业务查询</strong>服务</p></blockquote></li><li><p>面向主题</p><ul><li>从大量的历史数据中提取</li></ul></li><li><p>持久数据集合</p></li><li><p>业务</p><ul><li>OLAP：数据<strong>仓库</strong>联机<strong>分析</strong>处理</li><li>OLTP：数据<strong>库</strong>联机<strong>事务</strong>处理</li></ul></li><li><p>数据仓库系统</p><ul><li><p>数据源</p><ul><li>数据库</li><li>数据文件</li></ul></li><li><p>数据仓库管理工具</p><ul><li><p>数据建模工具：根据主题确定，例如学生就业情况。</p></li><li><p>抽取、转换、装载(<code>ETL</code>)</p></li><li><p>元数据库：描述数据的数据</p><blockquote><p>类似数据库中的数据字典</p></blockquote></li></ul></li><li><p>数据仓库</p><ul><li>高度综合数据：准决策数据</li><li>轻度综合数据：来自近期基本数据</li><li>当前数据：最近时期业务数据</li><li>历史数据：早期基本数据</li></ul></li><li><p>分析工具</p><ul><li>用户查询工具</li><li>OLAP工具</li><li>DM工具</li></ul></li><li><p>比较</p><ul><li><p>数据库</p><p><img src="https://pic4.zhimg.com/80/v2-bdc235fbdd1825c1b67ef7d609f81adb_1440w.jpg?source=1940ef5c" alt="img" style="zoom: 33%;" /></p><ul><li>一种事务处理技术</li><li>表格结构复杂，存储结构紧致，冗余数据少。</li><li>读写均进行优化</li><li>查询要求较简单，单次作用的数据量小。</li><li>常见：MySQL, Oracle, SqlServer.</li></ul></li><li><p>数据仓库</p><p><img src="https://pic4.zhimg.com/80/v2-ccefb7a678de237560cc4df80c11cca3_1440w.jpg?source=1940ef5c" alt="img" style="zoom:33%;" /></p><ul><li>一种体系结构</li><li>表格结构简单，存储结构松散，冗余数据多。</li><li>通常只优化读</li><li>查询要求较复杂，单次作用的数据量大。</li><li>常见：AWS Redshift, Hive.</li></ul><blockquote><ul><li>数据仓库是为某种特定的查询而设置的，是对数据库中多张表的整合，因此可以承担相应的分析工作。</li><li>数据仓库来自于“分析型数据库”，但也因此不满足数据库的一些规范，所以被改叫“数据仓库”。</li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="分布式数据库系统"><a href="#分布式数据库系统" class="headerlink" title="分布式数据库系统"></a>分布式数据库系统</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><p>基础：网络+数据库</p></li><li><p>结构</p><ul><li>全局应用=局部应用+网络，操作<strong>两个及以上</strong>节点中的数据库。</li><li>局部应用=数据库+服务器，操作<strong>一个</strong>节点中的数据库。</li></ul><blockquote><p>结构必须完整，缺一不可。</p></blockquote></li><li><p>前提：数据分布存储</p><ul><li>场地自治性</li><li>场地协作性</li></ul></li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>数据独立性<ul><li>逻辑</li><li>物理</li><li><strong>分布</strong>（分布透明性）：数据的存储特征（分片、位置等）和用户/应用程序无关</li></ul></li><li>控制结构：集中和自治相结合<ul><li>共享<ul><li>局部</li><li>全局</li></ul></li></ul></li><li>适当增加数据冗余：在不同节点存储同一数据的多个副本<ul><li>提高系统可靠性、可用性</li><li>提高系统性能</li><li>不利于更新，增大了系统维护代价。</li></ul></li><li>全局一致性、可串行性、可恢复性</li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">全局外模式--&gt;|映象1|全局概念模式</span><br><span class="line">全局概念模式--&gt;|映象2|分片模式</span><br><span class="line">分片模式--&gt;|映象3|分布模式</span><br><span class="line">分布模式--&gt;|映象4|局部概念模式</span><br></pre></td></tr></table></figure><ul><li>全局概念模式定义了数据库的整体逻辑结构</li><li>分片模式定义了数据库关系的全局关系的分片方式</li><li>分布模式定义了各片段的存储位置，进而决定了数据库是否冗余。</li><li>各级映像中存储了上级模式到下级模式的映射关系</li></ul><blockquote><p>映象的作用类似虚拟地址和物理地址的转换。例如，映象1为外模式在概念模式中选取合适的部分进行构造；映象2的作用就是为每个关系指定合适的分片方式；映象3则是为每个分片方式确定合适的存储位置（虚拟，类似数据库1、2、3…）；映象4将分布模式中的虚拟存储位置映射到现实中的物理存储位置。</p><p>综上，模式是<strong>“原则/方法/定义”</strong>的集合，映象是集合间的映射关系，通常是在下级映象中进行选择，然后返回结果由上级映象使用。</p></blockquote><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul><li><p>水平：关系模式不变，将元组进行分割。</p></li><li><p>垂直：对属性集合进行划分</p><blockquote><p>为了具有可复原性，<strong>通常</strong>让各个片段都具有原关系的码。（不是必要条件）</p></blockquote></li><li><p>导出：利用其他关系模式的属性对某一关系进行水平分片。</p><blockquote><p>连表后选择，然后再去掉多余属性。</p></blockquote></li><li><p>混合</p></li></ul><h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5><ul><li>完全性：各个片段的并需要涵盖全局关系的所有信息</li><li>不相交性</li><li>可重构性：片段可以重构全局关系<ul><li>水平：并</li><li>垂直：自然连接</li></ul></li></ul><h4 id="分布透明性"><a href="#分布透明性" class="headerlink" title="分布透明性"></a>分布透明性</h4><ul><li><strong>分片</strong>透明性（分片模式）</li><li><strong>位置</strong>透明性（分布模式）</li><li>局部数据模型透明性（局部概念模式）：用户/应用程序不关心节点的DBMS类型（使用统一的查询语言）</li></ul><h4 id="DDBMS"><a href="#DDBMS" class="headerlink" title="DDBMS"></a>DDBMS</h4><ul><li>LDBMS：场地自治，执行局部应用及全局查询的<strong>子查询</strong></li><li>GDBMS：提供分布透明性，保证数据库的全局一致性。<ul><li>协调全局事务的执行</li><li>协调局部DBMS</li><li>并发控制</li><li>更新同步</li><li>全局恢复</li></ul></li><li>GDD<ul><li>全局概念模式、分片模式、分布模式、各级映象</li><li>用户权限定义</li><li>完整性约束条件</li></ul></li><li>CM：通信管理</li></ul><h5 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5><ul><li>全局控制<strong>集中</strong>：GDD和GDBMS集成在一起<ul><li>控制简单</li><li>易形成<strong>性能</strong>瓶颈</li><li>可靠性低</li></ul></li><li>全局控制<strong>分散</strong><ul><li>完全：GDBMS和GDD分布在<strong>每个</strong>节点上<ul><li>节点独立</li><li>自治性强</li><li>控制复杂</li></ul></li><li>部分：GDBMS和GDD分布在<strong>某些</strong>节点上</li></ul></li><li>同构型：各个节点的DBMS相同</li><li>异构型：各个节点的DBMS不同</li></ul><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><h5 id="分类-5"><a href="#分类-5" class="headerlink" title="分类"></a>分类</h5><ul><li>局部</li><li>远程</li><li>全局</li></ul><blockquote><p>局部和远程查询<strong>只</strong>涉及<strong>单个</strong>节点，全局查询涉及<strong>多个</strong>节点。</p></blockquote><h5 id="处理-1"><a href="#处理-1" class="headerlink" title="处理"></a>处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">查询分解--&gt;确定操作次序</span><br><span class="line">确定操作次序--&gt;选择操作执行方法</span><br></pre></td></tr></table></figure><h5 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h5><p>查询开销=I/O代价+CPU代价+通信代价（主要）</p><ul><li><p>分类</p><ul><li><p>分布优化（<strong>更重要</strong>）</p><ul><li><p>传送时间T=总传输延迟（由网络本身决定）+总数据量/传输速度</p><blockquote><p>问答方式中通常会<strong>忽略</strong>传送时间而<strong>只考虑</strong>传输延迟</p></blockquote></li></ul></li><li><p>局部优化</p></li></ul></li><li><p>目标：减小通信代价</p><blockquote><p>通信代价通常来自于不同节点间的<strong>连接和并</strong>操作</p></blockquote></li><li><p>技术</p><ul><li><p>半连接：在连接之前，先对其中某个关系进行所需属性的投影，然后再进行连接。</p><p>$R_3=R_1{\ltimes}_{A=B} R_2=R_1{\bowtie}_{A=B}(\Pi_B(R_2))$</p><ul><li><p>得到的结果是<strong>没有投影</strong>的关系$R_1$的子集</p><blockquote><p>从$R_1$中提取出了<strong>有用</strong>的元组</p></blockquote></li><li><p>$R_1\bowtie R_2=(R_1\ltimes R_2)\bowtie R_2$</p><blockquote><p>连接=半连接+连接=投影+连接+连接</p></blockquote></li><li><p>在使用优化技术之前，需要进行估算。</p></li></ul></li></ul></li><li><p>分布事务处理</p><ul><li><p><code>NewSQL</code></p></li><li><p>原子性：全局事务的子事务要么一起提交，要么全部回滚。</p></li><li><p>可串行性：多用户系统</p></li><li><p>恢复：两段提交协议</p><ul><li>局部事务管理<ul><li>协调者（一个）</li><li>参与者（多个）</li></ul></li><li>第一阶段：协调者征求意见做决定</li><li>第二阶段：参与者执行决定</li></ul></li><li><p>并发控制：封锁技术</p><ul><li><p>写操作需要申请<strong>所有</strong>副本的<code>X</code>锁，读操作<strong>只要</strong>申请一个副本的<code>S</code>锁。</p></li><li><p>读/写操作均对<strong>大多数</strong>副本申请<code>X</code>和<code>S</code>锁</p><blockquote><p>大多数指“<strong>大于</strong>一半”，所以上锁时一定会出现相交情况。</p></blockquote></li><li><p>设置主副本，所有读/写都需要对主副本上锁。</p></li><li><p>全局死锁解决（<strong>两个及以上</strong>场地发生死锁）</p><ul><li>检测及解除</li><li>预防</li></ul></li></ul></li></ul></li></ul><h2 id="Reference-9"><a href="#Reference-9" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Database Theory Lecture, Autumn of 2020.</li><li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2020 BUAA Database course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Backend" scheme="http://yoursite.com/categories/Backend/"/>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ Learning Note</title>
    <link href="http://yoursite.com/2021/06/23/C++%20Learning%20Note/"/>
    <id>http://yoursite.com/2021/06/23/C++%20Learning%20Note/</id>
    <published>2021-06-23T12:34:24.552Z</published>
    <updated>2021-06-23T12:37:25.756Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全文共<code>2981</code>字，为暑期C++学习记录，推荐按照顺序阅读。</strong></p><a id="more"></a><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li><p>每个<code>.h</code>文件智能定义一个<code>class</code></p></li><li><p>函数主体放在<code>.cpp</code>中</p></li><li><p><code>.h</code>文件需要使用标准头文件格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NAME_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NAME_H_</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul><li>变量是对象自己的</li><li>函数是类的<ul><li>隐藏了<code>this</code>参数将对象传进类的函数</li></ul></li><li>私有变量通过<code>::</code>也<strong>不能</strong>访问</li></ul><h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><p>创建对象时使用</p></li><li><p>和类同名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    A(); <span class="comment">// no return type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A()</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>没有参数</strong>的构造函数<strong>都叫</strong><code>default constructor</code>，不一定是编译器默认创造的。</p></blockquote></li><li><p>参数化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree::Tree(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">t</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass c1;<span class="comment">//表示使用不带参数的构造函数，或者有默认参数值的构造函数。</span></span><br><span class="line"><span class="function">MyClass <span class="title">c2</span><span class="params">()</span></span>;<span class="comment">//不会调用无参构造函数,各种情况下该处是声明一个返回值为MyClass类型的函数而已</span></span><br><span class="line"><span class="function">MyClass <span class="title">c3</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//调用参数为int的构造函数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li><p>销毁对象时使用</p><blockquote><p>对象的生存周期是<strong>大括号</strong></p></blockquote></li><li><p>无参数，在构造函数前加一个<code>~</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> height; <span class="comment">// default to be private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree(<span class="keyword">int</span> initialHeight);</span><br><span class="line">    ~Tree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> years)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new&amp;delete"></a>new&amp;delete</h2><ul><li><p>delete不能操作没有new的空间</p></li><li><p>delete对同一个对象不能连续使用两次</p></li><li><p>delete[]和new[]需要<strong>成对</strong>使用</p></li><li><p>在delete之前最好判断一下是否是空指针（是空指针<strong>大多数情况</strong>也安全）</p></li><li><p>new创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------对于new关键字加括号和不加括号的区别---</span></span><br><span class="line"><span class="comment">1.对于自定义类型来说没有区别，都是使用默认构造函数</span></span><br><span class="line"><span class="comment">2.对于内置类型来说加括号会初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">MyClass *c4 = <span class="keyword">new</span> MyClass();</span><br><span class="line">c4-&gt;MyMethod();</span><br><span class="line">MyClass *c5 = <span class="keyword">new</span> MyClass(<span class="number">1</span>);</span><br><span class="line">c5-&gt;MyMethod();</span><br><span class="line">MyClass *c6 = <span class="keyword">new</span> MyClass;</span><br><span class="line">c6-&gt;MyMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *pint1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> *pint2 = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// *pint2 is 0</span></span><br><span class="line"><span class="keyword">int</span> *pint3 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// *pint3 is a random number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*pint1&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint2&lt;&lt;<span class="string">" "</span>&lt;&lt;*pint3&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><code>new</code>创建对象需要<strong>指针</strong>接收</li><li><code>new</code>创建对象需要<code>delete</code>销毁</li><li><code>new</code>创建的对象在<strong>堆</strong>上，不使用<code>new</code>创建的对象在<strong>栈</strong>上。</li></ul></li></ul><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul><li><p><code>private</code>的变量在类的函数中可以被<strong>其他的对象</strong>访问，即同类对象可以相互访问私有变量。</p><blockquote><p><code>private</code>只在编译时有限制</p></blockquote></li><li><p>使用<code>friend</code>授权某些函数访问<strong>私有变量</strong></p></li><li><p>class的访问属性默认为<code>private</code>，struct默认为<code>public</code>.</p></li></ul><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> x, y;</span><br><span class="line">    Point(<span class="keyword">float</span> xa = <span class="number">0.0</span>, <span class="keyword">float</span> ya = <span class="number">0.0</span>): x(xa), y(ya)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>初始化列表在构造函数<strong>之前</strong>执行</p></li><li><p>和构造器赋值的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(String s): name(s)&#123;&#125;</span><br><span class="line">Student::Student(String s) &#123;name = s;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>推荐使用初始化列表进行对象的初始化。</p><p>在构造器赋值时，如果有一个成员变量是自定义类的对象，并且该类没有无参数构造函数，那么在构造函数中对该对象赋值时就会报错。（因为在<strong>构造函数</strong>中，会默认调用无参数构造函数）</p></blockquote></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>名称隐藏：当子类覆写父类函数时，所有的父类函数都会被子类屏蔽。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> ii) : i(ii) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : A(<span class="number">15</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.print(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>b</code><strong>没有</strong>无参数的<code>print</code>方法</p></blockquote></li></ul><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><ul><li><p>只能在<code>.h</code>（函数声明）时设置默认值，<strong>不可以</strong>在函数定义处使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j=<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>和Python不同的是，修改<code>j</code>时直接传数据即可，<strong>不需要</strong>写参数名称。</p></li><li><p>尽量<strong>不使用</strong>默认参数值</p></li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li><p>在调用的地方直接展开，减少调用函数时的栈操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b = f(a); <span class="comment">// int b = a * 2;</span></span><br><span class="line">    <span class="keyword">int</span> c = f(<span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内联函数的定义<strong>不在</strong><code>.cpp</code>文件中，而应该和声明<strong>都放在</strong><code>.h</code>中</p><blockquote><p>因为<code>inline</code>告诉编译器这是个<strong>函数声明</strong>而不是定义，在<strong>使用函数</strong>的地方再进行展开。</p></blockquote></li><li><p>当<code>inline</code>函数太大时（例如递归），编译器可能会拒绝展开。</p></li><li><p>类的<code>.h</code>文件中直接写出函数体的函数<strong>都是</strong>内联函数，在<code>.h</code>中也可以单独声明内联函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is a inline function defined in header file."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环体中的<strong>小函数</strong>推荐使用内联函数</p></li><li><p>和宏相比，内联函数可以做类型检查，更加安全。</p></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li><p><strong>不可修改</strong>机制是在编译时确定的，因此是编译器进行检查。</p><ul><li><p>编译时确定的值可以用来声明数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_size = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> finalGrade[class_size];</span><br></pre></td></tr></table></figure></li><li><p><code>const</code>在<code>*</code>前后对指针的影响</p><ul><li><p>在<code>*</code>前：<strong>对象</strong>是<code>const</code>（<strong>不能</strong>通过该指针改变对象，但是<strong>可以</strong>通过其他指针）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;a;</span><br><span class="line">*p2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person *p = &amp;p1;</span><br><span class="line">Person <span class="keyword">const</span> *p = &amp;p1;</span><br></pre></td></tr></table></figure></li><li><p>在<code>*</code>后：<strong>指针</strong>是<code>const</code>（<strong>不能</strong>改变该指针的指向）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *<span class="keyword">const</span> p = &amp;p1;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>普通指针<strong>不能</strong>指向<code>const</code>变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">3</span>;</span><br><span class="line">ip = &amp;ci; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>不可</strong>修改对象的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::get_day</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    day++; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在声明和定义处要重复<code>const</code></p></li><li><p>便于编译器对<code>const</code>对象调用方法时进行安全检查</p></li><li><p>本质是将<code>this</code>设置为<code>const</code></p></li><li><p><code>const</code>可以实现重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : i(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    ~A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"f() with const"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> A a;</span><br><span class="line">    a.f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>const</code>对象<strong>只能</strong>调用<code>const</code>函数</li></ul></li></ul></li><li><p><code>const</code>成员变量必须在<strong>初始化列表</strong>中初始化（<strong>不可以</strong>在构造函数中进行）</p></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p>一种访问对象的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;p = c;</span><br></pre></td></tr></table></figure><ul><li>引用<strong>必须</strong>初始化（成员变量、函数参数除外）</li><li>引用相当于是<strong>别名</strong></li><li>引用的目的就是为了减少代码中的<code>*</code></li></ul></li><li><p>引用和指针的比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">(<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>不同于</strong>指针，引用在执行过程中<strong>不能</strong>改变对象。</p></li><li><p>引用<strong>不能</strong>是<code>NULL</code></p></li><li><p>传入的<code>x</code>在两种情况中<strong>都会</strong>被修改</p></li><li><p>传入函数的参数<strong>不是指针</strong>时，也<strong>可能</strong>被修改。</p></li><li><p>引用是由<code>const</code>指针实现的</p></li><li><p>引用的引用实际上<strong>不存在</strong>，只是改变了引用的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> &amp;a = x;</span><br><span class="line"><span class="keyword">int</span> &amp;b = y; </span><br><span class="line"></span><br><span class="line">b = a; <span class="comment">// y = x, but not b refer to a.</span></span><br></pre></td></tr></table></figure><blockquote><p>Java的引用实际上对应C++的指针</p></blockquote></li><li><p>引用的指针可以存在，但是指针的引用不存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;*p1; <span class="comment">// illegal</span></span><br><span class="line"><span class="keyword">int</span> *&amp;p2; <span class="comment">// reference to pointer</span></span><br></pre></td></tr></table></figure><blockquote><p>引用<strong>没有</strong>地址</p></blockquote></li><li><p><strong>没有</strong>引用数组（因为引用并不是实体，<strong>没有</strong>地址）</p></li></ul></li><li><p>引用作为成员变量时，需要在初始化列表中写上这个引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> &amp;b): a(b) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为返回值时，最好<strong>不是</strong>局部变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> &amp;<span class="title">subscript</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为函数参数传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">int</span>&amp;z)</span></span>&#123;</span><br><span class="line">    z *= <span class="number">5</span>; <span class="comment">// OK</span></span><br><span class="line">    y += <span class="number">8</span>; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>传<strong>非</strong><code>const</code>引用时<strong>不可以</strong>是算式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(i * <span class="number">3</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li><p>动态调用的方法需要使用<code>virtual</code>关键字声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在父类中声明一次<code>virtual</code>后，所有子类中的函数都是虚函数，可以省略<code>virtual</code>，但是推荐加上。</li><li>所有含虚函数的类的对象都会增加一个<code>vptr</code>指针，指向类自己的<code>vtable</code>，存储了<strong>该类</strong>所有的虚函数。</li></ul></li><li><p>继承关系对象的赋值<strong>不改变</strong><code>vtable</code>（与指针赋值不同）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a = b;</span><br><span class="line">a.f(); <span class="comment">// A's f() instead of B's</span></span><br></pre></td></tr></table></figure></li><li><p>析构函数需要是<code>virtual</code>的</p></li><li>多态需要使用指针实现，<strong>不能</strong>通过<code>.</code>实现。</li></ul><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><ul><li><p>编译器默认的拷贝构造是浅拷贝</p><ul><li><p>当字符串是<code>char *</code>时，内存会被<code>delete</code>两次，这样会发生错误。因此Cpp通常使用<code>string</code>类来定义字符串。</p><blockquote><p>尽管是浅拷贝，标准库中的类<strong>也不会</strong>出现内存问题。</p></blockquote></li></ul></li><li><p>拷贝构造和<strong>初始化</strong>的形式相同，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = p;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>一个类必须声明的三个函数</p><ul><li><p>默认构造函数（参数列表为空）</p></li><li><p><code>virtual</code>的析构函数</p></li><li><p>自定义的拷贝构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(<span class="keyword">const</span> ClassName &amp;p) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>Cpp保证对象只被构造一次</li><li><code>static</code>让对象变成全局的</li></ul><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><ul><li><p>通过<code>static</code>成为和对象<strong>无关</strong>的变量</p></li><li><p>类中只是<strong>声明</strong>，需要单独定义后才能使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;i = <span class="number">0</span>;&#125; <span class="comment">// A():i(0) &#123;&#125; is illegal</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::i; <span class="comment">// not static int A::i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a, b;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">    b.print();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化列表只能对<strong>非静态</strong>成员变量使用</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>调用<ul><li>对象：<code>a.f()</code></li><li>类：<code>A::f()</code></li></ul></li><li>在静态函数中<strong>没有</strong><code>this</code>参数</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>在Cpp中，几乎所有的运算符都可以被重载，除了<code>./.*/::/?:</code>.</li><li>重载只能在类/枚举类发生</li><li>优先级、运算格式<strong>不能</strong>改变。</li><li><p>关键字<code>operator</code>+运算符表示重载函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> *(...);</span><br><span class="line"><span class="keyword">const</span> String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String &amp;that);</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp;n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(i + n.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z = x + y; <span class="comment">// OK</span></span><br><span class="line">z = x + <span class="number">3</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + <span class="number">7</span>; <span class="comment">// OK</span></span><br><span class="line">z = <span class="number">3</span> + y; <span class="comment">// Error!</span></span><br><span class="line">z = x + <span class="number">3.5</span> <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li><p>设置全局函数解决<code>z=3+y</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+ (<span class="keyword">const</span> Integer &amp;l, <span class="keyword">const</span> Integer &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer(l.i + r.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一元运算符<strong>不需要</strong>设置参数，应该是成员的。</li><li><code>=/()/[]/-&gt;/-&gt;*</code><strong>必须是</strong>成员的</li><li>其他二元运算符<strong>最好是</strong>全局的</li></ul></li></ul></li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><p><code>+-*/%^&amp;|~</code>:<code>const T operatorX(const T &amp;l, const T&amp;r) const;</code></p></li><li><p><code>!/&amp;&amp;/||/&lt;/&lt;=/==/&gt;=/&gt;</code>:<code>bool operatorX(const T &amp;l, const T &amp;r) const;</code></p></li><li><p><code>[]</code>:<code>T &amp;T::operator[](int index);</code></p></li><li><p><code>++/--</code>：参数填一个占位<code>int</code>表示<strong>后置</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Integer &amp;<span class="keyword">operator</span>++() <span class="comment">// ++a</span></span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>++(<span class="keyword">int</span>) <span class="comment">// a++</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName a = b; <span class="comment">// copy construct</span></span><br><span class="line">a = b; <span class="comment">// assign</span></span><br></pre></td></tr></table></figure><ul><li><p>标准写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T &amp;T::<span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;r) &#123;</span><br><span class="line">        <span class="comment">// assign</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自己和自己相等进行赋值时，若成员中有指针，可能出现指针被改变后导致原来的内容无法访问，从而赋值失败的问题。</li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>禁止<strong>隐式</strong>类型转换：<code>explicit</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Two</span><span class="params">(class One &amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">one = two <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><ul><li>定义在<code>Two</code>中</li></ul></li><li><p>强制类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassName::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>定义在<code>One</code>中（不是<code>double</code>）</li><li><strong>没有</strong>返回类型</li></ul><blockquote><ul><li>两者地位相同，有哪种用哪种。</li><li>两种类型转换<strong>只能</strong>存在一种，除非第一种加了<code>explicit</code>.</li></ul></blockquote></li><li><p>不推荐使用默认转换，应该写成显式的转换方法<code>toXXX()</code>.</p></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>重用代码的一种方式，类似于Java中的泛型编程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // &lt;class Key, class Value&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">foo</span>(<span class="title">void</span>) &#123;</span><span class="comment">/* ... */</span>&#125;</span><br><span class="line">foo&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// type for T is int</span></span><br><span class="line">foo&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure></li><li><p>指定其他参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">bounds</span> = 100&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>继承</p><ul><li><p>模板之间不能继承，只能用来指定父类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> List&lt;A&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125; <span class="keyword">catch</span> (VectorIndexError &amp;e) &#123;</span><br><span class="line">    <span class="comment">// throw;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>不带对象的<code>throw</code>就是抛出<strong>原异常</strong></p></li><li><p><code>catch(...)</code>捕捉<strong>所有的</strong>异常，但是没有办法确定具体是哪一种。</p></li><li><p>函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a)</span> : <span class="title">throw</span><span class="params">(MathErr)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数抛异常之前，使用<code>delete this;</code>防止出现内存垃圾。</p></li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li><p>自定义类的输入流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>&gt;&gt;(istream &amp;is, T &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// construct obj</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul><li>包含常见的数据结构和算法<ul><li><code>Vector</code></li><li><code>List</code></li><li><code>Deque</code></li><li><code>Sets &amp; Maps</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;全文共&lt;code&gt;2981&lt;/code&gt;字，为暑期C++学习记录，推荐按照顺序阅读。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm Course Note</title>
    <link href="http://yoursite.com/2021/06/23/Algorithm%20Course%20Note/"/>
    <id>http://yoursite.com/2021/06/23/Algorithm%20Course%20Note/</id>
    <published>2021-06-23T12:31:27.612Z</published>
    <updated>2021-06-23T12:59:58.109Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Learning note of 2020 BUAA Algorithm course.</strong></p><a id="more"></a><h1 id="Chapter0-Introduction"><a href="#Chapter0-Introduction" class="headerlink" title="Chapter0 Introduction"></a>Chapter0 Introduction</h1><p>Total Count: <code>161</code> words</p><p>Preferred Reading Time: <code>3~5</code> minutes</p><h2 id="Syllabus"><a href="#Syllabus" class="headerlink" title="Syllabus"></a>Syllabus</h2><ul><li>Basics</li><li>Divide and Conquer</li><li>DP</li><li>Greedy</li><li>Graph</li><li>Hard Problems</li></ul><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ul><li>Design</li><li>Analyze</li></ul><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><ul><li>Computational Problem</li><li>Instance</li><li>Algorithm</li></ul><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><ul><li>Memory</li><li>Running time(focus of course)<ul><li>computer</li><li>implementation details</li><li>input(size etc.)</li></ul></li></ul><h3 id="Machine-independent-running-time"><a href="#Machine-independent-running-time" class="headerlink" title="Machine-independent running time"></a>Machine-independent running time</h3><ul><li>depend on quantity of <strong>primitive operations</strong><ul><li>addition</li><li>multiplication</li><li>comparison</li></ul></li><li>$T(n)$:denote the running time of n-size input<ul><li>n<ul><li>sorting: items to be sorted</li><li>graph: vertices and edges</li></ul></li></ul></li><li>Best Case: an instance for given size <code>n</code> results in the most efficient situation<ul><li>eg. A sorted list for insertion sort</li></ul></li><li>Worst Case<strong>(Mostly Used)</strong>: opposite to Best Case<ul><li>eg. A rev-sorted list for insertion sort</li></ul></li><li>Average Case: based on probability of all situations </li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li><p>$Θ(n)$ notation</p><ul><li><p>a supplement of <code>T(n)</code> notation</p><blockquote><p>$T(n)$ is exact while $Θ(n)$ is approximate</p></blockquote></li><li><p>eg. Mergesort</p><p>$T(n) = 2T(n/2) + Θ(n)\ (n&gt;1)$</p><p>$T(n)=Θ(1)\ (n=1)$</p><blockquote><p>Recursive notation</p></blockquote></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter1-Asymptotic-Notations-And-Recurrence"><a href="#Chapter1-Asymptotic-Notations-And-Recurrence" class="headerlink" title="Chapter1 Asymptotic Notations And Recurrence"></a>Chapter1 Asymptotic Notations And Recurrence</h1><p>Total Count: <code>291</code> words</p><p>Preferred Reading Time: <code>5~10</code> minutes</p><h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><h3 id="Big-Oh"><a href="#Big-Oh" class="headerlink" title="Big-Oh"></a>Big-Oh</h3><ul><li><p><strong>Upper</strong> bounds</p></li><li><p>$f(n)=O(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\leq{c*g(n)}\ (c&gt;0, n&gt;n0)$</p></li><li><p>Example</p><ul><li>$sin(n)=O(1)$</li><li>$log(n!)=O(nlog(n))$</li><li>$\sum{1/n}=O(log(n))$</li></ul></li><li><p>$log_{b_1}(n)=O(log_{b_2}(n))$</p><blockquote><p>Bases in <code>O</code> notation are usually omitted.</p></blockquote></li></ul><h3 id="Big-Omega"><a href="#Big-Omega" class="headerlink" title="Big-Omega"></a>Big-Omega</h3><ul><li><p><strong>Lower</strong> bounds</p></li><li><p>$f(n)=Ω(g(n))$ and <strong>exists</strong> <code>c, n0</code> satisfying $f(n)\geq{c*g(n)}\ (c&gt;0,n&gt;n0)$</p></li><li><p>Example</p><ul><li><p>$\sum{1/n}=Ω(log(n))$</p><blockquote><p><code>log(n)</code> is both bounds above and below, the difference is coefficient.</p></blockquote></li></ul></li></ul><h3 id="Big-Theta"><a href="#Big-Theta" class="headerlink" title="Big-Theta"></a>Big-Theta</h3><ul><li><strong>Tight</strong> bounds</li><li>$f(n)=Θ(g(n))$ when $f(n)=O(g(n))$ and $f(n)=Ω(g(n))$</li></ul><h2 id="Recurrence"><a href="#Recurrence" class="headerlink" title="Recurrence"></a>Recurrence</h2><script type="math/tex; mode=display">\begin{cases} T(n)=3T(n/4)+n^2&(n>1) \\ 1&(n=1) \tag{1} \end{cases}</script><ul><li>$n^2$ is workload of first level</li></ul><h3 id="Recursion-tree-Method"><a href="#Recursion-tree-Method" class="headerlink" title="Recursion-tree Method"></a>Recursion-tree Method</h3><p>$T(n) \leq n^2+3/16n^2+(3/16)^2n^2 + … =O(n^2)$</p><h3 id="Substitution-Method"><a href="#Substitution-Method" class="headerlink" title="Substitution Method"></a>Substitution Method</h3><p>Prove $T(n) \leq cn^2$.</p><p>$T(n)=3T(n/4)+n^2 \le3c(n/4)^2 =cn^2-(13c/16-1)n^2 \leq cn^2 (c\geq16/13)$</p><p>So when $c\geq16/13$, we can prove $T(n)\leq cn^2$.</p><blockquote><p>Since $T(n) \geq n^2$, then $Θ(n)=Ω(n)=O(n)$.</p></blockquote><h3 id="Master-Method-and-Master-Theorem"><a href="#Master-Method-and-Master-Theorem" class="headerlink" title="Master Method and Master Theorem"></a>Master Method and Master Theorem</h3><p>If $T(n)=aT(upper(\frac{n}{b}))+O(n^d)(a&gt;0,b&gt;1,d\geq0)$, then</p><script type="math/tex; mode=display">T(n)=\begin{cases} O(n^d)&d>lob_ba,b^d>a \\ O(n^dlogn)&d=lob_ba,b^d=a \\ O(n^{log_b{a}})&d<lob_ba,b^d<a \end{cases}</script><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter2-Divide-and-Conquer"><a href="#Chapter2-Divide-and-Conquer" class="headerlink" title="Chapter2 Divide and Conquer"></a>Chapter2 Divide and Conquer</h1><p>Total Count: <code>559</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><h2 id="MCS"><a href="#MCS" class="headerlink" title="MCS"></a>MCS</h2><ul><li>Maximum Contiguous Subarray<ul><li>Find the span of years in which the company earned most</li></ul></li></ul><h3 id="Exhaustive-Search"><a href="#Exhaustive-Search" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_Val</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^3)$</li></ul><h3 id="Data-Reuse"><a href="#Data-Reuse" class="headerlink" title="Data-Reuse"></a>Data-Reuse</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">        <span class="comment"># calculate V(i, j)</span></span><br><span class="line">        <span class="comment"># update max_val</span></span><br></pre></td></tr></table></figure><ul><li>$V(i,j)=V(i,j-1)+A[j]$</li><li>$O(n^2)$</li></ul><h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input A[s...t]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s == t:</span><br><span class="line">    retun A[s] <span class="comment"># O(1)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    MCS(A, s, mid) <span class="comment"># T(n/2)</span></span><br><span class="line">    MCS(A, mid, t) <span class="comment"># T(n/2)</span></span><br><span class="line">    <span class="comment"># find the max_val of cut position containing A[mid] and A[mid+1]</span></span><br></pre></td></tr></table></figure><ul><li>Be cautious the array may be at the cut position.</li><li>When finding the <code>max_val</code> containing <code>A[mid]</code> and <code>A[mid+1]</code>, we can do it from <code>mid</code> to <code>0</code>.</li><li>$T(n)=2T([n/2])+n$</li><li>$O(nlogn)$</li></ul><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, temp, ans, temp_sum;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">    temp_sum = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// When temp_sum &lt; 0, it means last temp &lt; 0, and last temp has already been compared with ans to decide whether to update the start point of the sub-array.</span></span><br><span class="line">        temp_sum = max(<span class="number">0</span>, temp_sum); </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        temp_sum += temp;</span><br><span class="line">        ans = max(temp_sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Counting-inversions"><a href="#Counting-inversions" class="headerlink" title="Counting inversions"></a>Counting inversions</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># count inversion</span></span><br></pre></td></tr></table></figure><ul><li>$O(n^2)$</li></ul><h3 id="Merge-Sort-Idea"><a href="#Merge-Sort-Idea" class="headerlink" title="Merge Sort Idea"></a>Merge Sort Idea</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(L) == <span class="number">0</span>:</span><br><span class="line">    reutrn <span class="number">0</span>, L</span><br><span class="line">cnt_a, A = sort_and_count(L[l, mid])</span><br><span class="line">cnt_b, B = sort_and_count(L[mid+<span class="number">1</span>, r])</span><br><span class="line">cnt_c, L = merge_and_count(L[l, mid], L[mid+<span class="number">1</span>, r])</span><br><span class="line"><span class="keyword">return</span> cnt_a + cnt_b + cnt_c, L</span><br></pre></td></tr></table></figure><ul><li>Increase inversion count when merging sorted two list.</li><li>$O(nlogn)$</li></ul><h2 id="Polynomial-Multiplication"><a href="#Polynomial-Multiplication" class="headerlink" title="Polynomial Multiplication"></a>Polynomial Multiplication</h2><h3 id="Brute-Force-1"><a href="#Brute-Force-1" class="headerlink" title="Brute Force"></a>Brute Force</h3><ul><li>compute all coefficients and merge them at last<ul><li>multiplications:$O(n^2)$</li><li>addition:$O(n^2)$</li><li>complexity:$O(n^2)$</li></ul></li></ul><h3 id="Divide-and-Conquer-1"><a href="#Divide-and-Conquer-1" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><ul><li>extract $x^{\frac{n}{2}}$ to make size <code>n</code> problem into $2*2$ problem</li><li>$O(n^2)$</li></ul><h4 id="Improve"><a href="#Improve" class="headerlink" title="Improve"></a>Improve</h4><ul><li>We need $A_0B_1+A_1B_0$ instead of $A_0B_1$and$A_1B_0$.<ul><li>$\begin{cases} U=A_0B_0 \\ V=A_0B_1 \\ W=A_1B_0 \\ Z=A_1B_1\end{cases}$</li><li>Take $Y=(A_0+A_1)(B_0+B_1)$, then we can get $A_0B_1+A_1B_0=Y-U-Z$.</li><li>$T(n)=\begin{cases} 3T(n/2) + n&amp;(n&gt;1) \\ 1&amp;(n=1) \end{cases}$</li></ul></li></ul><h2 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h2><ul><li>partition with pivot as a benchmark</li><li>place pivot into right place</li><li>above can be a recursive process</li><li>$O(nlogn)$: the average complexity</li></ul><h3 id="Improve-1"><a href="#Improve-1" class="headerlink" title="Improve"></a>Improve</h3><ul><li><p>The normal complexity of quicksort is $O(n^2)$ because the array may be partially sorted.</p><p>$T(n)=T(0)+T(n-1)+O(n)$</p><blockquote><ul><li>The complexity of quick sort is $O(n^2)$ instead of $O(nlogn)$.</li><li>$O(n)$ comes from the count of key comparisons.</li></ul></blockquote></li><li><p>Adopt random pivot to get randomized partition</p><ul><li>Swap random position with the last position for reuse the partition function</li><li>This action can validly lower the probability to encounter unlucky array partition</li></ul></li></ul><h4 id="Expected-Case"><a href="#Expected-Case" class="headerlink" title="Expected Case"></a>Expected Case</h4><ul><li>Analysis for randomization algorithm</li></ul><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter3-Dynamic-Programming"><a href="#Chapter3-Dynamic-Programming" class="headerlink" title="Chapter3 Dynamic Programming"></a>Chapter3 Dynamic Programming</h1><p>Total Count: <code>906</code> words</p><p>Preferred Reading Time: <code>20~25</code> minutes</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><p>Similar to Divide and Conquer, but when subproblems overlap, DP is preferred.</p><blockquote><ul><li>Recurrence is from top to bottom, while DP is from bottom to top.</li><li>Recurrence is efficient when subproblems are independent, while DP requires overlapped subproblems.</li><li>DP trades space for time.</li></ul></blockquote></li><li><p>DP is used for <strong>optimization</strong> problems</p></li><li><p><strong>Core: As long as all subproblems are optimized, the merged problem can be optimized.</strong></p><blockquote><p>Prerequisite: All subproblems cannot be completely individual, and in other words,  they have to affect each other’s solution.</p></blockquote></li></ul><h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ul><li>model subproblems</li><li>establish value connections between subproblems</li><li>bottom-up computation to get result</li><li>trace to get format answer</li></ul><h2 id="0-1-knapsack"><a href="#0-1-knapsack" class="headerlink" title="0-1 knapsack"></a>0-1 knapsack</h2><h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute force"></a>brute force</h3><ul><li>try all $2^n$ methods and compare them.</li></ul><h4 id="Simple-Recursion"><a href="#Simple-Recursion" class="headerlink" title="Simple Recursion"></a>Simple Recursion</h4><ul><li><p>$V[i,w]=max(V[i-1,w], v_i+V[i-1,w-w_i])$</p><ul><li><p>$V[i,w]$ denote any subset of items $\{1, 2, 3, …i\}$ value sum with <strong>at most</strong> weight $w$.</p><blockquote><p>Real weight may be smaller than $w$.</p></blockquote></li></ul></li></ul><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><ul><li>State of subproblems<ul><li>establish formal description for problem requirements</li></ul></li><li><p>Relate a problem to its subproblems</p><ul><li>establish recurrence equation</li><li>set boundary cases</li></ul></li><li><strong>Bottom-up</strong> computation of $V[i,w]$</li><li>initialize boundary cases<ul><li>Save trace when calculating $V[i,j]$, and till the end we can use recorded result to get $V[i,w]$.</li></ul></li><li>Add <code>keep[i,w]</code> to record for a specific w, whether an item is taken.</li></ul><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>DP save duplicate computation.</li><li>DP trades space for time.</li><li>Strategy<ul><li>Structure</li><li>Recursion</li><li>Bottom-up computation</li><li>Construct optimal solution: trace the table</li></ul></li></ul><h2 id="Rod-Cutting"><a href="#Rod-Cutting" class="headerlink" title="Rod Cutting"></a>Rod Cutting</h2><h3 id="brute-force-1"><a href="#brute-force-1" class="headerlink" title="brute force"></a>brute force</h3><ul><li>$r_n=max(p_n,r_1+r_{n-1},…,r_{n-1}+r_1)$<ul><li>$r_n$ is the optimal revenue of length <code>n</code> rod.</li><li>$p_n$ is the price of length <code>n</code> rod.</li><li>simpler definition:  $r_n=max_{1\leq i \leq n}(p_i+r_{n-i})$</li></ul></li><li>Even recurrence equation is established, the recursive method still contains duplicate computation.</li></ul><h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><ul><li>one-dimension array <code>r[]</code> to store max revenue of length from 0 to n.</li><li><code>r[i] = max(r[i], p[j] + r[i - j])</code></li></ul><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>$O(n^2)$</li></ul><h2 id="Chain-Matrix-Multiplication"><a href="#Chain-Matrix-Multiplication" class="headerlink" title="Chain Matrix Multiplication"></a>Chain Matrix Multiplication</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>C(<code>p*q</code> and <code>q*r</code> matrix to multiply, each entry takes $O(q)$ to calculate): $O(pqr)$</p></li><li><p>$A_1A_2A_3=(A_1A_2)A_3=A_1(A_2A_3)$</p><blockquote><p>cause of different complexity</p></blockquote></li></ul><h3 id="Exhaustive-Search-1"><a href="#Exhaustive-Search-1" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h3><ul><li>$\Omega(\frac{4^n}{n^{\frac{3}{2}}})$</li></ul><h3 id="DP-2"><a href="#DP-2" class="headerlink" title="DP"></a>DP</h3><p>for matrix $A_i$, it has dimension of $p_{i-1}*p_i$.</p><ul><li><p>model subproblems</p></li><li><p>establish <strong>value</strong> connection between subproblems</p><p>$m[i,j]=\begin{cases}0, &amp; i=j\\min_{i\leq k&lt;j}(m[i,k]+m[k+1,j])+p_{i-1}p_kp_j, &amp; i&lt;j\end{cases}$</p></li></ul><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$<ul><li>Outlying loop layer is for traverse multiply-array’s length from 2 to n.</li></ul></li><li>space: $O(n^2)$</li></ul><h2 id="Longest-Common-Subsequence-Problem"><a href="#Longest-Common-Subsequence-Problem" class="headerlink" title="Longest Common Subsequence Problem"></a>Longest Common Subsequence Problem</h2><h3 id="Basic-Concepts-1"><a href="#Basic-Concepts-1" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>subsequence: not necessarily continuous</li><li>substring: <strong>must</strong> be continuous</li></ul><h3 id="DP-3"><a href="#DP-3" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ the length of LCS in $A[1..i]$ of $A[1..m]$ and $B[1..j]$ of $B[1..n]$</p><ul><li>$d_{i,j}=\begin{cases} 0, &amp; i,j=0 \\ d_{i-1,j-1}+1, &amp; x_i=y_j \\ max(d_{i-1.j},d_{i,j-1}), &amp; x_i\neq y_j\end{cases}$</li></ul><h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(mn)$</p></li><li><p>space: $O(n^2)$</p><ul><li><p>optimization for solution matrix: only save two rows</p><blockquote><p>The trace matrix needs totally preserving.</p></blockquote></li></ul></li><li><p>Different trace may lead to different subsequence.</p></li></ul><h2 id="Longest-Common-Substring-Problem"><a href="#Longest-Common-Substring-Problem" class="headerlink" title="Longest Common Substring Problem"></a>Longest Common Substring Problem</h2><h3 id="Basic-Concepts-2"><a href="#Basic-Concepts-2" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>Different from subsequence, substring must be contiguous.</li></ul><h3 id="DP-4"><a href="#DP-4" class="headerlink" title="DP"></a>DP</h3><p>define $d_{i,j}$ to be the length of the longest common substring of $X[1..i]$ and $Y[1..j]$</p><ul><li>$d_{i,j}=\begin{cases} d_{i-1,j-1}+1, &amp;x_i=y_j\\ 0, &amp;x_i\neq y_j\end{cases}$</li><li>$maxSubstring(X,Y)=max(d_{i,j})$</li></ul><h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Without saving DP direction, we can still trace the whole substring by knowing the <strong>end index</strong> of substring $(X_i|Y_j)$ and its length $d_{i,j}$.</li><li>time: $O(mn)$</li><li>Subsequence algorithm can be used to solve this problem by only outputting diagonal $LU$ elements.</li></ul><h2 id="Minimum-Edit-Distance"><a href="#Minimum-Edit-Distance" class="headerlink" title="Minimum Edit Distance"></a>Minimum Edit Distance</h2><h3 id="Basic-Concepts-3"><a href="#Basic-Concepts-3" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><ul><li>“Spell Correction” in search engine</li><li>Computational Biology such as comparing DNA</li><li>Machine Translation, Information Extraction, Speech Recognition etc.</li></ul><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>calculate the smallest number of edit operations</p><ul><li><p>edit operations</p><ul><li>insertion: add a letter</li><li>deletion: delete a letter</li><li>substitution: replace a character</li></ul><blockquote><p>All operations’ cost is usually (throughout the course) counted as <code>1</code>, but the cost can be adjusted.</p></blockquote></li></ul><h3 id="DP-5"><a href="#DP-5" class="headerlink" title="DP"></a>DP</h3><p>define $D[i,j]$ the edit distance of $X[1..i]$ and $Y[1..j]$</p><ul><li>$D[i,j]=min\begin{cases} D[i-1,j]+1, &amp;delete\ X[i] \\ D[i,j-1]+1, &amp;insert\ Y[j] \\ D[i-1,j-1] +0, &amp;X[i]=Y[j] \\ D[i-1,j-1]+1, &amp;X[i] \neq Y[j] \end{cases}$</li></ul><blockquote><ul><li>All edit operations take place on $X[1..i]$.</li><li>When operation cost changes, the constant in equation will be changed as well.</li><li>When the problem can be depicted as a state graph, <strong>shortest path algorithm</strong> can be used to solve the problem. In other words, the problems degrades to shortest path problem.</li></ul></blockquote><h3 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>When tracing the edit process, <code>L</code>/<code>U</code>/<code>LR</code> stand for four different operations(<strong>including doing nothing</strong>).</li><li>time: $O(mn)$</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>multi-stage strategy problem</li><li>DP is not a specific method but a way of thinking.</li><li>Key to DP: basic equations and boundary conditions</li><li>DP’s effect is also called Markova effect for there’s no effect on future events. </li></ul><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter4-Mid-term-Review"><a href="#Chapter4-Mid-term-Review" class="headerlink" title="Chapter4 Mid-term Review"></a>Chapter4 Mid-term Review</h1><p>Total Count: <code>413</code> words</p><p>Preferred Reading Time: <code>15~20</code> minutes</p><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2><h3 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h3><ul><li><p>Any comparison-based sorting algorithm requires $\Omega(nlogn)$ comparisons.</p><blockquote><p>proved by binary decision tree</p></blockquote></li><li><p>Thus, in order to break the lower bound, we should take other methods except comparison.</p></li><li><p>counting sort isn’t based on comparison.</p></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>When inputting numbers, count occurrences of all numbers.</p><blockquote><p>counting array’s length is based on boundary value of inputting array.</p></blockquote></li><li><p>Fill sorted array with the counting array.</p></li></ul><h3 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n)$</li><li>counting sort is a <strong>stable</strong> sort as long as the final filling loop is from raw array’s <strong>end</strong> to its <strong>head</strong>.</li></ul><h2 id="Randomized-Selection-Problem"><a href="#Randomized-Selection-Problem" class="headerlink" title="Randomized Selection Problem"></a>Randomized Selection Problem</h2><h3 id="Basic-Concepts-4"><a href="#Basic-Concepts-4" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>find the <code>i-th</code> smallest element in a given array</li></ul><h3 id="brute-force-2"><a href="#brute-force-2" class="headerlink" title="brute force"></a>brute force</h3><ul><li>sort the array and index specific element</li></ul><h3 id="Partition-and-Selection"><a href="#Partition-and-Selection" class="headerlink" title="Partition and Selection"></a>Partition and Selection</h3><ul><li>The same as quick sort, part the array into two subarrays, and then make sure the index of selected separator number.</li><li>When the index is greater than <code>i</code>, handle another branch and abandon this one, vice versa.</li></ul><h3 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(n)$</p><blockquote><p>Different from quick sort’s $O(nlogn)$, this algorithm only deals with one branch of subproblems, while quick sort handles both branches.</p></blockquote></li></ul><h2 id="Optimal-Binary-Search-Tree"><a href="#Optimal-Binary-Search-Tree" class="headerlink" title="Optimal Binary Search Tree"></a>Optimal Binary Search Tree</h2><h3 id="Basic-Concepts-5"><a href="#Basic-Concepts-5" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li><p>construct a BST with smallest search cost</p></li><li><p>height</p><ul><li>$node_height=max(children_height + 1)$</li><li>$leave_ height=0$</li><li>$tree_height=root_height$</li><li>$empty_tree_height = -1$</li></ul><blockquote><p><code>root_height</code> is the <strong>biggest</strong> one.</p></blockquote></li><li><p>$depth=H(root)-H(n)+1$</p><ul><li>$root_depth=1$</li></ul></li><li><p>balanced binary tree: the height difference of two subtrees cannot go beyond 1.</p><ul><li>$balance_factor = H(right)-H(left)$</li></ul></li><li><p>AVL tree: besides balanced binary tree, every node will store the height of two subtrees.</p></li></ul><h3 id="DP-6"><a href="#DP-6" class="headerlink" title="DP"></a>DP</h3><ul><li><p>subproblem: find an optimal BST containing $keys<a href="1 \leq i \leq j \leq n">i..j</a>$</p></li><li><p>$e[i,j]$: the expected search cost of a subtree with $k[i..j]$.</p><ul><li>$e[i, j] =\begin{cases} q_{i-1}, &amp;j=i-1 \\ min_{i\leq r\leq j}(e[i, r-1]+e[r+1, j]+w[i, j]), &amp;i\leq j\end{cases}$</li><li>$w[i,j]=E_r=w[i,r-1]+p_r+w[r+1,j]=w[i,j-1]+p_j+q_j$</li></ul></li><li><p>diagonal traverse template</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>): <span class="comment"># length of fixed diagnals</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n-l+<span class="number">1</span>):</span><br><span class="line">        j = i + l - <span class="number">1</span> <span class="comment"># (n-l+1, n) is always on f(i, j)</span></span><br></pre></td></tr></table></figure><blockquote><p>Due to $i\leq j$, then the traverse should be diagonal.</p></blockquote></li></ul><h3 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(n^3)$</li><li>space: $O(n^2)$</li></ul><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter5-Greedy-Algorithms"><a href="#Chapter5-Greedy-Algorithms" class="headerlink" title="Chapter5 Greedy Algorithms"></a>Chapter5 Greedy Algorithms</h1><p>Total Count: <code>522</code> words</p><p>Preferred Reading Time: <code>10~15</code> minutes</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li><p>Greedy algorithms don’t always produce the optimal solution.</p></li><li><p>As a result, if the result is optimal, we need to prove its correctness.</p><blockquote><p>The usual way is to prove that any other optimal solution can be converted into the greedy one.</p></blockquote></li></ul><h2 id="Fraction-Knapsack-Problem"><a href="#Fraction-Knapsack-Problem" class="headerlink" title="Fraction Knapsack Problem"></a>Fraction Knapsack Problem</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Different from 0-1 problem, knapsack can take only a fraction of an item.</li></ul><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><ul><li>calculate value-per-pound of every item</li><li>sort items by <strong>decreasing</strong> value-per-pound</li><li>put as much as possible weight of an item into knapsack from the starting point to the end of the sorted array</li></ul><h3 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$, the time complexity of sort process.</li><li>Different from DP, all subproblems of greedy algorithms are optimal no matter whether they are connected with each other.</li></ul><h2 id="Huffman-Coding-Problem"><a href="#Huffman-Coding-Problem" class="headerlink" title="Huffman Coding Problem"></a>Huffman Coding Problem</h2><h3 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>Encode characters according to its frequency so that the variable length can save the memory space compared with fixed length.</p><blockquote><p>especially useful when storing images</p></blockquote></li><li><p>Uniquely Decodable: In order to decode correctly, the encoding method should avoid one character’s code being the prefix of another character, and then the code can be named after <strong>prefix (free) code</strong>.</p></li><li><p>Huffman coding targets at the <strong>minimized binary prefix code</strong>.</p></li></ul><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><ul><li>pick two least-occur characters from alphabet and build a subtree</li><li>the subtree’s frequency is the sum of its sub-subtrees</li><li><strong>note that the Huffman tree can be a complete binary tree as well</strong></li></ul><h3 id="Analysis-10"><a href="#Analysis-10" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$<ul><li>Every update of the priority queue is $O(logn)$ and the total operation count is $n$.</li></ul></li></ul><h2 id="Activity-Selection-Problem"><a href="#Activity-Selection-Problem" class="headerlink" title="Activity Selection Problem"></a>Activity Selection Problem</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Given activities that may overlap with each other, take part in as many activities as possible.</li><li>core: find a maximized compatible activity set</li></ul><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>sort activities list in ascending order of finishing time</p></li><li><p>select the first activity: the one <strong>finishes at the earliest time</strong></p><blockquote><p>not the one starting earliest or the shortest one</p></blockquote></li><li><p>advance the time and update sort activities until the head activity’s starting time is still valid</p></li><li><p>select next activity</p></li></ul><h3 id="Analysis-11"><a href="#Analysis-11" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>Time: $O(nlogn)$ to sort activity list.</p></li><li><p>The correctness can be proved that greedy algorithms produce the optimal solution of this problem.</p><blockquote><p>Proof: we can convert any other optimal solution($P’$) to the greedy algorithm solution($P$) by replacing different elements in $P’$ with corresponding elements in $P$.</p></blockquote></li></ul><h2 id="Weighted-Activity-Selection-Problem"><a href="#Weighted-Activity-Selection-Problem" class="headerlink" title="Weighted Activity Selection Problem"></a>Weighted Activity Selection Problem</h2><h3 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Every activity is given a weight, and the goal is to construct the set with maximized weight sum.</li></ul><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><ul><li><p>Greedy algorithm is correct when weight are all equal.</p></li><li><p>DP can still work in this weight-varied scenario.</p><ul><li><p><strong>First of all, sort activity with its finishing time.</strong></p></li><li><p>$p(j)$ : the largest index $i&lt;j$ guaranteeing $a_i$ compatible with $a_j$.</p><blockquote><p><strong>index</strong> is the one of <strong>sorted</strong> activity array.</p></blockquote></li><li><p>$OPT(j)$: the max weight sum of any subset in $a[1..j]$</p><script type="math/tex; mode=display">OPT(j)=\begin{cases} 0,& j=0 \\ max(OPT(i-1), w_j+OPT(p(j)), & j>0\end{cases}</script></li></ul></li></ul><h3 id="Analysis-12"><a href="#Analysis-12" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>Time: $O(nlogn)$ to sort the activity list</li><li>Greedy algorithms never reconsider its previous choices, while DP construct its solution by comparing all possible previous choices.</li></ul><h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li></ul><h1 id="Chapter6-Graph-Algorithms"><a href="#Chapter6-Graph-Algorithms" class="headerlink" title="Chapter6 Graph Algorithms"></a>Chapter6 Graph Algorithms</h1><p>Total Count: <code>1887</code> words</p><p>Preferred Reading Time: <code>30~45</code> minutes</p><h2 id="Basic-Concepts-6"><a href="#Basic-Concepts-6" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><ul><li><p>complete graph</p><ul><li>undirected: $|E|=n(n-1)/2$</li><li>directed: $|E|=n(n-1)$</li></ul></li><li><p>dense &amp; sparse graph: not quantitative defined</p></li><li><p>degree: number of edges incident on a vertex</p><ul><li>degree of a graph is the sum of degrees of all vertices</li></ul></li><li><p>leave node</p><ul><li>directed graph: no out degree</li><li>undirected graph: degree is <code>1</code></li></ul></li><li><p>path length: <strong>edges’</strong> count(not vertex)</p></li><li><p>simple path: all <strong>vertices</strong> are distinct on the path(no cycle, acyclic)</p></li><li><p>cycle: requires all <strong>edges</strong> are distinct with multi-exist vertices</p><blockquote><ul><li><p>an edge cannot be used twice in a cycle</p></li><li><p>Q: self-to-self edge can produce cycle?</p><p>A: Yes, that’s why a legal tree <strong>cannot</strong> have self-to-self edge.</p></li></ul></blockquote></li><li><p>connected component</p><ul><li><p><strong>disconnected</strong> graph’s biggest connected subgraph</p><blockquote><p>a disconnected graph can have <strong>more than one</strong> connected components</p></blockquote></li><li><p>connected graph itself</p></li></ul></li><li><p>included subgraph: As long as <strong>both</strong> endpoints are preserved, the edges should be preserved.</p></li><li><p>leaf</p><ul><li>directed graph: out-degree is zero</li><li>undirected graph: degree is one</li></ul></li></ul><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><ul><li>Adjacency List<ul><li>space complexity: $O(V+E)$</li><li>$adj[u]$: hold all vertices adjacent to $u$, usually a linked list.</li><li>mostly for sparse graph</li></ul></li><li>Adjacency Matrix<ul><li>space complexity: $O(V^2)$</li><li>undirected graphs always have <strong>symmetric</strong> adjacency matrix</li><li>mostly for dense graph</li></ul></li></ul><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul><li><p>data structure</p><ul><li><code>color[u]</code>: state of vertex <code>u</code><ul><li><code>undiscovered</code></li><li><code>discovered but not finishing processing</code></li><li><code>finished processing</code></li></ul></li><li><code>pred[u]</code>: the predecessor of vertex <code>u</code></li><li><code>d[u]</code>: distance from starting point to <code>u</code></li></ul></li><li><p>end-loop condition: the vertex queue is empty</p></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><blockquote><p>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</p></blockquote></li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li><p>tree-like traverse process</p></li><li><p>data structure</p><ul><li><code>color[u]</code></li><li><code>pred[u]</code></li><li><code>d[u]</code>: discovery time of vertex <code>u</code></li><li><code>f[u]</code>: finishing time of vertex <code>u</code></li></ul></li><li><p><code>u</code> is a descendant of <code>v</code> if and only if $[d[u],f[u]]\subset[d[v],f[v]]$</p><ul><li><p>tree edge$(u,v)$: $u$ is the predecessor in a DFS path</p></li><li><p>back edge$(u,v)$: $v$ is the predecessor in a DFS path</p><blockquote><p>As long as the graph is acyclic, there is no back edge.</p></blockquote></li><li><p>cross edge$(u,v)$: both vertices are endpoints of a DFS path</p></li></ul></li><li><p>time: $O(V+E)=\sum_{u \in V}(O(1+degree(u)))$</p><ul><li>Different from normal complexity calculation, we can think it in this way: as for each vertex, $O(1)$ is needed to update the timestamp, and $O(degree(u))$ is required to run the for loop. Therefore, the total time complexity is the sum of every single time complexity.</li></ul><blockquote><ul><li>Prerequisite: adjacency <strong>list</strong> is used to store the graph.</li><li>The time complexity is the same as the one of BFS under adjacency list.</li></ul></blockquote></li><li><p>White-path theorem: As long as $v$ is a descendant(direct or indirect) of $u$, then there is a white path between them in DFS algorithm.</p></li></ul><h2 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h2><h3 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition"></a>Definition</h3><ul><li>Topological sort is adopted for <strong>directed acyclic graph(DAG)</strong>.<ul><li>$G$ doesn’t need to be connected, for the order of disconnected parts won’t break the rule.</li></ul></li><li>find a sequence based on edge $(u,v)$ that $u$ must be ahead of $v$</li><li>If no “zero in-degree” vertex is found, the graph must contain cycle.</li></ul><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><ul><li>BFS<ul><li>find all vertices with in-degree as 0</li><li>delete them and their outgoing edges(decrease in-degree of its direct descendants)</li><li>repeat above steps</li></ul></li><li>DFS<ul><li>traverse all vertices and build a DFS tree</li><li>Once a vertex cannot span the tree anymore, add it into $L$.<ul><li>all direct descendants are added into $L$</li><li>no direct descendant exists</li></ul></li><li>next DFS tree traverse won’t reach vertices in $L$</li><li>Tasks with <strong>later</strong> finishing time should be down <strong>earlier</strong>, so $L$ needs reversing to be correct order.</li></ul></li></ul><h3 id="Analysis-13"><a href="#Analysis-13" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>BFS<ul><li>time: $O(|V|+|E|)$</li></ul></li><li>DFS<ul><li>time: $O(|V|+|E|)$</li></ul></li></ul><h2 id="Strongly-Connected-Components"><a href="#Strongly-Connected-Components" class="headerlink" title="Strongly Connected Components"></a>Strongly Connected Components</h2><h3 id="Definition-6"><a href="#Definition-6" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>SCC is a subset of a <strong>directed</strong> graph, in which all vertices can reach each other, <strong>and</strong> the subset should be <strong>maximal</strong>(no more vertex can be added).</p><ul><li>SCC can contain <strong>only one</strong> vertex.</li></ul></li><li><p>Theorem: Suppose $S_1$ and $S_2$ are both SCCs of $G$, then the intersection must be $\Phi$.</p><blockquote><p>Proof: Any vertex in intersection can make $S_1\cup S_2$ a bigger SCC.</p><ul><li>After finding a SCC, all vertices within can be taken as a single vertex.</li></ul></blockquote></li><li><p>Finding all SCC of $G$ is to find a partition with all subset are SCC.</p></li><li><p>Sink SCC: SCC with no outgoing edge</p><ul><li><p>$G^{SCC}$ is a graph taking all SCC as a single vertex.</p></li><li><p>$G^{SCC}$ is a DAG</p><blockquote><p>Proof: As long as there is a cycle, the element of $SCC$ can be merged.</p></blockquote></li><li><p>$G^{SCC}$ must contain at least one <strong>SSCC</strong>.</p><blockquote><p>Proof: The DAG graph can be topological sorted, so the last vertex in the topological order has no outgoing edge, which means the vertex is a SSCC.</p></blockquote></li></ul></li></ul><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><ul><li>generate reverse graph $G^R$</li><li>Operate topological sort on $G^R$, and the result is $L^R$.</li><li>reverse $L^R$ to get $L$</li><li>execute DFS on $G$ with starting point as white ones in $L$</li><li>Every DFS on $G$ can produce a SCC, and corresponding vertices should be marked black.<ul><li>Starting from a SSCC, then the component won’t contain vertices of other SCC.</li></ul></li></ul><h3 id="Analysis-14"><a href="#Analysis-14" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li>time: $O(V+E)$</li></ul><h2 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a>Spanning Tree</h2><h3 id="Definition-7"><a href="#Definition-7" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>An <strong>undirected</strong> graph’s subgraph containing all vertices.</p><blockquote><p>Q: Can spanning tree has cycle?</p><p>A: No,  tree is an <strong>acyclic</strong> graph.</p></blockquote></li><li><p>Every connected graph has at least one spanning tree.</p></li><li><p>Minimum Spanning Tree: the subgraph with smallest weight sum in a weighted undirected graph</p><ul><li><p>minimum spanning tree may <strong>not</strong> be unique</p><blockquote><p>Only when weight varies from one to another, the minimum spanning tree is unique.</p></blockquote></li></ul></li><li><p>safe edge: After adding safe edge to a subset of MST, the new set is still a subset of MST.</p><ul><li><p>Find the light edge of a cut respecting subset A, and then the light edge is the sage edge.</p><blockquote><p>Subset contains only edges, which means <strong>not all</strong> edges needs selecting even though their endpoints are with in the subset.</p></blockquote></li></ul></li><li><p>min heap</p><ul><li>root has min value</li><li>any vertex’s sons have <strong>greater</strong> value than its own value.</li></ul></li></ul><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><ul><li><p><strong>focus on vertex</strong></p></li><li><p>start with a randomly picked up <strong>vertex</strong></p></li><li><p>iterate to find the <strong>lightest</strong> edge outside the tree and add it (and its <strong>endpoint</strong>) into tree</p><ul><li><p>priority queue</p><ul><li><p>insert: insert at tail and <strong>reverse up</strong></p></li><li><p>extract min</p><ul><li><p>After extracting the first element, the last element needs swapping to the first.</p><blockquote><p>Only the last element won’t influence the tree structure.</p></blockquote></li><li><p><strong>roll down</strong> new first element to construct a new heap</p></li><li><p>time complexity is $O(logn)$</p></li></ul></li><li><p>update value: <strong>reverse up</strong> to respect the heap</p></li></ul></li></ul></li><li><p>When adding an new edge and its vertex into SMT, loop over its adjacent vertices to update key values.</p></li></ul><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><ul><li><strong>focus on edges</strong></li><li>Construct many forests, and finally they will be merged.<ul><li>When selecting edges, be cautious there cannot be cycles.<ul><li>disjoint set</li></ul></li></ul></li></ul><h3 id="Analysis-15"><a href="#Analysis-15" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time</p><ul><li><p>Prim: $O(VlogV+ElogV)=O(ElogV)$</p><ul><li>Usually, $E$ is greater than $V$ and sometimes may be $V^2$, which means $E=O(V^2)$.</li></ul><blockquote><p>As for loops like <code>while Q.size() &gt; 0</code>, and <code>Q</code> is changed within, we can consider it based on every single operation instead of every loop.</p></blockquote></li><li><p>Kruskal: $O(ElogE)=O(ElogV)$</p><blockquote><p>$logE\leq logV^2 \leq 2logV \leq O(logV)$</p><ul><li>Usually place $E$ outside $log$, and $V$ is placed inside.</li></ul></blockquote></li></ul></li></ul><h2 id="Shortest-Path"><a href="#Shortest-Path" class="headerlink" title="Shortest Path"></a>Shortest Path</h2><h3 id="Definition-8"><a href="#Definition-8" class="headerlink" title="Definition"></a>Definition</h3><ul><li>distance is the <strong>minimal</strong> length between two vertices</li><li>lemma: Any sub-path of a shortest path must also be a shortest path.</li></ul><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><ul><li><p>single source problem</p></li><li><p>can only handle <strong>no-negative-edge</strong> graph</p></li><li><p>greedy algorithm</p></li><li><p>maintain <code>d[v]</code> and <code>S</code></p><ul><li><p><code>d[v]</code>: upper bound of length <code>l(source, v)</code></p><ul><li><p>can be optimized by priority queue</p></li><li><p>relax</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[v] &lt;- min(d[v], d[u] + w(u, v));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>S</code>: set of distance-settled vertices</p></li></ul></li></ul><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><ul><li><p>single source problem</p></li><li><p>relax according to <strong>edges</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to <span class="params">|V|</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> E <span class="keyword">do</span></span><br><span class="line">        relax(e.p1, e.p2, e.w);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>Every iteration will settle an edge in the shortest paths.</p></li><li><p>The shortest path can at <strong>most</strong> contain <code>(|V|-1)</code> edges.</p></li><li><p>Iteration at most runs for <code>(|V|-1)</code> times.</p><blockquote><p><code>ith</code> iteration settle the paths containing <code>i</code> edges</p></blockquote></li></ul></li><li><p>If relaxation still happens after <code>(|V|-1)</code> iterations, there must be negative cycles in graph.</p></li></ul><h4 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h4><ul><li><p>all-pairs problem</p></li><li><p>dynamic programming algorithm</p><ul><li><p>$f[k][i][j]=min\{f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j]\}$</p><ul><li><p>using rolling array to optimize</p><p>$f[i][j]=min\{f[i][j],f[i][k]+f[k][j]\}$</p></li></ul></li></ul></li><li><p>The sequence to traverse <code>k</code>(intermediate vertex) isn’t important.</p><blockquote><p>Proof: Mathematics Induction(<a href="https://blog.csdn.net/dypdypdyp123/article/details/50492894" target="_blank" rel="noopener">https://blog.csdn.net/dypdypdyp123/article/details/50492894</a>)</p></blockquote></li></ul><h3 id="Analysis-16"><a href="#Analysis-16" class="headerlink" title="Analysis"></a>Analysis</h3><p>time</p><ul><li><p>Dijkstra: $O(VlogV+ElogV)=O(ElogV)$</p></li><li><p>Bellman-Ford: $O(EV)$</p></li><li><p>Floyd-Warshall: $O(V^3)$</p><blockquote><p>Apart from data structure, Floyd’s traversal decides the $n^3$ complexity.</p></blockquote></li></ul><h2 id="Maximum-Flow-amp-Minimum-Cut"><a href="#Maximum-Flow-amp-Minimum-Cut" class="headerlink" title="Maximum Flow &amp; Minimum Cut"></a>Maximum Flow &amp; Minimum Cut</h2><h3 id="Definition-9"><a href="#Definition-9" class="headerlink" title="Definition"></a>Definition</h3><ul><li><p>a flow network <code>G</code> with source <code>s</code>, sink <code>t</code> and no parallel edges.</p></li><li><p>capacity is nonnegative: $c(e) \geq 0$</p></li><li><p>cut’s capacity: $cap(A, B)=\sum_{e\ out\ of\ A}c(e)$</p><ul><li>a cut requires $s \in A$ and $t \in B$</li></ul></li><li><p>minimum cut: output a cut of minimum capacity</p></li><li><p>maximum flow: output a flow of maximum value</p></li><li><p>Except <code>s</code> and <code>t</code>, every vertex’s <code>out</code> equals <code>in</code>, which means it cannot store any water.</p></li><li><p>flow value: $val(f)=\sum_{e\ out\ of\ s}f(e)$, and <code>s</code> is the source.</p><blockquote><p><code>value</code> may not be the sum of capacity</p></blockquote></li></ul><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Heuristic-Algorithm"><a href="#Heuristic-Algorithm" class="headerlink" title="Heuristic Algorithm"></a>Heuristic Algorithm</h4><ul><li>initialize all <code>f(e)</code> to zero</li><li>find a <code>s-t</code> path where each edge meets $f(e)&lt;c(e)$</li><li>augment flow along <code>s-t</code> path</li><li>iterate above steps until no <code>s-t</code> path can be found</li></ul><blockquote><p><code>Heuristic Algorithm</code> <strong>cannot</strong> guarantee the optimal answer</p></blockquote><h4 id="Ford-Fulkerson-Method"><a href="#Ford-Fulkerson-Method" class="headerlink" title="Ford-Fulkerson Method"></a>Ford-Fulkerson Method</h4><ul><li><p>residual network: add reverse edges to dynamically adjust the flow of an edge</p><ul><li>residual capacity: $c_f(e)=\begin{cases} c(e)-f(e), &amp; c(e)&gt;f(e) \\ f(e), &amp;f(e)&gt;0 \end{cases}$</li></ul><blockquote><p>Once and residual capacity is zero, there is <strong>only one</strong> edge between two vertices.(even no edge at all)</p></blockquote></li><li><p>augment(ing) path: a simple <code>s-t</code> path in $G_f$</p><ul><li><p>bottleneck capacity: minimum residual capacity of any edge in augment path</p></li><li><p>key property: $val(f’)=val(f)+bottoleneck(G_f, P)$</p><ul><li>As for specific edge, the flow may decrease. However, the overall flow will increase.</li></ul></li><li><p>$val(f’)&gt;val(f)$</p><blockquote><p>the out edges of <code>s</code> must have the <strong>same</strong> direction as that in augment path</p></blockquote></li></ul></li><li><p>Process</p><ul><li>start with all <code>f(u, v) = 0</code></li><li>randomly choose an augment path to update <code>f</code> and $G_f$.</li><li>iterate until there is <strong>no</strong> augment path $\Leftrightarrow$ no <code>s-t</code> path in $G_f$</li></ul></li></ul><h3 id="Analysis-17"><a href="#Analysis-17" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>time: $O(|E||f^<em>|)$, $f^</em>$ is the max flow of graph $G$.</p><ul><li><p>BFS/DFS: $O(|V| + 2|E|)=O(|E|)$</p><blockquote><p>the worst case: one edge in $G$ has two corresponding edges in $G_f$</p></blockquote></li><li><p>The time complexity is determined by $|f^*|$, so the method to pick up an augment path is important.</p><ul><li>EK Algorithm: ignore all edges’ weight and find a shortest path</li><li>In a flow network, EK’s time complexity is $O(|V||E|)$.<ul><li>an edge <strong>at most</strong> can be critical for $|V|/2$ times</li></ul></li><li>new time complexity of Ford-Fulkerson Algorithm: $O(|V||E|^2)$</li></ul></li></ul></li><li><p>Augmenting Path Theorem: A flow of $f$ is a max-flow $\Leftrightarrow$ <strong>no</strong> augment path in $G_f$</p></li><li><p>Max Flow &amp; Min Cut Theorem</p><ul><li>$val(f)=cap(min_cut)$</li><li>$f$ is the max flow</li><li>$f$ has no augmenting path</li></ul></li></ul><h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul><li>BUAA Algorithm Lecture, Autumn of 2020.</li><li>BUAA Algorithm MOOC, Autumn of 2020.</li><li>OI Wiki</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Learning note of 2020 BUAA Algorithm course.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
  </entry>
  
</feed>

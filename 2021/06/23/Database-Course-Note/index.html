<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="Learning note of 2020 BUAA Database course.">
<meta property="og:type" content="article">
<meta property="og:title" content="Database Course Note">
<meta property="og:url" content="http://yoursite.com/2021/06/23/Database-Course-Note/index.html">
<meta property="og:site_name" content="Silence Jiang&#39;s Cite">
<meta property="og:description" content="Learning note of 2020 BUAA Database course.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://bs-uploads.toptal.io/blackfish-uploads/blog/post/seo/og_image_file/og_image/15493/0712-Bad_Practices_in_Database_Design_-_Are_You_Making_These_Mistakes_Dan_Social-754bc73011e057dc76e55a44a954e0c3.png">
<meta property="og:image" content="https://i.loli.net/2020/11/20/VgGK16P2QrdtBqf.png">
<meta property="og:image" content="https://i.loli.net/2020/11/20/8KL7aMQVrhPAmRF.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-bdc235fbdd1825c1b67ef7d609f81adb_1440w.jpg?source=1940ef5c">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ccefb7a678de237560cc4df80c11cca3_1440w.jpg?source=1940ef5c">
<meta property="article:published_time" content="2021-06-23T12:39:10.027Z">
<meta property="article:modified_time" content="2021-06-24T01:32:07.749Z">
<meta property="article:author" content="Silence Jiang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bs-uploads.toptal.io/blackfish-uploads/blog/post/seo/og_image_file/og_image/15493/0712-Bad_Practices_in_Database_Design_-_Are_You_Making_These_Mistakes_Dan_Social-754bc73011e057dc76e55a44a954e0c3.png">

<link rel="canonical" href="http://yoursite.com/2021/06/23/Database-Course-Note/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Database Course Note | Silence Jiang's Cite</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Silence Jiang's Cite" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Silence Jiang's Cite</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-lover">

    <a href="/lover/" rel="section"><i class="fa fa-heart fa-fw"></i>lover</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter0-概论"><span class="nav-number">1.</span> <span class="nav-text">Chapter0 概论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据和信息"><span class="nav-number">1.1.</span> <span class="nav-text">数据和信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理"><span class="nav-number">1.1.1.</span> <span class="nav-text">处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理"><span class="nav-number">1.1.2.</span> <span class="nav-text">管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库系统"><span class="nav-number">1.2.</span> <span class="nav-text">数据库系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#架构-B-S"><span class="nav-number">1.2.1.</span> <span class="nav-text">架构(B&#x2F;S)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">1.2.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">1.2.3.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">1.3.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter1-概述"><span class="nav-number">2.</span> <span class="nav-text">Chapter1 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据管理技术发展"><span class="nav-number">2.1.</span> <span class="nav-text">数据管理技术发展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库系统组成"><span class="nav-number">2.2.</span> <span class="nav-text">数据库系统组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库"><span class="nav-number">2.2.1.</span> <span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件"><span class="nav-number">2.2.2.</span> <span class="nav-text">软件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件"><span class="nav-number">2.2.3.</span> <span class="nav-text">硬件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户"><span class="nav-number">2.2.4.</span> <span class="nav-text">用户</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据模型"><span class="nav-number">2.3.</span> <span class="nav-text">数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#层次"><span class="nav-number">2.3.1.</span> <span class="nav-text">层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念模型"><span class="nav-number">2.3.2.</span> <span class="nav-text">概念模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本概念"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#E-R"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">E-R</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#组成"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#语义"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">语义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据模型-1"><span class="nav-number">2.3.3.</span> <span class="nav-text">数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据操作"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">数据操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#约束条件"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">约束条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">2.3.4.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库系统结构"><span class="nav-number">2.4.</span> <span class="nav-text">数据库系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式"><span class="nav-number">2.4.1.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外模式"><span class="nav-number">2.4.2.</span> <span class="nav-text">外模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内模式"><span class="nav-number">2.4.3.</span> <span class="nav-text">内模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两级映象"><span class="nav-number">2.4.4.</span> <span class="nav-text">两级映象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBMS"><span class="nav-number">2.4.5.</span> <span class="nav-text">DBMS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要功能"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">主要功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组成-1"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">组成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBA"><span class="nav-number">2.4.6.</span> <span class="nav-text">DBA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-1"><span class="nav-number">2.5.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter2-关系数据库"><span class="nav-number">3.</span> <span class="nav-text">Chapter2 关系数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">基本概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据模型-2"><span class="nav-number">3.2.</span> <span class="nav-text">数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语义约束"><span class="nav-number">3.2.2.</span> <span class="nav-text">语义约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据操作-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">数据操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系代数"><span class="nav-number">3.3.</span> <span class="nav-text">关系代数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系演算"><span class="nav-number">3.4.</span> <span class="nav-text">关系演算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元组"><span class="nav-number">3.4.1.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#域"><span class="nav-number">3.4.2.</span> <span class="nav-text">域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安全约束"><span class="nav-number">3.5.</span> <span class="nav-text">安全约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">3.5.1.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系数据语言"><span class="nav-number">3.6.</span> <span class="nav-text">关系数据语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类-1"><span class="nav-number">3.6.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点"><span class="nav-number">3.6.2.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-2"><span class="nav-number">3.7.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter3-SQL"><span class="nav-number">4.</span> <span class="nav-text">Chapter3 SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-1"><span class="nav-number">4.1.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">4.1.2.</span> <span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查询"><span class="nav-number">4.2.</span> <span class="nav-text">查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本结构"><span class="nav-number">4.2.1.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#投影检索"><span class="nav-number">4.2.2.</span> <span class="nav-text">投影检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选取检索"><span class="nav-number">4.2.3.</span> <span class="nav-text">选取检索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运算符"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序检索"><span class="nav-number">4.2.4.</span> <span class="nav-text">排序检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接（连表）检索"><span class="nav-number">4.2.5.</span> <span class="nav-text">连接（连表）检索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自身连接"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">自身连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外连接"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">外连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套检索"><span class="nav-number">4.2.6.</span> <span class="nav-text">嵌套检索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自身嵌套"><span class="nav-number">4.2.6.1.</span> <span class="nav-text">自身嵌套</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并、差、交检索"><span class="nav-number">4.2.7.</span> <span class="nav-text">并、差、交检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#库函数检索"><span class="nav-number">4.2.8.</span> <span class="nav-text">库函数检索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用"><span class="nav-number">4.2.8.1.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组检索"><span class="nav-number">4.2.9.</span> <span class="nav-text">分组检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算术表达式值检索"><span class="nav-number">4.2.10.</span> <span class="nav-text">算术表达式值检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部分匹配"><span class="nav-number">4.2.11.</span> <span class="nav-text">部分匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于派生表的查询"><span class="nav-number">4.2.12.</span> <span class="nav-text">基于派生表的查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据定义"><span class="nav-number">4.3.</span> <span class="nav-text">数据定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">4.3.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本表"><span class="nav-number">4.3.2.</span> <span class="nav-text">基本表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模板"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引"><span class="nav-number">4.3.3.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模板-1"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例-1"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图"><span class="nav-number">4.3.4.</span> <span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#作用"><span class="nav-number">4.3.4.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板-2"><span class="nav-number">4.3.4.2.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例-2"><span class="nav-number">4.3.4.3.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据更新"><span class="nav-number">4.4.</span> <span class="nav-text">数据更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插入"><span class="nav-number">4.4.1.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改"><span class="nav-number">4.4.2.</span> <span class="nav-text">修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除"><span class="nav-number">4.4.3.</span> <span class="nav-text">删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空值"><span class="nav-number">4.5.</span> <span class="nav-text">空值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运算"><span class="nav-number">4.5.1.</span> <span class="nav-text">运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检索"><span class="nav-number">4.5.2.</span> <span class="nav-text">检索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据控制"><span class="nav-number">4.6.</span> <span class="nav-text">数据控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌入式SQL"><span class="nav-number">4.7.</span> <span class="nav-text">嵌入式SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-3"><span class="nav-number">4.8.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter4-数据库设计"><span class="nav-number">5.</span> <span class="nav-text">Chapter4 数据库设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-2"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计方法"><span class="nav-number">5.1.1.</span> <span class="nav-text">设计方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求分析"><span class="nav-number">5.2.</span> <span class="nav-text">需求分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标"><span class="nav-number">5.2.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">5.2.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概念结构设计"><span class="nav-number">5.3.</span> <span class="nav-text">概念结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#E-R法"><span class="nav-number">5.3.1.</span> <span class="nav-text">E-R法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#E-R图概述"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">E-R图概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#E-R图设计"><span class="nav-number">5.3.2.</span> <span class="nav-text">E-R图设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-1"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-1"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据抽象"><span class="nav-number">5.3.2.2.1.</span> <span class="nav-text">数据抽象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#步骤"><span class="nav-number">5.3.2.2.2.</span> <span class="nav-text">步骤</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑结构设计"><span class="nav-number">5.4.</span> <span class="nav-text">逻辑结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#E-R图与关系模型"><span class="nav-number">5.4.1.</span> <span class="nav-text">E-R图与关系模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#普适转换规则"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">普适转换规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱实体"><span class="nav-number">5.4.1.2.</span> <span class="nav-text">弱实体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#超类-子类联系"><span class="nav-number">5.4.1.3.</span> <span class="nav-text">超类&#x2F;子类联系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规范化"><span class="nav-number">5.4.2.</span> <span class="nav-text">规范化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化"><span class="nav-number">5.4.3.</span> <span class="nav-text">优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#水平分解"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">水平分解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垂直分解"><span class="nav-number">5.4.3.2.</span> <span class="nav-text">垂直分解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计用户子模式"><span class="nav-number">5.4.4.</span> <span class="nav-text">设计用户子模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理结构设计"><span class="nav-number">5.5.</span> <span class="nav-text">物理结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存储结构"><span class="nav-number">5.5.1.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存取方法"><span class="nav-number">5.5.2.</span> <span class="nav-text">存取方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#索引-1"><span class="nav-number">5.5.2.1.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚集"><span class="nav-number">5.5.2.2.</span> <span class="nav-text">聚集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HASH文件"><span class="nav-number">5.5.2.3.</span> <span class="nav-text">HASH文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-4"><span class="nav-number">5.6.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter5-关系数据理论"><span class="nav-number">6.</span> <span class="nav-text">Chapter5 关系数据理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-3"><span class="nav-number">6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数依赖"><span class="nav-number">6.2.</span> <span class="nav-text">函数依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">6.2.1.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#术语"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性联系"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">属性联系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类-2"><span class="nav-number">6.2.1.3.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系键"><span class="nav-number">6.2.2.</span> <span class="nav-text">关系键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑蕴涵"><span class="nav-number">6.2.3.</span> <span class="nav-text">逻辑蕴涵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Armstrong公理系统"><span class="nav-number">6.2.4.</span> <span class="nav-text">Armstrong公理系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">6.2.5.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数依赖集"><span class="nav-number">6.2.6.</span> <span class="nav-text">函数依赖集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-1"><span class="nav-number">6.2.6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#极小化"><span class="nav-number">6.2.6.2.</span> <span class="nav-text">极小化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#规范化-1"><span class="nav-number">6.3.</span> <span class="nav-text">规范化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#范式-Normal-Form"><span class="nav-number">6.3.1.</span> <span class="nav-text">范式(Normal Form)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分级"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">分级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多值依赖"><span class="nav-number">6.4.</span> <span class="nav-text">多值依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-2"><span class="nav-number">6.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性质"><span class="nav-number">6.4.2.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四范式-4NF"><span class="nav-number">6.4.3.</span> <span class="nav-text">第四范式(4NF)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模式分解理论"><span class="nav-number">6.5.</span> <span class="nav-text">模式分解理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-3"><span class="nav-number">6.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无损连接性"><span class="nav-number">6.5.2.</span> <span class="nav-text">无损连接性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保持函数依赖性"><span class="nav-number">6.5.3.</span> <span class="nav-text">保持函数依赖性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原则"><span class="nav-number">6.5.4.</span> <span class="nav-text">原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分解算法"><span class="nav-number">6.5.5.</span> <span class="nav-text">分解算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#候选码求解"><span class="nav-number">6.6.</span> <span class="nav-text">候选码求解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单属性"><span class="nav-number">6.6.1.</span> <span class="nav-text">单属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分类-3"><span class="nav-number">6.6.1.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#求解"><span class="nav-number">6.6.1.2.</span> <span class="nav-text">求解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定"><span class="nav-number">6.6.1.3.</span> <span class="nav-text">判定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多属性"><span class="nav-number">6.6.2.</span> <span class="nav-text">多属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">6.7.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-5"><span class="nav-number">6.8.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter6-关系查询处理与查询优化"><span class="nav-number">7.</span> <span class="nav-text">Chapter6 关系查询处理与查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-4"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化-1"><span class="nav-number">7.2.</span> <span class="nav-text">优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代数优化"><span class="nav-number">7.2.1.</span> <span class="nav-text">代数优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理优化"><span class="nav-number">7.2.2.</span> <span class="nav-text">物理优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤-1"><span class="nav-number">7.2.3.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-6"><span class="nav-number">7.3.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter7-事务处理技术"><span class="nav-number">8.</span> <span class="nav-text">Chapter7 事务处理技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-5"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特性-ACID"><span class="nav-number">8.1.1.</span> <span class="nav-text">特性(ACID)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#破坏"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">破坏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL"><span class="nav-number">8.1.2.</span> <span class="nav-text">SQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库恢复技术"><span class="nav-number">8.2.</span> <span class="nav-text">数据库恢复技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#故障"><span class="nav-number">8.2.1.</span> <span class="nav-text">故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-2"><span class="nav-number">8.2.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#策略"><span class="nav-number">8.2.3.</span> <span class="nav-text">策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查点"><span class="nav-number">8.2.4.</span> <span class="nav-text">检查点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像"><span class="nav-number">8.2.5.</span> <span class="nav-text">镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发控制"><span class="nav-number">8.3.</span> <span class="nav-text">并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题"><span class="nav-number">8.3.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本思想"><span class="nav-number">8.3.2.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本手段"><span class="nav-number">8.3.3.</span> <span class="nav-text">基本手段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#活锁和死锁"><span class="nav-number">8.3.4.</span> <span class="nav-text">活锁和死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可串行化调度"><span class="nav-number">8.3.5.</span> <span class="nav-text">可串行化调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-7"><span class="nav-number">8.4.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter8-数据库保护"><span class="nav-number">9.</span> <span class="nav-text">Chapter8 数据库保护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安全性"><span class="nav-number">9.1.</span> <span class="nav-text">安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-4"><span class="nav-number">9.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制"><span class="nav-number">9.1.2.</span> <span class="nav-text">控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可信系统评测"><span class="nav-number">9.1.3.</span> <span class="nav-text">可信系统评测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完整性"><span class="nav-number">9.2.</span> <span class="nav-text">完整性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-5"><span class="nav-number">9.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约束条件-1"><span class="nav-number">9.2.2.</span> <span class="nav-text">约束条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制-1"><span class="nav-number">9.2.3.</span> <span class="nav-text">控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-8"><span class="nav-number">9.3.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter9-数据库新技术"><span class="nav-number">10.</span> <span class="nav-text">Chapter9-数据库新技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据仓库-Data-Warehouse"><span class="nav-number">10.1.</span> <span class="nav-text">数据仓库(Data Warehouse)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式数据库系统"><span class="nav-number">10.2.</span> <span class="nav-text">分布式数据库系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-1"><span class="nav-number">10.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-2"><span class="nav-number">10.2.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#体系结构"><span class="nav-number">10.2.3.</span> <span class="nav-text">体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式结构"><span class="nav-number">10.2.3.1.</span> <span class="nav-text">模式结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分片"><span class="nav-number">10.2.3.2.</span> <span class="nav-text">分片</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#约束"><span class="nav-number">10.2.3.2.1.</span> <span class="nav-text">约束</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布透明性"><span class="nav-number">10.2.3.3.</span> <span class="nav-text">分布透明性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DDBMS"><span class="nav-number">10.2.3.4.</span> <span class="nav-text">DDBMS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分类-4"><span class="nav-number">10.2.3.4.1.</span> <span class="nav-text">分类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主要技术"><span class="nav-number">10.2.4.</span> <span class="nav-text">主要技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查询-1"><span class="nav-number">10.2.4.1.</span> <span class="nav-text">查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分类-5"><span class="nav-number">10.2.4.1.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理-1"><span class="nav-number">10.2.4.1.2.</span> <span class="nav-text">处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优化-2"><span class="nav-number">10.2.4.1.3.</span> <span class="nav-text">优化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-9"><span class="nav-number">10.3.</span> <span class="nav-text">Reference</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Silence Jiang"
      src="https://i.loli.net/2021/06/24/DBH4z2SpijZrQ17.jpg">
  <p class="site-author-name" itemprop="name">Silence Jiang</p>
  <div class="site-description" itemprop="description">I'm right here waiting for you.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SilenceX12138" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SilenceX12138" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/silencejiang12138" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;silencejiang12138" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/2214676725" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;2214676725" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:silencejiang12138@gmail.com" title="E-Mail → mailto:silencejiang12138@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/23/Database-Course-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2021/06/24/DBH4z2SpijZrQ17.jpg">
      <meta itemprop="name" content="Silence Jiang">
      <meta itemprop="description" content="I'm right here waiting for you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silence Jiang's Cite">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Database Course Note
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-23 20:39:10" itemprop="dateCreated datePublished" datetime="2021-06-23T20:39:10+08:00">2021-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-24 09:32:07" itemprop="dateModified" datetime="2021-06-24T09:32:07+08:00">2021-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/06/23/Database-Course-Note/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/23/Database-Course-Note/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>26 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>Learning note of 2020 BUAA Database course.</strong></p>
<p><img src="https://bs-uploads.toptal.io/blackfish-uploads/blog/post/seo/og_image_file/og_image/15493/0712-Bad_Practices_in_Database_Design_-_Are_You_Making_These_Mistakes_Dan_Social-754bc73011e057dc76e55a44a954e0c3.png" alt="Eight Common Database Design Bad Practices | Toptal"></p>
<a id="more"></a>
<h1 id="Chapter0-概论"><a href="#Chapter0-概论" class="headerlink" title="Chapter0 概论"></a>Chapter0 概论</h1><p>全文共<code>430</code>字，推荐阅读时间<code>5~10</code>分钟。</p>
<h2 id="数据和信息"><a href="#数据和信息" class="headerlink" title="数据和信息"></a>数据和信息</h2><ul>
<li>信息是<strong>一种</strong>已经被加工为<strong>特定形式</strong>的数据</li>
<li>数据是信息的载体，是信息的具体表现形式。</li>
</ul>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ul>
<li>对数据进行加工得到信息的过程</li>
</ul>
<h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><ul>
<li>数据处理的<strong>基本操作</strong></li>
<li>数据库技术就是一种数据管理技术<ul>
<li>提供数据共享</li>
</ul>
</li>
</ul>
<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><ul>
<li>建立在DBMS之上，以<strong>数据管理</strong>为<strong>主要功能</strong>的计算机软件系统。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;DBMS</span><br><span class="line">DBMS--&gt;数据库</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DBS &gt; DBMS &gt; DB</p>
<ul>
<li>DBS包括了<strong>用户/应用程序</strong>构成的交互层</li>
</ul>
</blockquote>
<h3 id="架构-B-S"><a href="#架构-B-S" class="headerlink" title="架构(B/S)"></a>架构(B/S)</h3><ul>
<li>Browser</li>
<li>Server<ul>
<li>Web Server</li>
<li>DB Server(DBMS location)</li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>数据模型</li>
<li>底层实现技术、事务处理、数据库安全、完整性控制</li>
<li>关系数据理论、数据库设计方法</li>
</ul>
<blockquote>
<p>事务处理（原子性）是DBMS的工作，不是DBS.</p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>图书馆</li>
<li>电商</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
</ul>
<h1 id="Chapter1-概述"><a href="#Chapter1-概述" class="headerlink" title="Chapter1 概述"></a>Chapter1 概述</h1><p>全文共<code>2102</code>字，推荐阅读时间<code>15~20</code>分钟。</p>
<h2 id="数据管理技术发展"><a href="#数据管理技术发展" class="headerlink" title="数据管理技术发展"></a>数据管理技术发展</h2><ul>
<li><p>人工管理</p>
<ul>
<li><p>数据<strong>不在</strong>计算机上保存</p>
</li>
<li><p>程序决定数据的逻辑结构和物理结构，数据与程序之间<strong>不具有独立性</strong>。</p>
<blockquote>
<p>要改变数据的结构就要改变程序</p>
</blockquote>
</li>
<li><p>数据面向应用，程序之间<strong>不能共享</strong>数据。</p>
</li>
</ul>
</li>
<li><p>文件系统</p>
<ul>
<li><p>存取方法作为中介出现</p>
</li>
<li><p>数据以<strong>文件形式</strong>保存在<strong>外存</strong>上</p>
</li>
<li><p>数据的存取以<strong>记录</strong>为单位</p>
</li>
<li><p>程序和数据具有<strong>一定的独立性</strong></p>
</li>
<li><p>缺点：</p>
<ul>
<li>数据冗余度大（因为数据<strong>不能</strong>被程序共享，即不能够同时进行操作，必须创建多个副本），可能带来数据的不一致性。</li>
<li>数据和程序之间的独立性依然<strong>不</strong>明显，缺乏<strong>逻辑独立性</strong>。（改文件逻辑结构时还要修改程序）</li>
</ul>
<blockquote>
<p>文件系统是<strong>不具弹性</strong>的<strong>无结构</strong>的数据集合，<strong>数据之间</strong>（<strong>不是</strong>程序和数据）是孤立的，不能反映现实世界事物之间的内在联系。</p>
<ul>
<li>不具弹性：改变数据的结构就得改程序</li>
<li>无结构：数据之间孤立</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>数据库系统</p>
<ul>
<li><p>数据结构化：描述数据时，不仅描述数据本身，还要描述数据之间的联系。</p>
<blockquote>
<p><strong>数据结构化</strong>是数据库与文件系统的<strong>根本区别</strong></p>
</blockquote>
</li>
<li><p>数据冗余度小，易扩充。</p>
</li>
<li><p>数据和程序的独立性<strong>较高</strong></p>
<ul>
<li><p>数据独立性</p>
<ul>
<li>物理：数据的物理结构改变时，数据的逻辑结构可以不变，从而程序也不用改变。</li>
<li>逻辑：数据的逻辑结构改变时，程序不用改变。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">应用程序--&gt;局部逻辑结构</span><br><span class="line">局部逻辑结构--&gt;全局逻辑结构</span><br><span class="line">全局逻辑结构--&gt;物理结构</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数据库映象：不同结构之间数据的<strong>转换关系</strong></p>
<p>物理结构发生变化时，可以通过调整数据库映象来确保逻辑结构不变。</p>
</li>
<li><p>统一的数据控制功能</p>
<ul>
<li><p>安全性控制</p>
</li>
<li><p>完整性控制：数据的正确性和相容性</p>
<blockquote>
<p>相容性：同一条数据在不同的程序应该是相同的</p>
</blockquote>
</li>
<li><p>并发控制</p>
</li>
<li><p>恢复</p>
</li>
<li><p>存取单位是数据项</p>
<p>可以存取一组记录，也可以取一组数据项。</p>
<blockquote>
<p>数据项的粒度小于文件</p>
<p>Q：数据项和记录的区别</p>
<p>A：数据项是列，记录是行。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>集成：本质是数据结构化</li>
<li>共享</li>
</ul>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul>
<li>DBMS</li>
<li>应用系统</li>
</ul>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul>
<li>存储数据</li>
<li>运行系统</li>
</ul>
<h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><ul>
<li>终端用户</li>
<li>应用程序员</li>
<li>数据库管理员</li>
</ul>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul>
<li>用于抽象和表示现实世界中的<strong>数据和信息</strong></li>
<li>层次<ul>
<li>概念模型（信息模型）</li>
<li>数据模型（层次、网状、关系模型）</li>
</ul>
</li>
</ul>
<h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">现实世界--&gt;信息世界</span><br><span class="line">信息世界--&gt;机器世界</span><br></pre></td></tr></table></figure>
<ul>
<li>信息世界就是<strong>概念</strong>模型：E-R图</li>
<li>机器世界就是<strong>数据</strong>模型：数据表</li>
</ul>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><ul>
<li>基于信息世界的主要概念，表达语义。</li>
<li>语义表达能力强</li>
<li>清晰</li>
<li>最常用的表示方法：E-R法(Entity-Relation)</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>实体(Entity)：客观存在并可以<strong>相互区分</strong>的食物，在E-R图中为<strong>矩形</strong>。</p>
</li>
<li><p>属性(Attribute)：实体具有的某一<strong>特性</strong>，在E-R图中为<strong>椭圆形</strong>。</p>
</li>
<li><p>码(Key)：<strong>唯一</strong>的标识实体的<strong>属性集</strong>（至少一个，最多由属性集大小确定）</p>
</li>
<li><p>域(Domain)：某些属性的<strong>取值范围</strong></p>
</li>
<li><p>实体型(Entity Type)：表示一类实体(Class)</p>
<ul>
<li>用名称和属性集表示</li>
</ul>
</li>
<li><p>联系(Relation)：实体型之间的联系，在E-R图中为<strong>菱形</strong>。</p>
<ul>
<li>名称：产品<strong>由</strong>若干零件<strong>构成</strong></li>
<li>类型<ul>
<li>一对一(1:1)</li>
<li>一对多(1:n)</li>
<li>多对多(m:n)</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>联系可以具有<strong>属性</strong>，例如产品-组装-零件中，组装可以有<strong>零件数</strong>属性。</li>
<li>联系是有方向的，一对多<strong>不等价于反向</strong>的多对一。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="E-R"><a href="#E-R" class="headerlink" title="E-R"></a>E-R</h4><ul>
<li>用E-R图描述现实世界</li>
<li>将E-R图转换为数据模型</li>
</ul>
<h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul>
<li>实体</li>
<li>属性<ul>
<li>作为Key的属性<ul>
<li>在属性下画线，多个属性就都画。</li>
<li>在无向边上画两条杠</li>
<li>组合属性作为Key：在两条无向边之间画一条弧之后，在弧上画两条杠。</li>
</ul>
</li>
</ul>
</li>
<li>联系：无向边旁需要标注联系的类型（三选一）<ul>
<li>可能存在<strong>自相联</strong>关系</li>
<li>三个或多个实体可能通过<strong>一个联系</strong>建立关系</li>
<li>两个实体之间可能存在多种联系<ul>
<li>工人使用/维修仪器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h5><ul>
<li>存在依赖：<strong>有向边</strong>指向<strong>弱实体</strong>（依赖于其他实体的实体）<ul>
<li>弱实体是双层框</li>
</ul>
</li>
<li>标识依赖：<strong>有向边</strong>指向<strong>被标识实体</strong>（不能由自己的属性来唯一标识，需要和其他实体的属性组合起来作为Key）</li>
<li>实体的子类：<strong>无向边</strong>上画一个圆<ul>
<li>子类是外侧框加两条竖线</li>
<li>子类的交<strong>不一定</strong>为空</li>
</ul>
</li>
</ul>
<h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li>数据结构</li>
<li>数据操作</li>
<li>完整性约束</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>描述对象的相关性质</li>
<li>描述对象之间的联系，如关系模型中的关系。</li>
<li>数据<strong>静态特征</strong>的描述</li>
<li>三要素中<strong>最重要</strong>的方面</li>
</ul>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><ul>
<li><p>操作及操作规则</p>
</li>
<li><p>操作符号、操作规则、操作语言</p>
<blockquote>
<p>SQL就是一种操作语言</p>
</blockquote>
</li>
<li><p>数据<strong>动态特征</strong>的描述</p>
</li>
<li><p>数据库中主要有<strong>检索和更新</strong>两大类操作</p>
</li>
</ul>
<h4 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h4><ul>
<li>完整性规则的集合</li>
<li>模型通用的完整性约束条件</li>
<li>针对具体数据的特定语义的约束条件</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>层次模型：树<ul>
<li>最早出现</li>
<li>有向树，连线表示一对多的联系（包含一对一）。</li>
<li>结构简单，效率高，但是支持的联系的种类太少（只能直接表示<strong>二元一对多</strong>联系）</li>
</ul>
</li>
<li>网状模型：图<ul>
<li>有向图，连线表示一对多的联系（包含一对一）。</li>
<li>结构复杂，效率高。</li>
</ul>
</li>
<li>关系模型：二维表<ul>
<li>用二维表格表示实体及实体之间的联系</li>
<li><strong>规范化关系</strong>：每个分量（域）是<strong>不可分割</strong>的数据项，并且不能出现表中套表的情况。</li>
<li>有数学基础</li>
</ul>
</li>
</ul>
<h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><ul>
<li>三级模式<ul>
<li>外模式</li>
<li>模式</li>
<li>内模式</li>
</ul>
</li>
<li>两级映象<ul>
<li>外模式/模式映象</li>
<li>模式/内模式映象</li>
</ul>
</li>
<li>优点<ul>
<li>数据独立性</li>
<li>简化用户接口</li>
<li>有利于数据共享（外模式可以相互覆盖）</li>
<li>利于数据的安全保密</li>
</ul>
</li>
</ul>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul>
<li><strong>逻辑模式/概念模式</strong></li>
<li><strong>全体数据</strong>的逻辑结构和特性的描述，例如所有关系模式构成的集合。</li>
<li><strong>三级模式的核心</strong></li>
<li>模式描述语言(DDL, Data Description Language)</li>
</ul>
<h3 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h3><ul>
<li><p>个别用户的数据<strong>视图</strong>（与某一应用有关的数据逻辑表示）</p>
</li>
<li><p>通常是<strong>模式的子集</strong>（子模式）</p>
</li>
<li><p>不同的外模式可以相互覆盖，<strong>一个</strong>应用只能启用<strong>一个</strong>外模式。</p>
<blockquote>
<p>外模式和应用是<strong>一对多</strong>的关系</p>
</blockquote>
</li>
<li><p>外模式DDL，通常和应用具有相同的语法。</p>
</li>
</ul>
<h3 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h3><ul>
<li>存储模式，数据的物理结构和存储方式的描述。</li>
<li>内模式DDL</li>
</ul>
<h3 id="两级映象"><a href="#两级映象" class="headerlink" title="两级映象"></a>两级映象</h3><ul>
<li>数据<strong>逻辑</strong>独立性：外模式/模式映象</li>
<li>数据<strong>物理</strong>独立性：模式/内模式映象</li>
</ul>
<h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul>
<li>数据库的定义功能<ul>
<li>使用DDL语言描述外模式、模式、内模式（源模式）</li>
</ul>
</li>
<li>数据存取功能<ul>
<li>提供DML(Data Manipulation Language)语言进行CRUD</li>
</ul>
</li>
<li>数据库运行管理<ul>
<li>并发控制</li>
<li>存取控制</li>
<li>完整性</li>
<li>日志组织和管理</li>
<li>事务管理</li>
<li>自动恢复</li>
</ul>
</li>
</ul>
<h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul>
<li>语言编译处理程序</li>
<li>系统运行控制程序</li>
<li>系统建立和维护</li>
<li>数据字典（数据目录）：由若干个表组成</li>
</ul>
<h3 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h3><p>数据库管理员</p>
<ul>
<li>建库</li>
<li>用库</li>
</ul>
<h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
</ul>
<h1 id="Chapter2-关系数据库"><a href="#Chapter2-关系数据库" class="headerlink" title="Chapter2 关系数据库"></a>Chapter2 关系数据库</h1><p>全文共<code>1694</code>字，推荐阅读时间<code>15~20</code>分钟。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>关系理论建立在集合代数（离散数学）理论之上</li>
</ul>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>关系模型的数据结构：关系</p>
</li>
<li><p>域(Domain)：一组具有<strong>相同数据类型</strong>的值的集合</p>
</li>
<li><p>元组和分量</p>
<blockquote>
<p>多个<strong>域</strong>进行笛卡尔积运算可以表示为<strong>二维表</strong></p>
</blockquote>
</li>
<li><p>关系：笛卡尔积$D_1 \times D_2 \times …\times D_n$的<strong>子集</strong>叫做这些域上的关系，用$R(D_1,D_2,…,D_n)$表示。</p>
<ul>
<li><p>$R$：关系名</p>
</li>
<li><p>$n$：度/目</p>
</li>
<li><p><strong>关系二维表</strong></p>
<ul>
<li><p>每个列附加一个名称，被称为<strong>属性</strong>(Attribute)。</p>
<blockquote>
<p>属性的名字需要<strong>唯一</strong></p>
</blockquote>
</li>
<li><p>关系是元组构成的集合</p>
</li>
</ul>
</li>
<li><p>关系的列是<strong>同质</strong>的</p>
</li>
<li><p>不同的列可以出自同一域（自相关）</p>
</li>
<li><p>列的顺序可以互换</p>
</li>
<li><p>任何两个元组（行）<strong>不能</strong>完全相同</p>
</li>
<li><p>规范性：分量不可再分，即1NF（First Normal Form，第一范式）</p>
</li>
</ul>
</li>
</ul>
<h2 id="数据模型-2"><a href="#数据模型-2" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>数据结构：关系</p>
</li>
<li><p>码</p>
<ul>
<li><p>候选码(Candidate Key)：具有<strong>最小性</strong>和唯一标识功能的<strong>属性组</strong></p>
<ul>
<li>最小性：指候选码的子集不能够唯一标识当前记录，和候选码的<strong>属性个数</strong>无关。例如候选码A中可能只有一个属性，但是在候选码B中可能有两个其他的属性。</li>
</ul>
<blockquote>
<p>属性组中<strong>可以</strong>只有一个属性</p>
</blockquote>
</li>
<li><p>主码(Primary Key)：简称为码，在多个候选码中选定一个为主码。</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>主属性：<strong>所有候选码</strong>中的属性</li>
<li>非主属性：<strong>不包含</strong>在任何候选码中的属性</li>
</ul>
<blockquote>
<p>属性<strong>要么为</strong>主属性，<strong>要么为</strong>非主属性。</p>
</blockquote>
</li>
<li><p>关系模式：$R(U,D,dom,F,I)$</p>
<ul>
<li><p>$U$：属性名集合</p>
</li>
<li><p>$D$：域集合</p>
</li>
<li><p>$dom$：属性$\rightarrow$域的映象集合</p>
</li>
<li><p>$F$：数据依赖关系集合</p>
</li>
<li><p>$I$：完整性约束集合</p>
</li>
<li><p>关系是关系模式在<strong>某一时刻</strong>的<strong>状态或内容</strong></p>
<blockquote>
<p>关系模式相对稳定，可以理解成<strong>设计表</strong>；关系是动态的，是一张表的<strong>具体内容</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="语义约束"><a href="#语义约束" class="headerlink" title="语义约束"></a>语义约束</h3><p>前两个是<strong>模型</strong>必须支持的约束条件</p>
<ul>
<li><p>实体完整性</p>
<ul>
<li><p>主码必须存在，<strong>其中任何一个域</strong>都不能为空。</p>
<blockquote>
<p>空：不知道/不存在的值</p>
</blockquote>
</li>
</ul>
</li>
<li><p>参照完整性</p>
<ul>
<li><p>外部码(Foreign Key)如果有效，则对应的外表必须存在对应记录。</p>
<blockquote>
<ul>
<li>外部码可以是<strong>同一个关系</strong>之间的联系（即同<strong>一张表</strong>中<strong>不同</strong>元组之间的联系）</li>
<li>外部码可以为空</li>
<li>外部码可以是<strong>属性组</strong></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>用户定义完整性</p>
<ul>
<li>用户根据特定的应用环境定义的完整性约束条件</li>
</ul>
</li>
</ul>
<h3 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h3><ul>
<li><p>集合操作：操作的对象和结果<strong>都是</strong>集合</p>
</li>
<li><p>关系运算</p>
<ul>
<li>关系代数（代数方式）</li>
<li>关系演算（逻辑方式）<ul>
<li>元组关系</li>
<li>域关系</li>
</ul>
</li>
</ul>
<blockquote>
<p>各种运算之间等价，可以相互转换。</p>
</blockquote>
</li>
</ul>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><ul>
<li><p>常规集合运算：并、差、交、广义笛卡尔积</p>
<ul>
<li><p>广义笛卡尔积</p>
<p>对度为<code>n</code>、<code>m</code>的两个集合，元组数分别为<code>k1</code>、<code>k2</code>，它们笛卡尔积的结果</p>
<ul>
<li><p>度为$(n+m)$</p>
</li>
<li><p>元组共$k1*k2$个</p>
</li>
<li><p>当出现重名属性时，需要进行重命名。</p>
<blockquote>
<p>通常使用<code>Tablename.Fieldname</code>的组合进行重命名</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特殊关系运算：选择、投影、连接、自然连接、除法</p>
<ul>
<li><p>选择：在关系R中选择<strong>满足给定条件</strong>的元组，记为$\sigma_F(R)=\{t|t\in R,F(t)=True\}$.</p>
</li>
<li><p>投影：从关系中取若干属性列，并删去重复行，组成新的关系，记为$\Pi_A(R)=\{t[A]|t \in R, A \subseteq U\}$.</p>
</li>
<li><p>连接：在两个关系的<strong>广义笛卡尔积</strong>中，指定属性<strong>组</strong>$X,Y$，并且选择其中满足条件$\theta$的<strong>元组</strong>并返回<strong>整条组合记录</strong>构成的集合。</p>
<ul>
<li><p>$\theta$</p>
<ul>
<li><code>=</code>：等值连接</li>
<li><code>&lt;</code>：小于连接</li>
<li><code>&gt;</code>：大于连接</li>
</ul>
</li>
<li><strong>一个元组</strong>可能和<strong>多个元组</strong>进行连接</li>
</ul>
</li>
</ul>
</li>
<li><p>自然连接（更常用）：在笛卡尔积中选取在<strong>相同属性组列</strong>上<strong>取值相等</strong>的记录，并<strong>去掉重复</strong>的列。</p>
<ul>
<li>不能自定义$X,Y$</li>
<li>不能更换连接条件$\theta$</li>
</ul>
</li>
<li><p>除法：对关系$R(X,Y),S(Z)$，它们的除法记为：</p>
<p>$R \div S=\{t|t \in \Pi_X(R) \and \forall s\in S \and <t,s> \in R\}$.</p>
<ul>
<li>要求$Y,Z$域等价<ul>
<li>属性数相同</li>
<li>对应属性出自同样的域</li>
</ul>
</li>
<li>除法$A \div B$的意义就是<strong>A包含了多少个B</strong></li>
<li>通俗地说，把B认为是组别，除法的意义就是得到A中指定属性满足<strong>同时在B中所有组</strong>的<strong>投影</strong>。</li>
</ul>
</li>
<li><p>运算组合</p>
<ul>
<li>从内套外嵌套</li>
<li>（自然）连接的语义：指定域后跨表查找，同时<strong>保留其他域</strong>。</li>
<li>除法：解决<strong>“任意”</strong>问题</li>
<li>先投影再运算效率更高</li>
</ul>
</li>
<li><p>基本运算（可以推出其他运算）</p>
<ul>
<li>并</li>
<li>差</li>
<li>笛卡尔积</li>
<li>选择</li>
<li>投影</li>
</ul>
</li>
</ul>
<h2 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h2><ul>
<li>将<strong>谓词演算</strong>应用到关系运算中就是关系演算</li>
</ul>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul>
<li>以元组为变量</li>
<li>基本结构：元组演算表达式$\{t|\Phi(t)\}$表示所有使$\Phi$为真的<strong>元组</strong>集合</li>
<li>优先级<ul>
<li>算术比较</li>
<li>量词($\exists &gt; \forall$)</li>
<li>逻辑运算符</li>
</ul>
</li>
<li>例子<ul>
<li>$R1=\{t|R(t) \and t[3] \geq 4\}$：关系R中第三个域大于等于4的元组集合<ul>
<li>$R(t)$：$t$是关系$R$中的元组</li>
</ul>
</li>
<li>$R2=\{(\exists u)(R(t) \and W(u) \and t[3] &lt; u[3])\}$</li>
</ul>
</li>
</ul>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><ul>
<li>变量对应元组各个分量的域变量<ul>
<li>$R(t) \Rightarrow R(x_1,x_2,…x_n)$</li>
</ul>
</li>
<li>例子<ul>
<li>$R1=\{xyz|R(xyz) \and Z&lt;8 \and x=d\}$</li>
</ul>
</li>
</ul>
<h2 id="安全约束"><a href="#安全约束" class="headerlink" title="安全约束"></a>安全约束</h2><ul>
<li>关系代数是安全的，但是关系演算<strong>不一定</strong>安全。</li>
<li>无限关系：$\{t|\neg R(t)\}$集合有无穷多个元素</li>
<li>无穷运算：$\forall t(R(t))$，当$t$域无穷时，即为无穷验证运算。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>对$\Phi$定义一个有限符号集$DOM(\Phi)$，使$\Phi$中的运算结果和中间过程中产生的元组及其分量均属于$DOM(\Phi)$</li>
<li>在实现安全约束后，三种运算方式<strong>才是</strong>等价并且可以相互转换的。</li>
</ul>
<h2 id="关系数据语言"><a href="#关系数据语言" class="headerlink" title="关系数据语言"></a>关系数据语言</h2><ul>
<li>核心是查询，所以也称为查询语言。</li>
</ul>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li>数据定义（描述）语言(DDL)：包括模式DDL、外模式DDL、内模式DDL.</li>
<li>数据模拟语言(DML)：CRUD<ul>
<li>联机交互：独立于系统存在</li>
<li>宿主语言：嵌入在高级语言中</li>
</ul>
</li>
<li>数据控制语言(DCL)：安全性和完整性控制</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>一体化：例如SQL将DDL、DML、DCL的功能集成在一起</li>
<li>非过程化：用户不需要关注底层的实现细节</li>
<li>面向集合的存取方式<ul>
<li>操作对象是一个或多个关系</li>
<li>操作结果是新的关系</li>
</ul>
</li>
<li>可独立也可嵌套</li>
</ul>
<h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
</ul>
<h1 id="Chapter3-SQL"><a href="#Chapter3-SQL" class="headerlink" title="Chapter3 SQL"></a>Chapter3 SQL</h1><p>全文共<code>3006</code>字，推荐阅读时间<code>25~30</code>分钟</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>综合统一</li>
<li>高度<strong>非过程化</strong>（只注重交互结果，而不是具体的实现）</li>
<li>面向集合操作</li>
<li>同一个语法结构可以实现关系代数和关系演算两种使用方式</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>基本表：独立、实际存在的，有对应的实体文件。</p>
<blockquote>
<p>在SQL中，一个关系对应一个表。</p>
</blockquote>
</li>
<li><p>导出表：从<strong>一个或多个</strong>基本表导出的表，分为视图(View)和快照(Snapshot).</p>
<ul>
<li><p>视图</p>
<ul>
<li>虚表，只在数据字典中存储视图的定义。</li>
<li>视图可以进行CRUD基本操作，也可以用来定义新的视图。</li>
</ul>
<blockquote>
<p>SQL可以直接操作基本表（模式）和导出表（外模式）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>从目标表<code>T</code>中选择符合条件<code>Q</code>的目标列<code>C</code></p>
<blockquote>
<p><code>WHERE</code>相当于是<code>filter()</code></p>
</blockquote>
</li>
<li><p>表的水平方向：根据检索条件选择<strong>元组</strong>（记录）</p>
</li>
<li><p>表的垂直方向：对<strong>目标列</strong>进行投影</p>
</li>
</ul>
<h3 id="投影检索"><a href="#投影检索" class="headerlink" title="投影检索"></a>投影检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT C</span><br><span class="line">FROM T;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>DISTINCT</code>删去结果中的重复行</li>
</ul>
<h3 id="选取检索"><a href="#选取检索" class="headerlink" title="选取检索"></a>选取检索</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul>
<li><code>=</code>/<code>&lt;</code>等</li>
<li><code>AND</code>/<code>OR</code>/<code>NOT</code></li>
<li><code>()</code></li>
<li><code>BETWEEN ... AND ...</code></li>
</ul>
<blockquote>
<p><code>WHERE</code>子句<code>Q</code>中出现的列通常会在<code>SELECT C</code>中出现</p>
</blockquote>
<h3 id="排序检索"><a href="#排序检索" class="headerlink" title="排序检索"></a>排序检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T</span><br><span class="line">WHERE Q</span><br><span class="line">ORDER BY A ASC&#x2F;DESC;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>ASC</code>：根据<code>A</code>升序（<strong>缺省</strong>）</p>
</li>
<li><p><code>DESC</code>：根据<code>A</code>降序</p>
</li>
<li><p>多列排序，按照<strong>语句顺序</strong>进行多要素排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S</span><br><span class="line">ORDER BY SD ASC, SA DESC;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序语句通常放在<code>SELECT</code>语句的<strong>最后</strong></p>
</li>
</ul>
<h3 id="连接（连表）检索"><a href="#连接（连表）检索" class="headerlink" title="连接（连表）检索"></a>连接（连表）检索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT C</span><br><span class="line">FROM T1, T2</span><br><span class="line">WHERE T1.c1 &#x3D; T2.c2;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>c1</code>/<code>c2</code>被称为<strong>连接字段</strong></li>
<li>本质就是将<code>T1</code>，<code>T2</code>进行<strong>笛卡尔积</strong>操作，然后对新的表的符合条件的元组进行筛选。</li>
</ul>
<h4 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT X.SN, X.SA</span><br><span class="line">FROM S X, S Y</span><br><span class="line">WHERE X.SA&gt;Y.SA AND Y.SN&#x3D;&#39;xxx&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>连接后选取的属性（<code>SELECT</code>选择的属性）中如果有重名属性，<strong>也要加上表名</strong>用以区分。同时，在查询的时候不会被起别名，即返回结果中依然是<code>SN</code>/<code>SA</code>.</li>
<li>起别名后，原有的<code>S</code><strong>不能够</strong>再使用。</li>
</ul>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM S, SC</span><br><span class="line">WHERE S.S &#x3D; SC.S(*);</span><br></pre></td></tr></table></figure>
<ul>
<li>单纯使用连接语句可能造成信息丢失，例如没有选课的学生在连接学生表和选课表时会被忽略。</li>
<li>增加<code>*/+</code>的表中会<strong>增加</strong>万能空行与<strong>另一个表</strong>进行连接</li>
</ul>
<h3 id="嵌套检索"><a href="#嵌套检索" class="headerlink" title="嵌套检索"></a>嵌套检索</h3><ul>
<li>子查询（嵌套查询）：<code>WHERE</code>中包含的另一个查询块<ul>
<li>普通：与外部查询无关，<strong>可以单独执行</strong>获得一组值。</li>
<li>相关：把<strong>外查询的值</strong>作为检索的条件值，<strong>不可以</strong>单独执行。</li>
</ul>
</li>
<li>外部查询：包含子查询的语句</li>
</ul>
<h4 id="自身嵌套"><a href="#自身嵌套" class="headerlink" title="自身嵌套"></a>自身嵌套</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM s</span><br><span class="line">WHERE S.SA &#x3D; (SELECT SA FROM S WHERE S.SN &#x3D; &#39;xxx&#39;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>嵌套运算的效率<strong>高于</strong>连表运算，空间开销也更低。</p>
</blockquote>
<ul>
<li><p>子查询返回<strong>单值</strong>时可以直接使用<strong>运算符</strong>进行连接</p>
</li>
<li><p>子查询返回<strong>一组值</strong>，则需要在子查询结果前加上<code>ANY</code>/<code>ALL</code>.</p>
<ul>
<li><p><code>IN</code>可以替代<code>=ANY</code></p>
</li>
<li><p><code>NOT IN</code>可以替代<code>!=ALL</code>，<strong>不是</strong><code>!=ANY</code>.</p>
<blockquote>
<p><code>!=ALL</code>和<code>!=ANY</code>的区别</p>
<ul>
<li><code>!=ALL</code>：当左值和<strong>任意</strong>右值<strong>都不相等</strong>的时候为真</li>
<li><code>!=ANY</code>：当左值和<strong>某个</strong>右值<strong>不相等</strong>的时候为真</li>
</ul>
</blockquote>
</li>
<li><p><code>EXISTS</code>：当仅当<strong>子查询</strong>结果为<strong>非空</strong>时为真，即<code>filter()</code>的拓展，可以在<code>filter()</code>中放更加复杂的筛选条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE EXISTS</span><br><span class="line">	(SELECT * FROM SC WHERE SC.S&#x3D;S.S AND C&#x3D;&#39;xxx&#39;);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>相当于遍历S表中的每一个学生，然后利用学号在SC中进行检索。</li>
<li><strong>相关</strong>子查询，因为子查询的<code>S</code>不独立。</li>
<li><code>EXISTS</code>判定的方式决定了<code>SELECT</code><strong>不需要</strong>明确某一列</li>
</ul>
</blockquote>
</li>
<li><p><code>NOT EXISTS</code>：在子查询结果为<strong>空</strong>时返回真，可以使用<code>NOT EXISTS</code>表示谓词逻辑。</p>
<ul>
<li><p>单层<code>NOT EXISTS</code>：即<code>exclude()</code>，排除掉所有满足嵌套条件的记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM C</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">	(SELECT * FROM SC WHERE SC.C &#x3D; C.S);</span><br></pre></td></tr></table></figure>
</li>
<li><p>全称量词$\forall$：$(\forall x)P=\neg(\exist x(\neg P))$</p>
<ul>
<li><p>对命题和子命题都取反，把任意变成存在，然后根据等价命题进行SQL语句构造。</p>
</li>
<li><p><strong>检索选修所有课程的学生的姓名</strong></p>
<ul>
<li><p>$Given\ s,\forall cP(s,c).$</p>
<p>其中$P(s,c)$表示学生选上了这门课，为了能够返回布尔值，我们使用$EXISTS$语句进行包装。</p>
<p>将其转换为$Given\ s, \neg\exist c(\neg P(s,c))$（其中$\neg$就是<code>NOT</code>）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">	(SELECT * FROM C</span><br><span class="line">     WHERE NOT EXISTS</span><br><span class="line">     	 (SELECT * FROM SC WHERE SC.S&#x3D;S.S AND SC.C&#x3D;C.C))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命题等价于：不存在没有选修的课程的学生的姓名，即排除没有全部选修的学生。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>蕴涵：$p \rightarrow q = \neg p \or q$</p>
<ul>
<li><p><strong>检索至少选修了学生S2选修的全部课程的学生学号</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT S</span><br><span class="line">FROM SC SCX</span><br><span class="line">WHERE NOT EXISTS # 不存在S2选了但是该学生没选的课程，所以下面是S2选了但是他没选的。</span><br><span class="line">	(SELECT * FROM SC SCY</span><br><span class="line">     WHERE SCY.S&#x3D;S2 AND NOT EXISTS ( # 他没有选择这门课</span><br><span class="line">     	SELECT * FROM SC SCZ WHERE SCZ.S&#x3D;SCX.S AND SCZ.C&#x3D;SCY.C))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p</code>：S2选修了某门课</li>
<li><code>q</code>：该学生也要选修这门课</li>
</ul>
<blockquote>
<p>命题等价于：不存在S2选修但是他没有选修的课程</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>用<code>NOT EXISTS</code>表示谓词逻辑：</p>
<ul>
<li>使用纯数理逻辑进行推导，但是对于谓词过多的情况可能出现问题。</li>
<li><strong>把命题改写成“不存在…”的形式，然后逐层使用<code>NOT EXISTS</code>.</strong></li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="并、差、交检索"><a href="#并、差、交检索" class="headerlink" title="并、差、交检索"></a>并、差、交检索</h3><p>操作对象必须是<strong>相容</strong>的：有相同的属性列。</p>
<ul>
<li><p>UNION</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c1&#39;</span><br><span class="line">UNION</span><br><span class="line">SELECT S FROM SC WHERE C&#x3D;&#39;c2&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MINUS</p>
</li>
<li><p>INTERSECT</p>
</li>
</ul>
<h3 id="库函数检索"><a href="#库函数检索" class="headerlink" title="库函数检索"></a>库函数检索</h3><ul>
<li><p><code>COUNT()</code>：按<strong>列值</strong>计数，统计<strong>属性数</strong>。</p>
<blockquote>
<p><code>COUNT(*)</code>：对<strong>行</strong>计数，统计<strong>记录数</strong>。</p>
</blockquote>
</li>
<li><p><code>SUM()</code>：对数值列求总和</p>
</li>
<li><p><code>AVG()</code>：对数值列求平均</p>
</li>
<li><p><code>MAX()</code>：在列中找出最大值</p>
</li>
<li><p><code>MIN()</code>：在列中找出最小值</p>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li><p>只能在<code>SELECT</code>和<code>HAVING</code>子句中出现</p>
</li>
<li><p>检索学生总数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM S;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检索选择了课程的学生总数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT S)</span><br><span class="line">FROM SC;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<code>DISTINCT</code>的位置</p>
</blockquote>
</li>
<li><p>求S4的总分和平均分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(G), AVG(G)</span><br><span class="line">FROM SC</span><br><span class="line">WHERE SC.S&#x3D;&#39;S4&#39;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分组检索"><a href="#分组检索" class="headerlink" title="分组检索"></a>分组检索</h3><p>按<strong>属性列</strong>将记录分组，每组具有某个共同特征，然后对每一组进行<code>SELECT</code>操作。（相当于对记录进行了<strong>打包</strong>）</p>
<ul>
<li><p>分组子句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GROUP BY C</span><br><span class="line">[HAVING conditionExpression]</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>WHERE</code>是对<strong>行</strong>进行过滤，去掉不符合条件的行。</p>
</li>
<li><p><code>HAVING</code>只能对<strong>分组</strong>进行过滤，必须建立在<code>GROUP BY</code>之上.</p>
<blockquote>
<p><code>WHERE-&gt;GROUP BY-&gt;HAVING</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>检索至少选修了三门课的学生学号和选课门数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, COUNT(*)</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY S</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 3;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>GROUP BY</code>同时影响了<code>SELECT</code>的范围，相当于是<code>FROM SC GROUP BY S</code>.</p>
</blockquote>
</li>
</ul>
<h3 id="算术表达式值检索"><a href="#算术表达式值检索" class="headerlink" title="算术表达式值检索"></a>算术表达式值检索</h3><ul>
<li><p>为算术表达式起别名提高可读性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT EMPN, BONUS&#x2F;SALARY BS</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><ul>
<li><p><code>LIKE/NOT LIKE</code>：对字符型列适用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># &lt;列名&gt; LIKE&#x2F;NOT LIKE &lt;字符串常量&gt;</span><br><span class="line">SELECT S, SN</span><br><span class="line">FROM S</span><br><span class="line">WHERE SN LIKE &#39;刘%&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;字符串常量&gt;</code>可包含特殊符号<ul>
<li><code>%</code>：通配<strong>0或多个</strong>字符</li>
<li><code>_</code>：通配<strong>单个</strong>字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h3><ul>
<li><p>MySQL目前不支持</p>
</li>
<li><p>出现在<code>FROM</code>中的子查询生成的表叫做派生表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S, C</span><br><span class="line">FROM SC, (SELECT S, AVG(G) FROM SC GROUP BY S) AS AVG_SC(AVG_S,AVG_G)</span><br><span class="line"># WHERE ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><ul>
<li>基本表：定义、删除、<strong>修改</strong></li>
<li>视图：定义、删除</li>
<li>索引：定义、删除</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><code>char(n)</code>：固定长度的字符串</li>
<li><code>varchar(n)</code>：可变长字符串</li>
<li><code>numeric(p, q)</code>：定点数共<code>p</code>位，小数点右边<code>q</code>位。</li>
<li><code>interval</code>：两个<code>date</code>或<code>time</code>类型数据之间的差</li>
</ul>
<h3 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;tablename&gt; (&lt;columnname&gt;&lt;datatype&gt;[&lt;columnintegrity&gt;],...);</span><br><span class="line">ALTER TABLE &lt;tablename&gt; (ADD&#x2F;DROP&#x2F;MODIFY);</span><br></pre></td></tr></table></figure>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li><p>创建学生表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(S CHAR(5) NOT NULL UNIQUE,</span><br><span class="line"> SN CHAR(50) NOT NULL,</span><br><span class="line"> SA INT NOT NULL,</span><br><span class="line"> PRIMARY KEY(S),</span><br><span class="line"> CHECK (SA&gt;&#x3D;18 AND SA&lt;&#x3D;45));</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE S ADD SCOME DATE;</span><br><span class="line">ALTER TABLE S MODIFY SA SMALLINT; # modify the data type</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除基本表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE S;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>为了对<strong>经常查询的属性</strong>的存取进行<strong>加速</strong>而提出的策略</p>
<ul>
<li>索引项：属性组取值</li>
<li>位置指针：索引对应的记录存储的位置</li>
<li>索引文件是<strong>排序文件</strong>，进而加快了查找速度。</li>
</ul>
<h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE][CLUSTER] INDEX &lt;indexname&gt; ON &lt;tablename&gt; (&lt;columnname&gt;[sequence]);</span><br><span class="line">DROP UNIQUE INDEX &lt;indexname&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>CLUSTER</code>：索引项的指针所指的<strong>内存顺序</strong>和<strong>实际数据库</strong>中的顺序是相同的（不常使用）</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX Scno ON SC (S ASC, C DESC);</span><br><span class="line">DROP INDEX Scno ON S;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>DROP INDEX</code>可以作为<code>ALTER TABLE</code>的子句使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON tablename;</span><br><span class="line">ALTER TABLE tablename DROP INDEX index_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul>
<li>视图是一个虚表，属于外模式。</li>
<li>视图消解(View Resolution)：对视图的操作会被等价的转化为对<strong>基本表</strong>的操作，然后再执行。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>简化用户操作</li>
<li>为同样的原始数据提供不同的角度（为一间房子在不同的方向开了窗）</li>
<li>逻辑独立性（数据的逻辑结构改变时，应用程序对数据的操作不需要改变）</li>
<li>安全保护（权限管理）</li>
</ul>
<h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW &lt;viewname&gt; [&lt;columnname&gt;] AS &lt;subquery&gt; [WITH CHECK OPTION];</span><br><span class="line">DROP VIEW &lt;viewname&gt; [IF EXISTS &lt;viewname&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li><code>WITH CHECK OPTION</code>：让用户只能对视图中的数据进行CRUD，从而保护了数据库中的其他数据。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW CS_Student</span><br><span class="line">AS</span><br><span class="line">SELECT S, SN, SA FROM S</span><br><span class="line">WHERE SD&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在视图上查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S,SA</span><br><span class="line">FROM CS_Student</span><br><span class="line">WHERE SA&lt;20;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li><p>单个元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;tablename&gt; (&lt;columnname1&gt;,...) VALUES (&lt;value1&gt;,...);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO S VALUES (&#39;xxx&#39;, &#39;yyy&#39;, &#39;zzz&#39;);</span><br><span class="line">INSERT INTO SC (S, C) VALUES (&#39;xxx&#39;, &#39;yyy&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>子查询结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO DA(SD, Aveage)</span><br><span class="line">SELECT SD, AVG(SA) FROM S GROUP BY SD;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;tablename&gt; SET &lt;columnname&gt;&#x3D;&lt;expression&gt;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE SC</span><br><span class="line">SET G&#x3D;666</span><br><span class="line">WHERE &#39;CS&#39;&#x3D;(SELECT SD FROM S</span><br><span class="line">           	WHERE S.S&#x3D;SC.S);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>WHERE</code>中可以把常量放在等号<strong>左边</strong></p>
</blockquote>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;tablename&gt; [WHERE &lt;conditions&gt;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<strong>不是</strong><code>DROP</code></p>
</blockquote>
<h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><ul>
<li><p>空值用<code>NULL</code>表示</p>
<ul>
<li>不能确定的值</li>
<li>属性不应该被赋值</li>
<li>属性值不方便填写</li>
</ul>
</li>
<li><p>属性有<code>NOT NULL</code>或者<code>UNIQUE</code>约束的，以及主属性不能够为<code>NULL</code>.</p>
<blockquote>
<p>部分系统允许<code>UNIQUE</code>为空</p>
</blockquote>
</li>
</ul>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul>
<li>算数运算：<code>NULL</code></li>
<li>比较运算：<code>UNKNOWN</code></li>
<li>逻辑运算：除了<code>False AND NULL</code>和<code>True OR NULL</code>可以确定之外，其余都为<code>UNKNOWN</code>.</li>
</ul>
<h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><ul>
<li>使用<code>IS NULL</code>或<code>IS NOT NULL</code>判断</li>
</ul>
<h2 id="数据控制"><a href="#数据控制" class="headerlink" title="数据控制"></a>数据控制</h2><ul>
<li><p>完整性约束</p>
</li>
<li><p>事务操作</p>
</li>
<li><p>安全控制</p>
<ul>
<li><p>授权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; TO &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>收回权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;permission&gt; ON &lt;objecttype&gt; &lt;objectname&gt; FROM &lt;userxxx&gt;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h2><ul>
<li><p>将SQL的特性和程序设计语言的<strong>过程处理能力</strong>结合起来</p>
</li>
<li><p>预编译</p>
<ul>
<li>把嵌入在程序中的SQL语句翻译为高级语言源码，然后再编译、链接、执行。</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li><p>区分SQL和高级语言：在SQL语句前加<code>EXEC SQL</code></p>
</li>
<li><p>数据库工作单元和程序工作单元之间的通信：通过主变量（主程序语言变量）的值来传递</p>
</li>
<li><p>SQL和主语言之间操作方式的协调：通过游标(<code>Cursor</code>)解决，由游标进行记录的操作，然后将结果传递给主变量。</p>
<blockquote>
<p>游标时系统开辟的存放SQL执行结果的缓冲区</p>
</blockquote>
</li>
</ul>
</li>
<li><p>动态SQL：允许嵌入式语句的某些参数不确定，在运行时动态生成<code>SQL</code>语句。</p>
</li>
<li><p>ODBC/JDBC</p>
<ul>
<li><p>执行效率相比嵌入式SQL低，但是开发效率高。</p>
</li>
<li><p>组件</p>
<ul>
<li>应用程序</li>
<li>驱动程序管理器</li>
<li>驱动程序</li>
<li>数据源</li>
</ul>
<blockquote>
<p>不同的数据库提供相同的API接口，通过驱动管理程序即可以实现程序的移植性。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
</ul>
<h1 id="Chapter4-数据库设计"><a href="#Chapter4-数据库设计" class="headerlink" title="Chapter4 数据库设计"></a>Chapter4 数据库设计</h1><p>全文共<code>2640</code>字，推荐阅读时间<code>20~25</code>分钟。</p>
<h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><ul>
<li>直接设计法（手工试凑）<ul>
<li>高度依赖开发人员经验</li>
<li>后期维护困难</li>
<li>移植困难</li>
<li>难以合作设计</li>
</ul>
</li>
<li>规范设计法<ul>
<li>将设计过程分为若干个阶段，每个阶段只解决整个设计中的部分问题。<ul>
<li>需求分析：调查应用环境</li>
<li>概念结构设计（在三级模式两级映象中<strong>没有</strong>对应的部分）：形成可以<strong>用E-R图</strong>表示的模型</li>
<li>逻辑结构设计（<strong>概念模型</strong>，即模式、信息世界）：将E-R图转换成DBMS的模式和子模式</li>
<li>物理结构设计（<strong>数据模型</strong>，即内模式、机器世界）：存储结构（内模式）和存取方法（例如索引）</li>
<li>数据库实施：建立数据库</li>
<li>数据库运行和维护</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>处理要求</li>
<li>信息要求</li>
<li>安全性和完整性要求</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>和用户交流</p>
</li>
<li><p>分析、表达用户需求</p>
<ul>
<li><p>用<strong>数据流图</strong>表达数据和处理之间的关系</p>
<ul>
<li>数据流图(Data Flow Diagram, DFD)：表达系统逻辑功能和数据逻辑流向和逻辑变换<ul>
<li><strong>自顶向下</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>用<strong>数据字典</strong>描述系统中各类数据</p>
<ul>
<li><p>数据字典：对数据进行集中的说明，包含数据元素的名字、含义等。</p>
<ul>
<li>从数据流图中提取原子数据项</li>
<li>把有联系的数据项组合为数据组</li>
</ul>
<blockquote>
<p>上述数据字典和在数据库实施阶段的数据字典<strong>不同</strong>，前者可以看作是现实世界的<strong>数据元素表</strong>，后者是数据库系统的组成部分。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><ul>
<li>概念结构是信息世界的结构，即概念模型。</li>
</ul>
<h3 id="E-R法"><a href="#E-R法" class="headerlink" title="E-R法"></a>E-R法</h3><ul>
<li>描述概念模型</li>
<li>组成部分<ul>
<li>E-R图</li>
<li>转换E-R图为对应的数据模型</li>
</ul>
</li>
</ul>
<h4 id="E-R图概述"><a href="#E-R图概述" class="headerlink" title="E-R图概述"></a>E-R图概述</h4><ul>
<li>组成<ul>
<li>实体（方框）</li>
<li>属性（椭圆框）</li>
<li>联系（菱形框）<ul>
<li>联系也可以有属性，例如学生和课程的选修联系可以拥有成绩属性。</li>
<li>两个实体型之间可以具有多种联系，例如机器和工人可以有使用、维修两种联系。</li>
<li>语义扩充<ul>
<li>存在依赖(<code>E</code>)</li>
<li>标识依赖(<code>E&amp;I</code>)</li>
<li>实体的子类（连线上有一个圈）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="E-R图设计"><a href="#E-R图设计" class="headerlink" title="E-R图设计"></a>E-R图设计</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>自顶向下</p>
</li>
<li><p>自底向上<strong>（最常用）</strong></p>
<blockquote>
<p>自顶向下需求分析，自底向上概念设计。</p>
</blockquote>
</li>
<li><p>逐步扩张：先定义核心概念结构</p>
</li>
<li><p>混合策略</p>
</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>以自底向上为例</p>
<h5 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h5><ul>
<li>分类</li>
<li>聚集：定义某个实体型的组成成分</li>
<li>概括：定义类型之间的子集联系</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li><p>设计<strong>局部</strong>E-R图</p>
<ul>
<li><p>选择局部应用</p>
</li>
<li><p>利用数据抽象建立实体模型</p>
</li>
<li><p>确定实体之间的联系</p>
</li>
<li><p>必要调整（属性上升为实体）</p>
<ul>
<li><p>属性规范化（不可分割）：E-R图中属性不能和其他属性有<strong>关系</strong>（包括联系）</p>
</li>
<li><p>一个属性不能和多个实体之间有联系</p>
</li>
<li><p>属性和实体之间应该是“一对一”或者“多对一”的关系，不能“多对多”或者“一对多”。（即实体的某个属性取值是否确定）</p>
<blockquote>
<p>例如学生和课程号可能是“多对多”的关系，因此需要将课程号上升为实体。</p>
<ul>
<li>这里的多对多和<strong>实体</strong>之间的多对多不同，后者是靠<strong>联系</strong>体现的。但前者指<strong>取值的个数</strong>，例如存在一个学生有多门课，那么课程号的取值有多个，即一对多。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>综合<strong>局部</strong>E-R图</p>
<ul>
<li><p>集成</p>
<ul>
<li>一次集成</li>
<li>逐步集成：累加</li>
</ul>
</li>
<li><p>消除冲突</p>
<ul>
<li><p>属性：类型、取值范围、取值单位</p>
<blockquote>
<p>协商讨论</p>
</blockquote>
</li>
<li><p>命名</p>
<blockquote>
<p>建立命名表</p>
</blockquote>
</li>
<li><p>结构</p>
<ul>
<li><p>同一个对象在不同应用中抽象层次不同，例如一个为实体，在另一个中为属性。</p>
<blockquote>
<p>实体上升或属性下降，通常为前者。</p>
</blockquote>
</li>
<li><p>同一个实体在不同应用中描述不同，例如属性个数、次序不同。</p>
<blockquote>
<p>取并集</p>
</blockquote>
</li>
<li><p>联系类型不同</p>
<blockquote>
<p>根据语义综合</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>消除冗余：集成得到的初步E-R图可能存在<strong>数据冗余</strong>和<strong>联系冗余</strong>，调整过后得到<strong>基本E-R图</strong>。</p>
<ul>
<li>分析法<ul>
<li>重点考察<strong>联系的属性</strong>（可能由其他的属性表示，<strong>不一定成环</strong>）</li>
</ul>
</li>
<li>规范化方法</li>
</ul>
<blockquote>
<p>冗余危害：数据不一致。当某个属性变化时，需要更改所有相关的冗余属性，少改任何一个就会出问题。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><ul>
<li><p>把概念模型（E-R图）转换为DBMS支持的数据模型（模式）的过程</p>
</li>
<li><p>任务</p>
<ul>
<li><p>形成初始关系数据库模式：关系</p>
<blockquote>
<p>其他的数据库可能是网状、层次等结构。</p>
</blockquote>
</li>
<li><p>关系模式规范化：特定DBMS支持下的数据模型</p>
</li>
<li><p>关系模式优化</p>
</li>
<li><p>子模式定义（定义外模式）</p>
<blockquote>
<p>模式是很多张表的<strong>规范</strong>（设计表），关系是具体的<strong>数据内容</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="E-R图与关系模型"><a href="#E-R图与关系模型" class="headerlink" title="E-R图与关系模型"></a>E-R图与关系模型</h3><h4 id="普适转换规则"><a href="#普适转换规则" class="headerlink" title="普适转换规则"></a>普适转换规则</h4><blockquote>
<p>一个关系模式就是一种<strong>数据模型</strong></p>
</blockquote>
<ul>
<li><p>前提：确定每个关系模式的<strong>码</strong></p>
</li>
<li><p>一个实体型转换为一个关系模式</p>
</li>
<li><p>一个联系转换为一个关系模式</p>
<ul>
<li><p><code>1:1</code>：每个实体的码均是该联系的候选码，任意选择一个作为联系模型的主码即可。</p>
<blockquote>
<p><strong>不可以</strong>同时选，因为不满足码的<strong>最小性</strong>。</p>
</blockquote>
</li>
<li><p><code>1:n</code>：关系的码是<strong><code>n</code>端实体</strong>的码</p>
<blockquote>
<ul>
<li><code>n</code>端实体码才有唯一标识作用</li>
<li><strong>不是<code>n</code>端所有实体码的组合</strong></li>
</ul>
</blockquote>
</li>
<li><p><code>m:n</code>：关系的码是<strong>两端所有</strong>实体码的组合</p>
</li>
</ul>
<blockquote>
<ul>
<li>一般只有<code>n:m</code>关系才有属性，其他的联系都可以整合进属性，例如<code>1:n</code>可以在<code>n</code>端实体增加存放<code>1</code>端的码。</li>
<li>只选择一端实体的码<strong>不代表</strong>只存储一端实体的属性</li>
</ul>
</blockquote>
</li>
<li><p>多元联系转换为一个关系模式</p>
</li>
<li><p>具有相同的码的关系可以<strong>合并</strong>。例如消耗关系和零件的码都是零件号，就可以合并为一个关系。</p>
<blockquote>
<p>合并后可能和概念模型E-R图规范不符，但是在逻辑结构设计环节是合法的。</p>
</blockquote>
</li>
</ul>
<h4 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h4><p>存在依赖中依赖别的实体的实体</p>
<ul>
<li>为每个弱实体创建新的关系</li>
<li>将<strong>被依赖关系的码</strong>作为新关系的<strong>外码</strong></li>
<li>新关系的主码是<strong>被依赖实体的码</strong>和<strong>自身部分标识属性</strong>的组合</li>
</ul>
<h4 id="超类-子类联系"><a href="#超类-子类联系" class="headerlink" title="超类/子类联系"></a>超类/子类联系</h4><ul>
<li><p>为超类和每个子类创建单独的关系</p>
</li>
<li><p>超类关系中，<strong>包含所有子类共有的属性</strong>，包括<strong>主码</strong>。</p>
</li>
<li><p>在超类中选定属性组作为子类的判定符</p>
</li>
<li><p>子类关系中，包含超类主码以及子类特有的属性。（<strong>没有</strong>共有属性）</p>
<blockquote>
<p>子类使用超类的主码作为自己的主码</p>
</blockquote>
</li>
</ul>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul>
<li>确定范式等级（通常需要达到3NF）</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>模式的合并和分解</li>
<li>关系模式的分解可以提高存取效率和存储空间的利用率</li>
</ul>
<h4 id="水平分解"><a href="#水平分解" class="headerlink" title="水平分解"></a>水平分解</h4><ul>
<li><p>选取操作</p>
</li>
<li><p><code>2-8</code>原则：常使用的部分提取出来作为一个关系</p>
</li>
<li><p>数据分片：根据不相交的事务将关系分解为多个子关系</p>
<blockquote>
<p>事务：一组相对独立的操作</p>
</blockquote>
</li>
<li><p>恢复：并运算</p>
</li>
</ul>
<h4 id="垂直分解"><a href="#垂直分解" class="headerlink" title="垂直分解"></a>垂直分解</h4><ul>
<li><p>投影操作</p>
</li>
<li><p>将经常使用的属性提取出来作为一个子关系模式</p>
</li>
<li><p>垂直分解需要保证<strong>无损连接性</strong>和<strong>保持函数依赖</strong>（能够完全复原关系）</p>
<blockquote>
<p>完全复原的必要条件：垂直分解得到的子关系模式保留了主码</p>
</blockquote>
</li>
<li><p>恢复：连表运算</p>
</li>
</ul>
<h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><ul>
<li>用户需求</li>
<li>具体DBMS的特点，例如MySQL是<code>CREATE VIEW</code>.<ul>
<li>根据不同的用户设置不同的列名</li>
<li>权限管理保证系统的安全性</li>
<li>降低复杂查询的难度</li>
</ul>
</li>
</ul>
<h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><ul>
<li>确定数据库的存储结构（内模式）</li>
<li>存取方法</li>
</ul>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul>
<li>存放位置<ul>
<li>冷热数据分开存放</li>
<li>数据和日志备份放在<strong>不同的磁盘</strong>上</li>
</ul>
</li>
<li>系统配置<ul>
<li>存储分配参数</li>
<li>物理优化</li>
</ul>
</li>
</ul>
<h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><ul>
<li><p>索引记录/索引项：索引文件的记录</p>
<ul>
<li>索引域：数据文件中属性组的<strong>一个取值</strong></li>
<li>指针：指向索引域对应的磁盘块地址</li>
</ul>
<blockquote>
<p>在MySQL的底层，在发起查询时会先查找记录索引域的数据区，然后确定是否对索引进行查找。</p>
</blockquote>
</li>
<li><p>分类</p>
<ul>
<li>稀疏索引：把所有数据记录按索引值分组，每组设立一个索引项。</li>
<li>稠密索引：为每个记录设置一个索引项，记录的存放是任意的，但是<strong>索引是有序</strong>的。</li>
</ul>
</li>
<li><p>多级索引</p>
<ul>
<li>（排序）二叉树索引</li>
<li>多叉树索引：每个结点有<code>D</code>个值作为分界点，共<code>(D+1)</code>个指针。</li>
<li>平衡树索引：限制每个结点放置的关键字和指针最小/最大个数，从而使所有的叶子结点都在一层。</li>
<li><code>B+</code>树索引（常用）：把树中所有关键字按<strong>递增次序</strong>从左到右安排在叶结点上，并<strong>链接</strong>起来。</li>
</ul>
</li>
<li><p>索引域选择</p>
<ul>
<li>经常被查询的属性</li>
<li>经常作为库函数的参数</li>
<li>经常作为连接属性</li>
</ul>
<blockquote>
<p>索引并非越多越好</p>
</blockquote>
</li>
</ul>
<h4 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h4><ul>
<li><p>将关系中<strong>某个属性组值相同</strong>的记录集中存放在<strong>连续的物理块</strong>中，可以提高查询速度。</p>
<blockquote>
<p>就像同学院的同学安排在一栋宿舍楼中</p>
</blockquote>
</li>
<li><p><strong>一个</strong>关系<strong>只能</strong>参与<strong>一个</strong>聚集（一个关系只能被存储一次）</p>
</li>
<li><p>选择原则</p>
<ul>
<li>经常进行连接操作的关系</li>
<li>单个关系中经常比较的属性组</li>
<li>关系<strong>属性组值</strong>重复率高的属性组</li>
<li>更新操作较多时<strong>不应该</strong>使用聚集方法</li>
</ul>
</li>
</ul>
<h4 id="HASH文件"><a href="#HASH文件" class="headerlink" title="HASH文件"></a>HASH文件</h4><ul>
<li><p>通过HASH函数将记录关键字转换成地址，并将这个地址作为<strong>记录</strong>的存储地址。</p>
</li>
<li><p>选择原则</p>
<ul>
<li><p>关系大小可预知，并且不变。</p>
<blockquote>
<p>如果大小会变化，DBMS需要提供对应的动态HASH存取方法。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
</ul>
<h1 id="Chapter5-关系数据理论"><a href="#Chapter5-关系数据理论" class="headerlink" title="Chapter5 关系数据理论"></a>Chapter5 关系数据理论</h1><p>全文共<code>4341</code>字，推荐阅读时间<code>30~45</code>分钟。</p>
<h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul>
<li>数据依赖：影响<strong>模式质量</strong>的因素<ul>
<li>关系内部属性之间的约束关系</li>
<li>分类<ul>
<li>函数依赖</li>
<li>多值依赖</li>
</ul>
</li>
</ul>
</li>
<li>范式理论：衡量模式质量的标准</li>
<li>规范化方法与算法：提升模式质量的办法</li>
</ul>
<h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>给定属性集$U$，及其子集$X$，$Y$，$R(U)$是其上的<strong>关系模式</strong>（域名元组），$r$是$R$的<strong>任意一个</strong>具体关系（填入了任意的具体内容），$t$，$s$是$r$中<strong>任意</strong>两个元组。</p>
<ul>
<li>如果$t[X]=s[X]$，则$t[Y]=s[Y]$.此时称“$X$函数确定$Y$”或“$Y$函数依赖于$X$”，记作$X\rightarrow Y$.</li>
</ul>
<blockquote>
<p>等价定义：对于$X$的每个具体值，$Y$有唯一的值与之对应。</p>
</blockquote>
</li>
<li><p>函数依赖属于<strong>语义</strong>范畴</p>
</li>
<li><p>函数依赖具有时间稳定性，<strong>不随</strong>时间改变。</p>
<blockquote>
<p><code>r</code>（具体关系）可能会发生变化，但是函数依赖<strong>不会</strong>发生改变。</p>
</blockquote>
</li>
</ul>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li>平凡依赖：若$Y\subseteq X$，则$X\rightarrow Y$是平凡依赖。</li>
<li>非平凡</li>
<li>决定因素：$X$被称为决定因素</li>
</ul>
<h4 id="属性联系"><a href="#属性联系" class="headerlink" title="属性联系"></a>属性联系</h4><ul>
<li><code>1:1</code>：$X\rightarrow Y,Y \rightarrow X$，即两者<strong>相互决定</strong>。</li>
<li><code>1:n</code>：<code>n</code>端项($X$)决定<code>1</code>端项($Y$)，即$X\rightarrow Y$.</li>
<li><code>m:n</code>：两者之间<strong>不存在</strong>函数依赖</li>
</ul>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>完全：$X$的<strong>任意</strong>真子集（除空集）都<strong>不能够</strong>确定$Y$，记为$X \rightarrow Y$（箭头上有一个<code>f</code>）。</p>
</li>
<li><p>部分：$X\rightarrow Y$（箭头上有一个<code>p</code>）</p>
</li>
<li><p>传递：若$X\rightarrow Y(Y\nsubseteq X),Y\rightarrow Z(Z\nsubseteq Y)$，且$Y$<strong>不确定</strong>$X$，则称为$Z$对$X$<strong>传递</strong>函数依赖（箭头上有一个<code>t</code>）。</p>
<blockquote>
<ul>
<li>如果$Y$可以确定$X$，则$Z$对$X$是<strong>直接</strong>依赖（因为可以归为以上三种类型之一，因此<strong>不是</strong>独立的类型）。</li>
<li>注意传递依赖要求两个函数依赖都是<strong>非平凡</strong>的</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="关系键"><a href="#关系键" class="headerlink" title="关系键"></a>关系键</h3><ul>
<li>候选码：设$K$是$R<U,F>$（$F$是属性集$U$上的函数依赖<strong>集</strong>）的属性或属性组合，若$U$<strong>完全依赖</strong>于$K$，则称$K$是$R$的候选码。当候选码多于一个时，选定其中一个作为主码。</li>
<li>性质<ul>
<li>唯一性</li>
<li>最小性</li>
</ul>
</li>
<li>属性分类<ul>
<li>主属性：包含在<strong>任一候选码</strong>中的属性</li>
<li>非主属性：不包含在任何候选码中的属性</li>
</ul>
</li>
<li>外码：关系模式$R$中的属性或属性组$X$并非$R$的码，但$X$是另一个关系模式的码，则称$X$是$R$的外码。</li>
</ul>
<h3 id="逻辑蕴涵"><a href="#逻辑蕴涵" class="headerlink" title="逻辑蕴涵"></a>逻辑蕴涵</h3><ul>
<li>通过函数依赖集$F$能够推出$X\rightarrow Y$，则称$F$逻辑蕴涵$X\rightarrow Y$.</li>
<li>$F$的闭包：$F$蕴涵的<strong>全体函数依赖</strong>称为$F$的闭包，记为$F^+$.</li>
</ul>
<h3 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h3><ul>
<li><p>定律（可从蕴涵定义出发证明）</p>
<p>对$R<U,F>$</p>
<ul>
<li><p>自反律：属性集蕴涵其<strong>子集</strong></p>
</li>
<li><p>增广率：对属性$Z\subseteq U$，若$X\rightarrow Y$，则$XZ\rightarrow YZ$.</p>
<blockquote>
<p>$XZ$：将两个属性组<strong>直接拼接</strong></p>
</blockquote>
</li>
<li><p>传递率</p>
</li>
</ul>
</li>
<li><p>推论</p>
<ul>
<li>合并：若$X\rightarrow Y, X\rightarrow Z$，则$X\rightarrow YZ$.</li>
<li>伪传递：若$X \rightarrow Y, WY\rightarrow Z$，则$WX\rightarrow Z$.</li>
<li>分解：若$X\rightarrow Y$且$Z\subseteq Y$，则$X \rightarrow Z$.</li>
</ul>
</li>
<li><p>定理</p>
<p>$X\rightarrow A_1A_2…A_k \Longleftrightarrow X\rightarrow A_i(i=1,2,…,k)$</p>
</li>
<li><p>属性集闭包：$X\subseteq U$，将所有从$X$出发，通过$F$能够导出的<strong>属性的集合</strong>，记为$X_F^+$.</p>
<ul>
<li>$K_F^+=U$，即通过主码能够推出全体属性。</li>
<li>定理：$X\rightarrow Y \Longleftrightarrow Y\subseteq X_F^+$</li>
</ul>
</li>
<li><p>有效性（正确性）：从$F$出发，根据Armstrong公理导出的所有函数依赖一定在$F$蕴涵的<strong>全体函数依赖</strong>中</p>
</li>
<li><p>完备性（实用性）：$F^+$一定可以由Armstrong公理系统导出</p>
<blockquote>
<p>证明逆否命题：如果$X\rightarrow Y$不能用Armstrong公理从$F$中导出，则它一定不被$F$逻辑蕴涵。（即不属于该函数依赖集合下的关系模式）</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Armstrong公理系统是一种操作$F$的方式，还可以有其他公理系统，<strong>不</strong>影响$F$本身的存在。</p>
</blockquote>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>算法：求$X_F^+$</p>
<ul>
<li>以$X$为起始属性集，对其所有<strong>子集</strong>（不只是元素）进行迭代推导。</li>
<li>属性集在某一次迭代中没有更新或者等于全集$U$时终止算法</li>
</ul>
<blockquote>
<p>闭包表示</p>
<ul>
<li>函数依赖闭包$F^+$：<code>{}</code></li>
<li>属性集闭包$X_F^+$：<strong>直接列举元素</strong>，外层不需要<code>{}</code>或<code>()</code>修饰。</li>
</ul>
</blockquote>
<h3 id="函数依赖集"><a href="#函数依赖集" class="headerlink" title="函数依赖集"></a>函数依赖集</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>对于$F,G$，若$F^+=G^+$，即两者能推出的全体函数依赖相同，则称两者等价。<ul>
<li>此时称$F$和$G$相互覆盖</li>
<li>$F^+=G^+\Longleftrightarrow F \subseteq G^+ \Longleftrightarrow G \subseteq F^+$</li>
</ul>
</li>
<li>最小依赖集<ul>
<li>右部单属性化：$F$中任一函数依赖$X\rightarrow A$，$A$必是单属性。</li>
<li>函数依赖<strong>左部</strong>没有多余属性：<strong>不存在</strong>部分函数依赖</li>
<li>没有多余的函数依赖：$F$中<strong>不存在</strong>可以被其他函数依赖导出的函数依赖</li>
</ul>
</li>
</ul>
<h4 id="极小化"><a href="#极小化" class="headerlink" title="极小化"></a>极小化</h4><ul>
<li><p>定理：每个函数依赖集$F$<strong>均等价于</strong>一个极小函数依赖集$Fm$</p>
</li>
<li><p>算法</p>
<ul>
<li><p>对于<strong>右部</strong>是属性集合的函数依赖进行分解，转换为<strong>多个</strong>单属性依赖。</p>
</li>
<li><p>对于<strong>左部</strong>是属性集合的函数依赖，对左侧进行消融检查。对于消融后函数依赖不受影响属性，均从左侧属性集中删除<strong>并更新迭代集</strong>。</p>
<blockquote>
<p>也可能消融实验后，左部依然是属性组。</p>
</blockquote>
</li>
<li><p>对于<strong>每个函数依赖</strong>做消融检查，如果消融某个依赖后依然可以推导出该函数依赖，则可以将该函数依赖删除<strong>并更新迭代集</strong>。</p>
<ul>
<li>算法一：转化为图的连通性判定</li>
<li>算法二：求该函数依赖左侧属性<strong>新的属性集闭包</strong>，判断是否包含该消融函数依赖的右侧元素。</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于算法的2，3步而言，如果消融的顺序不一样，可能会得到不一样的$Fm$，即$Fm$不唯一。</p>
</blockquote>
</li>
</ul>
<h2 id="规范化-1"><a href="#规范化-1" class="headerlink" title="规范化"></a>规范化</h2><ul>
<li>目的：消除冗余和异常</li>
<li>思想：“一事一地”，一个关系只描述一个实体或者实体间的一种联系。</li>
<li>消除部分函数依赖和传递函数依赖</li>
</ul>
<h3 id="范式-Normal-Form"><a href="#范式-Normal-Form" class="headerlink" title="范式(Normal Form)"></a>范式(Normal Form)</h3><ul>
<li>一个关系满足的某个<strong>指定的约束集</strong></li>
<li>各级范式联系：$5NF \sub 4NF\sub BCNF \sub 3CNF \sub 2NF \sub 1NF$（反证法）</li>
<li>规范化：通过<strong>模式分解</strong>将低级范式的关系模式提升到更高的范式等级</li>
</ul>
<h4 id="分级"><a href="#分级" class="headerlink" title="分级"></a>分级</h4><ul>
<li><p>第一范式(1NF)：最低要求，满足的关系被称为<strong>规范化关系</strong>。</p>
<ul>
<li>一个关系只包含原子值（属性<strong>不可</strong>再分）</li>
</ul>
</li>
<li><p>第二范式(2NF)</p>
<ul>
<li><p>$R\in 1NF$，并且每个<strong>非主属性完全依赖</strong>于码，则称$R\in2NF$.</p>
</li>
<li><p><strong>允许主属性部分依赖于码</strong></p>
<blockquote>
<ul>
<li>任一主属性<strong>均部分依赖</strong>于码</li>
<li>某些所有属性都是主属性，但是码<strong>不是</strong>全体主属性的情况，例如<code>STC(S, T, C)</code>.</li>
</ul>
</blockquote>
</li>
<li><p>如果$R$的全体属性都是主属性，则$R\in 2NF$.</p>
</li>
<li><p>从$1NF$中消除非主属性对码的部分函数依赖即可升级为2NF</p>
<ul>
<li>画函数依赖图</li>
<li>投影分解法（选择部分列）</li>
</ul>
</li>
</ul>
</li>
<li><p>第三范式(3NF)</p>
<ul>
<li><p>若$R\in2NF$，并且每个<strong>非主属性</strong>都<strong>不传递依赖</strong>于$R$的任何码，则$R\in3NF$.</p>
<ul>
<li><p>推论：若非主属性$Z$<strong>部分依赖</strong>于码$X$，则$R\notin 3NF$.</p>
<blockquote>
<p>此时$R\notin 2NF$</p>
</blockquote>
</li>
</ul>
</li>
<li><p>投影分解法</p>
</li>
</ul>
</li>
<li><p>BCNF</p>
<ul>
<li><p>3NF<strong>没有限制主属性</strong>对码的<strong>部分及传递函数依赖</strong>，依然会在某些情况下带来异常。</p>
</li>
<li><p>若$R\in 1NF$，对任意函数依赖$X\to Y$，且$Y\nsubseteq X$时，$X$必含有码，则$R\in BCNF$.</p>
<blockquote>
<p>等价定义：BCNF中任意<strong>非平凡</strong>函数依赖的<strong>左部</strong>含有码</p>
</blockquote>
</li>
<li><p>性质（反证法）</p>
<ul>
<li><p><strong>所有</strong>非主属性<strong>完全函数依赖</strong>于任一候选码(2NF)</p>
</li>
<li><p><strong>所有</strong>主属性<strong>完全函数依赖</strong>于每个<strong>不包含它</strong>的候选码(BCNF)</p>
</li>
<li><p><strong>没有</strong>属性<strong>完全函数依赖</strong>于非码的任意属性组(3NF, BCNF)</p>
<blockquote>
<p>如果没有完全函数依赖，则不可能有部分函数依赖。</p>
</blockquote>
</li>
<li><p>全码（所有属性一起作为码的关系模式）关系就是BCNF</p>
</li>
</ul>
</li>
<li><p>BCNF是只考虑函数依赖的<strong>最高标准</strong></p>
<blockquote>
<p>和多值依赖对应，不是指保持函数依赖。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>给定属性组$X$，$Y$，$Z$，满足$Z=U-X-Y$.当给定一组$(x,z)$可以得到一个$Y$的取值集合，若该集合与$X$有关而与$Z$无关，则称$Y$多值依赖于$X$，记为$X\to \to Y$.</p>
<blockquote>
<ul>
<li>即$(x,z)$中$z$任意变化对$Y$的取值集合<strong>没有</strong>影响，由$X$确定了$Y$的一组取值。</li>
<li>因为一个自变量对应了多个因变量，因此叫做多值依赖而不是函数依赖。</li>
<li>函数依赖是多值依赖的特殊情况。</li>
</ul>
</blockquote>
</li>
<li><p>有效性范围</p>
</li>
<li><p>现实场景：各个域之间均为多对多关系，即<strong>不能够</strong>提取出函数依赖关系的模式。</p>
</li>
</ul>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>给定$Z=U-X-Y$</p>
<ul>
<li><p>对称性：若$X\to \to Y$，则$X\to\to Z$.</p>
</li>
<li><p>若$X\to Y$，则$X\to\to Y$，即函数依赖可以看作多值依赖的特例。</p>
</li>
<li><p>平凡：若$X\to\to Y$，且$Z= \phi$.</p>
<blockquote>
<p>即$U$只被划分为了$X$和$Y$</p>
</blockquote>
</li>
<li><p>非平凡：若$X\to\to Y$，且$Z\neq \phi$.</p>
</li>
</ul>
<h3 id="第四范式-4NF"><a href="#第四范式-4NF" class="headerlink" title="第四范式(4NF)"></a>第四范式(4NF)</h3><ul>
<li><p>对任意<strong>非平凡</strong>多值依赖$X\to\to Y(Y\nsubseteq X)$，$X$都含有码，则称$R\in 4NF$.</p>
<blockquote>
<p>若关系已经满足BCNF，且所有的多值依赖都是平凡的，则关系也满足4NF.</p>
</blockquote>
</li>
<li><p>意义：降低数据冗余程度，减少修改异常。</p>
</li>
</ul>
<h2 id="模式分解理论"><a href="#模式分解理论" class="headerlink" title="模式分解理论"></a>模式分解理论</h2><ul>
<li><p>目的：通过模式分解，将关系模式的范式等级提高，同时保有原关系模式的一定信息。</p>
<blockquote>
<p>如果不保有信息，分解是没有意义的。因此，所有的分解算法都和性质的保持有关。</p>
</blockquote>
</li>
</ul>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>分解$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>,…,R_n<U_n,F_n>\}$，满足：</p>
<ul>
<li><p>$U=\bigcup_{i=1}^n U_i$，且$\forall 1\leq i,j \leq n,U_i\nsubseteq U_j$.</p>
<blockquote>
<p>可以相交但<strong>不能</strong>包含</p>
</blockquote>
</li>
<li><p>$F_i$是$F$在$U_i$上的一个投影，即选择了$F^+$中相关属性<strong>都在</strong>$U_i$中($XY\subseteq U_i)$的函数依赖作为$F_i$.（可以只选择一部分，不一定全选）</p>
</li>
<li><p>表示</p>
<p>$\rho=\{R_1&lt;\{Sno,Sdept\},\{Sno \to Sdept\}&gt;,R_2&lt;\{Sno,Mname\},\{Sno \to Mname\}&gt; \}$</p>
</li>
</ul>
<h3 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性"></a>无损连接性</h3><ul>
<li><p>将分解后的关系模式做<strong>自然连接</strong>得到合成的新关系模式，如果新关系模式中的关系和分解前的原关系模式中的关系逐一相等，则称该分解$\rho$具有无损连接性，记为<strong>无损分解</strong>。</p>
</li>
<li><p>判定</p>
<ul>
<li><p>算法</p>
</li>
<li><p>定理（无损连接性的充要条件）：以分解为两个子模式为例，若$R_1$和$R_2$的共同属性<strong>至少构成二者之一</strong>的候选码，则为无损分解。</p>
<blockquote>
<p>扩展为<code>n</code>个子关系模式：将子模式间<strong>两两进行比较</strong>，若<strong>所有</strong>的比较都满足以上条件，则该分解无损连接性。（每一次都是无损连接，则合成后的连接也是无损连接）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="保持函数依赖性"><a href="#保持函数依赖性" class="headerlink" title="保持函数依赖性"></a>保持函数依赖性</h3><ul>
<li>若$F^+=(\bigcup_{i=1}^nF_i)^+$，即两个函数依赖集等价，则称$\rho$是保持函数依赖性的分解。</li>
<li>判定：设$G=(\bigcup_{i=1}^nF_i)$，$G\subseteq F^+$一定成立，则只需要判断$F^+\subseteq G$是否成立。<ul>
<li>$\forall (X\to Y) \in F$，判断$Y$是否属于$X_G^+$.</li>
<li>对于$F$中的每个函数依赖，判断是否可以从$G$中的函数依赖导出。</li>
</ul>
</li>
</ul>
<blockquote>
<p>分解$\rho$可以无损连接性和保持函数依赖性，也可以只满足其中一个，也可以同时都不满足。</p>
</blockquote>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li>规范化过程中采用的投影分解可能不唯一，但是好的无损分解应该无损连接并且保持函数依赖。</li>
<li>若要保持函数依赖，则最高可能只能到3NF.（BCNF的粒度过小，可能<strong>不保持</strong>函数依赖）</li>
<li>若要进行无损分解，则可以到达4NF或更高。</li>
</ul>
<blockquote>
<ul>
<li>模式分解是在求当前模式的“数据等价子集”，在保证<strong>数据完整性（无损连接）</strong>的条件下尽可能地减小单个模式的复杂度，因此某些不影响数据完整性的函数依赖可能被舍弃。</li>
<li>大多数情况下，3NF是最为合适的规范化等级，因为它是能够无损连接并且保持函数依赖的最高等级。</li>
</ul>
</blockquote>
<h3 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h3><ul>
<li><p>3NF+函数依赖</p>
<ul>
<li><p>对$F$进行<strong>极小化</strong>处理，记为$F$.</p>
</li>
<li><p>将<strong>不在</strong>$F$中出现的属性从$U$中删除，记为$U$.</p>
<blockquote>
<p>删除了部分元素，所以<strong>不具有</strong>无损连接性。</p>
</blockquote>
</li>
<li><p>若$F$只有一个函数依赖，则$\rho=\{R\}$.</p>
</li>
<li><p>对$F$按照<strong>“具有相同左部”</strong>的原则进行分组，由$F_i$求出$U_i$，则$\rho=\{R_1<U_1,F_1>,…R_k<U_k,F_k>\}$为所求。</p>
</li>
</ul>
</li>
<li><p>3NF+无损连接性+函数依赖</p>
<p>从<strong>满足保持函数依赖</strong>的分解$\rho$出发，设$X$是$R<U,F>$的码。</p>
<ul>
<li><p>若$\exist U_i, X\subseteq U_i$，则$\rho$为所求。</p>
</li>
<li><p>否则，令$\tau=\rho \cup\{R^*<X,F_X>\}$，则$\tau$为所求。</p>
<blockquote>
<ul>
<li>$F_X$是以$X$为属性集的函数依赖的投影</li>
<li>$X_F$是属性$X$蕴涵的属性集</li>
<li>在满足函数依赖的算法中，删去了<strong>不出现</strong>在$F$中的属性，但是它们是<strong>主属性</strong>，因此通过$X$对无损连接性进行了恢复。</li>
<li>注意，$\tau$求解时是直接把$R^<em>$并入，而<em>*不是</em></em>把$X$添加进$U_i$.</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>BCNF+无损连接性</p>
<p>设$\rho$中$R_i<U_i,F_i>\notin BCNF$</p>
<ul>
<li>则$R_i$中存在$X\to A\in F_i^+(A\notin X)$，且$X$不是$R_i$的码（也不含有），则$XA$是$U_i$的真子集，将$R_i$分解为$\sigma=\{S_1,S_2\}$，其中$U_{S_1}=XA$，$U_{S_2}=U_i-\{A\}$.</li>
</ul>
<blockquote>
<p>$A$是<strong>单属性</strong>，而<strong>不是</strong>属性组。</p>
</blockquote>
<ul>
<li><p>使用$\sigma$进行迭代，直到$\sigma \in BCNF$.</p>
<blockquote>
<p>相当于逐步分离不符合BCNF的函数依赖</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="候选码求解"><a href="#候选码求解" class="headerlink" title="候选码求解"></a>候选码求解</h2><h3 id="单属性"><a href="#单属性" class="headerlink" title="单属性"></a>单属性</h3><h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><ul>
<li>$L$：<strong>仅</strong>出现在左部</li>
<li>$R$：<strong>仅</strong>出现在右部</li>
<li>$N$：两边均未出现</li>
<li>$LR$：两边均出现</li>
</ul>
<blockquote>
<p>以上是<strong>属性</strong>分类，而不是<strong>属性组</strong>分类。</p>
<p>例如，$BC\to A$和$C\to B$均成立时，$BC\notin L$.</p>
</blockquote>
<h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><ul>
<li>L类属性一定是<strong>所有候选码</strong>中的成员（<strong>强于</strong>主属性）<ul>
<li>若L类属性能够推出全体属性，则该属性单独作为候选码，且由码的极小性，该候选码唯一，即<strong>主码</strong>为该属性。</li>
</ul>
</li>
<li>R类属性一定<strong>不是</strong>任意候选码成员</li>
<li>N类属性一定是<strong>所有候选码</strong>中的成员<ul>
<li>若L和N类属性组成的集合能够推出全体属性，则该属性集是<strong>主码</strong>。</li>
</ul>
</li>
</ul>
<h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><p>将<strong>单属性依赖</strong>关系模式转换为图$G(U,F)$，其中$F$为有向边集合，表示<strong>单属性</strong>函数依赖。</p>
<ul>
<li>关键点（原始点+孤立点）对应的属性必在$R$的任何候选码中</li>
<li>属性集$X$是$R$的唯一候选码$\Leftrightarrow$X能到达$G$中的任一结点<ul>
<li>在单属性条件下，即不存在独立回路。</li>
</ul>
</li>
<li>对途中点而言，成为候选码成员$\Leftrightarrow$途中点是独立回路中的结点。</li>
<li>对于存在独立回路的关系模式而言，候选码=关键属性集+独立回路笛卡尔积中的任意元素。</li>
</ul>
<h3 id="多属性"><a href="#多属性" class="headerlink" title="多属性"></a>多属性</h3><ul>
<li><p>$X=L\cup N，Y=LR$.</p>
</li>
<li><p>判断$X$是否可以推出全体属性集，如果不可以的话就从$Y$中取一个并进$X$，然后再次判断。</p>
</li>
<li><p>依次迭代取的个数，直到能够推出全体属性。</p>
<blockquote>
<ul>
<li>这是一个穷举算法，取两个不只是在取的第一个的基础上再取，而是遍历所有取两个的情况。</li>
<li>证明了独立回路存在时，主码$K\neq L\cup N$.</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>通过最小函数依赖集消除<strong>冗余</strong>联系</li>
<li>$D=F-F_m$中的函数依赖<strong>不一定</strong>是冗余的，因此除了$F_m$中的函数依赖外，可能$D$中也有需要保留的函数依赖。</li>
</ul>
<h2 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
</ul>
<h1 id="Chapter6-关系查询处理与查询优化"><a href="#Chapter6-关系查询处理与查询优化" class="headerlink" title="Chapter6 关系查询处理与查询优化"></a>Chapter6 关系查询处理与查询优化</h1><p>全文共<code>448</code>字，推荐阅读时间<code>3~5</code>分钟。</p>
<h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul>
<li>分析</li>
<li>检查<ul>
<li>将查询转换为<strong>查询树</strong>（语法分析树）</li>
</ul>
</li>
<li>优化<ul>
<li>代数：恒等变换</li>
<li>物理：根据数据规模、分布等确定对应的底层存储策略。</li>
</ul>
</li>
<li>执行</li>
</ul>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><ul>
<li>查询代价=I/O代价<strong>（主要）</strong>+CPU代价+内存代价</li>
</ul>
<h3 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h3><ul>
<li>变换规则：主要是优化<strong>连接</strong>（笛卡尔积为主）运算。<ul>
<li>交换律</li>
<li>结合律</li>
</ul>
</li>
<li>特殊优化：先缩小范围再运算一般效率更高<ul>
<li>投影、选择的串接：合并操作减小遍历次数</li>
<li>投影、选择的交换律：先投影再选择</li>
<li>选择、笛卡尔积的交换律：能先投影时，先投影再作笛卡尔积。</li>
</ul>
</li>
<li>查询树的启发式优化<ul>
<li>减少<strong>中间</strong>（临时）关系：选择、投影尽可能先做。</li>
<li>减少扫描次数：投影、选择并行等操作。</li>
<li>减少操作总数：连接=笛卡尔积+选择</li>
<li>中间结果复用：使用中间文件存储公共表达式的结果</li>
</ul>
</li>
</ul>
<h3 id="物理优化"><a href="#物理优化" class="headerlink" title="物理优化"></a>物理优化</h3><ul>
<li><p>存取路径选择</p>
<ul>
<li><p>选择操作</p>
<ul>
<li>小关系：全表扫描</li>
<li>大关系：索引扫描</li>
</ul>
</li>
<li><p>连接操作</p>
<ul>
<li><p>排序-合并</p>
</li>
<li><p>索引连接：为连接属性建立索引</p>
</li>
<li><p>Hash Join：为小表建Hash文件</p>
</li>
<li><p>嵌套循环：小表在外层</p>
<blockquote>
<p>原因：分配时通常给外表的内存更大</p>
<ul>
<li><p>设外表分配$(K-1)$块，内表$1$块。</p>
<p>$Cost=Cost_{out}+Cost_{in}*\frac{B_{out}}{K-1}$</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>将查询转换成语法树</li>
<li>代数优化</li>
<li>物理优化，确定底层的存储路径</li>
<li>生成查询计划</li>
</ul>
<h2 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
</ul>
<h1 id="Chapter7-事务处理技术"><a href="#Chapter7-事务处理技术" class="headerlink" title="Chapter7 事务处理技术"></a>Chapter7 事务处理技术</h1><p>全文共<code>2870</code>字，推荐阅读时间<code>15~20</code>分钟。</p>
<h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ul>
<li>事务(Transaction)：用户定义的数据库操作序列，这些操作要么一起做，要么都不做，是一个不可分割的<strong>工作单位</strong>。<ul>
<li>应用程序可以包含<strong>多个</strong>事务</li>
<li>事务的开始和结束可以由用户显式控制（DBMS也会缺省定义一部分事务划分），从而保证数据的<strong>完整性</strong>。</li>
</ul>
</li>
<li>事务是<strong>数据库恢复</strong>及<strong>并发控制</strong>的基本单位</li>
</ul>
<h3 id="特性-ACID"><a href="#特性-ACID" class="headerlink" title="特性(ACID)"></a>特性(ACID)</h3><ul>
<li><p>原子性</p>
<ul>
<li>基础：恢复机制<ul>
<li>回退，将已经执行的部分进行撤销。</li>
</ul>
</li>
</ul>
</li>
<li><p>一致性：事务执行前后数据库均为一致性状态</p>
<ul>
<li>基础：原子性</li>
</ul>
<blockquote>
<p>Q：什么是一致性状态</p>
<p>A：满足数据库约束的状态</p>
</blockquote>
</li>
<li><p>隔离性：并发事务之间不能相互影响</p>
<ul>
<li>基础：并发控制机制</li>
</ul>
</li>
<li><p>持久性：事务<strong>提交后</strong>对数据库的改变应该是永久的，故障等情况不应该有影响。</p>
<ul>
<li>基础：恢复机制</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>ACID</code>里的<code>AID</code>都是数据库的特征,也就是<strong>依赖数据库的具体实现</strong>。而唯独这个C，实际上它依赖于<strong>应用层</strong>，也就是依赖于开发者。做个比喻事务就好比一个保镖，我们提到事务就会说ACID，而我们提到保镖会说强壮、保护安全、好功夫、踏实。这里强壮、好功夫和踏实都是保镖自己的特征，而安全是属于你的，即你通过保镖的特征来保护你的安全。</p>
</blockquote>
<h4 id="破坏"><a href="#破坏" class="headerlink" title="破坏"></a>破坏</h4><ul>
<li><p>事务并行时，不同事务的操作交叉进行。（隔离性）</p>
<blockquote>
<p>交叉是指<strong>完整</strong>事务间，而<strong>不是</strong>在某个事务中进行切换。</p>
</blockquote>
</li>
<li><p>事务运行时被强行停止（持久性）</p>
</li>
</ul>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul>
<li><p>开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION</span><br></pre></td></tr></table></figure>
</li>
<li><p>结束</p>
<ul>
<li><p>正常结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
</li>
<li><p>非正常结束：撤销全部更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h2><ul>
<li>从<strong>错误</strong>状态恢复到某一已知<strong>正确</strong>状态</li>
<li>通过DBMS的<strong>恢复子系统</strong>完成</li>
</ul>
<h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><ul>
<li>事务<ul>
<li>可预期：事务根据<strong>内部</strong>测试条件而触发的回滚</li>
<li>不可预期：不能由应用程序处理</li>
</ul>
</li>
<li><p>系统</p>
<ul>
<li><p>事务异常中断：数据库本身不会受到破坏。</p>
<blockquote>
<p>指数据不会丢失，而<strong>不是数据的正确性</strong>。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>介质</p>
<ul>
<li>数据库本身受到破坏及正在使用这部分数据的相关事务</li>
</ul>
</li>
<li><p>病毒</p>
<ul>
<li>对数据进行非法修改</li>
</ul>
</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>基本原理：冗余</p>
</li>
<li><p>建立冗余</p>
<ul>
<li><p>数据转储（备份）</p>
<ul>
<li>静态：保证一致性，但是可用性低。</li>
<li>动态：不影响可用性，不能保证一致性。<ul>
<li>建立日志文件，在使用副本进行数据库恢复时，需要经过一遍日志处理。</li>
</ul>
</li>
<li>海量：每次转储全部数据库</li>
<li>增量：每次只转储上一次转储后更新的部分</li>
</ul>
</li>
<li><p>登录日志文件：记录事务对数据库的更新操作</p>
<ul>
<li>记录单位：事务驱动</li>
<li>数据块单位：数据驱动</li>
</ul>
<blockquote>
<ul>
<li>事务、系统故障必须使用日志文件</li>
<li>写入规则<ul>
<li>按照并发事务的时间顺序</li>
<li><strong>先写</strong>日志文件，<strong>再写</strong>数据库。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul>
<li>事务：UNDO<ul>
<li><strong>反向</strong>扫描日志，对更新执行逆操作，直到事务开始标志。</li>
</ul>
</li>
<li>系统：UNDO+REDO<ul>
<li>未完成的事务已经修改了数据库，此时采取<strong>撤销</strong>操作。</li>
<li>已经提交的事务还留在缓冲区中，没有写入数据库，此时采取<strong>重做</strong>操作。<ul>
<li><strong>正向</strong>扫描日志，获得撤销队列和重做队列。</li>
<li>对队列中的事务分别执行<strong>撤销</strong>和<strong>重做</strong>操作</li>
</ul>
</li>
</ul>
</li>
<li>介质：REDO<ul>
<li>装入最新数据库的后备副本</li>
<li>装入日志文件副本，重做已完成的事务。</li>
</ul>
</li>
</ul>
<h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><ul>
<li><p>缩小日志文件的检查范围</p>
</li>
<li><p>新增“重新开始”文件记录检查点在日志的位置</p>
</li>
<li><p>在日志文件增加检查点记录</p>
<ul>
<li><p>存储检查点时正在运行的事务清单</p>
</li>
<li><p>维护</p>
<ul>
<li><p>将<strong>日志缓存</strong>写入磁盘，同时增加一个检查点记录。</p>
</li>
<li><p>将<strong>数据缓存</strong>写入磁盘</p>
<blockquote>
<p>由此，检查点<strong>之前</strong>的提交的缓存事务<strong>不需要</strong>被加入正在执行的事务清单。</p>
</blockquote>
</li>
<li><p>将检查点记录的地址写入“重新开始”文件</p>
</li>
</ul>
</li>
<li><p>恢复</p>
<ul>
<li><p>从检查点开始进行日志扫描，从而对事务清单进行分类，得到撤销列表和重做列表。</p>
<blockquote>
<p>在正向扫描的过程中，可能会存在检查点之后才开始的事务。对于这些事务，一样需要把它们加入<strong>正在执行</strong>的事务清单。</p>
</blockquote>
</li>
<li><p>对两个列表中的事务采取不同操作</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul>
<li>利用镜像来维护原始数据库</li>
</ul>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul>
<li>并发(Concurrency)：<strong>单</strong>处理器，<strong>逻辑</strong>并列。</li>
<li>并行(Parallel)：<strong>多</strong>处理器，<strong>物理</strong>并列。</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>主要：数据不一致</p>
<ul>
<li>丢失更新(Lost Update)：并发事务的结果出现了“不正常”覆盖</li>
<li>脏数据读出(Dirty Read)：数据处理未完成时被读出</li>
<li>不能重复读(Non-Repeatable Read)：数据在相邻读之间被更新，导致读操作无法复现。</li>
</ul>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li>合理调度并发事务，避免事务之间的互相干扰造成数据的不一致。</li>
</ul>
<h3 id="基本手段"><a href="#基本手段" class="headerlink" title="基本手段"></a>基本手段</h3><ul>
<li><p>封锁（上锁）</p>
</li>
<li><p>分类</p>
<ul>
<li><p>排它锁（<code>X</code>锁、独占锁）：<strong>只允许</strong>上锁事务<strong>读取和修改</strong>数据对象</p>
</li>
<li><p>共享锁（<code>S</code>锁）：上锁事务<strong>只能读</strong>数据对象，其他事务能够继续上<code>S</code>锁，但是不能上<code>X</code>锁。</p>
<blockquote>
<p>同一个数据对象可以有多个<code>S</code>锁，但是只能有一个<code>X</code>锁，并且两个锁不能同时出现。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>相容矩阵</p>
<p><img src="https://i.loli.net/2020/11/20/VgGK16P2QrdtBqf.png" alt="image-20201120114606476" style="zoom:50%;" /></p>
</li>
<li><p>封锁协议：各级协议间是<strong>包含关系</strong>，<strong>不是并列</strong>。</p>
<ul>
<li><p>一级：事务在修改数据对象之前必须上<code>X</code>锁，等到<strong>事务结束</strong>后再释放锁。</p>
<blockquote>
<ul>
<li><p>事务结束$\neq$修改完成，因为可能是<strong>非正常结束(ROLLBACK)</strong>。</p>
</li>
<li><p>限制写，解决<strong>写间冲突</strong><code>Lost Update</code>；因为没有限制读操作，所以没有解决<strong>读写冲突</strong><code>Dirty Read</code>和<code>Non-Repeatable Read</code>.</p>
</li>
<li><p>Q：上了<code>X</code>锁不也限制了其他事务的读吗？</p>
<p>A：上<code>X</code>锁<strong>并不是不允许</strong>其他事务读，而是限制了其他事务上<code>S</code>锁。因此如果读之前不进行上锁操作，则不会受到<code>X</code>锁的限制，一样能够读到脏数据。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>二级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>读完之后</strong>释放。</p>
<blockquote>
<p>解决了<code>Dirty Read</code>，但是由于<strong>上锁时间较短</strong>，所以依然可能出现<code>Non-Repeatable Read</code>.</p>
</blockquote>
</li>
<li><p>三级：<strong>一级</strong>+事务读数据对象之前必须上<code>S</code>锁，<strong>事务结束之后</strong>释放。</p>
<blockquote>
<p>解决了三种数据不一致问题</p>
</blockquote>
</li>
</ul>
</li>
<li><p>粒度：封锁对象的大小（被上锁的对象的大小）</p>
<ul>
<li><p>常见封锁对象：属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库、物理页、块等。</p>
</li>
<li><p>多粒度封锁：一个系统的封锁机制可以提供多种粒度</p>
<ul>
<li><p>多粒度树：根据数据对象及其之间的关系构造的树</p>
<ul>
<li><p>显式：锁<strong>直接</strong>加在事务需要的数据对象上 </p>
</li>
<li><p>隐式：锁加在事务需要的<strong>数据对象的上级结点</strong>上</p>
</li>
<li><p>上锁检查：显式锁和隐式锁都需要检查</p>
<ul>
<li>隐式锁需要检查<strong>所有</strong>的上级节点</li>
</ul>
<blockquote>
<p>包括<strong>下级结点的显式锁</strong>（下级结点的隐式锁在对当前结点的检查中就已经被判断了）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>意向锁：表示<strong>下级节点</strong>被上了相应类型的锁（优化多粒度树上锁检查）</p>
<ul>
<li><p>在为对象上锁时，需要先对其<strong>所有</strong>上级节点添加意向锁。</p>
</li>
<li><p>在为对象解锁时，需要向上逐级为上级节点释放锁。</p>
<blockquote>
<p><strong>不能</strong>优化当前结点的<strong>隐式锁</strong>检查</p>
</blockquote>
</li>
<li><p>分类</p>
<ul>
<li><p>意向共享锁(<code>IS</code>, Intent Share Lock)</p>
</li>
<li><p>意向排它锁(<code>IX</code>, Intent Exclusive Lock)</p>
</li>
<li><p>意向共享排它锁(<code>SIX</code>, Share Intent Exclusive Lock)：对该对象加<code>S</code>锁后，再加<code>IX</code>锁。</p>
<blockquote>
<p><strong>不是</strong>下级对象的<code>IS</code>和<code>IX</code>的叠加</p>
</blockquote>
</li>
</ul>
</li>
<li><p>相容矩阵</p>
<p><img src="https://i.loli.net/2020/11/20/8KL7aMQVrhPAmRF.png" alt="image-20201120115143845" style="zoom:50%;" /></p>
<ul>
<li><p>上了<code>IS</code>后，可以上<code>IX</code>，反之亦然。</p>
<blockquote>
<p>意向锁来自不同的结点，所以<code>S</code>和<code>X</code>能够“同时出现”。</p>
</blockquote>
</li>
<li><p>可以多次上<code>IS</code>和<code>IX</code>锁</p>
</li>
<li><p>上了<code>IS</code>后，还可以上<code>S</code>和<code>IX</code>变成<code>SIX</code>；但是上了<code>IX</code>之后，<strong>不能</strong>再上<code>S</code>和<code>IX</code>变成<code>SIX</code>了。</p>
<blockquote>
<p>上了<code>IX</code>后<strong>不能</strong>再为下级结点隐式上<code>S</code>锁了</p>
</blockquote>
</li>
<li><p>上了<code>SIX</code>之后，还可以上<code>IS</code>，但是不能再上<code>IX</code>了。</p>
<blockquote>
<p>因为下级结点已经隐式上了<code>S</code>，不能再上<code>X</code>了。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="活锁和死锁"><a href="#活锁和死锁" class="headerlink" title="活锁和死锁"></a>活锁和死锁</h3><ul>
<li><p>活锁：系统正常运行，但是有些事务可能永远不能得到上锁机会。</p>
<ul>
<li>采用<code>FCFS</code>解决</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li><p>预防</p>
<ul>
<li><p>一次封锁法：事务执行前为<strong>所有</strong>需要的资源上锁</p>
<ul>
<li>降低系统并发度</li>
</ul>
</li>
<li><p>顺序封锁法：为资源编号，事务执行时必须按照顺序对所需的资源上锁。</p>
<ul>
<li>实现难度大</li>
</ul>
<blockquote>
<p>不是按照顺序获取<strong>所有</strong>资源，而是在获取所需对象时按照顺序进行。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>检测</p>
<ul>
<li>超时法：事务等待时间过长时认为发生死锁</li>
<li>等待图法：结点表示事务，边指向等待的事务，出现回路则发生死锁。</li>
</ul>
</li>
<li><p>恢复（解除）</p>
<ul>
<li><p>选择代价小的事务撤销</p>
<blockquote>
<p>撤销后，需要回滚该事务的所有操作</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h3><ul>
<li><p>调度的单位是事务的<strong>操作</strong>，而<strong>不是</strong>事务本身。</p>
</li>
<li><p>事务执行正确性：保证数据库<strong>一致性</strong>的都是正确的执行结果</p>
<blockquote>
<p>不同执行顺序可能有不一样的执行结果（随机性），但可能都是正确的。</p>
</blockquote>
</li>
<li><p>可串行化：事务的并发执行正确$\Leftrightarrow$按照某一次序<strong>串行执行</strong>的结果和<strong>并发执行</strong>结果相同</p>
<ul>
<li>可串行化的并发调度是正确调度</li>
</ul>
</li>
<li><p>判定</p>
<ul>
<li><p><strong>冲突可串行化</strong>调度：调度$Sc$交换<strong>事务间不冲突</strong>操作的次序后，得到<strong>串行调度</strong>$Sc’$.</p>
<ul>
<li>不能交换<strong>事务间</strong>的冲突操作</li>
<li>不能交换<strong>一个事务内</strong>的操作</li>
</ul>
</li>
<li><p>冲突操作：读-写、写-写</p>
</li>
<li><p>充分条件：冲突可串行化调度$\Rightarrow$可串行化调度</p>
<blockquote>
<p>冲突可串行化调度$\Rightarrow$可串行化调度$\Rightarrow$正确调度</p>
</blockquote>
</li>
</ul>
</li>
<li><p>两段锁协议：保证并发调度可串行</p>
<ul>
<li>扩展阶段：读写操作执行前需要上锁</li>
<li>收缩阶段：开始释放锁之后，事务不再获取其他任何锁。</li>
</ul>
<blockquote>
<p>依然可能发生死锁</p>
</blockquote>
</li>
</ul>
<h2 id="Reference-7"><a href="#Reference-7" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
<li><a href="https://www.zhihu.com/question/31346392" target="_blank" rel="noopener">https://www.zhihu.com/question/31346392</a></li>
</ul>
<h1 id="Chapter8-数据库保护"><a href="#Chapter8-数据库保护" class="headerlink" title="Chapter8 数据库保护"></a>Chapter8 数据库保护</h1><p>全文共<code>732</code>字，推荐阅读时间<code>7~10</code>分钟。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul>
<li>安全性(<code>security</code>)：防止不合法的使用造成的<strong>数据泄露</strong>、<strong>更改</strong>、<strong>破坏</strong>。</li>
</ul>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul>
<li><p>用户标识和认证（最外层）</p>
<ul>
<li>常用：用户名和密码（口令）</li>
</ul>
</li>
<li><p>存取控制</p>
<ul>
<li><p>权限定义</p>
</li>
<li><p>权限检查</p>
</li>
<li><p>方法</p>
<ul>
<li><p>自主(<code>DAC</code>)：用户可以将权限转授</p>
<ul>
<li><p>权限=数据对象+操作类型</p>
</li>
<li><p>SQL</p>
<ul>
<li>用户级：操作数据库，例如创建外模式、创建会话、创建表等。</li>
<li>关系级：操作某个关系和视图，针对具体的对象，例如在某个表中进行CRUD操作。</li>
</ul>
</li>
<li><p>角色：一组权限的集合，可以授给<strong>用户或其他角色</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT CREATE SESSION to xxx; # 用户级</span><br><span class="line">GRANT CREATE TABLE to xxx; # 用户级</span><br><span class="line">REVOKE CREATE TABLE FROM xxx; # 用户级</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>强制(<code>MAC</code>)：不同数据对象有不同的加密等价，每个用户的许可证级别决定了能够访问哪些数据，由系统<strong>直接指定</strong>级别。</p>
<ul>
<li>实体=主体+客体</li>
<li>主体：实际用户</li>
<li>客体：系统中的被动实体，包括文件、基本表、索引、视图等。</li>
<li>许可证级别(<code>Label</code>，敏感度标记)<ul>
<li>主体<strong>大于等于</strong>客体：读</li>
<li>主体<strong>等于</strong>客体：写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统/网络安全保护</p>
</li>
<li><p>数据加密</p>
</li>
<li><p>其他</p>
<ul>
<li>视图：不同用户有不同的视图</li>
<li>审计：将用户对数据库的操作记录在审计日志中，出现安全问题时进行审查。</li>
</ul>
</li>
</ul>
<h3 id="可信系统评测"><a href="#可信系统评测" class="headerlink" title="可信系统评测"></a>可信系统评测</h3><ul>
<li>TCSEC</li>
<li>TDI</li>
</ul>
<h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul>
<li>完整性=正确性+相容性<ul>
<li>正确性：类型、取值范围</li>
<li>相容性：同一个事实的值应该相同</li>
</ul>
</li>
<li>确保数据库语义正确</li>
</ul>
<h3 id="约束条件-1"><a href="#约束条件-1" class="headerlink" title="约束条件"></a>约束条件</h3><ul>
<li>作用对象<ul>
<li>列：对属性进行约束</li>
<li>元组：元组间的<strong>字段</strong>约束（属性间约束）</li>
<li>关系：元组之间、关系之间的约束，例如实体完整性、参照完整性。</li>
</ul>
</li>
<li>时机<ul>
<li>静态：数据库在每一确定状态应该满足的约束</li>
<li>动态：新、旧值之间的约束，例如年龄只能上升不能下降。</li>
</ul>
</li>
</ul>
<blockquote>
<p>总共可以组合出3*2=6种约束条件</p>
</blockquote>
<h3 id="控制-1"><a href="#控制-1" class="headerlink" title="控制"></a>控制</h3><ul>
<li><p>定义</p>
</li>
<li><p>检查</p>
<ul>
<li>立即执行：<strong>语句</strong>执行完后立即检查</li>
<li>延迟执行：<strong>事务</strong>执行完毕后再进行检查</li>
</ul>
</li>
<li><p>违约相应</p>
</li>
<li><p>规则：$(D,O,A,C,P)$</p>
<ul>
<li><code>D</code>：数据本身</li>
<li><code>O</code>：操作</li>
<li><code>A</code>：断言</li>
<li><p><code>C</code>：<code>A</code>指定的谓词（自然语言约束的主语）</p>
</li>
<li><p><code>P</code>：违反规则时触发的过程</p>
</li>
</ul>
</li>
<li><p>SQL</p>
<ul>
<li><p><code>CREATE TABLE</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NULL</span><br><span class="line">NOT NULL</span><br><span class="line">UNIQUE</span><br><span class="line">PRIMARY KEY</span><br><span class="line">FOREIGN KEY</span><br><span class="line">CHECK</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CREATE ASSERTION</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSERTION ASSE_NAME</span><br><span class="line">CHECK (60 &gt;&#x3D; ALL(SELECT COUNT(*) FROM SD GROUP BY C));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CREATE TRIGGER</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Reference-8"><a href="#Reference-8" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
<li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li>
</ul>
<h1 id="Chapter9-数据库新技术"><a href="#Chapter9-数据库新技术" class="headerlink" title="Chapter9-数据库新技术"></a>Chapter9-数据库新技术</h1><p>全文共<code>2031</code>字，推荐阅读时间<code>10~15</code>分钟。</p>
<h2 id="数据仓库-Data-Warehouse"><a href="#数据仓库-Data-Warehouse" class="headerlink" title="数据仓库(Data Warehouse)"></a>数据仓库(<code>Data Warehouse</code>)</h2><ul>
<li><p>支持管理决策过程</p>
<blockquote>
<p>不同于数据库提供的<strong>日常业务查询</strong>服务</p>
</blockquote>
</li>
<li><p>面向主题</p>
<ul>
<li>从大量的历史数据中提取</li>
</ul>
</li>
<li><p>持久数据集合</p>
</li>
<li><p>业务</p>
<ul>
<li>OLAP：数据<strong>仓库</strong>联机<strong>分析</strong>处理</li>
<li>OLTP：数据<strong>库</strong>联机<strong>事务</strong>处理</li>
</ul>
</li>
<li><p>数据仓库系统</p>
<ul>
<li><p>数据源</p>
<ul>
<li>数据库</li>
<li>数据文件</li>
</ul>
</li>
<li><p>数据仓库管理工具</p>
<ul>
<li><p>数据建模工具：根据主题确定，例如学生就业情况。</p>
</li>
<li><p>抽取、转换、装载(<code>ETL</code>)</p>
</li>
<li><p>元数据库：描述数据的数据</p>
<blockquote>
<p>类似数据库中的数据字典</p>
</blockquote>
</li>
</ul>
</li>
<li><p>数据仓库</p>
<ul>
<li>高度综合数据：准决策数据</li>
<li>轻度综合数据：来自近期基本数据</li>
<li>当前数据：最近时期业务数据</li>
<li>历史数据：早期基本数据</li>
</ul>
</li>
<li><p>分析工具</p>
<ul>
<li>用户查询工具</li>
<li>OLAP工具</li>
<li>DM工具</li>
</ul>
</li>
<li><p>比较</p>
<ul>
<li><p>数据库</p>
<p><img src="https://pic4.zhimg.com/80/v2-bdc235fbdd1825c1b67ef7d609f81adb_1440w.jpg?source=1940ef5c" alt="img" style="zoom: 33%;" /></p>
<ul>
<li>一种事务处理技术</li>
<li>表格结构复杂，存储结构紧致，冗余数据少。</li>
<li>读写均进行优化</li>
<li>查询要求较简单，单次作用的数据量小。</li>
<li>常见：MySQL, Oracle, SqlServer.</li>
</ul>
</li>
<li><p>数据仓库</p>
<p><img src="https://pic4.zhimg.com/80/v2-ccefb7a678de237560cc4df80c11cca3_1440w.jpg?source=1940ef5c" alt="img" style="zoom:33%;" /></p>
<ul>
<li>一种体系结构</li>
<li>表格结构简单，存储结构松散，冗余数据多。</li>
<li>通常只优化读</li>
<li>查询要求较复杂，单次作用的数据量大。</li>
<li>常见：AWS Redshift, Hive.</li>
</ul>
<blockquote>
<ul>
<li>数据仓库是为某种特定的查询而设置的，是对数据库中多张表的整合，因此可以承担相应的分析工作。</li>
<li>数据仓库来自于“分析型数据库”，但也因此不满足数据库的一些规范，所以被改叫“数据仓库”。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式数据库系统"><a href="#分布式数据库系统" class="headerlink" title="分布式数据库系统"></a>分布式数据库系统</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>基础：网络+数据库</p>
</li>
<li><p>结构</p>
<ul>
<li>全局应用=局部应用+网络，操作<strong>两个及以上</strong>节点中的数据库。</li>
<li>局部应用=数据库+服务器，操作<strong>一个</strong>节点中的数据库。</li>
</ul>
<blockquote>
<p>结构必须完整，缺一不可。</p>
</blockquote>
</li>
<li><p>前提：数据分布存储</p>
<ul>
<li>场地自治性</li>
<li>场地协作性</li>
</ul>
</li>
</ul>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>数据独立性<ul>
<li>逻辑</li>
<li>物理</li>
<li><strong>分布</strong>（分布透明性）：数据的存储特征（分片、位置等）和用户/应用程序无关</li>
</ul>
</li>
<li>控制结构：集中和自治相结合<ul>
<li>共享<ul>
<li>局部</li>
<li>全局</li>
</ul>
</li>
</ul>
</li>
<li>适当增加数据冗余：在不同节点存储同一数据的多个副本<ul>
<li>提高系统可靠性、可用性</li>
<li>提高系统性能</li>
<li>不利于更新，增大了系统维护代价。</li>
</ul>
</li>
<li>全局一致性、可串行性、可恢复性</li>
</ul>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">全局外模式--&gt;|映象1|全局概念模式</span><br><span class="line">全局概念模式--&gt;|映象2|分片模式</span><br><span class="line">分片模式--&gt;|映象3|分布模式</span><br><span class="line">分布模式--&gt;|映象4|局部概念模式</span><br></pre></td></tr></table></figure>
<ul>
<li>全局概念模式定义了数据库的整体逻辑结构</li>
<li>分片模式定义了数据库关系的全局关系的分片方式</li>
<li>分布模式定义了各片段的存储位置，进而决定了数据库是否冗余。</li>
<li>各级映像中存储了上级模式到下级模式的映射关系</li>
</ul>
<blockquote>
<p>映象的作用类似虚拟地址和物理地址的转换。例如，映象1为外模式在概念模式中选取合适的部分进行构造；映象2的作用就是为每个关系指定合适的分片方式；映象3则是为每个分片方式确定合适的存储位置（虚拟，类似数据库1、2、3…）；映象4将分布模式中的虚拟存储位置映射到现实中的物理存储位置。</p>
<p>综上，模式是<strong>“原则/方法/定义”</strong>的集合，映象是集合间的映射关系，通常是在下级映象中进行选择，然后返回结果由上级映象使用。</p>
</blockquote>
<h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul>
<li><p>水平：关系模式不变，将元组进行分割。</p>
</li>
<li><p>垂直：对属性集合进行划分</p>
<blockquote>
<p>为了具有可复原性，<strong>通常</strong>让各个片段都具有原关系的码。（不是必要条件）</p>
</blockquote>
</li>
<li><p>导出：利用其他关系模式的属性对某一关系进行水平分片。</p>
<blockquote>
<p>连表后选择，然后再去掉多余属性。</p>
</blockquote>
</li>
<li><p>混合</p>
</li>
</ul>
<h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5><ul>
<li>完全性：各个片段的并需要涵盖全局关系的所有信息</li>
<li>不相交性</li>
<li>可重构性：片段可以重构全局关系<ul>
<li>水平：并</li>
<li>垂直：自然连接</li>
</ul>
</li>
</ul>
<h4 id="分布透明性"><a href="#分布透明性" class="headerlink" title="分布透明性"></a>分布透明性</h4><ul>
<li><strong>分片</strong>透明性（分片模式）</li>
<li><strong>位置</strong>透明性（分布模式）</li>
<li>局部数据模型透明性（局部概念模式）：用户/应用程序不关心节点的DBMS类型（使用统一的查询语言）</li>
</ul>
<h4 id="DDBMS"><a href="#DDBMS" class="headerlink" title="DDBMS"></a>DDBMS</h4><ul>
<li>LDBMS：场地自治，执行局部应用及全局查询的<strong>子查询</strong></li>
<li>GDBMS：提供分布透明性，保证数据库的全局一致性。<ul>
<li>协调全局事务的执行</li>
<li>协调局部DBMS</li>
<li>并发控制</li>
<li>更新同步</li>
<li>全局恢复</li>
</ul>
</li>
<li>GDD<ul>
<li>全局概念模式、分片模式、分布模式、各级映象</li>
<li>用户权限定义</li>
<li>完整性约束条件</li>
</ul>
</li>
<li>CM：通信管理</li>
</ul>
<h5 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5><ul>
<li>全局控制<strong>集中</strong>：GDD和GDBMS集成在一起<ul>
<li>控制简单</li>
<li>易形成<strong>性能</strong>瓶颈</li>
<li>可靠性低</li>
</ul>
</li>
<li>全局控制<strong>分散</strong><ul>
<li>完全：GDBMS和GDD分布在<strong>每个</strong>节点上<ul>
<li>节点独立</li>
<li>自治性强</li>
<li>控制复杂</li>
</ul>
</li>
<li>部分：GDBMS和GDD分布在<strong>某些</strong>节点上</li>
</ul>
</li>
<li>同构型：各个节点的DBMS相同</li>
<li>异构型：各个节点的DBMS不同</li>
</ul>
<h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><h5 id="分类-5"><a href="#分类-5" class="headerlink" title="分类"></a>分类</h5><ul>
<li>局部</li>
<li>远程</li>
<li>全局</li>
</ul>
<blockquote>
<p>局部和远程查询<strong>只</strong>涉及<strong>单个</strong>节点，全局查询涉及<strong>多个</strong>节点。</p>
</blockquote>
<h5 id="处理-1"><a href="#处理-1" class="headerlink" title="处理"></a>处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">查询分解--&gt;确定操作次序</span><br><span class="line">确定操作次序--&gt;选择操作执行方法</span><br></pre></td></tr></table></figure>
<h5 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h5><p>查询开销=I/O代价+CPU代价+通信代价（主要）</p>
<ul>
<li><p>分类</p>
<ul>
<li><p>分布优化（<strong>更重要</strong>）</p>
<ul>
<li><p>传送时间T=总传输延迟（由网络本身决定）+总数据量/传输速度</p>
<blockquote>
<p>问答方式中通常会<strong>忽略</strong>传送时间而<strong>只考虑</strong>传输延迟</p>
</blockquote>
</li>
</ul>
</li>
<li><p>局部优化</p>
</li>
</ul>
</li>
<li><p>目标：减小通信代价</p>
<blockquote>
<p>通信代价通常来自于不同节点间的<strong>连接和并</strong>操作</p>
</blockquote>
</li>
<li><p>技术</p>
<ul>
<li><p>半连接：在连接之前，先对其中某个关系进行所需属性的投影，然后再进行连接。</p>
<p>$R_3=R_1{\ltimes}_{A=B} R_2=R_1{\bowtie}_{A=B}(\Pi_B(R_2))$</p>
<ul>
<li><p>得到的结果是<strong>没有投影</strong>的关系$R_1$的子集</p>
<blockquote>
<p>从$R_1$中提取出了<strong>有用</strong>的元组</p>
</blockquote>
</li>
<li><p>$R_1\bowtie R_2=(R_1\ltimes R_2)\bowtie R_2$</p>
<blockquote>
<p>连接=半连接+连接=投影+连接+连接</p>
</blockquote>
</li>
<li><p>在使用优化技术之前，需要进行估算。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分布事务处理</p>
<ul>
<li><p><code>NewSQL</code></p>
</li>
<li><p>原子性：全局事务的子事务要么一起提交，要么全部回滚。</p>
</li>
<li><p>可串行性：多用户系统</p>
</li>
<li><p>恢复：两段提交协议</p>
<ul>
<li>局部事务管理<ul>
<li>协调者（一个）</li>
<li>参与者（多个）</li>
</ul>
</li>
<li>第一阶段：协调者征求意见做决定</li>
<li>第二阶段：参与者执行决定</li>
</ul>
</li>
<li><p>并发控制：封锁技术</p>
<ul>
<li><p>写操作需要申请<strong>所有</strong>副本的<code>X</code>锁，读操作<strong>只要</strong>申请一个副本的<code>S</code>锁。</p>
</li>
<li><p>读/写操作均对<strong>大多数</strong>副本申请<code>X</code>和<code>S</code>锁</p>
<blockquote>
<p>大多数指“<strong>大于</strong>一半”，所以上锁时一定会出现相交情况。</p>
</blockquote>
</li>
<li><p>设置主副本，所有读/写都需要对主副本上锁。</p>
</li>
<li><p>全局死锁解决（<strong>两个及以上</strong>场地发生死锁）</p>
<ul>
<li>检测及解除</li>
<li>预防</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Reference-9"><a href="#Reference-9" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>BUAA Database Theory Lecture, Autumn of 2020.</li>
<li>Shan Wang, Shixuan Sa, Database System Syllabus(5th Edition), Advanced Education Express.</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/23/C++-Learning-Note/" rel="prev" title="C++ Learning Note">
      <i class="fa fa-chevron-left"></i> C++ Learning Note
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/23/JavaScript-Learning-Note/" rel="next" title="JavaScript Learning Note">
      JavaScript Learning Note <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silence Jiang</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  Visitors: <span id="busuanzi_value_site_pv"></span>
</span>
</div>

<div class="theme-info">
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">101.1k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">3:15</span>
  <div class="powered-by"></div>
</div>
  <div class="powered-by">
  </div>

        








      </div>
    </footer>
  </div>

  
  <script defer src="//cdn.jsdelivr.net/npm/three@0/build/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/next-boot.js"></script>


  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: location.pathname,
    }, {"enable":true,"appId":"GMneVEFPu4TwpvejAPqllWGc-gzGzoHsz","appKey":"5eNvc7SV1dxRT000WSXjRDuD","placeholder":"Just write what you'd like to write.","avatar":"mm","meta":["nick","mail"],"pageSize":10,"language":"en","visitor":false,"comment_count":true,"recordIP":false,"serverURLs":null}
    ));
  }, window.Valine);
});
</script>

  <!-- 背景动画 -->
  <!-- three_waves
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/three-waves.min.js"></script>
  -->

  <!-- canvas_lines
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/three-waves.min.js"></script>
  -->

  <!-- canvas_sphere
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/three-waves.min.js"></script>
  -->

  <!-- Canvas-nest
  <script type="text/javascript" color="0,0,255" opacity='0.5' zIndex="-2" count="999" src="https://files.cnblogs.com/files/yaohunzhanyue/canvas-nest.js"></script>
  -->

  <!-- Canvas-ribbon -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
</body>
</html>

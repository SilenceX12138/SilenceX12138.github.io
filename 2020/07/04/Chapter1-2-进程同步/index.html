<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="全文共6329字，推荐阅读时间30~45分钟。">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter1-2-进程同步">
<meta property="og:url" content="http://yoursite.com/2020/07/04/Chapter1-2-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/index.html">
<meta property="og:site_name" content="Silence">
<meta property="og:description" content="全文共6329字，推荐阅读时间30~45分钟。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-04T08:05:30.916Z">
<meta property="article:modified_time" content="2020-07-04T08:10:16.049Z">
<meta property="article:author" content="Silence">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/07/04/Chapter1-2-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Chapter1-2-进程同步 | Silence</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Silence" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Silence</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-lover">

    <a href="/lover/" rel="section"><i class="fa fa-heart fa-fw"></i>lover</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发错误"><span class="nav-number">2.</span> <span class="nav-text">并发错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据竞争-data-race"><span class="nav-number">2.1.</span> <span class="nav-text">数据竞争(data race)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性违反-Atomicity-Violation"><span class="nav-number">2.2.</span> <span class="nav-text">原子性违反(Atomicity Violation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">2.3.</span> <span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步机制"><span class="nav-number">3.</span> <span class="nav-text">同步机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥方法"><span class="nav-number">4.</span> <span class="nav-text">互斥方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于忙等待的互斥方法"><span class="nav-number">4.1.</span> <span class="nav-text">基于忙等待的互斥方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于信号量的方法"><span class="nav-number">4.2.</span> <span class="nav-text">基于信号量的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥"><span class="nav-number">4.2.1.</span> <span class="nav-text">互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#汇合-Rendezvous"><span class="nav-number">4.2.2.</span> <span class="nav-text">汇合(Rendezvous)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多路复用-Multiplex"><span class="nav-number">4.2.3.</span> <span class="nav-text">多路复用(Multiplex)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#屏障-Barriers"><span class="nav-number">4.2.4.</span> <span class="nav-text">屏障(Barriers)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#“信号量集”机制"><span class="nav-number">4.2.5.</span> <span class="nav-text">“信号量集”机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AND型信号量集"><span class="nav-number">4.2.6.</span> <span class="nav-text">AND型信号量集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一般“信号量集”机制"><span class="nav-number">4.2.7.</span> <span class="nav-text">一般“信号量集”机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥量-Mutex"><span class="nav-number">4.2.8.</span> <span class="nav-text">互斥量(Mutex)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于管程的同步和互斥"><span class="nav-number">4.3.</span> <span class="nav-text">基于管程的同步和互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#管程-Monitor"><span class="nav-number">4.3.1.</span> <span class="nav-text">管程(Monitor)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件变量"><span class="nav-number">4.3.2.</span> <span class="nav-text">条件变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程通信-IPC-方法"><span class="nav-number">4.4.</span> <span class="nav-text">进程通信(IPC)方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分类"><span class="nav-number">4.4.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道通信"><span class="nav-number">4.4.2.</span> <span class="nav-text">管道通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息传递"><span class="nav-number">4.4.3.</span> <span class="nav-text">消息传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存"><span class="nav-number">4.4.4.</span> <span class="nav-text">共享内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经典的进程同步问题"><span class="nav-number">5.</span> <span class="nav-text">经典的进程同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者"><span class="nav-number">5.1.</span> <span class="nav-text">生产者消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写者问题"><span class="nav-number">5.2.</span> <span class="nav-text">读写者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理发师问题"><span class="nav-number">5.3.</span> <span class="nav-text">理发师问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序唤醒问题"><span class="nav-number">5.4.</span> <span class="nav-text">有序唤醒问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#固定差值问题"><span class="nav-number">5.5.</span> <span class="nav-text">固定差值问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建水分子-H2O"><span class="nav-number">5.6.</span> <span class="nav-text">构建水分子(H2O)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁-deadlock"><span class="nav-number">6.</span> <span class="nav-text">死锁(deadlock)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">6.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#必要条件"><span class="nav-number">6.2.</span> <span class="nav-text">必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理办法"><span class="nav-number">6.3.</span> <span class="nav-text">处理办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁检测"><span class="nav-number">6.4.</span> <span class="nav-text">死锁检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资源分配图"><span class="nav-number">6.4.1.</span> <span class="nav-text">资源分配图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源向量（矩阵）法"><span class="nav-number">6.4.2.</span> <span class="nav-text">资源向量（矩阵）法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁恢复"><span class="nav-number">6.5.</span> <span class="nav-text">死锁恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁预防"><span class="nav-number">6.6.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哲学家进餐问题-the-dining-philosophers-problem"><span class="nav-number">6.7.</span> <span class="nav-text">哲学家进餐问题(the dining philosophers problem)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁避免"><span class="nav-number">6.8.</span> <span class="nav-text">死锁避免</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#银行家算法"><span class="nav-number">6.8.1.</span> <span class="nav-text">银行家算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源分配图-1"><span class="nav-number">6.8.2.</span> <span class="nav-text">资源分配图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FAQ"><span class="nav-number">7.</span> <span class="nav-text">FAQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">8.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Silence"
      src="https://i.loli.net/2020/07/05/Ml7X4UshoCJgn52.jpg">
  <p class="site-author-name" itemprop="name">Silence</p>
  <div class="site-description" itemprop="description">I'm right here waiting for you.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SilenceX12138" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SilenceX12138" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/silencejiang12138" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;silencejiang12138" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/04/Chapter1-2-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2020/07/05/Ml7X4UshoCJgn52.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="I'm right here waiting for you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silence">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Chapter1-2-进程同步
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-04 16:05:30 / Modified: 16:10:16" itemprop="dateCreated datePublished" datetime="2020-07-04T16:05:30+08:00">2020-07-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Operating-System/" itemprop="url" rel="index"><span itemprop="name">Operating System</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/07/04/Chapter1-2-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/07/04/Chapter1-2-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>全文共<code>6329</code>字，推荐阅读时间<code>30~45</code>分钟。</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>制约</p>
<ul>
<li>直接：进程合作</li>
<li>间接：资源共享</li>
</ul>
</li>
<li><p>进程同步：多个相关进程在<strong>次序</strong>上的协调</p>
</li>
<li><p>原语：由若干条指令组成的序列，并实现某个特定的操作功能。</p>
<ul>
<li><p>指令序列的执行是连续的，不可<strong>分割</strong>。</p>
<blockquote>
<p>即指原语的执行是原子的，不能够被打断。</p>
</blockquote>
</li>
<li><p>OS的核心组成部分</p>
</li>
<li><p>必须在管态（内核态）下执行，且常驻内存。</p>
</li>
<li><p>根据用途进行命名，例如用于进程同步则叫做“同步原语”。</p>
</li>
</ul>
</li>
</ul>
<h2 id="并发错误"><a href="#并发错误" class="headerlink" title="并发错误"></a>并发错误</h2><h3 id="数据竞争-data-race"><a href="#数据竞争-data-race" class="headerlink" title="数据竞争(data race)"></a>数据竞争(data race)</h3><ul>
<li><p>多个进程/线程对共享变量<strong>无保护同时</strong>访问，且<strong>至少有一个</strong>是<strong>写</strong>。</p>
</li>
<li><p>互斥：一个时刻只能由一个进程访问共享数据。</p>
<blockquote>
<p>避免数据竞争</p>
</blockquote>
</li>
<li><p>临界区：对临界资源进行访问的<strong>程序片段</strong></p>
<ul>
<li>一个时间，临界区内只能有<strong>一个</strong>进程。</li>
<li>临界区外的进程不能妨碍其他的进程进入临界区</li>
<li>一个进程不能在临界区外<strong>无限等待</strong></li>
</ul>
</li>
<li><p>临界资源：一次只允许<strong>一个</strong>进程使用的资源，如打印机、共享变量。</p>
<blockquote>
<p>假脱机打印(spooling)：进程打印文件是把文件放在缓冲区，使临界资源（打印机）可以被共享访问。</p>
</blockquote>
</li>
</ul>
<h3 id="原子性违反-Atomicity-Violation"><a href="#原子性违反-Atomicity-Violation" class="headerlink" title="原子性违反(Atomicity Violation)"></a>原子性违反(Atomicity Violation)</h3><ul>
<li><code>HeisenBug</code></li>
<li>多线程结果不可再现的原因<ul>
<li>不同的环境输入</li>
<li>不同的API返回</li>
<li>不同的调度时间</li>
<li>中断时间</li>
<li>共享内存访问的顺序（取决于各个核执行的快慢）</li>
</ul>
</li>
<li>执行<strong>重放技术</strong>：在执行时记录所有的相关信息，重放时再写回。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>进程集合中都在<strong>互相等待</strong></li>
</ul>
<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待：当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</li>
</ul>
<h2 id="互斥方法"><a href="#互斥方法" class="headerlink" title="互斥方法"></a>互斥方法</h2><h3 id="基于忙等待的互斥方法"><a href="#基于忙等待的互斥方法" class="headerlink" title="基于忙等待的互斥方法"></a>基于忙等待的互斥方法</h3><ul>
<li><p>忙等：不能满足进入临界区条件就一直等</p>
<blockquote>
<p>可能导致优先级反转：进入临界区后的进程被调度后依然在临界区中</p>
<p>Q：用户级线程实现会不会发生优先级反转</p>
<p>A： 不会。</p>
<p>在<strong>用户级</strong>线程之间，因为抢占发生在<strong>进程</strong>级别，所以低优先级不会被高优先级抢占。但是<strong>内核级</strong>线程可能会发生优先级反转。</p>
</blockquote>
</li>
<li><p>屏蔽中断</p>
<ul>
<li>用户程序不可取（安全问题）</li>
<li>关闭中断<strong>只能关闭</strong>一个CPU</li>
<li>内核常使用</li>
</ul>
</li>
<li><p>共享锁变量</p>
<ul>
<li>初值设置为0</li>
<li>发现未上锁，并且在上锁（置1）<strong>前</strong>被调度的话会导致多个进程进入临界区</li>
</ul>
<blockquote>
<p>读取和设置锁<strong>必须</strong>是一个原子操作</p>
</blockquote>
</li>
<li><p>严格轮换法</p>
<ul>
<li><p>要求<strong>两个</strong>进程交替执行（使用<code>turn</code>实现）</p>
</li>
<li><p>由于IO可能会导致进程被<strong>未处在</strong>临界区的进程阻塞，违反了同步机制和临界区的规则。</p>
</li>
</ul>
</li>
<li><p>Peterson算法</p>
<ul>
<li><p>在严格轮换法基础上增加<code>interested[]</code>表示进程是否会马上使用CPU</p>
<blockquote>
<ul>
<li>当两个进程同时调度<code>enter_region</code>时，先被写入的<code>turn</code>会被覆盖，因此调度执行的可能会是后写<code>turn</code>的进程。</li>
<li>并发执行也能正常执行，但是<strong>非抢占式</strong>调度可能导致不公平。</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line"><span class="keyword">int</span> interested[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> procnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> othernum;</span><br><span class="line">    </span><br><span class="line">    othernum = <span class="number">1</span> - procnum;</span><br><span class="line">    interested[procnum] = TRUE;</span><br><span class="line">	<span class="built_in">turn</span> = procnum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">turn</span> == procnum &amp;&amp; interested[other] == TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> procnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    interested[procnum] = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>硬件指令机制</p>
<ul>
<li><p><code>TSL</code>：CPU会锁住<strong>内存总线</strong></p>
</li>
<li><p><code>XCHG</code>：<strong>原子性</strong>的值交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVE REG,#1</span><br><span class="line">XCHG REG,LOCK</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>信号量机制(Semaphore)</p>
<ul>
<li><p>原子操作：一组相关联的操作要么<strong>不间断</strong>地执行，要么<strong>都不</strong>执行。</p>
</li>
<li><p>S有且只有一次置初值的机会</p>
<ul>
<li><p>$S&gt;0$：表示可以同时获取的资源数目</p>
<blockquote>
<p>不同的OS中可能出现$S&lt;0$的情况</p>
</blockquote>
</li>
<li><p>只能由P/V操作改变</p>
</li>
</ul>
</li>
<li><p>$P(S)$：<code>down</code>操作分配资源</p>
</li>
<li><p>$S&gt;0$：信号量减1后继续执行</p>
<ul>
<li>$S=0$：进程被直接阻塞，减1操作等到阻塞完成后再执行。 </li>
</ul>
<blockquote>
<p>原子操作，只有一个进程能完成$P(S)$.</p>
</blockquote>
</li>
<li><p>$V(S)$：<code>up</code>操作释放资源</p>
<ul>
<li><p>首先将S加1</p>
</li>
<li><p>如果加1后发现有进程在信号量队列中<code>sleep</code>,则随机唤醒一个进程然后进行<code>P(S)</code></p>
<blockquote>
<p>S：0-&gt;1-&gt;0</p>
</blockquote>
</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li>DS：一个整数+一个队列（类似哈希链表）</li>
<li>操作前关闭中断，操作后打开中断。</li>
<li>单CPU：关闭中断后测试并更新信号量</li>
<li>多CPU：使用<strong>锁变量</strong>保护信号量，使用<code>TSL</code>/<code>XCHG</code>保证每次只能由一个CPU检查<strong>信号量</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>类似于分配一个数组中的元素，s是数组的元素个数，当s设置为1时，就是<code>mutex</code>（互斥）的。</p>
</blockquote>
</li>
</ul>
<h3 id="基于信号量的方法"><a href="#基于信号量的方法" class="headerlink" title="基于信号量的方法"></a>基于信号量的方法</h3><p>信号量将<code>sleep</code>和<code>wakup</code>信息存储了起来，避免了相关信息丢失造成的死锁。</p>
<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><ul>
<li>信号量初值设置为1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line">P(mutex)</span><br><span class="line">a();</span><br><span class="line">V(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line">P(mutex);</span><br><span class="line">b();</span><br><span class="line">V(mutex);</span><br></pre></td></tr></table></figure>
<h4 id="汇合-Rendezvous"><a href="#汇合-Rendezvous" class="headerlink" title="汇合(Rendezvous)"></a>汇合(Rendezvous)</h4><ul>
<li><p>两个进程的同步，使得a1永远在b2之前，b1永远在a2之前</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore aArrived = <span class="number">0</span>; <span class="comment">// not 1</span></span><br><span class="line">semaphore bArrived = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1</span></span><br><span class="line">a1();</span><br><span class="line">V(aArrived);</span><br><span class="line">P(bArrived);</span><br><span class="line">a2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// P2</span></span><br><span class="line">b1();</span><br><span class="line">V(bArrived);</span><br><span class="line">P(aArrived);</span><br><span class="line">b2();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="多路复用-Multiplex"><a href="#多路复用-Multiplex" class="headerlink" title="多路复用(Multiplex)"></a>多路复用(Multiplex)</h4><ul>
<li><code>mutex</code>泛化，使n个线程能够<strong>同时在临界区</strong>运行，也称为限流阀。</li>
</ul>
<h4 id="屏障-Barriers"><a href="#屏障-Barriers" class="headerlink" title="屏障(Barriers)"></a>屏障(Barriers)</h4><ul>
<li><p>低级通信原语</p>
</li>
<li><p>对Rendezvous进行<strong>泛化</strong>，能够同步<strong>多个</strong>线程。 </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = the number of threads</span><br><span class="line">count = <span class="number">0</span> <span class="comment"># threads arrive at barrier</span></span><br><span class="line">semaphore mutex = <span class="number">1</span> <span class="comment"># protect count</span></span><br><span class="line">semaphore barrier = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">count = count + <span class="number">1</span></span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count == n:</span><br><span class="line">    V(barrier)</span><br><span class="line">P(barrier)</span><br><span class="line">V(barrier)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意在<code>count==n</code>时地进程也需要执行尾部的一对PV操作</p>
</blockquote>
<h4 id="“信号量集”机制"><a href="#“信号量集”机制" class="headerlink" title="“信号量集”机制"></a>“信号量集”机制</h4><ul>
<li>当出现多个临界资源时（多个对不同信号量的P操作），不正确的PV顺序可能会导致死锁。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1</span></span><br><span class="line">P(mutex1); <span class="comment">// step 1</span></span><br><span class="line">P(mutex2); <span class="comment">// wait</span></span><br><span class="line">V(mutex2); <span class="comment">// cannot execute</span></span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line">P(mutex2); <span class="comment">// step 2</span></span><br><span class="line">P(mutex1); <span class="comment">// wait</span></span><br><span class="line">V(mutex1); <span class="comment">// cannot execute</span></span><br><span class="line">V(mutex2);</span><br></pre></td></tr></table></figure>
<h4 id="AND型信号量集"><a href="#AND型信号量集" class="headerlink" title="AND型信号量集"></a>AND型信号量集</h4><ul>
<li>同时需要<strong>多个</strong>资源且每种占用<strong>一个</strong>资源</li>
<li>基本思想：将几个进程需要的所有资源一次性分配给其中一个进程，等它使用完它需要的资源后再释放。</li>
<li>$SP(S_1,S_2,…,S_n)$</li>
<li>$SV(S_1,S_2,…,S_n)$</li>
<li>可能影响SP操作进程化归到不同的阻塞队列，但是资源的<strong>原子性</strong>获取不受影响，所以不会死锁。</li>
</ul>
<blockquote>
<p>当某个资源数量不够时，其他资源也<strong>不会被</strong>分配，因此<strong>原子性</strong>分配保证了安全性。</p>
</blockquote>
<h4 id="一般“信号量集”机制"><a href="#一般“信号量集”机制" class="headerlink" title="一般“信号量集”机制"></a>一般“信号量集”机制</h4><ul>
<li><p>同时需要多种资源，每种占用数目<strong>不同</strong>，并且被分配的资源还存在一个<strong>临界值</strong>（大于该临界值才能够分配资源）。</p>
</li>
<li><p>$SP(S_1,t_1,d_1;…;S_n,t_n,d_n)$</p>
<p><code>ti</code>是检测值，当所有<code>Si&gt;=ti</code>时才分配<code>di</code>个<code>i</code>类资源，其余情况则阻塞。</p>
</li>
<li><p>$SV(S_1,d_1;…;S_n,d_n)$</p>
</li>
</ul>
<blockquote>
<p>特殊情况：</p>
<ul>
<li>$SP(S,d,d)$：每次分配d个资源，少于d时不分配。</li>
<li>$SP(S,1,1)$：当S初值为1时，等价于<code>mutex</code>.</li>
<li>$SP(S,1,0)$：开关机制，S为0时可以禁止所有的进程进入临界区。</li>
</ul>
</blockquote>
<h4 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量(Mutex)"></a>互斥量(Mutex)</h4><ul>
<li>信号量设置为1就是互斥量</li>
<li><strong>0表示解锁，1表示加锁。</strong>（和PV操作中0阻塞不同）</li>
<li>如果<code>mutex</code>已经加锁，调用<code>mutex_lock</code>会阻塞。</li>
<li>主要在<strong>用户线程库</strong>实现</li>
<li><code>mutex_trylock</code>使得进程不会因为无法获得锁而阻塞，而是返回错误码。</li>
</ul>
<h3 id="基于管程的同步和互斥"><a href="#基于管程的同步和互斥" class="headerlink" title="基于管程的同步和互斥"></a>基于管程的同步和互斥</h3><h4 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h4><ul>
<li>一种<strong>高级</strong>的同步原语，基于条件变量实现。</li>
<li>定义了一个数据结构和并发进程能执行的一组操作</li>
<li>为每个临界资源设立一个管程</li>
<li>任意时刻，管程中只能有一个活跃进程。</li>
</ul>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul>
<li>增加<code>wait/signal</code>操作</li>
<li>条件变量不像信号量可以存储信号，因此<code>wait</code>必须在<code>signal</code>之前执行。</li>
</ul>
<blockquote>
<ul>
<li>依赖于编译器支持</li>
<li>不适用于分布式系统</li>
</ul>
</blockquote>
<h3 id="进程通信-IPC-方法"><a href="#进程通信-IPC-方法" class="headerlink" title="进程通信(IPC)方法"></a>进程通信(IPC)方法</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>低级通信：只能传递<strong>状态和整数值</strong>（控制信息）<ul>
<li>进程互斥/同步采用的信号量和管程机制</li>
</ul>
</li>
<li><p>高级通信：可以传递任意数量的数据</p>
<ul>
<li>管道(Pipe)</li>
<li>共享内存(Shared Memory)：最快的IPC形式</li>
<li>消息系统</li>
</ul>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4></li>
<li><p>无名管道：使用<code>|</code>连接</p>
<ul>
<li>半双工：<strong>单方向</strong>流动</li>
<li>只能用于<strong>父子</strong>进程/<strong>兄弟</strong>进程</li>
</ul>
</li>
<li>有名管道：使用<code>mkfifo()</code>创建</li>
</ul>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><ul>
<li><p>通信原语</p>
<ul>
<li><code>send(dest, &amp;message)</code></li>
<li><code>receive(src, &amp;message)</code></li>
</ul>
</li>
<li><p>过程：</p>
<ul>
<li>发起<code>send</code>请求并<strong>陷入内核</strong></li>
<li>将消息复制进入OS空间的消息缓冲区</li>
<li>将消息加入<strong>接收进程</strong>PCB的消息队列</li>
<li>将消息复制到<strong>接收进程</strong>中</li>
</ul>
</li>
<li><p>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore buf_empty = N;</span><br><span class="line">semaphore buf_full = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1 = <span class="number">1</span>; <span class="comment">// mem</span></span><br><span class="line">semaphore mutex2 = <span class="number">1</span>; <span class="comment">// PCB queue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// send</span></span><br><span class="line">P(buf_empty);</span><br><span class="line">P(mutex1);</span><br><span class="line">dup_to_mem();</span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line">P(mutex2);</span><br><span class="line">add_to_queue();</span><br><span class="line">V(mutex2);</span><br><span class="line">V(buf_full);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reveive</span></span><br><span class="line">P(buf_full);</span><br><span class="line">P(mutex1);</span><br><span class="line">dup_to_proc();</span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line">P(mutex2);</span><br><span class="line">del_from_queue();</span><br><span class="line">V(mutex2);</span><br><span class="line">V(buf_empty);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本质上也是一个生产者-消费者模型</p>
<ul>
<li>消费者<strong>一开始</strong>就申请满缓冲区，<strong>最后</strong>释放空缓冲区。</li>
<li>生产者<strong>一开始</strong>就申请空缓冲区，<strong>最后</strong>释放满缓冲区。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul>
<li>需要同步机制的约束</li>
</ul>
<h2 id="经典的进程同步问题"><a href="#经典的进程同步问题" class="headerlink" title="经典的进程同步问题"></a>经典的进程同步问题</h2><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><ul>
<li>网络应用响应</li>
</ul>
<h3 id="读写者问题"><a href="#读写者问题" class="headerlink" title="读写者问题"></a>读写者问题</h3><ul>
<li><p>共享资源<strong>并发</strong>访问</p>
</li>
<li><p>分类互斥问题</p>
<ul>
<li><p>写进程在临界区：其他进程不可以进入临界区</p>
</li>
<li><p>读进程在临界区：写进程不可以进入临界区</p>
<blockquote>
<p>第一个读线程加锁，最后一个读线程解锁。（灯开关模式）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readers = <span class="number">0</span>;</span><br><span class="line">  semaphore mutex = <span class="number">1</span>;</span><br><span class="line">  semaphore roomEmpty = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  cobegin&#123;</span><br><span class="line">    <span class="built_in">Process</span> Writer</span><br><span class="line">      P(roomEmpty);</span><br><span class="line">    	<span class="built_in">write</span>();</span><br><span class="line">      V(roomEmpty);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Process</span> Reader</span><br><span class="line">      P(mutex);</span><br><span class="line">      <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">          P(roomEmpty);</span><br><span class="line">      readers += <span class="number">1</span>;</span><br><span class="line">      V(mutex);</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">read</span>();</span><br><span class="line">  </span><br><span class="line">      P(mutex);</span><br><span class="line">      readers -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">          V(roomEmpty);</span><br><span class="line">      V(mutex);</span><br><span class="line">  &#125;coend</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现方式</p>
<ul>
<li><p>一般信号量集机制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore readers = N;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin&#123;</span><br><span class="line">    <span class="built_in">Process</span> Writer</span><br><span class="line">    SP(mutex,<span class="number">1</span>,<span class="number">1</span>;readers,N,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    SV(mutex,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Process</span> Reader</span><br><span class="line">    SP(mutex,<span class="number">1</span>,<span class="number">0</span>;readers,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    SV(readers,<span class="number">1</span>);</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在写者中维护<code>mutex</code>，在读者中维护<code>readers</code>.</p>
</blockquote>
</li>
<li><p><code>wait-signal</code></p>
</li>
<li><p>PV</p>
</li>
</ul>
<blockquote>
<p>灯开关模式对<strong>读</strong>有利，对<strong>写</strong>不利。</p>
</blockquote>
</li>
<li><p>公平读写（非饥饿版本）</p>
<ul>
<li>使用<code>barrier</code>实现<code>Turnstile</code></li>
<li>闸机可以阻塞所有的进程，也可以让进程轮流通过。<ul>
<li>当信号量为0，闸机关闭，任何进程都<strong>不能够</strong>进入。（在写者<strong>进入</strong>后设置）</li>
<li>当信号量为1，闸机打开，允许多个进程<strong>排队</strong>进入。（在写者<strong>完成</strong>后设置）</li>
</ul>
</li>
</ul>
<blockquote>
<p>是否完全公平还取决于<strong>调度器</strong>选择哪一个在<code>turnstile</code>中排队的进程</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int readers = <span class="number">0</span></span><br><span class="line">Semaphore mutex = <span class="number">1</span>		<span class="comment"># mutually exclusively access readers</span></span><br><span class="line">Semaphore roomEmpty = <span class="number">1</span></span><br><span class="line">Semaphore turnstile = <span class="number">1</span> <span class="comment"># use turnstile as a barrier to make it fair</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader</span></span><br><span class="line">P(turnstile)</span><br><span class="line">V(turnstile)</span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">readers += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (readers == <span class="number">1</span>):</span><br><span class="line">    P(roomEmpty) <span class="comment"># the first reader will lock the room</span></span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line">read_in_critical_region()</span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">reader -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(readers == <span class="number">0</span>):</span><br><span class="line">    V(roomEmpty) <span class="comment"># the last reader will unlock the room</span></span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Writer</span></span><br><span class="line">P(turnstile) <span class="comment"># wait in line of turnstile</span></span><br><span class="line">P(roomEmpty) <span class="comment"># wait in line of roomEmpty</span></span><br><span class="line"></span><br><span class="line">write_in_critical_region()</span><br><span class="line"></span><br><span class="line">V(roomEmpty) <span class="comment"># after writing, unlock the room.</span></span><br><span class="line">V(turnstile) <span class="comment"># after writing, reopen the turnstile.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在两个进程最开始都是获得<code>turnsile</code>，不会出现写者获得<code>turnsile</code>并且<code>roomEmpty</code>被锁定时的同时没有任何<strong>读进程</strong>在执行的死锁情况。（一定先有读进程获得了<code>turnsile</code>才会获得<code>roomEmpty</code>.</p>
</blockquote>
<h3 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h3><ul>
<li><p>理发店中有一位理发师、一把理发椅和<code>n</code>把等候椅。</p>
</li>
<li><p>没有顾客时，理发师在理发椅上休息，顾客到来时叫醒理发师。</p>
</li>
<li><p>顾客到来时，如果有空椅子则等待，否则离开。</p>
</li>
<li><p>分析：</p>
<ul>
<li><p><strong>互斥</strong>：两个进程对等待人数的改变</p>
<blockquote>
<p>本质是两个进程都会改变的<strong>非信号量</strong></p>
</blockquote>
</li>
<li><p><strong>同步</strong>：第一个顾客唤醒理发师，理发师唤醒下一个顾客。</p>
<blockquote>
<p>本质是使用<strong>信号量</strong>进行进程间同步</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAIRS 10</span></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore clients = <span class="number">0</span>;</span><br><span class="line">semaphore barber = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin&#123;</span><br><span class="line">    Barber</span><br><span class="line">    P(clients);</span><br><span class="line">    </span><br><span class="line">    P(mutex);</span><br><span class="line">    waiting -= <span class="number">1</span>;</span><br><span class="line">    V(mutex);</span><br><span class="line">    </span><br><span class="line">    cut();</span><br><span class="line">    V(barber);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Client</span></span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting == CHAIRS)</span><br><span class="line">    &#123;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    waiting += <span class="number">1</span>;</span><br><span class="line">    V(mutex)</span><br><span class="line">    </span><br><span class="line">    V(clients);</span><br><span class="line">    P(barber);</span><br><span class="line">    get_cut();</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>P</code>操作就是在排队，相当于是一个<code>while(conditionNotSatisfied);</code>阻塞。</li>
<li><code>waiting</code>计数在限制等待容量时才有意义</li>
<li>在某某些条件不满足直接返回时（如没有椅子直接离开和没有顾客直接睡觉），要<strong>释放</strong>当前进程已经占有的资源，不能够直接<code>continue</code>或者<code>return</code>.</li>
<li><code>waiting</code>和<code>clients</code>虽然意义相似，但是信号量不能直接取值进行比较，所以需要增加<code>waiting</code>.</li>
<li>在<code>Barber</code>线程中，将<code>P(clients)</code>放在最前面可以简化将<code>waiting</code>放在前面时对0的判断。</li>
</ul>
</blockquote>
<h3 id="有序唤醒问题"><a href="#有序唤醒问题" class="headerlink" title="有序唤醒问题"></a>有序唤醒问题</h3><ul>
<li>顾客接受服务的顺序应该和进入顺序保持一致</li>
<li>分析：<ul>
<li>互斥：当前已经进入银行的人员总数</li>
<li>同步：注意<strong>同一个柜台连续两次</strong>服务的人员<code>id</code>可能是<strong>跳跃</strong>的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> clients = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next_id = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore next_mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin&#123;</span><br><span class="line">    Stuff</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(next_mutex);</span><br><span class="line">        <span class="keyword">if</span>(next_id == clients)</span><br><span class="line">        &#123;</span><br><span class="line">            V(next_mutex);</span><br><span class="line">            V(mutex);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_id += <span class="number">1</span>;</span><br><span class="line">        V(next_mutex);</span><br><span class="line">        V(mutex);</span><br><span class="line"></span><br><span class="line">        serve(next_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Client</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    P(mutex);</span><br><span class="line">    clients += <span class="number">1</span>;</span><br><span class="line">    id = clients;</span><br><span class="line">	V(mutex);</span><br><span class="line">    </span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>此时人员不用<strong>唤醒柜台</strong>（柜台没有睡觉），柜台会自动进行服务，所以能够简化<code>stuff</code>信号量。</li>
</ul>
</blockquote>
<h3 id="固定差值问题"><a href="#固定差值问题" class="headerlink" title="固定差值问题"></a>固定差值问题</h3><ul>
<li>无限大的仓库装A和B，要求两者始终满足库存$-M&lt;=A-B&lt;=N$</li>
<li>分析：<ul>
<li>互斥：A和B的差值，只取正数的话需要分为两个。</li>
<li>同步：满足条件时才能够继续入库</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">semaphore sa = N; <span class="comment">// A - B</span></span><br><span class="line">semaphore sb = M; <span class="comment">// B - A</span></span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">&#123;</span><br><span class="line">	A</span><br><span class="line">    P(sa);</span><br><span class="line">   	a += <span class="number">1</span>;</span><br><span class="line">    V(sb);</span><br><span class="line">    </span><br><span class="line">    B</span><br><span class="line">    P(sb);</span><br><span class="line">    b += <span class="number">1</span>;</span><br><span class="line">    V(sa);</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果仓库容量有限，可以在两个进程的最前面加一个判断。</li>
<li>增加<strong>一个</strong>消费者：需要先对库存进行<strong>非零</strong>判断，同时，P操作其实隐含了一个条件判断，所以在消费是，需要把P操作放在V操作之前，如果P不能通过，那么V就不应该出现。<ul>
<li>消费A：<code>P(sb)&amp;V(sa)&amp;mutex</code></li>
<li>消费B：<code>P(sa)&amp;V(sb)&amp;mutex</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="构建水分子-H2O"><a href="#构建水分子-H2O" class="headerlink" title="构建水分子(H2O)"></a>构建水分子(H<sub>2</sub>O)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">oxygen = <span class="number">0</span></span><br><span class="line">hydrogen = <span class="number">0</span></span><br><span class="line">Semaphore mutex = <span class="number">1</span> <span class="comment"># only oxygen or hydrogen can be modified at a time</span></span><br><span class="line">Barrier barrier(<span class="number">3</span>)  <span class="comment"># after wait for three times, process can go on.</span></span><br><span class="line">Semaphore oxyQueue = <span class="number">0</span></span><br><span class="line">Semaphore hydroQueue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># oxygen atom</span></span><br><span class="line">P(mutex)</span><br><span class="line">oxygen += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (hydrogen &gt;= <span class="number">2</span>):</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    hydrogen -= <span class="number">2</span></span><br><span class="line">    V(oxygenQueue)</span><br><span class="line">    oxygen -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    V(mutex)</span><br><span class="line">P(oxygenQueue)</span><br><span class="line">bond()</span><br><span class="line">barrier.wait()</span><br><span class="line">V(mutex) <span class="comment"># only oxygen thread has this V operation</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hydrogen atom</span></span><br><span class="line">P(mutex)</span><br><span class="line">hydrogen += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (hydrogen &gt;= <span class="number">2</span> <span class="keyword">and</span> oxygen &gt;= <span class="number">1</span>):</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    V(hydrogenQueue)</span><br><span class="line">    hydrogen -= <span class="number">2</span></span><br><span class="line">    V(oxygenQueue)</span><br><span class="line">    oxygen -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    V(mutex)</span><br><span class="line">P(hydrogenQueue)</span><br><span class="line">bond()</span><br><span class="line">barrier.wait()</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>分子中有<strong>几个原子</strong>就开<strong>几个线程</strong></li>
<li>同时开启三个线程/进程，由于氧原子<strong>进程</strong>只有一个，因此最后释放<code>mutex</code>的操作在氧原子操作中。</li>
<li><code>bond()</code>操作会在三个原子凑齐后在三个线程中<strong>各</strong>被调用一次。</li>
<li><code>mutex</code>同时对<code>hydrogen</code>和<code>oxygen</code>进行了上锁操作。</li>
</ul>
</blockquote>
<h2 id="死锁-deadlock"><a href="#死锁-deadlock" class="headerlink" title="死锁(deadlock)"></a>死锁(deadlock)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>并发死锁</p>
<p>并发程序执行的<strong>顺序不当</strong>造成的死锁</p>
</li>
<li><p>资源死锁</p>
<ul>
<li>$饥饿\neq死锁$</li>
</ul>
<blockquote>
<p>资源</p>
<ul>
<li>可剥夺资源：CPU、内存。</li>
<li>非可剥夺资源：CD刻录机、打印机、<strong>临时性资源（消息、中断）</strong></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul>
<li>互斥：一段时间内某个资源只能够由<strong>一个</strong>进程占用</li>
<li>保持和请求：已经得到资源的线程<strong>可以</strong>请求新的资源（多个锁的请求顺序）</li>
<li>不剥夺：已经获得资源的进程不能被强制剥夺该资源，只能自行释放。</li>
<li>环路（循环）等待条件：发生死锁时必然存在多个进程组成的环形链。</li>
</ul>
<h3 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h3><ul>
<li><p>鸵鸟算法</p>
<p>死锁概率小、影响低时可以考虑。</p>
</li>
<li><p>死锁检测&amp;死锁恢复(detection and recovery)</p>
<ul>
<li>允许死锁发生，发生后采取措施恢复。</li>
<li>检测方法<ul>
<li>资源分配图<ul>
<li>使用场景：每类资源只有<strong>一个</strong></li>
</ul>
</li>
<li>资源向量计算<ul>
<li>使用场景：每类资源有<strong>多个</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁预防(avoidance)</p>
<ul>
<li><p><strong>静态</strong>行为</p>
</li>
<li><p>破坏四个<strong>必要条件</strong>之一（或更多）</p>
</li>
</ul>
</li>
<li><p>死锁避免(prevention)</p>
<ul>
<li><strong>动态</strong>行为</li>
<li>分配资源前进行<strong>安全检查</strong><ul>
<li>银行家算法：运行前知道所有进程所需资源的最大值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>检测算法核心：是否存在进程之间的<strong>循环等待</strong></p>
<h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>适合每类资源只有一个的死锁检测，主要是检查图中是否存在<strong>有向环</strong>。</p>
<ul>
<li>圆形：进程(<code>P</code>)</li>
<li>方形：资源(<code>R</code>)</li>
<li>资源-&gt;进程：资源被占用</li>
<li>进程-&gt;资源：进程正在请求资源</li>
</ul>
<blockquote>
<p>作图：<strong>先画资源然后画进程</strong></p>
</blockquote>
<h4 id="资源向量（矩阵）法"><a href="#资源向量（矩阵）法" class="headerlink" title="资源向量（矩阵）法"></a>资源向量（矩阵）法</h4><p><strong>概念</strong></p>
<p>适用于每类资源有多个的死锁检测</p>
<p>$\sum_{i=1}^{n}C_{ij}+A_j=E_j$</p>
<p>当前分配矩阵中选定一列和A中对应列一起求和的值等于资源总量中对应的列的值。</p>
<ul>
<li>E(existing resource vector)：存在资源<strong>行向量</strong>，表示各类资源存在的<strong>总量</strong>。</li>
<li>A(available resource vector)：可用资源<strong>行向量</strong>，当前未被分配的可用资源数.</li>
<li>C(current allocation matrix)：当前分配<strong>矩阵</strong>，第<code>i</code>个行向量对应第<code>i</code>个进程<strong>已经分配</strong>到的各类资源数量。</li>
<li>R(request matrix)：第<code>i</code>个行向量表示第<code>i</code>个进程<strong>还需要的</strong>资源数量</li>
</ul>
<p><strong>实现步骤</strong></p>
<ul>
<li>寻找进程$P_i$,要求其在R矩阵中对应的第<code>i</code>行<strong>小于等于</strong>A，如果找不到，则跳过下一步。</li>
<li>使$P_i$运行完成，将$P_i$的当前分配向量<code>flush</code>到A中，并<strong>标记该进程执行完毕</strong>，然后<strong>跳转回第一步</strong>。</li>
<li>算法结束，如果存在没有标记的进程，则发生死锁。</li>
</ul>
<blockquote>
<p>Q：选择$P_i$的顺序是否有影响</p>
<p>A：没有，这是一个饱和式算法，会有多次遍历。</p>
</blockquote>
<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><ul>
<li><p>资源抢占法</p>
<p>挂起一些占有资源的进程，解除死锁，等待死锁结束后，<strong>再次激活</strong>这些被挂起的进程。</p>
</li>
<li><p>杀死进程法</p>
<p>杀死一个或若干进程，直到打破死循环。</p>
<blockquote>
<p><strong>编译进程</strong>可以，但是<strong>数据库进程、打印进程</strong>等不可以。</p>
</blockquote>
</li>
<li><p>回滚法</p>
<p>设置检查点（记录上下文），当出现死锁时选择一个拥有资源的进程回滚到<strong>未占用资源</strong>的检查点状态。</p>
<ul>
<li>定期创建检查点</li>
<li>回滚常用来<strong>容错</strong><ul>
<li>数据库事务</li>
<li>高可用服务系统：脱敏疗法（脱离过敏原）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul>
<li><p>打破互斥条件</p>
<p>使用假脱机技术让独占资源共享（缓冲区）</p>
</li>
<li><p>打破保持和请求条件</p>
<ol>
<li>当进程需要的<strong>所有</strong>资源都满足后一次性分配，进程结束后再<strong>统一释放</strong>。<strong>（SP&amp;SV操作）</strong></li>
<li>每次请求资源之前<strong>先释放</strong>已有资源，然后再尝试<strong>获取所有的资源</strong>。</li>
</ol>
<blockquote>
<p>局限：</p>
<ul>
<li>不可预测</li>
<li>资源利用率低</li>
<li>降低进程的并发性</li>
</ul>
</blockquote>
</li>
<li><p>打破不可抢占条件</p>
<p>允许进程强行抢占某些资源</p>
</li>
<li><p>打破循环等待条件</p>
<p>提前为资源编号，分配资源时必须按照顺序进行。</p>
<blockquote>
<p>局限：</p>
<ul>
<li>增加系统开销</li>
<li>因为必须按照顺序申请，则“挡”在<strong>现在</strong>需要的资源之前的进程也要被<strong>一并申请</strong>，因此会增加进程对资源的占用时间。(不产生竞争条件的资源<strong>不用</strong>进行编号)</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="哲学家进餐问题-the-dining-philosophers-problem"><a href="#哲学家进餐问题-the-dining-philosophers-problem" class="headerlink" title="哲学家进餐问题(the dining philosophers problem)"></a>哲学家进餐问题(the dining philosophers problem)</h3><p>解决思路</p>
<ul>
<li>每次只允许4个哲学家竞争餐具，则总有一个哲学家可以进餐完毕。（破除<strong>循环等待</strong>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Semaphore dinners = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_forks</span><span class="params">(i)</span>:</span></span><br><span class="line">    dinners.wait()</span><br><span class="line">    </span><br><span class="line">    forks[right[i]].wait()</span><br><span class="line">    forks[left[i]].wait()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_forks</span><span class="params">()</span>:</span></span><br><span class="line">    forks[right[i]].signal()</span><br><span class="line">    forks[left[i]].signal()</span><br><span class="line">    </span><br><span class="line">    dinners.signal()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>假如至少一个左撇子和一个右撇子，则不会发生死锁。（反证法）（破除<strong>循环等待</strong>）</p>
</li>
<li><p>对餐具进行编号，哲学家按照<strong>升序</strong>拿餐具。（破除<strong>循环等待</strong>）</p>
<p>本质上，1号哲学家是<strong>右撇子</strong>，5号哲学家是<strong>左撇子</strong>。</p>
<blockquote>
<p>Q：当被1和5号筷子夹着的1号哲学家哲学家用餐时，是否会同时占用2、3、4？</p>
<p>A：不会。假设大家都拿起了筷子，那么1、5或者1、2之间的哲学家一定有一个没有拿起，不如假设是前者。那么4、5之间的哲学家可以正常用餐，放下筷子后又可以正常进行竞争，因此1、5之间的哲学家不需要去竞争2、3、4，所以便不会出现问题中描述的情况。</p>
</blockquote>
</li>
<li><p>对哲学家编号，奇数号先拿左再拿右，偶数号相反。（破除<strong>循环等待</strong>）</p>
<blockquote>
<p>相当于加入了左撇子和右撇子</p>
</blockquote>
</li>
<li><p><strong>同时拿起</strong>两边的餐具，要不都不拿。（破除<strong>保持等待</strong>）</p>
</li>
<li><p><code>Tanebum</code>算法：加入对哲学家状态<code>eating</code>/<code>bungry</code>的判断</p>
<blockquote>
<p>破除<strong>死锁</strong>，但是依然有<strong>饥饿</strong>现象。</p>
</blockquote>
</li>
</ul>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p><strong>动态策略</strong>，对每个资源请求进行检查，避免<strong>资源死锁</strong>。</p>
<blockquote>
<p>这里的动态和死锁恢复不一样，死锁恢复的动态体现在死锁<strong>发生后</strong>，而这里是死锁<strong>发生前</strong>。</p>
</blockquote>
<ul>
<li><p>安全序列：不产生死锁的资源分配顺序</p>
</li>
<li><p>安全状态：没有死锁时，所有进程突然请求<strong>最大</strong>需要的资源量<strong>（同时请求并不是同时分配）</strong>，也<strong>不发生</strong>死锁。</p>
</li>
<li><p>不安全状态：<strong>不存在</strong>安全序列使进程可以运行完毕</p>
<blockquote>
<p>系统进入不安全状态也<strong>不一定</strong>会产生死锁；但是产生死锁后，<strong>一定处于</strong>不安全状态。</p>
<p>Q：为什么不安全状态不一定产生死锁</p>
<p>A：不安全状态是由<strong>最大需求</strong>推导出的，但是实际上，可能在进程下一次真正申请资源时，资源条件已经得到满足，从而<strong>不产生</strong>死锁。</p>
</blockquote>
</li>
</ul>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li><p>可用资源向量(Available)</p>
</li>
<li><p>最大需求矩阵(Max)</p>
</li>
<li><p>分配矩阵(Allocation)</p>
</li>
<li><p>需求矩阵(Need)</p>
<p>$Need_{ij}=Max_{ij}-Allocation_{ij}$</p>
</li>
</ul>
<p><strong>实现步骤：</strong></p>
<p>设request是P的请求向量，且需要k个R类资源</p>
<ul>
<li>${request}\leq{need}$则进入下一步，否则认为出错。（请求资源超过了<strong>事先约定的</strong>限额）</li>
<li>${request}\leq{available}$则进入下一步，否则进入等待状态。</li>
<li>系统模拟把资源分配给P,并执行<strong>安全性算法检查</strong>。</li>
<li>如果检查通过，则正式分配资源，否则恢复到模拟前的状态，让P等待。</li>
</ul>
<p><strong>安全性算法：</strong></p>
<ul>
<li><p>设置两个向量</p>
<ul>
<li><p>工作向量(Work)：表示系统<strong>可提供的各类资源的数目</strong></p>
<p>初始时<code>Work:=Available</code></p>
</li>
<li><p>完成向量(Finish)：表示系统是否有足够的资源分配给进程</p>
<p>初始时<code>Finish[i]:=false</code>，如果资源足够（<strong>不是检查通过</strong>）则置为<code>true</code>.</p>
</li>
</ul>
</li>
<li><p>寻找满足以下条件的进程</p>
<ul>
<li>$Finish[i]=false$</li>
<li>${Need_i}\leq{Work}$</li>
</ul>
<p>如果找到则进入下一步，否则跳过。</p>
</li>
<li><p>将Allocation<code>flush</code>到Available并返回上一步</p>
</li>
<li><p>如果<code>Finish[i]=true</code><strong>都成立</strong>则检查通过</p>
</li>
</ul>
<blockquote>
<p>特点：</p>
<ul>
<li>算法考虑到了<strong>互斥、部分分配、不可抢占</strong>，因而可提高资源利用率</li>
<li>要求实现说明最大资源要求，在现实中无法使用。</li>
</ul>
</blockquote>
<h4 id="资源分配图-1"><a href="#资源分配图-1" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>原理和银行家算法相同</p>
<ul>
<li>封锁进程：对应银行家算法中Need无法被满足的线程</li>
<li>非封锁进程：没有被封锁的进程</li>
<li>化简：一个进程运行完成则使其成为孤立节点</li>
</ul>
<p>死锁定理：</p>
<ul>
<li>死锁等价于资源分配图<strong>不能</strong>完全化简（不能全部成为孤立节点）</li>
</ul>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Q：一个进程的死锁是否存在？</p>
<p>A：否，死锁发生时必须存在环路（必要条件）</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>Modern Operating System, Fourth Edition.</li>
<li>BUAA OS Lecture, Spring Of 2020.</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/04/Chapter2-1-%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%8F%8A%E8%AE%BE%E8%AE%A1/" rel="prev" title="Chapter2-1-分页系统管理及设计">
      <i class="fa fa-chevron-left"></i> Chapter2-1-分页系统管理及设计
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/04/Chapter4-1-inode%E8%A7%A3%E6%9E%90/" rel="next" title="Chapter4-1-inode解析">
      Chapter4-1-inode解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silence</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  Visitors: <span id="busuanzi_value_site_pv"></span>
</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">|   total: 38.6k words</span>
</div>
  <div class="powered-by">
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: location.pathname,
    }, {"enable":true,"appId":"GMneVEFPu4TwpvejAPqllWGc-gzGzoHsz","appKey":"5eNvc7SV1dxRT000WSXjRDuD","placeholder":"Just write what you'd like to write.","avatar":"mm","meta":["nick","mail"],"pageSize":10,"language":"en","visitor":false,"comment_count":true,"recordIP":false,"serverURLs":null}
    ));
  }, window.Valine);
});
</script>

</body>
</html>
